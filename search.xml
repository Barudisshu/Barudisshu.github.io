<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gentoo+Enlightenment+Systemd 安装记录</title>
      <link href="/2020/08/26/gentoo/Gentoo-Enlightenment-Systemd/"/>
      <url>/2020/08/26/gentoo/Gentoo-Enlightenment-Systemd/</url>
      
        <content type="html"><![CDATA[<p>Enlightenment 是一款重新思考设计的linux桌面系统。</p><span id="more"></span><p>不多废话，首先上图。</p><p><img src="/img/gentoo/Gentoo_Env_1.png" alt="gentoo env"></p><p>自由切换主题后。</p><p><img src="/img/gentoo/Gentoo_Env_2.png" alt="gentoo env"></p><p>在安装桌面之前，首先要安装好Gentoo系统环境。</p><p><code>make.conf</code> 配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># These settings were set by the catalyst build script that automatically</span><br><span class="line"># built this stage.</span><br><span class="line"># Please consult /usr/share/portage/config/make.conf.example for a more</span><br><span class="line"># detailed example.</span><br><span class="line">COMMON_FLAGS=&quot;-march=native -O2 -pipe&quot;</span><br><span class="line">MAKEOPTS=&quot;-j2&quot;</span><br><span class="line">CFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">CXXFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">FCFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line">FFLAGS=&quot;$&#123;COMMON_FLAGS&#125;&quot;</span><br><span class="line"></span><br><span class="line"># NOTE: This stage was built with the bindist Use flag enabled</span><br><span class="line">PORTDIR=&quot;/var/db/repos/gentoo&quot;</span><br><span class="line">DISTDIR=&quot;/var/cache/distfiles&quot;</span><br><span class="line">PKGDIR=&quot;/var/cache/binpkgs&quot;</span><br><span class="line"></span><br><span class="line">DARKELF_FEATURES=&quot;postmerge_distclean&quot;</span><br><span class="line"></span><br><span class="line"># This sets the language of build output to English.</span><br><span class="line"># Please keep this setting intact when reporting bugs.</span><br><span class="line">LC_MESSAGES=C</span><br><span class="line"></span><br><span class="line">INPUT_DEVICES=&quot;libinput synaptics&quot;</span><br><span class="line"></span><br><span class="line">VIDEO_CARDS=&quot;vmware&quot;</span><br><span class="line"></span><br><span class="line">ACCEPT_LICENSE=&quot;*&quot;</span><br><span class="line"></span><br><span class="line">PYTHON_TARGETS=&quot;python3_6 python3_7 python3_8 python3_9&quot;</span><br><span class="line"></span><br><span class="line">USE=&quot;icu bindist mmx sse sse2 systemd llvm wayland xwayland X drm eet fontconfig infinality xml egl gles gles2 gles2-only alas glib gstreamer harfbuzz ico jpeg2k pulseaudio sound svg system-lz4 gif png raw openjpeg udev alsa meson freetype -harfbuzz&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GENTOO_MIRRORS=&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自动unmask 生成文件 <code>/etc/portage/packase.use/zz-autounmask</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># package.use# required by app-misc/neofetch-6.0.0::gentoo[X]</span><br><span class="line"># required by neofetch (argument)</span><br><span class="line">&gt;=www-client/w3m-0.5.3_p20180125 imlib</span><br><span class="line"># required by x11-drivers/xf86-video-vmware-13.3.0::gentoo</span><br><span class="line"># required by x11-base/xorg-drivers-1.20-r2::gentoo[video_cards_vmware]</span><br><span class="line"># required by x11-base/xorg-server-1.20.8-r1::gentoo[xorg]</span><br><span class="line"># required by x11-drivers/xf86-input-libinput-0.30.0::gentoo</span><br><span class="line">&gt;=x11-libs/libdrm-2.4.102 libkms</span><br><span class="line"># required by x11-drivers/xf86-video-vmware-13.3.0::gentoo</span><br><span class="line"># required by x11-base/xorg-drivers-1.20-r2::gentoo[video_cards_vmware]</span><br><span class="line"># required by x11-base/xorg-server-1.20.8-r1::gentoo[xorg]</span><br><span class="line"># required by x11-drivers/xf86-input-libinput-0.30.0::gentoo</span><br><span class="line">&gt;=media-libs/mesa-20.0.8 xa</span><br><span class="line"># required by net-p2p/epour-9999::enlightenment-live</span><br><span class="line"># required by @enlightenment-apps-9999 (argument)</span><br><span class="line">&gt;=net-libs/libtorrent-rasterbar-1.2.6 python</span><br><span class="line"># required by x11-misc/xdg-utils-1.1.3_p20200220::gentoo</span><br><span class="line"># required by net-p2p/epour-9999::enlightenment-live</span><br><span class="line"># required by @enlightenment-apps-9999 (argument)</span><br><span class="line">&gt;=app-text/xmlto-0.0.28-r3 text</span><br><span class="line"># required by net-libs/libtorrent-rasterbar-1.2.6::gentoo[python]</span><br><span class="line"># required by net-p2p/epour-9999::enlightenment-live</span><br><span class="line"># required by @enlightenment-apps-9999 (argument)</span><br><span class="line">&gt;=dev-libs/boost-1.72.0-r1 python</span><br></pre></td></tr></table></figure><p>因为使用的是live版。就是未稳定的测试版。添加overlay.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root #layman -a enlightenment-live</span><br></pre></td></tr></table></figure><p>如果你仅需要基本功能。则安装如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root #emerge --ask --autounmask-write @enlightenment-core-9999</span><br></pre></td></tr></table></figure><p>然后在<code>/etc/portage/package.accept_keywords</code>添加mask的包信息。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> required by =x11-wm/enlightenment-9999 (argument)</span></span><br><span class="line">=x11-wm/enlightenment-9999 **</span><br><span class="line">=x11-terms/terminology-9999 **</span><br><span class="line">=dev-libs/efl-9999 **</span><br></pre></td></tr></table></figure><p>因为是在虚拟机中安装，需要添加vmware工具。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> required by vmware</span></span><br><span class="line">=app-emulation/open-vm-tools-11.1.0 **</span><br></pre></td></tr></table></figure><p>如果你还想体验enlightenment自带的丰富app。则安装如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root #emerge --ask --autounmask-write @enlightenment-apps-9999</span><br></pre></td></tr></table></figure><p>安装过程中会发现问题比较多，添加mask包信息。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Needed <span class="keyword">for</span> the apps</span></span><br><span class="line">=dev-python/python-efl-9999 **</span><br><span class="line"><span class="meta">#</span><span class="bash"> Various apps</span></span><br><span class="line">=net-irc/express-9999 **</span><br><span class="line">=dev-util/enventor-9999 **</span><br><span class="line">=app-editors/ecrire-9999 **</span><br><span class="line">=media-gfx/ephoto-9999 **</span><br><span class="line">=app-misc/equate-9999 **</span><br><span class="line">=dev-vcs/egitu-9999 **</span><br><span class="line">=media-gfx/eluminance-9999 **</span><br><span class="line">=x11-misc/entrance-9999 **</span><br><span class="line"><span class="meta">#</span><span class="bash"> required by epour (argument)</span></span><br><span class="line">=net-p2p/epour-9999 **</span><br><span class="line"><span class="meta">#</span><span class="bash"> required by net-p2p/epour-9999::enlightenment-live</span></span><br><span class="line">=net-libs/rb_libtorrent-1.0.10 **</span><br><span class="line">=net-misc/econnman-9999 **</span><br><span class="line">=dev-util/espionage-9999 **</span><br><span class="line">=media-video/rage-9999 **</span><br><span class="line">=sys-process/evisum-9999 **</span><br><span class="line">media-libs/gstreamer:1.0 **</span><br></pre></td></tr></table></figure><p>再重新执行一次安装即可。</p><p>需要注意的是，内存一定要足够。！！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> gentoo,linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翱翔天际の人</title>
      <link href="/2020/07/30/musics/%E7%BF%B1%E7%BF%94%E5%A4%A9%E9%99%85%E3%81%AE%E4%BA%BA/"/>
      <url>/2020/07/30/musics/%E7%BF%B1%E7%BF%94%E5%A4%A9%E9%99%85%E3%81%AE%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p><img src alt></p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">无言的微风</span><br><span class="line"></span><br><span class="line">脉脉的离光</span><br><span class="line"></span><br><span class="line">为了见证勇敢</span><br><span class="line"></span><br><span class="line">今天终于抵达了</span><br><span class="line"></span><br><span class="line">可以瞭望天际的地方</span><br><span class="line"></span><br><span class="line">一直渴望新生的力量</span><br><span class="line"></span><br><span class="line">无论内心多么坦然</span><br><span class="line"></span><br><span class="line">总是在前进的路上遇上荆棘</span><br><span class="line"></span><br><span class="line">夏日的时光总是匆匆溜走</span><br><span class="line"></span><br><span class="line">时代的变迁令我顾虑</span><br><span class="line"></span><br><span class="line">若洒下的泪珠</span><br><span class="line"></span><br><span class="line">也能让枯萎的小花再次绽放</span><br><span class="line"></span><br><span class="line">心里微弱的亮光或许</span><br><span class="line"></span><br><span class="line">能照亮漫长的岁月</span><br><span class="line"></span><br><span class="line">沐浴阳光</span><br><span class="line"></span><br><span class="line">感受这呼吸吧</span><br><span class="line"></span><br><span class="line">能否抵达结局，故事是否真实，已经无人知晓</span><br><span class="line"></span><br><span class="line">所以就算有一天跌倒</span><br><span class="line"></span><br><span class="line">我亦无怨无悔</span><br><span class="line"></span><br><span class="line">或许明天陷入阴霾</span><br><span class="line"></span><br><span class="line">或许不存在，没有悲伤的世界</span><br><span class="line"></span><br><span class="line">让此刻的阳光，照亮天真的脸颊</span><br><span class="line"></span><br><span class="line">此刻</span><br><span class="line"></span><br><span class="line">只想守护</span><br><span class="line"></span><br><span class="line">落日的余晖</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> audio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于scala-swing构建的推箱子游戏</title>
      <link href="/2020/06/24/game/sokoban/"/>
      <url>/2020/06/24/game/sokoban/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><img src="/img/game/sokoban/sokoban-screenshot.png" alt="game"></p><p>推箱子游戏属于一种解谜问题。开发思路比较简单，并且有比较正规定义。</p><h2><span id="首先定义地图">首先定义地图</span></h2><p>地图格式可以参考<a href="http://www.sokobano.de/wiki/index.php?title=Level_format">这里</a></p><h2><span id="建立地图文件">建立地图文件</span></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    #####</span><br><span class="line">    #   #</span><br><span class="line">    #$  #</span><br><span class="line">  ###  $##</span><br><span class="line">  #  $ $ #</span><br><span class="line">### # ## #   ######</span><br><span class="line">#   # ## #####  ..#</span><br><span class="line"># $  $          ..#</span><br><span class="line">##### ### #@##  ..#</span><br><span class="line">    #     #########</span><br><span class="line">    #######</span><br><span class="line"></span><br><span class="line">############</span><br><span class="line">#..  #     ###</span><br><span class="line">#..  # $  $  #</span><br><span class="line">#..  #$####  #</span><br><span class="line">#..    @ ##  #</span><br><span class="line">#..  # #  $ ##</span><br><span class="line">###### ##$ $ #</span><br><span class="line">  # $  $ $ $ #</span><br><span class="line">  #    #     #</span><br><span class="line">  ############</span><br><span class="line">  ...</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>更多内容可以参考<a href="https://github.com/barudisshu/alg-fpp/tree/master/game/sokobanvl">源码</a>实现。</p><h2><span id="引入依赖">引入依赖</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val scalaSwing = &quot;org.scala-lang.modules&quot; %% &quot;scala-swing&quot; % scalaSwingV</span><br></pre></td></tr></table></figure><h2><span id="构建元素">构建元素</span></h2><p>包括墙壁、玩家、箱子等。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WorldElement</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>(<span class="params"></span>)                <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxOnGoalSquare</span>(<span class="params"></span>)    <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span>(<span class="params"></span>)             <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerOnGoalSquare</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Floor</span>(<span class="params"></span>)              <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GoalSquare</span>(<span class="params"></span>)         <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Wall</span>(<span class="params"></span>)               <span class="keyword">extends</span> <span class="title">WorldElement</span></span></span><br></pre></td></tr></table></figure><h2><span id="构建世界">构建世界</span></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">import</span> scala.swing.<span class="type">Publisher</span></span><br><span class="line"><span class="keyword">import</span> scala.swing.event.<span class="type">Event</span></span><br><span class="line"><span class="keyword">import</span> scala.swing.event.<span class="type">Key</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerMove</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Event</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerHint</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Event</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">World</span> <span class="keyword">extends</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Level</span> </span>= <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">WorldElement</span>]]</span><br><span class="line">  <span class="keyword">val</span> levels: <span class="type">ListBuffer</span>[<span class="type">Level</span>] = <span class="type">ListBuffer</span>[<span class="type">Level</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MAX_WIDTH</span>  = <span class="number">19</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MAX_HEIGHT</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentLevel: <span class="type">Level</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> manX = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> manY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> toGoX = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> toGoY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nb_move = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loadLevel</span></span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">    currentLevel = copyMap(levels(num))</span><br><span class="line">    nb_move = <span class="number">0</span></span><br><span class="line">    publish(<span class="type">PlayerMove</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onKeyPress</span></span>(keyCode: <span class="type">Value</span>) &#123;</span><br><span class="line">    keyCode <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Left</span>  =&gt; move(<span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Right</span> =&gt; move(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Up</span>    =&gt; move(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Down</span>  =&gt; move(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">case</span> _     =&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fromString</span></span>(stringWorld: <span class="type">String</span>): <span class="type">Level</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> level             = <span class="type">Array</span>.ofDim[<span class="type">WorldElement</span>](<span class="type">MAX_WIDTH</span>, <span class="type">MAX_HEIGHT</span>)</span><br><span class="line">    <span class="keyword">val</span> listStringMap     = stringWorld.toList</span><br><span class="line">    <span class="keyword">var</span> wEl: <span class="type">WorldElement</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> x, y              = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- listStringMap.indices) &#123;</span><br><span class="line">      listStringMap(i) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &#x27;#&#x27; =&gt; wEl = <span class="type">Wall</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;.&#x27; =&gt; wEl = <span class="type">GoalSquare</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;$&#x27; =&gt; wEl = <span class="type">Box</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;@&#x27; =&gt; wEl = <span class="type">Player</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;+&#x27; =&gt; wEl = <span class="type">PlayerOnGoalSquare</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;*&#x27; =&gt; wEl = <span class="type">BoxOnGoalSquare</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27; &#x27; =&gt; wEl = <span class="type">Floor</span>()</span><br><span class="line">        <span class="keyword">case</span> &#x27;\n&#x27; =&gt;</span><br><span class="line">          y += <span class="number">1</span></span><br><span class="line">          x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wEl != <span class="literal">null</span>) &#123;</span><br><span class="line">        level(x)(y) = wEl</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        wEl = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    level</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fromFile</span></span>(filePath: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lines: <span class="type">ListBuffer</span>[<span class="type">String</span>] = <span class="type">ListBuffer</span>()</span><br><span class="line">    <span class="keyword">val</span> stream                    = <span class="type">Source</span>.fromResource(filePath)</span><br><span class="line">    <span class="keyword">for</span> (line &lt;- stream.getLines()) &#123;</span><br><span class="line">      line <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&quot;</span> =&gt;</span><br><span class="line">          levels += fromString(lines.mkString(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">          lines = <span class="type">ListBuffer</span>()</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; lines += line</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">locateMan</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      i &lt;- currentLevel.indices</span><br><span class="line">      j &lt;- currentLevel(i).indices</span><br><span class="line">    &#125; &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentLevel(i)(j).isInstanceOf[<span class="type">Player</span>]) &#123;</span><br><span class="line">        manX = i</span><br><span class="line">        manY = j</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">    locateMan()</span><br><span class="line">    toGoX = x</span><br><span class="line">    toGoY = y</span><br><span class="line">    nb_move += <span class="number">1</span></span><br><span class="line">    currentLevel(manX + toGoX)(manY - toGoY) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Box</span>             =&gt; moveBox()</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Floor</span>           =&gt; movePlayerToFloor()</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">GoalSquare</span>      =&gt; movePlayerToGoalSquare()</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">BoxOnGoalSquare</span> =&gt; moveBox()</span><br><span class="line">      <span class="keyword">case</span> _                  =&gt; nb_move -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    publish(<span class="type">PlayerMove</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveBox</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> (x, y)               = nextCase(manX, manY)</span><br><span class="line">    <span class="keyword">val</span> (bhCrateX, bhCrateY) = nextCase(x, y)</span><br><span class="line">    currentLevel(bhCrateX)(bhCrateY) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Floor</span> =&gt;</span><br><span class="line">        currentLevel(bhCrateX)(bhCrateY) = <span class="type">Box</span>()</span><br><span class="line">        moveManToSpaceOrStorage(x, y)</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">GoalSquare</span> =&gt;</span><br><span class="line">        currentLevel(bhCrateX)(bhCrateY) = <span class="type">BoxOnGoalSquare</span>()</span><br><span class="line">        moveManToSpaceOrStorage(x, y)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">movePlayerToFloor</span></span>() &#123;</span><br><span class="line">    letSpaceOrStorage()</span><br><span class="line">    manX = manX + toGoX</span><br><span class="line">    manY = manY - toGoY</span><br><span class="line">    currentLevel(manX)(manY) = <span class="type">Player</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">movePlayerToGoalSquare</span></span>() &#123;</span><br><span class="line">    letSpaceOrStorage()</span><br><span class="line">    manX = manX + toGoX</span><br><span class="line">    manY = manY - toGoY</span><br><span class="line">    currentLevel(manX)(manY) = <span class="type">PlayerOnGoalSquare</span>()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">letSpaceOrStorage</span></span>() &#123;</span><br><span class="line">    currentLevel(manX)(manY) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Player</span> =&gt;</span><br><span class="line">        currentLevel(manX)(manY) = element.<span class="type">Floor</span>()</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">PlayerOnGoalSquare</span> =&gt;</span><br><span class="line">        currentLevel(manX)(manY) = <span class="type">GoalSquare</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveManToSpaceOrStorage</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">    currentLevel(x)(y) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Box</span> =&gt;</span><br><span class="line">        movePlayerToFloor()</span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">BoxOnGoalSquare</span> =&gt;</span><br><span class="line">        movePlayerToGoalSquare()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">nextCase</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = &#123;</span><br><span class="line">    (x + toGoX, y - toGoY)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">copyMap</span></span>(originMap: <span class="type">Level</span>): <span class="type">Level</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> copyMap = <span class="type">Array</span>.ofDim[<span class="type">WorldElement</span>](<span class="type">MAX_WIDTH</span>, <span class="type">MAX_HEIGHT</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      x &lt;- originMap.indices</span><br><span class="line">      y &lt;- originMap(x).indices</span><br><span class="line">    &#125; copyMap(x)(y) = originMap(x)(y)</span><br><span class="line">    copyMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="设计ui">设计UI</span></h2><p>比较简单，加载到地图元素后，匹配到元素直接画即可。我这里使用了Graphics2D直接画，如果有合适的图片元素，可以直接转BufferedImage。然后调用<code>g.drawImage</code>相对会更好看一些。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.&#123;<span class="type">Color</span>, <span class="type">Graphics2D</span>, <span class="type">RenderingHints</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.galudisu.game.<span class="type">World</span></span><br><span class="line"><span class="keyword">import</span> cn.galudisu.game.element._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.swing.<span class="type">Panel</span></span><br><span class="line"><span class="keyword">import</span> scala.swing.<span class="type">Swing</span>._</span><br><span class="line"><span class="keyword">import</span> scala.swing.event._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelFinish</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Event</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIWorld</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Panel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentLevelNum: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line">  background = <span class="type">Color</span>.white</span><br><span class="line">  preferredSize = (<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">  focusable = <span class="literal">true</span></span><br><span class="line">  listenTo(keys)</span><br><span class="line">  reactions += &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">KeyTyped</span>(_, &#x27;t&#x27;, _, _) =&gt;</span><br><span class="line">      publish(<span class="type">LevelFinish</span>())</span><br><span class="line">    <span class="keyword">case</span> <span class="type">KeyTyped</span>(_, &#x27;r&#x27;, _, _) =&gt;</span><br><span class="line">      restart()</span><br><span class="line">    <span class="keyword">case</span> <span class="type">KeyPressed</span>(_, key, _, _) =&gt;</span><br><span class="line">      <span class="type">World</span>.onKeyPress(key)</span><br><span class="line">      repaint()</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">FocusLost</span> =&gt; repaint()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> success = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loadWorld</span></span>(levelNum: <span class="type">Int</span>) &#123;</span><br><span class="line">    currentLevelNum = levelNum</span><br><span class="line">    <span class="type">World</span>.loadLevel(levelNum)</span><br><span class="line">    repaint()</span><br><span class="line">    requestFocus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">nextLevel</span></span>() &#123;</span><br><span class="line">    loadWorld(currentLevelNum + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">restart</span></span>() &#123;</span><br><span class="line">    <span class="type">World</span>.loadLevel(currentLevelNum)</span><br><span class="line">    repaint()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">paintComponent</span></span>(g: <span class="type">Graphics2D</span>) &#123;</span><br><span class="line">    g.clearRect(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)</span><br><span class="line">    <span class="keyword">val</span> level = <span class="type">World</span>.currentLevel</span><br><span class="line">    <span class="keyword">for</span> (x &lt;- level.indices) &#123;</span><br><span class="line">      <span class="keyword">for</span> (y &lt;- level(x).indices <span class="keyword">if</span> level(x)(y) != <span class="literal">null</span>) &#123;</span><br><span class="line">        level(x)(y) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Box</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">165</span>, <span class="number">130</span>, <span class="number">90</span>))</span><br><span class="line">            g.fillRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">            g.fill3DRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="literal">true</span>)</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>))</span><br><span class="line">            g.setRenderingHint(<span class="type">RenderingHints</span>.<span class="type">KEY_ANTIALIASING</span>, <span class="type">RenderingHints</span>.<span class="type">VALUE_ANTIALIAS_ON</span>)</span><br><span class="line">            g.drawLine((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">4</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">4</span>, (x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">20</span> - <span class="number">4</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">20</span> - <span class="number">4</span>)</span><br><span class="line">            g.drawLine((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">4</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">20</span> - <span class="number">4</span>, (x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">20</span> - <span class="number">4</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">4</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">BoxOnGoalSquare</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">255</span>, <span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line">            g.fillRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">            g.fill3DRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Player</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="type">Color</span>.<span class="type">WHITE</span>)</span><br><span class="line">            g.draw3DRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="literal">true</span>)</span><br><span class="line">            g.setColor(<span class="type">Color</span>.<span class="type">GREEN</span>)</span><br><span class="line">            g.fill3DRect((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">1</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">1</span>, <span class="number">20</span> - <span class="number">2</span>, <span class="number">20</span> - <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">PlayerOnGoalSquare</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">120</span>, <span class="number">160</span>, <span class="number">160</span>))</span><br><span class="line">            g.draw3DRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="literal">true</span>)</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">20</span>, <span class="number">250</span>, <span class="number">20</span>))</span><br><span class="line">            g.fill3DRect((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">1</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">1</span>, <span class="number">20</span> - <span class="number">2</span>, <span class="number">20</span> - <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">GoalSquare</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">90</span>, <span class="number">160</span>, <span class="number">90</span>))</span><br><span class="line">            g.drawOval((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">5</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">            g.fillOval((x + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">5</span>, (y + <span class="number">1</span>) * <span class="number">20</span> + <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Wall</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>))</span><br><span class="line">            g.fillRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">            g.fill3DRect((x + <span class="number">1</span>) * <span class="number">20</span>, (y + <span class="number">1</span>) * <span class="number">20</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="number">20</span> - <span class="number">1</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Floor</span>() =&gt;</span><br><span class="line">            g.setColor(<span class="type">Color</span>.<span class="type">WHITE</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        level(x)(y) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Box</span>() =&gt;</span><br><span class="line">            success = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      publish(<span class="type">LevelFinish</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      success = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="编写主程序入口">编写主程序入口</span></h2><p>主程序需要加载地图信息，设计按钮和处理事件等。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.galudisu.game.<span class="type">World</span>.<span class="type">Level</span></span><br><span class="line"><span class="keyword">import</span> cn.galudisu.game.ui.&#123;<span class="type">LevelFinish</span>, <span class="type">UIWorld</span>&#125;</span><br><span class="line"><span class="keyword">import</span> javax.swing.<span class="type">UIManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.swing.<span class="type">BorderPanel</span>.<span class="type">Position</span></span><br><span class="line"><span class="keyword">import</span> scala.swing.<span class="type">ListView</span>._</span><br><span class="line"><span class="keyword">import</span> scala.swing._</span><br><span class="line"><span class="keyword">import</span> scala.swing.event._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sokoban</span> <span class="keyword">extends</span> <span class="title">SimpleSwingApplication</span> </span>&#123;</span><br><span class="line">  activeNimbus()</span><br><span class="line"></span><br><span class="line">  <span class="type">World</span>.fromFile(<span class="string">&quot;worlds.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> uiWorld = <span class="keyword">new</span> <span class="type">UIWorld</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> uiChooseLevel: <span class="type">FlowPanel</span> = <span class="keyword">new</span> <span class="type">FlowPanel</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> comboBox: <span class="type">ComboBox</span>[<span class="type">Level</span>] = <span class="keyword">new</span> <span class="type">ComboBox</span>(<span class="type">World</span>.levels) &#123;</span><br><span class="line">      renderer = <span class="type">Renderer</span>(el =&gt; <span class="type">World</span>.levels.indexOf(el))</span><br><span class="line">      focusable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> loadLevelButton: <span class="type">Button</span> = <span class="keyword">new</span> <span class="type">Button</span> &#123;</span><br><span class="line">      text = <span class="string">&quot;Load level&quot;</span></span><br><span class="line">      focusable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> restartButton: <span class="type">Button</span> = <span class="keyword">new</span> <span class="type">Button</span> &#123;</span><br><span class="line">      text = <span class="string">&quot;Restart&quot;</span></span><br><span class="line">      focusable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contents += <span class="keyword">new</span> <span class="type">Label</span>(<span class="string">&quot;Change level&quot;</span>)</span><br><span class="line">    contents += comboBox</span><br><span class="line">    contents += loadLevelButton</span><br><span class="line">    contents += <span class="keyword">new</span> <span class="type">Separator</span>()</span><br><span class="line">    contents += restartButton</span><br><span class="line"></span><br><span class="line">    listenTo(loadLevelButton, restartButton)</span><br><span class="line"></span><br><span class="line">    reactions += &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ButtonClicked</span>(`loadLevelButton`) =&gt;</span><br><span class="line">        <span class="keyword">val</span> levelNum = <span class="type">World</span>.levels.indexOf(comboBox.selection.item)</span><br><span class="line">        uiWorld.loadWorld(levelNum)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ButtonClicked</span>(`restartButton`) =&gt;</span><br><span class="line">        uiWorld.restart()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> nbMoveLabel: <span class="type">Label</span> = <span class="keyword">new</span> <span class="type">Label</span>() &#123;</span><br><span class="line">    listenTo(<span class="type">World</span>)</span><br><span class="line">    reactions += &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">PlayerMove</span>() =&gt;</span><br><span class="line">        text = <span class="string">&quot;NB Move: &quot;</span> + <span class="type">World</span>.nb_move</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> uiStats: <span class="type">FlowPanel</span> = <span class="keyword">new</span> <span class="type">FlowPanel</span> &#123;</span><br><span class="line">    nbMoveLabel.text = <span class="string">&quot;NB Move:&quot;</span></span><br><span class="line">    contents += nbMoveLabel</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> borderPanel: <span class="type">BorderPanel</span> = <span class="keyword">new</span> <span class="type">BorderPanel</span> &#123;</span><br><span class="line">    add(uiChooseLevel, <span class="type">Position</span>.<span class="type">North</span>)</span><br><span class="line">    add(uiWorld, <span class="type">Position</span>.<span class="type">Center</span>)</span><br><span class="line">    add(uiStats, <span class="type">Position</span>.<span class="type">South</span>)</span><br><span class="line"></span><br><span class="line">    uiWorld.loadWorld(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    listenTo(uiWorld)</span><br><span class="line"></span><br><span class="line">    reactions += &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">LevelFinish</span>() =&gt;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="type">Dialog</span>.showOptions(</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          message = <span class="string">&quot;Success, level finish with &quot;</span> + <span class="type">World</span>.nb_move + <span class="string">&quot; move.&quot;</span>,</span><br><span class="line">          title = <span class="string">&quot;Level Finished!&quot;</span>,</span><br><span class="line">          messageType = <span class="type">Dialog</span>.<span class="type">Message</span>.<span class="type">Question</span>,</span><br><span class="line">          optionType = <span class="type">Dialog</span>.<span class="type">Options</span>.<span class="type">YesNo</span>,</span><br><span class="line">          entries = <span class="type">Seq</span>(<span class="string">&quot;Next level&quot;</span>, <span class="string">&quot;Ok&quot;</span>),</span><br><span class="line">          initial = <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        result <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Dialog</span>.<span class="type">Result</span>.<span class="type">Yes</span> =&gt;</span><br><span class="line">            uiWorld.nextLevel()</span><br><span class="line">          <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">top</span></span>: <span class="type">MainFrame</span> = <span class="keyword">new</span> <span class="type">MainFrame</span> &#123;</span><br><span class="line">    title = <span class="string">&quot;Sokoban Game&quot;</span></span><br><span class="line">    contents = borderPanel</span><br><span class="line">    centerOnScreen()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">activeNimbus</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (info &lt;- <span class="type">UIManager</span>.getInstalledLookAndFeels) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;Nimbus&quot;</span>.equals(info.getName)) &#123;</span><br><span class="line">        <span class="type">UIManager</span>.setLookAndFeel(info.getClassName)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得游戏功能单一，可以试试添加一个“提示”按钮，协助游戏玩家解题。可以参考<a href="http://bach.istc.kobe-u.ac.jp/copris/puzzles/sokoban/index.html">这里</a>。</p><p>Copris<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 是一门约束编程(Constraint programming)语言。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">[http://bach.istc.kobe-u.ac.jp/copris)</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何生成测试用服务端和客户端证书</title>
      <link href="/2020/06/23/certificate/generate-server-client-pk/"/>
      <url>/2020/06/23/certificate/generate-server-client-pk/</url>
      
        <content type="html"><![CDATA[<p>由于项目开发需要实现服务端和客户端的SSL双向认证，需要用到测试数据验证，下面介绍生成证书的步骤。</p><span id="more"></span><h2><span id="生成ca根证书">生成CA根证书</span></h2><ol><li>生成一个CA的私钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#generate ca key</span></span><br><span class="line">openssl genpkey -algorithm RSA -out ca.key</span><br></pre></td></tr></table></figure><ol start="2"><li>根据CA的私钥，生成一份自签名的CA根证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate self-signed ca certificate</span></span><br><span class="line">openssl req -new -x509 -nodes -days 365000 -key ca.key -out ca.crt \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=cplier.com/emailAddress=galudisu@cplier.com&quot;</span></span><br></pre></td></tr></table></figure><h2><span id="生成服务端证书">生成服务端证书</span></h2><ol><li>生成服务端私钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate server key</span></span><br><span class="line">openssl genpkey -algorithm RSA -out server.key</span><br></pre></td></tr></table></figure><ol start="2"><li>生成服务端证书CSR</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#generate server certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key server.key -out server.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=server.cplier.com/emailAddress=galudisu@cplier.com&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用前面生成的CA根证书对服务端的CSR签名，生成服务端证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate server certificate</span></span><br><span class="line">openssl x509 -req -days 365000 \</span><br><span class="line">  -<span class="keyword">in</span> server.csr -out server.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial</span><br></pre></td></tr></table></figure><h2><span id="生成客户端证书">生成客户端证书</span></h2><ol><li>生成客户端私钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate client key</span></span><br><span class="line">openssl genpkey -algorithm RSA -out client.key</span><br></pre></td></tr></table></figure><ol start="2"><li>生成客户端证书CSR</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate client certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key client.key -out client.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=client.cplier.com/emailAddress=galudisu@cplier.com&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用前面生成的CA根证书对客户端的CSR签名，生成客户端证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate client certificate</span></span><br><span class="line">openssl x509 -req -days 365000 \</span><br><span class="line">  -<span class="keyword">in</span> client.csr -out client.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial</span><br></pre></td></tr></table></figure><h2><span id="检查生成的服务端和客户端证书">检查生成的服务端和客户端证书</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl verify -CAfile ca.crt ca.crt server.crt </span><br><span class="line">openssl verify -CAfile ca.crt ca.crt client.crt </span><br><span class="line"></span><br><span class="line">openssl x509 -noout -text -<span class="keyword">in</span> server.crt</span><br><span class="line">openssl x509 -noout -text -<span class="keyword">in</span> client.crt</span><br></pre></td></tr></table></figure><h2><span id="生成pkcs8格式证书">生成PKCS8格式证书</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> server.key -out pkcs8_server.key</span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> client.key -out pkcs8_client.key</span><br></pre></td></tr></table></figure><h2><span id="生成trustore">生成trustore</span></h2><p>因为服务端和客户端使用同一个CA签发的证书，所以在此服务端和客户端使用同一个truststore就可以了，即truststore只包含一个此CA证书信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate server/client truststore</span></span><br><span class="line">keytool -import -noprompt -file ca.crt \</span><br><span class="line">  -keystore truststore.jks -storepass cplier</span><br></pre></td></tr></table></figure><h2><span id="生成服务端keystore">生成服务端keystore</span></h2><ol><li>生成服务端的P12格式证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate server p12</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> \</span><br><span class="line">  -<span class="keyword">in</span> server.crt -inkey server.key \</span><br><span class="line">  -out server.p12 -passout pass:server \</span><br><span class="line">  -name server -noiter -noomaciter</span><br></pre></td></tr></table></figure><ol start="2"><li>生成服务端的JKS格式证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate server jks</span></span><br><span class="line">keytool -importkeystore \</span><br><span class="line">  -srckeystore server.p12 -srcstoretype PKCS12 \</span><br><span class="line">  -destkeystore server.keystore.jks \</span><br><span class="line">  -srcstorepass server \</span><br><span class="line">  -deststorepass server</span><br></pre></td></tr></table></figure><h2><span id="生成客户端keystore">生成客户端keystore</span></h2><ol><li>生成客户端的P12格式证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate client p12</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> \</span><br><span class="line">  -<span class="keyword">in</span> client.crt -inkey client.key -out client.p12 \</span><br><span class="line">  -passout pass:client \</span><br><span class="line">  -name client -noiter -nomaciter</span><br></pre></td></tr></table></figure><ol start="2"><li>生成客户端的JKS格式证书</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate client jks</span></span><br><span class="line">keytool -importkeystore \</span><br><span class="line">  -srckeystore client.p12 -srcstoretype PKCS12 \</span><br><span class="line">  -destkeystore client.keystore.jks \</span><br><span class="line">  -srcstorepass client \</span><br><span class="line">  -deststorepass client</span><br></pre></td></tr></table></figure><h2><span id="验证jks证书的内容">验证JKS证书的内容</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool --list -keystore client.jks -storepass client</span><br><span class="line">keytool --list -keystore server.jks -storepass server</span><br><span class="line">keytool --list -keystore truststore.jks -storepass cplier</span><br></pre></td></tr></table></figure><h2><span id="更改访问主机域名">更改访问主机域名</span></h2><p>前面步骤中，生成的服务端和客户端的证书里面配置了证书subject的CN域为<code>sever</code>和<code>client</code>，在SSL验证主机名的时候要求主机的名字必须是<code>server</code>和<code>client</code>，否则SSL验证会报失败。</p><p>这个结果就是这个证书必须在主机名为<code>server/client</code>的机器上使用，不能在其它机器上使用。这个限制可不好，所以SSL标准定义了证书扩展属性SAN(Subject Alternative Name)，这是SSL 标准 x509 中定义的一个扩展，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。</p><p>具体怎么操作：</p><ol><li>首先配置openssl.cnf</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[ CA_default ]</span><br><span class="line">...</span><br><span class="line"># Extension copying option: use with caution.</span><br><span class="line">copy_extensions = copy</span><br><span class="line"></span><br><span class="line">[ req ]</span><br><span class="line">...</span><br><span class="line">req_extensions = v3_req # The extensions to add to a certificate request</span><br><span class="line"></span><br><span class="line">[ v3_req ]</span><br><span class="line">...</span><br><span class="line"># Extensions to add to a certificate request</span><br><span class="line">...</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = *.kafka.example.com</span><br><span class="line">DNS.2 = *.example.com</span><br></pre></td></tr></table></figure><ol start="2"><li>把前面步骤修改成如下，即指定扩展属性的openssl.cnf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 2.2: generate server certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key server.key -out server.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=server.cplier.com/emailAddress=galudisu@cplier.com&quot;</span> \</span><br><span class="line">  -config ./openssl.cnf -extensions v3_req</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2.3: generate server certificate</span></span><br><span class="line">openssl x509 -req -days 365000 \</span><br><span class="line">  -<span class="keyword">in</span> server.csr -out server.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">  -extfile ./openssl.cnf -extensions v3_req</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3.2: generate client certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key client.key -out client.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=client.cplier.com/emailAddress=galudisu@cplier.com&quot;</span> \</span><br><span class="line">  -config ./openssl.cnf -extensions v3_req</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3.3: generate client certificate</span></span><br><span class="line">openssl x509 -req -days 365000 -<span class="keyword">in</span> client.csr -out client.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">  -extfile ./openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure><ol start="3"><li>如果不想修改openssl.cnf,也可以直接使用命令行的方式</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 2.2: generate server certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key server.key -out server.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=server.cplier.com/emailAddress=galudisu@cplier.com&quot;</span> \</span><br><span class="line">  -reqexts SAN \</span><br><span class="line">  -config &lt;(cat /etc/pki/tls/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">&quot;\n[SAN]\nsubjectAltName=DNS:*.kafka.example.com,DNS:*.example.com&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2.3: generate server certificate</span></span><br><span class="line">openssl x509 -req -days 365000 \</span><br><span class="line">  -<span class="keyword">in</span> server.csr -out server.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">  -extensions SAN \</span><br><span class="line">  -extfile &lt;(cat /etc/pki/tls/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">&quot;[SAN]\nsubjectAltName=DNS:*.kafka.example.com,DNS:*.example.com&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3.2: generate client certificate signing request</span></span><br><span class="line">openssl req -new -nodes -days 365000 -key client.key -out client.csr \</span><br><span class="line">  -subj <span class="string">&quot;/C=cn/ST=Guangdong/L=Guangzhou/O=Cplier, Inc./OU=cplier/CN=client.cplier.com/emailAddress=galudisu@cplier.com&quot;</span> \</span><br><span class="line">  -reqexts SAN \</span><br><span class="line">  -config &lt;(cat /etc/pki/tls/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">&quot;\n[SAN]\nsubjectAltName=DNS:*.kafka.example.com,DNS:*.example.com&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3.3: generate client certificate</span></span><br><span class="line">openssl x509 -req -days 365000 -<span class="keyword">in</span> client.csr -out client.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">  -extensions SAN \</span><br><span class="line">  -extfile &lt;(cat /etc/pki/tls/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">&quot;[SAN]\nsubjectAltName=DNS:*.kafka.example.com,DNS:*.example.com&quot;</span>))</span><br></pre></td></tr></table></figure><h2><span id="椭圆算法ec的证书签名">椭圆算法(EC)的证书签名</span></h2><p>标准上除了定义RSA的签名算法，还有ECDSA(又叫EC)、DSA、PKCS8和PKCS8加密这几种。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam  -name secp256k1 -genkey</span><br><span class="line"></span><br><span class="line">-----BEGIN EC PARAMETERS-----</span><br><span class="line">BgUrgQQACg==</span><br><span class="line">-----END EC PARAMETERS-----</span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MHQCAQEEIKYV1xoz6smkpdMksfgI8/3465V02UZdaKj4JSH30bBhoAcGBSuBBAAK</span><br><span class="line">oUQDQgAEO1O+/xRGEVJgBEAOQorBveXPTQS3c7MA+9R+HEMP7TkscI9FONPclcRb</span><br><span class="line">5sXZJjYHNYWhvxuXdGl8QrFVRIVBYg==</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p><code>ecparam</code>是一个椭圆参数，用于实现私钥的生成，它是一个可选性。</p><h2><span id="如何在客户端发起ssl的请求">如何在客户端发起SSL的请求</span></h2><h3><span id="https-连接">https 连接</span></h3><h3><span id="http2-连接请求">http2 连接请求</span></h3><ol><li>GET</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k -vvv -L --http2-prior-knowledge --output - -X CONNECT --cert client.crt --key pkcs8_client.key --cacert ca.crt https://127.0.0.1:8443/</span><br></pre></td></tr></table></figure><ol start="2"><li>POST</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -k -vvvv \</span><br><span class="line"> -H &quot;Accept: application/json&quot; \</span><br><span class="line"> -H &quot;Content-Type: application/json; charset=UTF-8&quot; \</span><br><span class="line"> -d &#x27;&#123;&quot;framework&quot;:&quot;netty&quot;&#125;&#x27; \</span><br><span class="line"> -L \</span><br><span class="line"> --http2-prior-knowledge \</span><br><span class="line"> --output - \</span><br><span class="line"> --cert client.crt \</span><br><span class="line"> --key pkcs8_client.key \</span><br><span class="line"> --cacert ca.crt \</span><br><span class="line"> https://127.0.0.1:8443/</span><br></pre></td></tr></table></figure><p>Use <code>output</code> to print response message:</p><h3><span id="dtls-连接请求">dtls 连接请求</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl s_server -CAfile ca.crt -cert server.crt -key pkcs8_server.key -dtls -accept 4739 -verify_return_error -Verify 1</span><br><span class="line">openssl s_client -dtls -CAfile ca.crt -cert client.crt -key pkcs8_client.key -connect 127.0.0.1:4739 -debug</span><br></pre></td></tr></table></figure><p>For windows just using wireshark to capture packet, for linux please type:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i lo -s 0 -w tcpdump.pcap -n udp port 4739 -X</span><br></pre></td></tr></table></figure><p>to up the length to “a lot”, write the data to a file and use host rather than src to capture the data in both directions. Essentially you are missing the word and between src and udp.</p><p>假设实现两套SSL连接，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSLContext factory for handle client connection</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSLContextFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pem证书方式，带有证书和私钥</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLContext <span class="title">generate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Collection&lt;Path&gt; certPaths,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collection&lt;Path&gt; caPaths,</span></span></span><br><span class="line"><span class="params"><span class="function">            Path keyPath,</span></span></span><br><span class="line"><span class="params"><span class="function">            String keyStorePass)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException, IOException </span>&#123;</span><br><span class="line">        List&lt;Certificate&gt; certificate = PemUtils.readCertificates(certPaths);</span><br><span class="line">        PrivateKey privateKey = PemUtils.readPrivateKey(keyPath, keyStorePass::toCharArray);</span><br><span class="line">        List&lt;Certificate&gt; chain = PemUtils.readCertificates(caPaths);</span><br><span class="line">        KeyStore keyStore =</span><br><span class="line">                KeyStoreUtil.buildKeyStore(certificate, privateKey, keyStorePass.toCharArray());</span><br><span class="line">        KeyStore trustKeySore = KeyStoreUtil.buildTrustStore(chain);</span><br><span class="line">        <span class="keyword">return</span> SSLContexts.custom()</span><br><span class="line">                .loadKeyMaterial(keyStore, keyStorePass.toCharArray())</span><br><span class="line">                .loadTrustMaterial(trustKeySore, <span class="keyword">null</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// keystore 方式，用生成的JKS文件(可能是jks、p12、pfx、pkcs12)发起SSLContext</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLContext <span class="title">generate</span><span class="params">(Path keyStorePath, String keyStorePass, String keyStoreType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException, IOException </span>&#123;</span><br><span class="line">        KeyStore trustStore =</span><br><span class="line">                KeyStoreUtil.buildDefaultStore(keyStorePath, keyStorePass::toCharArray, keyStoreType);</span><br><span class="line">        <span class="keyword">return</span> SSLContexts.custom()</span><br><span class="line">                .loadTrustMaterial(trustStore, <span class="keyword">new</span> TrustSelfSignedStrategy())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是对不同的算法的私钥进行检测，解析得出<code>PrivateKey</code>对象；其次是解析证书为<code>Certificate</code>对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PemUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS1_HEADER = <span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS1_FOOTER = <span class="string">&quot;-----END RSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_DSA_HEADER = <span class="string">&quot;-----BEGIN DSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_DSA_FOOTER = <span class="string">&quot;-----END DSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_DSA_PARAMS_HEADER = <span class="string">&quot;-----BEGIN DSA PARAMETERS-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_DSA_PARAMS_FOOTER = <span class="string">&quot;-----END DSA PARAMETERS-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS8_HEADER = <span class="string">&quot;-----BEGIN PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS8_FOOTER = <span class="string">&quot;-----END PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS8_ENCRYPTED_HEADER = <span class="string">&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PKCS8_ENCRYPTED_FOOTER = <span class="string">&quot;-----END ENCRYPTED PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_EC_HEADER = <span class="string">&quot;-----BEGIN EC PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_EC_FOOTER = <span class="string">&quot;-----END EC PRIVATE KEY-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_EC_PARAMS_HEADER = <span class="string">&quot;-----BEGIN EC PARAMETERS-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPENSSL_EC_PARAMS_FOOTER = <span class="string">&quot;-----END EC PARAMETERS-----&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER = <span class="string">&quot;-----BEGIN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PemUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Utility class should not be instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of a file. Supports PKCS#1, PKCS#8 encoded</span></span><br><span class="line"><span class="comment">     * formats of encrypted and plaintext RSA, DSA and EC(secp256r1) keys</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPath the path for the key file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> passwordSupplier A password supplier for the potentially encrypted (password</span></span><br><span class="line"><span class="comment">     *     protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a private key from the contents of the file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PrivateKey <span class="title">readPrivateKey</span><span class="params">(Path keyPath, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader bReader = Files.newBufferedReader(keyPath, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            String line = bReader.readLine();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != line &amp;&amp; !line.startsWith(HEADER)) &#123;</span><br><span class="line">                line = bReader.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                        <span class="string">&quot;Error parsing Private Key [&quot;</span></span><br><span class="line">                                + keyPath.toAbsolutePath()</span><br><span class="line">                                + <span class="string">&quot;], file is empty&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (line.trim()) &#123;</span><br><span class="line">                <span class="keyword">case</span> PKCS8_ENCRYPTED_HEADER:</span><br><span class="line">                    <span class="keyword">char</span>[] password = passwordSupplier.get();</span><br><span class="line">                    <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                                <span class="string">&quot;cannot read encrypted key [&quot;</span></span><br><span class="line">                                        + keyPath.toAbsolutePath()</span><br><span class="line">                                        + <span class="string">&quot;] &quot;</span></span><br><span class="line">                                        + <span class="string">&quot;without a password&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> parsePKCS8Encrypted(bReader, password);</span><br><span class="line">                <span class="keyword">case</span> PKCS8_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parsePKCS8(bReader);</span><br><span class="line">                <span class="keyword">case</span> PKCS1_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parsePKCS1Rsa(bReader, passwordSupplier);</span><br><span class="line">                <span class="keyword">case</span> OPENSSL_DSA_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parseOpenSslDsa(bReader, passwordSupplier);</span><br><span class="line">                <span class="keyword">case</span> OPENSSL_DSA_PARAMS_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parseOpenSslDsa(removeDsaHeaders(bReader), passwordSupplier);</span><br><span class="line">                <span class="keyword">case</span> OPENSSL_EC_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parseOpenSslEC(bReader, passwordSupplier);</span><br><span class="line">                <span class="keyword">case</span> OPENSSL_EC_PARAMS_HEADER:</span><br><span class="line">                    <span class="keyword">return</span> parseOpenSslEC(removeECHeaders(bReader), passwordSupplier);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                            <span class="string">&quot;error parsing Private Key [&quot;</span></span><br><span class="line">                                    + keyPath.toAbsolutePath()</span><br><span class="line">                                    + <span class="string">&quot;], file &quot;</span></span><br><span class="line">                                    + <span class="string">&quot;does not contain a supported key format&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException | NoSuchFileException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;private key file [&quot;</span> + keyPath.toAbsolutePath() + <span class="string">&quot;] does not exist&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;private key file [&quot;</span> + keyPath.toAbsolutePath() + <span class="string">&quot;] cannot be parsed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the EC Headers that OpenSSL adds to EC private keys as the information in them is</span></span><br><span class="line"><span class="comment">     * redundant</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the EC Parameter footer is missing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BufferedReader <span class="title">removeECHeaders</span><span class="params">(BufferedReader bReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OPENSSL_EC_PARAMS_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, EC Parameters footer is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Verify that the key starts with the correct header before passing it to parseOpenSslEC</span></span><br><span class="line">        <span class="keyword">if</span> (!OPENSSL_EC_HEADER.equals(bReader.readLine())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, EC Key header is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the DSA Params Headers that OpenSSL adds to DSA private keys as the information in</span></span><br><span class="line"><span class="comment">     * them is redundant</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the EC Parameter footer is missing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BufferedReader <span class="title">removeDsaHeaders</span><span class="params">(BufferedReader bReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OPENSSL_DSA_PARAMS_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, DSA Parameters footer is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Verify that the key starts with the correct header before passing it to parseOpenSslDsa</span></span><br><span class="line">        <span class="keyword">if</span> (!OPENSSL_DSA_HEADER.equals(bReader.readLine())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, DSA Key header is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of &#123;<span class="doctag">@code</span> bReader&#125; that contains an plaintext</span></span><br><span class="line"><span class="comment">     * private key encoded in PKCS#8</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bReader the &#123;<span class="doctag">@link</span> BufferedReader&#125; containing the key file contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PrivateKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the file can&#x27;t be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the private key can&#x27;t be generated from the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     PKCS8EncodedKeySpec&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">parsePKCS8</span><span class="params">(BufferedReader bReader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PKCS8_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(line.trim());</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, PEM footer is invalid or missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.getDecoder().decode(sb.toString());</span><br><span class="line">        String keyAlgo = getKeyAlgorithmIdentifier(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of &#123;<span class="doctag">@code</span> bReader&#125; that contains an EC private</span></span><br><span class="line"><span class="comment">     * key encoded in OpenSSL traditional format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bReader the &#123;<span class="doctag">@link</span> BufferedReader&#125; containing the key file contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> passwordSupplier A password supplier for the potentially encrypted (password</span></span><br><span class="line"><span class="comment">     *     protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PrivateKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the file can&#x27;t be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the private key can&#x27;t be generated from the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     ECPrivateKeySpec&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">parseOpenSslEC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            BufferedReader bReader, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        Map&lt;String, String&gt; pemHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OPENSSL_EC_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Parse PEM headers according to https://www.ietf.org/rfc/rfc1421.txt</span></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">                String[] header = line.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                pemHeaders.put(header[<span class="number">0</span>].trim(), header[<span class="number">1</span>].trim());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(line.trim());</span><br><span class="line">            &#125;</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, PEM footer is invalid or missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">&quot;EC&quot;</span>);</span><br><span class="line">        ECPrivateKeySpec ecSpec = parseEcDer(keyBytes);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(ecSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of &#123;<span class="doctag">@code</span> bReader&#125; that contains an RSA</span></span><br><span class="line"><span class="comment">     * private key encoded in OpenSSL traditional format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bReader the &#123;<span class="doctag">@link</span> BufferedReader&#125; containing the key file contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> passwordSupplier A password supplier for the potentially encrypted (password</span></span><br><span class="line"><span class="comment">     *     protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PrivateKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the file can&#x27;t be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the private key can&#x27;t be generated from the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     RSAPrivateCrtKeySpec&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">parsePKCS1Rsa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            BufferedReader bReader, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        Map&lt;String, String&gt; pemHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PKCS1_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="comment">// Unencrypted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Parse PEM headers according to https://www.ietf.org/rfc/rfc1421.txt</span></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">                String[] header = line.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                pemHeaders.put(header[<span class="number">0</span>].trim(), header[<span class="number">1</span>].trim());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(line.trim());</span><br><span class="line">            &#125;</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, PEM footer is invalid or missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier);</span><br><span class="line">        RSAPrivateCrtKeySpec spec = parseRsaDer(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of &#123;<span class="doctag">@code</span> bReader&#125; that contains an DSA</span></span><br><span class="line"><span class="comment">     * private key encoded in OpenSSL traditional format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bReader the &#123;<span class="doctag">@link</span> BufferedReader&#125; containing the key file contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> passwordSupplier A password supplier for the potentially encrypted (password</span></span><br><span class="line"><span class="comment">     *     protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PrivateKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the file can&#x27;t be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the private key can&#x27;t be generated from the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     DSAPrivateKeySpec&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">parseOpenSslDsa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            BufferedReader bReader, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        Map&lt;String, String&gt; pemHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (OPENSSL_DSA_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="comment">// Unencrypted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Parse PEM headers according to https://www.ietf.org/rfc/rfc1421.txt</span></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">                String[] header = line.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                pemHeaders.put(header[<span class="number">0</span>].trim(), header[<span class="number">1</span>].trim());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(line.trim());</span><br><span class="line">            &#125;</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, PEM footer is invalid or missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = possiblyDecryptPKCS1Key(pemHeaders, sb.toString(), passwordSupplier);</span><br><span class="line">        DSAPrivateKeySpec spec = parseDsaDer(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> PrivateKey&#125; from the contents of &#123;<span class="doctag">@code</span> bReader&#125; that contains an encrypted</span></span><br><span class="line"><span class="comment">     * private key encoded in PKCS#8</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bReader the &#123;<span class="doctag">@link</span> BufferedReader&#125; containing the key file contents</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPassword The password for the encrypted (password protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PrivateKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the file can&#x27;t be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the private key can&#x27;t be generated from the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     PKCS8EncodedKeySpec&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">parsePKCS8Encrypted</span><span class="params">(BufferedReader bReader, <span class="keyword">char</span>[] keyPassword)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = bReader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PKCS8_ENCRYPTED_FOOTER.equals(line.trim())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(line.trim());</span><br><span class="line">            line = bReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == line) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, PEM footer is invalid or missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.getDecoder().decode(sb.toString());</span><br><span class="line"></span><br><span class="line">        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = <span class="keyword">new</span> EncryptedPrivateKeyInfo(keyBytes);</span><br><span class="line">        SecretKeyFactory secretKeyFactory =</span><br><span class="line">                SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());</span><br><span class="line">        SecretKey secretKey = secretKeyFactory.generateSecret(<span class="keyword">new</span> PBEKeySpec(keyPassword));</span><br><span class="line">        Arrays.fill(keyPassword, <span class="string">&#x27;\u0000&#x27;</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters());</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = encryptedPrivateKeyInfo.getKeySpec(cipher);</span><br><span class="line">        String keyAlgo = getKeyAlgorithmIdentifier(keySpec.getEncoded());</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decrypts the password protected contents using the algorithm and IV that is specified in the</span></span><br><span class="line"><span class="comment">     * PEM Headers of the file</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pemHeaders The Proc-Type and DEK-Info PEM headers that have been extracted from the</span></span><br><span class="line"><span class="comment">     *     key file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyContents The key as a base64 encoded String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> passwordSupplier A password supplier for the encrypted (password protected) key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the decrypted key bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the key can&#x27;t be decrypted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the PEM headers are missing or malformed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] possiblyDecryptPKCS1Key(</span><br><span class="line">            Map&lt;String, String&gt; pemHeaders, String keyContents, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException, IOException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.getDecoder().decode(keyContents);</span><br><span class="line">        String procType = pemHeaders.get(<span class="string">&quot;Proc-Type&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;4,ENCRYPTED&quot;</span>.equals(procType)) &#123;</span><br><span class="line">            <span class="comment">// We only handle PEM encryption</span></span><br><span class="line">            String encryptionParameters = pemHeaders.get(<span class="string">&quot;DEK-Info&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == encryptionParameters) &#123;</span><br><span class="line">                <span class="comment">// malformed pem</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM File, DEK-Info header is missing&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span>[] password = passwordSupplier.get();</span><br><span class="line">            <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;cannot read encrypted key without a password&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Cipher cipher = getCipherFromParameters(encryptionParameters, password);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(keyBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> Cipher&#125; from the contents of the DEK-Info header of a PEM file. RFC 1421</span></span><br><span class="line"><span class="comment">     * indicates that supported algorithms are defined in RFC 1423. RFC 1423 only defines DES-CBS</span></span><br><span class="line"><span class="comment">     * and triple DES (EDE) in CBC mode. AES in CBC mode is also widely used though ( 3 different</span></span><br><span class="line"><span class="comment">     * variants of 128, 192, 256 bit keys )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dekHeaderValue The value of the DEK-Info PEM header</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password The password with which the key is encrypted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a cipher of the appropriate algorithm and parameters to be used for decryption</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the algorithm is not available in the used security</span></span><br><span class="line"><span class="comment">     *     provider, or if the key is inappropriate for the cipher</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the DEK-Info PEM header is invalid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Cipher <span class="title">getCipherFromParameters</span><span class="params">(String dekHeaderValue, <span class="keyword">char</span>[] password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String padding = <span class="string">&quot;PKCS5Padding&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> SecretKey encryptionKey;</span><br><span class="line">        <span class="keyword">final</span> String[] valueTokens = dekHeaderValue.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (valueTokens.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, DEK-Info PEM header is invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String algorithm = valueTokens[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> String ivString = valueTokens[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] iv;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            iv = hexStringToByteArray(ivString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Malformed PEM file, DEK-Info IV is invalid&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;DES-CBC&quot;</span>.equals(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] key = generateOpenSslKey(password, iv, <span class="number">8</span>);</span><br><span class="line">            encryptionKey = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DES-EDE3-CBC&quot;</span>.equals(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] key = generateOpenSslKey(password, iv, <span class="number">24</span>);</span><br><span class="line">            encryptionKey = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AES-128-CBC&quot;</span>.equals(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] key = generateOpenSslKey(password, iv, <span class="number">16</span>);</span><br><span class="line">            encryptionKey = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AES-192-CBC&quot;</span>.equals(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] key = generateOpenSslKey(password, iv, <span class="number">24</span>);</span><br><span class="line">            encryptionKey = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AES-256-CBC&quot;</span>.equals(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] key = generateOpenSslKey(password, iv, <span class="number">32</span>);</span><br><span class="line">            encryptionKey = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GeneralSecurityException(</span><br><span class="line">                    <span class="string">&quot;Private Key encrypted with unsupported algorithm [&quot;</span> + algorithm + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String transformation = encryptionKey.getAlgorithm() + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;CBC&quot;</span> + <span class="string">&quot;/&quot;</span> + padding;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, encryptionKey, <span class="keyword">new</span> IvParameterSpec(iv));</span><br><span class="line">        <span class="keyword">return</span> cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs key stretching in the same manner that OpenSSL does. This is basically a KDF that</span></span><br><span class="line"><span class="comment">     * uses n rounds of salted MD5 (as many times as needed to get the necessary number of key</span></span><br><span class="line"><span class="comment">     * bytes)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;https://www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_PrivateKey_traditional.html</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateOpenSslKey(<span class="keyword">char</span>[] password, <span class="keyword">byte</span>[] salt, <span class="keyword">int</span> keyLength) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] passwordBytes = toUtf8Bytes(password);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md5 = MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[keyLength];</span><br><span class="line">            <span class="keyword">int</span> copied = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> remaining;</span><br><span class="line">            <span class="keyword">while</span> (copied &lt; keyLength) &#123;</span><br><span class="line">                remaining = keyLength - copied;</span><br><span class="line">                md5.update(passwordBytes, <span class="number">0</span>, passwordBytes.length);</span><br><span class="line">                md5.update(salt, <span class="number">0</span>, <span class="number">8</span>); <span class="comment">// AES IV (salt) is longer but we only need 8 bytes</span></span><br><span class="line">                <span class="keyword">byte</span>[] tempDigest = md5.digest();</span><br><span class="line">                <span class="keyword">int</span> bytesToCopy = Math.min(remaining, <span class="number">16</span>); <span class="comment">// MD5 digests are 16 bytes</span></span><br><span class="line">                System.arraycopy(tempDigest, <span class="number">0</span>, key, copied, bytesToCopy);</span><br><span class="line">                copied += bytesToCopy;</span><br><span class="line">                <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                md5.update(tempDigest, <span class="number">0</span>, <span class="number">16</span>); <span class="comment">// use previous round digest as IV</span></span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.fill(passwordBytes, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;unexpected exception creating MessageDigest instance for [md5]&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toUtf8Bytes(<span class="keyword">char</span>[] chars) &#123;</span><br><span class="line">        <span class="keyword">final</span> CharBuffer charBuffer = CharBuffer.wrap(chars);</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(charBuffer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">if</span> (byteBuffer.hasArray()) &#123;</span><br><span class="line">            <span class="comment">// there is no guarantee that the byte buffers backing array is the right size</span></span><br><span class="line">            <span class="comment">// so we need to make a copy</span></span><br><span class="line">            bytes =</span><br><span class="line">                    Arrays.copyOfRange(</span><br><span class="line">                            byteBuffer.array(), byteBuffer.position(), byteBuffer.limit());</span><br><span class="line">            Arrays.fill(byteBuffer.array(), (<span class="keyword">byte</span>) <span class="number">0</span>); <span class="comment">// clear sensitive data</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> length = byteBuffer.limit() - byteBuffer.position();</span><br><span class="line">            bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            byteBuffer.get(bytes);</span><br><span class="line">            <span class="comment">// if the buffer is not read only we can reset and fill with 0&#x27;s</span></span><br><span class="line">            <span class="keyword">if</span> (!byteBuffer.isReadOnly()) &#123;</span><br><span class="line">                byteBuffer.clear(); <span class="comment">// reset</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuffer.limit(); i++) &#123;</span><br><span class="line">                    byteBuffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Converts a hexadecimal string to a byte array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStringToByteArray(String hexString) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = hexString.length();</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> k = Character.digit(hexString.charAt(i), <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> l = Character.digit(hexString.charAt(i + <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (k == -<span class="number">1</span> || l == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            <span class="string">&quot;String [&quot;</span> + hexString + <span class="string">&quot;] is not hexadecimal&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                data[i / <span class="number">2</span>] = (<span class="keyword">byte</span>) ((k &lt;&lt; <span class="number">4</span>) + l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;Hexadecimal string [&quot;</span></span><br><span class="line">                            + hexString</span><br><span class="line">                            + <span class="string">&quot;] has odd length and cannot be converted to a byte array&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses a DER encoded EC key to an &#123;<span class="doctag">@link</span> ECPrivateKeySpec&#125; using a minimal &#123;<span class="doctag">@link</span> DerParser&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes the private key raw bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ECPrivateKeySpec&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the DER encoded key can&#x27;t be parsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ECPrivateKeySpec <span class="title">parseEcDer</span><span class="params">(<span class="keyword">byte</span>[] keyBytes)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        DerParser parser = <span class="keyword">new</span> DerParser(keyBytes);</span><br><span class="line">        DerParser.Asn1Object sequence = parser.readAsn1Object();</span><br><span class="line">        parser = sequence.getParser();</span><br><span class="line">        parser.readAsn1Object().getInteger(); <span class="comment">// version</span></span><br><span class="line">        String keyHex = parser.readAsn1Object().getString();</span><br><span class="line">        BigInteger privateKeyInt = <span class="keyword">new</span> BigInteger(keyHex, <span class="number">16</span>);</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">&quot;EC&quot;</span>);</span><br><span class="line">        AlgorithmParameterSpec prime256v1ParamSpec = <span class="keyword">new</span> ECGenParameterSpec(<span class="string">&quot;secp256r1&quot;</span>);</span><br><span class="line">        keyPairGenerator.initialize(prime256v1ParamSpec);</span><br><span class="line">        ECParameterSpec parameterSpec =</span><br><span class="line">                ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ECPrivateKeySpec(privateKeyInt, parameterSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses a DER encoded RSA key to a &#123;<span class="doctag">@link</span> RSAPrivateCrtKeySpec&#125; using a minimal &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * DerParser&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes the private key raw bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> RSAPrivateCrtKeySpec&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the DER encoded key can&#x27;t be parsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RSAPrivateCrtKeySpec <span class="title">parseRsaDer</span><span class="params">(<span class="keyword">byte</span>[] keyBytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DerParser parser = <span class="keyword">new</span> DerParser(keyBytes);</span><br><span class="line">        DerParser.Asn1Object sequence = parser.readAsn1Object();</span><br><span class="line">        parser = sequence.getParser();</span><br><span class="line">        parser.readAsn1Object()</span><br><span class="line">                .getInteger(); <span class="comment">// (version) We don&#x27;t need it but must read to get to modulus</span></span><br><span class="line">        BigInteger modulus = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger publicExponent = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger privateExponent = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger prime1 = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger prime2 = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger exponent1 = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger exponent2 = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger coefficient = parser.readAsn1Object().getInteger();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RSAPrivateCrtKeySpec(</span><br><span class="line">                modulus,</span><br><span class="line">                publicExponent,</span><br><span class="line">                privateExponent,</span><br><span class="line">                prime1,</span><br><span class="line">                prime2,</span><br><span class="line">                exponent1,</span><br><span class="line">                exponent2,</span><br><span class="line">                coefficient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses a DER encoded DSA key to a &#123;<span class="doctag">@link</span> DSAPrivateKeySpec&#125; using a minimal &#123;<span class="doctag">@link</span> DerParser&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes the private key raw bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DSAPrivateKeySpec&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the DER encoded key can&#x27;t be parsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DSAPrivateKeySpec <span class="title">parseDsaDer</span><span class="params">(<span class="keyword">byte</span>[] keyBytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DerParser parser = <span class="keyword">new</span> DerParser(keyBytes);</span><br><span class="line">        DerParser.Asn1Object sequence = parser.readAsn1Object();</span><br><span class="line">        parser = sequence.getParser();</span><br><span class="line">        parser.readAsn1Object()</span><br><span class="line">                .getInteger(); <span class="comment">// (version) We don&#x27;t need it but must read to get to p</span></span><br><span class="line">        BigInteger p = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger q = parser.readAsn1Object().getInteger();</span><br><span class="line">        BigInteger g = parser.readAsn1Object().getInteger();</span><br><span class="line">        parser.readAsn1Object().getInteger(); <span class="comment">// we don&#x27;t need x</span></span><br><span class="line">        BigInteger x = parser.readAsn1Object().getInteger();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DSAPrivateKeySpec(x, p, q, g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parses a DER encoded private key and reads its algorithm identifier Object OID.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes the private key raw bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A string identifier for the key algorithm (RSA, DSA, or EC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GeneralSecurityException if the algorithm oid that is parsed from ASN.1 is unknown</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if the DER encoded key can&#x27;t be parsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getKeyAlgorithmIdentifier</span><span class="params">(<span class="keyword">byte</span>[] keyBytes)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, GeneralSecurityException </span>&#123;</span><br><span class="line">        DerParser parser = <span class="keyword">new</span> DerParser(keyBytes);</span><br><span class="line">        DerParser.Asn1Object sequence = parser.readAsn1Object();</span><br><span class="line">        parser = sequence.getParser();</span><br><span class="line">        parser.readAsn1Object().getInteger(); <span class="comment">// version</span></span><br><span class="line">        DerParser.Asn1Object algSequence = parser.readAsn1Object();</span><br><span class="line">        parser = algSequence.getParser();</span><br><span class="line">        String oidString = parser.readAsn1Object().getOid();</span><br><span class="line">        <span class="keyword">switch</span> (oidString) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1.2.840.10040.4.1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;DSA&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1.2.840.113549.1.1.1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1.2.840.10045.2.1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;EC&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GeneralSecurityException(</span><br><span class="line">                <span class="string">&quot;Error parsing key algorithm identifier. Algorithm with OID [&quot;</span></span><br><span class="line">                        + oidString</span><br><span class="line">                        + <span class="string">&quot;] is not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Certificate&gt; <span class="title">readCertificates</span><span class="params">(Collection&lt;Path&gt; certPaths)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CertificateException, IOException </span>&#123;</span><br><span class="line">        CertificateFactory certFactory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">        List&lt;Certificate&gt; certificates = <span class="keyword">new</span> ArrayList&lt;&gt;(certPaths.size());</span><br><span class="line">        <span class="keyword">for</span> (Path path : certPaths) &#123;</span><br><span class="line">            <span class="keyword">try</span> (InputStream input = Files.newInputStream(path)) &#123;</span><br><span class="line">                <span class="keyword">final</span> Collection&lt;? extends Certificate&gt; parsed =</span><br><span class="line">                        certFactory.generateCertificates(input);</span><br><span class="line">                <span class="keyword">if</span> (parsed.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                            <span class="string">&quot;failed to parse any certificates from [&quot;</span></span><br><span class="line">                                    + path.toAbsolutePath()</span><br><span class="line">                                    + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                certificates.addAll(parsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> certificates;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接下来要对keystore的SSLContext进行解析，</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KeyStoreUtil for handle &#123;<span class="doctag">@link</span> SSLContext&#125; storage facility</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyStoreUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KeyStoreUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Utility class should not be instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">inferKeyStoreType</span><span class="params">(Path path)</span> </span>&#123;</span><br><span class="line">        String name = path == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : path.toString().toLowerCase(Locale.ROOT);</span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.p12&quot;</span>) || name.endsWith(<span class="string">&quot;.pfx&quot;</span>) || name.endsWith(<span class="string">&quot;.pkcs12&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;PKCS12&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;jks&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">readKeyStore</span><span class="params">(Path path, String type, <span class="keyword">char</span>[] password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Files.notExists(path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;cannot read a [&quot;</span></span><br><span class="line">                            + type</span><br><span class="line">                            + <span class="string">&quot;] keystore from [&quot;</span></span><br><span class="line">                            + path.toAbsolutePath()</span><br><span class="line">                            + <span class="string">&quot;] because the file does not exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(type);</span><br><span class="line">            <span class="keyword">try</span> (InputStream in = Files.newInputStream(path)) &#123;</span><br><span class="line">                keyStore.load(in, password);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> keyStore;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;cannot read a [&quot;</span></span><br><span class="line">                            + type</span><br><span class="line">                            + <span class="string">&quot;] keystore from [&quot;</span></span><br><span class="line">                            + path.toAbsolutePath()</span><br><span class="line">                            + <span class="string">&quot;] - &quot;</span></span><br><span class="line">                            + e.getMessage(),</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct an in-memory keystore with a single key entry. */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">buildKeyStore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Collection&lt;Certificate&gt; certificateChain, PrivateKey privateKey, <span class="keyword">char</span>[] password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        KeyStore keyStore = buildNewKeyStore();</span><br><span class="line">        keyStore.setKeyEntry(</span><br><span class="line">                <span class="string">&quot;key&quot;</span>, privateKey, password, certificateChain.toArray(<span class="keyword">new</span> Certificate[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> keyStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct an in-memory keystore with multiple trusted cert entries. */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">buildTrustStore</span><span class="params">(Iterable&lt;Certificate&gt; certificates)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> certificates != <span class="keyword">null</span> : <span class="string">&quot;Cannot create keystore with null certificates&quot;</span>;</span><br><span class="line">        KeyStore store = buildNewKeyStore();</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Certificate certificate : certificates) &#123;</span><br><span class="line">            store.setCertificateEntry(<span class="string">&quot;cert-&quot;</span> + counter, certificate);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">buildDefaultStore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Path keyStorePath, Supplier&lt;<span class="keyword">char</span>[]&gt; passwordSupplier, String keyStoreType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> GeneralSecurityException, IOException </span>&#123;</span><br><span class="line">        KeyStore keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">        keyStore.load(</span><br><span class="line">                (keyStorePath.getFileSystem().provider().newInputStream(keyStorePath)),</span><br><span class="line">                passwordSupplier.get());</span><br><span class="line">        <span class="keyword">return</span> keyStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> KeyStore <span class="title">buildNewKeyStore</span><span class="params">()</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyStore.load(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                    <span class="string">&quot;Unexpected error initializing a new in-memory keystore&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> X509ExtendedKeyManager&#125; based on the key material in the provided &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * KeyStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> X509ExtendedKeyManager <span class="title">createKeyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            KeyStore keyStore, <span class="keyword">char</span>[] password, String algorithm)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);</span><br><span class="line">        kmf.init(keyStore, password);</span><br><span class="line">        KeyManager[] keyManagers = kmf.getKeyManagers();</span><br><span class="line">        <span class="keyword">for</span> (KeyManager keyManager : keyManagers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyManager <span class="keyword">instanceof</span> X509ExtendedKeyManager) &#123;</span><br><span class="line">                <span class="keyword">return</span> (X509ExtendedKeyManager) keyManager;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                <span class="string">&quot;failed to find a X509ExtendedKeyManager in the key manager factory for [&quot;</span></span><br><span class="line">                        + algorithm</span><br><span class="line">                        + <span class="string">&quot;] and keystore [&quot;</span></span><br><span class="line">                        + keyStore</span><br><span class="line">                        + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> X509ExtendedTrustManager&#125; based on the trust material in the provided &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * KeyStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> X509ExtendedTrustManager <span class="title">createTrustManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> KeyStore trustStore, String algorithm)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchAlgorithmException, KeyStoreException </span>&#123;</span><br><span class="line">        TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);</span><br><span class="line">        tmf.init(trustStore);</span><br><span class="line">        TrustManager[] trustManagers = tmf.getTrustManagers();</span><br><span class="line">        <span class="keyword">for</span> (TrustManager trustManager : trustManagers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trustManager <span class="keyword">instanceof</span> X509ExtendedTrustManager) &#123;</span><br><span class="line">                <span class="keyword">return</span> (X509ExtendedTrustManager) trustManager;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SslConfigException(</span><br><span class="line">                <span class="string">&quot;failed to find a X509ExtendedTrustManager in the trust manager factory for [&quot;</span></span><br><span class="line">                        + algorithm</span><br><span class="line">                        + <span class="string">&quot;] and truststore [&quot;</span></span><br><span class="line">                        + trustStore</span><br><span class="line">                        + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>读取的私钥是个ASN.1数据，解析其内容：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A bare-minimum ASN.1 DER decoder, just having enough functions to decode PKCS#1 private keys in</span></span><br><span class="line"><span class="comment"> * order to remain JCE/JVM agnostic.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Based on https://github.com/groovenauts/jmeter_oauth_plugin/blob/master/jmeter/src/</span></span><br><span class="line"><span class="comment"> * main/java/org/apache/jmeter/protocol/oauth/sampler/PrivateKeyReader.java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DerParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Constructed Flag</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTRUCTED = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tag and data types</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTEGER = <span class="number">0x02</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OCTET_STRING = <span class="number">0x04</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OBJECT_OID = <span class="number">0x06</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMERIC_STRING = <span class="number">0x12</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRINTABLE_STRING = <span class="number">0x13</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIDEOTEX_STRING = <span class="number">0x15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IA5_STRING = <span class="number">0x16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GRAPHIC_STRING = <span class="number">0x19</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ISO646_STRING = <span class="number">0x1A</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GENERAL_STRING = <span class="number">0x1B</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UTF8_STRING = <span class="number">0x0C</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNIVERSAL_STRING = <span class="number">0x1C</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BMP_STRING = <span class="number">0x1E</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream derInputStream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxAsnObjectLength;</span><br><span class="line"></span><br><span class="line">    DerParser(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="keyword">this</span>.derInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        <span class="keyword">this</span>.maxAsnObjectLength = bytes.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Asn1Object <span class="title">readAsn1Object</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tag = derInputStream.read();</span><br><span class="line">        <span class="keyword">if</span> (tag == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: stream too short, missing tag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line">        <span class="comment">// getLength() can return any 32 bit integer, so ensure that a corrupted encoding won&#x27;t</span></span><br><span class="line">        <span class="comment">// force us into allocating a very large array</span></span><br><span class="line">        <span class="keyword">if</span> (length &gt; maxAsnObjectLength) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                    <span class="string">&quot;Invalid DER: size of ASN.1 object to be parsed appears to be larger than the size of the key file &quot;</span></span><br><span class="line">                            + <span class="string">&quot;itself.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] value = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        <span class="keyword">int</span> n = derInputStream.read(value);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                    <span class="string">&quot;Invalid DER: stream too short, missing value. &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Could only read &quot;</span></span><br><span class="line">                            + n</span><br><span class="line">                            + <span class="string">&quot; out of &quot;</span></span><br><span class="line">                            + length</span><br><span class="line">                            + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Asn1Object(tag, length, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decode the length of the field. Can only support length encoding up to 4 octets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In BER/DER encoding, length can be encoded in 2 forms:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;Short form. One octet. Bit 8 has value &quot;0&quot; and bits 7-1 give the length.</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;Long form. Two to 127 octets (only 4 is supported here). Bit 8 of first octet has value</span></span><br><span class="line"><span class="comment">     *       &quot;1&quot; and bits 7-1 give the number of additional length octets. Second and following</span></span><br><span class="line"><span class="comment">     *       octets give the length, base 256, most significant digit first.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The length as integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = derInputStream.read();</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: length missing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A single byte short length</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; ~<span class="number">0x7F</span>) == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = i &amp; <span class="number">0x7F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can&#x27;t handle length longer than 4 bytes</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0xFF</span> || num &gt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: length field too big (&quot;</span> + i + <span class="string">&quot;)&quot;</span>); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[num];</span><br><span class="line">        <span class="keyword">int</span> n = derInputStream.read(bytes);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; num) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: length too short&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="number">1</span>, bytes).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An ASN.1 TLV. The object is not parsed. It can only handle integers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Asn1Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> tag;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a ASN.1 TLV. The TLV could be either a constructed or primitive entity.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;The first byte in DER encoding is made of following fields:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         * -------------------------------------------------</span></span><br><span class="line"><span class="comment">         * |Bit 8|Bit 7|Bit 6|Bit 5|Bit 4|Bit 3|Bit 2|Bit 1|</span></span><br><span class="line"><span class="comment">         * -------------------------------------------------</span></span><br><span class="line"><span class="comment">         * |  Class    | CF  |     +      Type             |</span></span><br><span class="line"><span class="comment">         * -------------------------------------------------</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;Class: Universal, Application, Context or Private</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;CF: Constructed flag. If 1, the field is constructed.</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;Type: This is actually called tag in ASN.1. It indicates data type (Integer,</span></span><br><span class="line"><span class="comment">         *       String) or a construct (sequence, choice, set).</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tag Tag or Identifier</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> length Length of the field</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value Encoded octet string for the field.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Asn1Object(<span class="keyword">int</span> tag, <span class="keyword">int</span> length, <span class="keyword">byte</span>[] value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">            <span class="keyword">this</span>.type = tag &amp; <span class="number">0x1F</span>;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] getValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConstructed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (tag &amp; DerParser.CONSTRUCTED) == DerParser.CONSTRUCTED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * For constructed field, return a parser for its content.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> A parser for the construct.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DerParser <span class="title">getParser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isConstructed())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: can&#x27;t parse primitive entity&quot;</span>); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DerParser(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Get the value as integer</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> BigInteger</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">getInteger</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (type != DerParser.INTEGER)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: object is not integer&quot;</span>); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            String encoding;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> DerParser.OCTET_STRING:</span><br><span class="line">                    <span class="comment">// octet string is basically a byte array</span></span><br><span class="line">                    <span class="keyword">return</span> toHexString(value);</span><br><span class="line">                <span class="keyword">case</span> DerParser.NUMERIC_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.PRINTABLE_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.VIDEOTEX_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.IA5_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.GRAPHIC_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.ISO646_STRING:</span><br><span class="line">                <span class="keyword">case</span> DerParser.GENERAL_STRING:</span><br><span class="line">                    encoding = <span class="string">&quot;ISO-8859-1&quot;</span>; <span class="comment">// $NON-NLS-1$</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> DerParser.BMP_STRING:</span><br><span class="line">                    encoding = <span class="string">&quot;UTF-16BE&quot;</span>; <span class="comment">// $NON-NLS-1$</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> DerParser.UTF8_STRING:</span><br><span class="line">                    encoding = <span class="string">&quot;UTF-8&quot;</span>; <span class="comment">// $NON-NLS-1$</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> DerParser.UNIVERSAL_STRING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: can&#x27;t handle UCS-4 string&quot;</span>); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid DER: object is not a string&quot;</span>); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(value, encoding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getOid</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != DerParser.OBJECT_OID) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Ivalid DER: object is not object OID&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">64</span>);</span><br><span class="line">            <span class="keyword">switch</span> (value[<span class="number">0</span>] / <span class="number">40</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    sb.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                    value[<span class="number">0</span>] -= <span class="number">40</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                    value[<span class="number">0</span>] -= <span class="number">80</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> oidPart = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                oidPart = (oidPart &lt;&lt; <span class="number">7</span>) + (value[i] &amp; <span class="number">0x7F</span>);</span><br><span class="line">                <span class="keyword">if</span> ((value[i] &amp; <span class="number">0x80</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    sb.append(oidPart);</span><br><span class="line">                    oidPart = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(bytes);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">2</span> * bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            sb.append(HEX_DIGITS[b &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>]).append(HEX_DIGITS[b &amp; <span class="number">0xf</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>要对其内容进行测试，我们可以模拟一个服务端：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Server;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpsMockServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configConnectors</span><span class="params">(Server mockServer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//config ssl</span></span><br><span class="line">        URL url = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;server.keystore.jks&quot;</span>);</span><br><span class="line">        SslContextFactory sslContextFactory = <span class="keyword">new</span> SslContextFactory();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = java.net.URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8.name());</span><br><span class="line">            sslContextFactory.setKeyStorePath(path);</span><br><span class="line">            sslContextFactory.setKeyStorePassword(<span class="string">&quot;ericsson&quot;</span>);</span><br><span class="line">            sslContextFactory.setKeyManagerPassword(<span class="string">&quot;ericsson&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpConfiguration httpsConfig = <span class="keyword">new</span> HttpConfiguration();</span><br><span class="line">        httpsConfig.setSecurePort(HTTPS_PORT);</span><br><span class="line">        httpsConfig.setSecureScheme(<span class="string">&quot;https&quot;</span>);</span><br><span class="line">        httpsConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());</span><br><span class="line"></span><br><span class="line">        ServerConnector sslConnector = <span class="keyword">new</span> ServerConnector(mockServer, <span class="keyword">new</span> SslConnectionFactory(sslContextFactory,</span><br><span class="line">                HttpVersion.HTTP_1_1.asString()), <span class="keyword">new</span> HttpConnectionFactory(httpsConfig));</span><br><span class="line">        sslConnector.setPort(HTTPS_PORT);</span><br><span class="line">        mockServer.addConnector(sslConnector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用我们分别用客户端生成的<code>client.keystore.jks</code>和<code>client.crt/client.key</code>进行测试即可。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> certificate </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于新型数字化技术架构的讨论</title>
      <link href="/2020/06/12/philosophy/architecture-retrospective-1/"/>
      <url>/2020/06/12/philosophy/architecture-retrospective-1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1><span id="历史限制">历史限制</span></h1><p>dubbo</p><p>reactive</p><p>spring boot cloud 已经过于冗杂，go语言大靠山k8s</p><p>SaaS —&gt; Cloud native 云生态</p><h1><span id="5g出现意味着什么">5G出现意味着什么？</span></h1><h1><span id="未来">未来</span></h1><p>reactive elastic resilience</p><p>职业将面向全栈，不再区分DBA、后台、前端、运维和开发融合一体。</p><p>应用开发将缩减到20分钟生产一个交互产品。</p><p>云计算将不再由Hadoop体系统治，出现新的计算模型，例如 Akka + Kubernetes</p><h1><span id="我们还能干啥">我们还能干啥</span></h1><p>摒弃原有的架构（阿里云最近重组自救）</p><p>创新、创造力（编程语言百家争鸣）</p><p>云原生</p>]]></content>
      
      
      
        <tags>
            
            <tag> 5g </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单构建的自动化devOps方案</title>
      <link href="/2020/03/27/ci/devops-ha-design/"/>
      <url>/2020/03/27/ci/devops-ha-design/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="流程架构图">流程架构图</span></h2><p><img src="/img/ci/devops.png" alt></p><p>简单设计了一套自动化devOps方案，其中有两个分支：</p><ul><li><p>jenkins分支，部署在公司内部开发服务器上。用于生产环境，由jenkins搭载一套CI/CD。开发完程序代码后，提交，触发构建、检查、单元测试、质量评估。之后推送到测试服务器，提供给测试人员进行功能测试。如果有问题，反馈给开发人员；如果功能点收集完善，通知teamcity分支。</p></li><li><p>teamcity分支，运营和项目负责人收集到功能点后，手动触发teamcity自动构建，推送镜像到harbor。邮件通知项目实施负责人。实施负责人收集功能点、汇报信息，更新k8s服务镜像，推送服务、进行灰度发布、之后上线、若有问题、回滚…</p></li></ul><p><img src="/img/ci/M2WIQ.png" alt></p><h2><span id="系统配置">系统配置</span></h2><p>安装系统监控</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --tls --name grafana --namespace monitoring -f grafana-settings.yaml -f grafana-dashboards.yaml grafana</span><br></pre></td></tr></table></figure><p>安装harbor</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --wait --name harbor --namespace kube-system harbor/harbor --set persistence.enabled=false --set expose.type=nodePort --set externalURL=&quot;https://harbor.cplier.com&quot; --set expose.ingress.hosts.core=harbor.cplier.com --set expose.tls.enabled=false --set proxy.httpProxy=&#x27;http://harbor.cplier.com&#x27; --set proxy.httpsProxy=&#x27;https://harbor.cplier.com&#x27;</span><br></pre></td></tr></table></figure><p>安装k9s，查看部署和服务情况</p><p><img src="/img/ci/k9s.png" alt></p><p>设置外部代理</p><p>nginx设置负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream harbor &#123;</span><br><span class="line">    server 192.168.0.160:30002;</span><br><span class="line">    server 192.168.0.125:30002;</span><br><span class="line">    server 192.168.0.56:30002;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name harbor.cplier.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">       proxy_pass http://harbor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name harbor.cplier.com;</span><br><span class="line">    ssl_certificate cert/1_harbor.cplier.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key cert/2_harbor.cplier.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        client_max_body_size 1000m;</span><br><span class="line">        proxy_pass http://harbor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>teamcity配置好参数后，触发构建。</p><p><img src="/img/ci/teamcity.png" alt></p><p>在k8s集群中，编写相应的service，进行部署，写pvc、配ingress、配字典… what ever…</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">cplier-gateway</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">cplier-gateway</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">cplier-gateway</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">harbor.cplier.com/library/cplier-gateway:latest</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cplier-gateway</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cplier-gateway</span></span><br></pre></td></tr></table></figure><p><code>image</code>为你的镜像仓储。</p>]]></content>
      
      
      <categories>
          
          <category> devOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> k8s </tag>
            
            <tag> jenkins </tag>
            
            <tag> harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年学习计划</title>
      <link href="/2020/03/11/learning-plan/2020_03_11_study_plan/"/>
      <url>/2020/03/11/learning-plan/2020_03_11_study_plan/</url>
      
        <content type="html"><![CDATA[<p>不得不说，2019制定的学习计划很糟糕，受干扰的因素太多。另外一方面是自我没有养成良好的习惯。定了7、8个任务，结果也就勉强完成了一半。</p><p>后面发现，学习之前，首先要学会如何学习，于是我硬着头皮去看完了一些如何管理时间、排除外界干扰的一些书籍，例如《刻意学习》、《行为组织管理》、《原则》等。不得不说，结合自身情况后，从书本上也看到自己很多弱点，有些弱点貌似怎么也绕不过去。譬如：</p><span id="more"></span><ol><li>三天打鱼两天晒网。这是职场人士的通病，因为只有一个原因，就是“太累”了。上班一天的脑力劳动，不知烧死了多少细胞，头发还健在不？</li><li>外界干扰。貌似这是不可避免的，例如来场说走就走的旅行，公司突然搞个活动，楼下天天大排档，大病一场… 从《原则》上所说的，如何避免重复犯错，如何进行决策，走倾向于最小风险和最大收获的方向，这是需要以后不断思考的问题。</li><li>习惯就是力量。这是真的，毕业三年后，和同学来个深度对比。就会发现，最后混的好的，不是成绩优秀的人、也不是学生会那帮饕餮之辈，而是拥有良好习惯，善于思考，做事有准备的人。这里的混得好，不是指赚了很多钱，而是能够妥善应对和解决自身的问题。例如，安置家人，发现自己的人生目标并作出成就，学会一项新技能，譬如学个车、考个外语证、打球很溜…</li><li>善于总结。</li><li>向有经验的人请教以及如何请教。</li><li>勇敢说“不”。</li><li>太快或不专心从而导致忽略了上层原理。</li></ol><p>嗯哼！天呀，我怎么这么多缺点… 不活了…</p><p>下面是正题：</p><p>去年基本看完了rust、kubernates、spring cloud、微服务、cassandra。花了比较多精力在看rust，有点难啃，而且社区还在继续改进中。另外还折腾了一下React，做了一个前后端的token登录的例子，稍微写了个vue项目(emmm… 写vue的感觉像极了打酱油)；重新折腾了以前github的一些项目。修改一些以前实现上的缺陷或不对的地方。</p><p>今年计划补完：</p><ol><li>Learning React with TypeScript (20%)</li><li>think in python (60%)</li><li>learning-go (80%)</li><li>Mathematica (20%)</li></ol><p>另外一点需要补充的，需要转变思维。学习用数学建模和算法思维解决问题。这一点是从《原则》的作者中学习得到的，任何凭直觉和自己的经验处理问题的方式，最终都是一种懒惰的技能。用数据来说服自己和他人，是最有力的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark 3.0 集群搭建教程</title>
      <link href="/2020/03/04/spark/installation/"/>
      <url>/2020/03/04/spark/installation/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="先决条件">先决条件</span></h2><p>在部署Spark之前，请确认集群的每个节点都符合以下条件：</p><ol><li>已安装Java 1.8.x或以上版本（推荐1.8版本）</li><li>节点两两之间可以SSH免密码登录</li><li>已部署Hadoop（如果只是部署Standalone Cluster则不需要Hadoop）</li></ol><p>如果你已经按照<a href="/2020/03/04/hadoop/installation">Hadoop集群搭建教程</a>成功建立了Hadoop集群，那么以上条件均已满足。</p><h3><span id="下载spark二进制文件">下载Spark二进制文件</span></h3><p>在Spark的<a href="https://spark.apache.org/downloads.html">下载页面</a>中有多个版本可以选择，因为之前选择了Hadoop 2.7.7版本，所以这里选择与之对应的 <a href="https://www.apache.org/dyn/closer.lua/spark/spark-3.0.0/spark-3.0.0-bin-without-hadoop.tgz">Pre-built with user-provided Apache Hadoop</a>版本，Scala版本选择最新的2.12。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.0/spark-3.0.0-bin-without-hadoop.tgz</span><br><span class="line">tar -xzvf spark-3.0.0-bin-without-hadoop.tgz</span><br></pre></td></tr></table></figure><h3><span id="配置spark环境变量">配置Spark环境变量</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Spark environment</span></span><br><span class="line">export SPARK_HOME=/opt/spark-3.0.0-bin-without-hadoop</span><br><span class="line">export PATH=$PATH:$&#123;SPARK_HOME&#125;/bin</span><br></pre></td></tr></table></figure><h4><span id="spark-envsh"></span></h4><p>因为我们下载的是不带hadoop依赖jar的spark版本，所以需要在spark中指定hadoop的classpath</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">配置文件spark-env.sh：</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## in conf/spark-env.sh ###</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If <span class="string">&#x27;hadoop&#x27;</span> binary is on your PATH</span></span><br><span class="line">export SPARK_DIST_CLASSPATH=$(hadoop classpath)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> With explicit path to <span class="string">&#x27;hadoop&#x27;</span> binary</span></span><br><span class="line">export SPARK_DIST_CLASSPATH=$(/path/to/hadoop/bin/hadoop classpath)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Passing a Hadoop configuration directory</span></span><br><span class="line">export SPARK_DIST_CLASSPATH=$(hadoop --config /path/to/configs classpath)</span><br></pre></td></tr></table></figure><p>这里在最后一行添加：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line">export SPARK_DIST_CLASSPATH=$(/opt/hadoop-2.7.7/bin/hadoop classpath)</span><br></pre></td></tr></table></figure><h3><span id="slaves">slaves</span></h3><p>向slaves文件写入slave节点的host/IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huawei-02</span><br><span class="line">huawei-03</span><br></pre></td></tr></table></figure><h3><span id="将配置好的spark分发到其它节点">将配置好的Spark分发到其它节点</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/spark-3.0.0-bin-without-hadoop huawei-02:/opt/spark-3.0.0-bin-without-hadoop</span><br><span class="line">scp -r /opt/spark-3.0.0-bin-without-hadoop huawei-03:/opt/spark-3.0.0-bin-without-hadoop</span><br></pre></td></tr></table></figure><h3><span id="启动spark">启动Spark</span></h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./opt/spark-3.0.0=bin-without-hadoop/sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>打开浏览器，输入<code>[主机]:8080</code> 出现下面节点则表示启动成功了。</p><p><img src="/img/spark/spark-master.png" alt="spark cluster"></p><p>关于：<code>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code>问题的解决。</p><p>其实该问题不影响使用。就是没有加载到linux共享库，打开<code>/etc/rpfile</code>，</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">export LD_LIBRARY_PATH=$HADOOP_HOME/lib/native/:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><p>source一下就解决了。</p><p>查看<code>sbin</code>目录，可以看到spark提供了几种启动方式.</p><h3><span id="spark-的三种启动方式">Spark 的三种启动方式</span></h3><p>Spark最主要资源管理方式按排名为Hadoop Yarn, Apache Standalone 和Mesos。在单机使用时，Spark还可以采用最基本的local模式。</p><p>目前Apache Spark支持三种分布式部署方式，分别是standalone、spark on mesos和 spark on YARN，其中，第一种类似于MapReduce 1.0所采用的模式，内部实现了容错性和资源管理，后两种则是未来发展的趋势，部分容错性和资源管理交由统一的资源管理系统完成：让Spark运行在一个通用的资源管理系统之上，这样可以与其他计算框架，比如MapReduce，公用一个集群资源，最大的好处是降低运维成本和提高资源利用率（资源按需分配）。本文将介绍这三种部署方式，并比较其优缺点。</p><ol><li>Standalone模式</li></ol><p>即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。从一定程度上说，该模式是其他两种的基础。借鉴Spark开发模式，我们可以得到一种开发新型计算框架的一般思路：先设计出它的standalone模式，为了快速开发，起初不需要考虑服务（比如master/slave）的容错性，之后再开发相应的wrapper，将stanlone模式下的服务原封不动的部署到资源管理系统yarn或者mesos上，由资源管理系统负责服务本身的容错。目前Spark在standalone模式下是没有任何单点故障问题的，这是借助zookeeper实现的，思想类似于Hbase master单点故障解决方案。将Spark standalone与MapReduce比较，会发现它们两个在架构上是完全一致的：</p><ol><li>都是由master/slaves服务组成的，且起初master均存在单点故障，后来均通过zookeeper解决（Apache MRv1的JobTracker仍存在单点问题，但CDH版本得到了解决）；</li><li>各个节点上的资源被抽象成粗粒度的slot，有多少slot就能同时运行多少task。不同的是，MapReduce将slot分为map slot和reduce slot，它们分别只能供Map Task和Reduce Task使用，而不能共享，这是MapReduce资源利率低效的原因之一，而Spark则更优化一些，它不区分slot类型，只有一种slot，可以供各种类型的Task使用，这种方式可以提高资源利用率，但是不够灵活，不能为不同类型的Task定制slot资源。总之，这两种方式各有优缺点。</li></ol><ol start="2"><li>Spark On Mesos模式</li></ol><p>这是很多公司采用的模式，官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。目前在Spark On Mesos环境中，用户可选择两种调度模式之一运行自己的应用程序（可参考Andrew Xia的“Mesos Scheduling Mode on Spark”）：</p><ol><li><p>粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。举个例子，比如你提交应用程序时，指定使用5个executor运行你的应用程序，每个executor占用5GB内存和5个CPU，每个executor内部设置了5个slot，则Mesos需要先为executor分配资源并启动它们，之后开始调度任务。另外，在程序运行过程中，mesos的master和slave并不知道executor内部各个task的运行情况，executor直接将任务状态通过内部的通信机制汇报给Driver，从一定程度上可以认为，每个应用程序利用mesos搭建了一个虚拟集群自己使用。</p></li><li><p>细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。与粗粒度模式一样，应用程序启动时，先会启动executor，但每个executor占用资源仅仅是自己运行所需的资源，不需要考虑将来要运行的任务，之后，mesos会为每个executor动态分配资源，每分配一些，便可以运行一个新任务，单个Task运行完之后可以马上释放对应的资源。每个Task会汇报状态给Mesos slave和Mesos Master，便于更加细粒度管理和容错，这种调度模式类似于MapReduce调度模式，每个Task完全独立，优点是便于资源控制和隔离，但缺点也很明显，短作业运行延迟大。</p></li></ol><ol start="3"><li>Spark On YARN模式</li></ol><p>这是一种很有前景的部署模式。但限于YARN自身的发展，目前仅支持粗粒度模式（Coarse-grained Mode）。这是由于YARN上的Container资源是不可以动态伸缩的，一旦Container启动之后，可使用的资源不能再发生变化，不过这个已经在YARN计划中了。<br>spark on yarn 的支持两种模式：</p><ol><li>yarn-cluster：适用于生产环境；</li><li>yarn-client：适用于交互、调试，希望立即看到app的输出</li></ol><p>yarn-cluster和yarn-client的区别在于yarn appMaster，每个yarn app实例有一个appMaster进程，是为app启动的第一个container；负责从ResourceManager请求资源，获取到资源后，告诉NodeManager为其启动container。yarn-cluster和yarn-client模式内部实现还是有很大的区别。如果你需要用于生产环境，那么请选择yarn-cluster；而如果你仅仅是Debug程序，可以选择yarn-client。</p><p>总结：<br>这三种分布式部署方式各有利弊，通常需要根据实际情况决定采用哪种方案。进行方案选择时，往往要考虑公司的技术路线（采用Hadoop生态系统还是其他生态系统）、相关技术人才储备等。上面涉及到Spark的许多部署模式，究竟哪种模式好这个很难说，需要根据你的需求，如果你只是测试Spark Application，你可以选择local模式。而如果你数据量不是很多，Standalone 是个不错的选择。当你需要统一管理集群资源（Hadoop、Spark等），那么你可以选择Yarn或者mesos，但是这样维护成本就会变高。<br>· 从对比上看，mesos似乎是Spark更好的选择，也是被官方推荐的<br>· 但如果你同时运行hadoop和Spark,从兼容性上考虑，Yarn是更好的选择。 · 如果你不仅运行了hadoop，spark。还在资源管理上运行了docker，Mesos更加通用。<br>· Standalone对于小规模计算集群更适合！</p><p>更多关于启动模式的介绍，可以查看<a href="/2018/10/26/spark/spark-cluster-config">先前</a>的文章。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 集群搭建教程</title>
      <link href="/2020/03/04/flink/installation/"/>
      <url>/2020/03/04/flink/installation/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="先决条件">先决条件</span></h2><p>在部署Flink之前，请确认集群的每个节点都符合以下条件：</p><ol><li>已安装Java 1.8.x或以上版本（推荐1.8版本）</li><li>节点两两之间可以SSH免密码登录</li><li>已部署Hadoop（如果只是部署Standalone Cluster则不需要Hadoop）</li></ol><p>如果你已经按照<a href="/2020/03/04/hadoop/installation">Hadoop集群搭建教程</a>成功建立了Hadoop集群，那么以上条件均已满足。</p><h3><span id="下载flink二进制文件">下载Flink二进制文件</span></h3><p>在Flink的<a href="https://flink.apache.org/downloads.html">下载页面</a>中有多个版本可以选择，因为之前选择了Hadoop 2.7.7版本，所以这里选择与之对应的 <a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.12.tgz">Apache Flink 1.9.2 for Scala 2.12</a>版本，Scala版本选择最新的2.12。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.12.tgz</span><br><span class="line">tar -xzvf flink-1.9.2-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><h3><span id="配置flink">配置Flink</span></h3><blockquote><p>注意：如果只需要部署Flink on YARN，那么可以跳过这小节，因为YARN会帮你打理好一切。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/flink-1.9.2/conf</span><br></pre></td></tr></table></figure><h4><span id="flink-confyaml">flink-conf.yaml</span></h4><p>将<code>jobmanager.rpc.address</code>指向master节点，其它配置可以按照机器实际硬件情况填写，此处使用默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The host/IP of JobManager</span></span><br><span class="line"><span class="attr">jobmanager.rpc.address:</span> <span class="string">huawei-01</span></span><br><span class="line"><span class="comment"># The heap size for the JobManager JVM</span></span><br><span class="line"><span class="attr">jobmanager.heap.size:</span> <span class="string">1024m</span></span><br><span class="line"><span class="comment"># The heap size for the TaskManager JVM</span></span><br><span class="line"><span class="attr">taskmanager.heap.size:</span> <span class="string">1024m</span></span><br><span class="line"><span class="comment"># The number of task slots that each TaskManager offers. Each slot runs one parallel pipeline.</span></span><br><span class="line"><span class="attr">taskmanager.numberOfTaskSlots:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># The parallelism used for programs that did not specify and other parallelism.</span></span><br><span class="line"><span class="attr">parallelism.default:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="slaves">slaves</span></h3><p>向slaves文件写入slave节点的host/IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huawei-02</span><br><span class="line">huawei-03</span><br></pre></td></tr></table></figure><h3><span id="将配置好的flink分发到其它节点">将配置好的Flink分发到其它节点</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/flink-1.9.2 huawei-02:/opt/flink-1.9.2</span><br><span class="line">scp -r /opt/flink-1.9.2 huawei-03:/opt/flink-1.9.2</span><br></pre></td></tr></table></figure><h3><span id="以standalone模式启动flink">以Standalone模式启动Flink</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $FLINK_HOME</span><br><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>然后可以在<code>huawei-01:8081</code>查看Flink集群的运行情况</p><p><img src="/img/flink/flink-dashboard.png" alt="flink-dashboard.png"></p><p><code>./examples</code>路径下游许多打包好的实例程序，可以用于验证Flink集群是否正常运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run ./exmaple/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>上面的命令会向 Flink 集群提交一个 wordcount 任务，这个示例程序可以指定输入和输出路径，这里没有指定，因此输入文件为程序自带的一小段文本，结果直接输出在屏幕上。 如果 Flink 集群工作正常，应该会在屏幕上输出以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略前面的输出</span></span><br><span class="line">(wrong,1)</span><br><span class="line">(you,1)</span><br><span class="line">Program execution finished</span><br><span class="line">Job with JobID d7df697505c1f68d4eda2828b6eb18e2 has finished.</span><br><span class="line">Job Runtime: 3158 ms</span><br><span class="line">Accumulator Results:</span><br><span class="line">- 47b31488879a3449d67aca67f5b75188 (java.util.ArrayList) [170 elements]</span><br></pre></td></tr></table></figure><h2><span id="以flink-on-yarn模式启动">以Flink on YARN模式启动</span></h2><p>把 Flink 运行在 YARN 上有两种方式，第一种方式是建立一个长期运行的 Flink YARN Session，然后向这个 Session 提交 Flink Job，多个任务同时运行时会共享资源。第二种方式是为单个任务启动一个 Flink 集群，这个任务会独占 Flink 集群的所有资源，任务结束即代表集群被回收。</p><p>另外，Flink on YARN 模式需要系统中设置了 YARN_CONF_DIR 或 HADOOP_CONF_DIR 环境变量，如果未设置，请在 <code>~/.profile</code> 中加入以下内容，然后使用 <code>source ~/.profile</code> 命令使修改立即生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在这条命令前定义HADOOP_HOME环境变量</span></span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br></pre></td></tr></table></figure><h3><span id="flink-yarn-session">Flink YARN Session</span></h3><p>由于新版本的Flink已经不包含Hadoop依赖项，需要自己添加依赖。首先下载<a href="https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-uber/2.7.5-10.0/flink-shaded-hadoop-2-uber-2.7.5-10.0.jar">Pre-bundled Hadoop 2.7.5</a> 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd cd $FLINK_HOME/lib</span><br><span class="line">wget https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-uber/2.7.5-10.0/flink-shaded-hadoop-2-uber-2.7.5-10.0.jar</span><br></pre></td></tr></table></figure><p>使用下列命令来启动一个拥有 2 个 TaskManager 的 Flink 集群，每个 TaskManager 有 2 GB 内存，2 个 slot。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/YARN-session.sh -n 2 -jm 1024m -tm 2048</span><br></pre></td></tr></table></figure><p>完整的参数列表如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">   Required</span><br><span class="line">     -n,--container &lt;arg&gt;   Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">   Optional</span><br><span class="line">     -D &lt;arg&gt;                        Dynamic properties</span><br><span class="line">     -d,--detached                   Start detached</span><br><span class="line">     -jm,--jobManagerMemory &lt;arg&gt;    Memory for JobManager Container with optional unit (default: MB)</span><br><span class="line">     -nm,--name                      Set a custom name for the application on YARN</span><br><span class="line">     -q,--query                      Display available YARN resources (memory, cores)</span><br><span class="line">     -qu,--queue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -s,--slots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -tm,--taskManagerMemory &lt;arg&gt;   Memory per TaskManager Container with optional unit (default: MB)</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths for HA mode</span><br></pre></td></tr></table></figure><p>启动 YARN Session 以后会输出 JobManager 的 Web Interface 地址，打开以后是这样的：</p><p><img src="/img/flink/tracking-ui.png" alt="hadop-application"></p><p><img src="/img/flink/yarn-session.png" alt="yarn-session.png"></p><p>仔细一看，Task Managers，Task Slots 怎么都是 0 呢？难道是哪里出了问题？其实并没有问题，从某个版本开始 Flink 允许动态分配资源，在没有任务的时候不分配 TaskManager。接下来我们就提交一个任务试试。</p><p>因为启动 YARN Session 以后 Flink Client 会一直在前台运行，所以先用 <code>Ctrl + Z</code> 快捷键把 Client 转到后台，然后再提交任务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p><img src="/img/flink/wordcount-job.png" alt="wordcount-job.png"></p><p>在任务运行期间观察 Web Interface，会发现 Task Managers 变为 1，Task Slots 变为 2 ，与启动集群时指定的参数不符，这是因为 YARN 集群中只有两个 NodeManager，huawei-02 和 huawei-03，其中一个作为 JobManager，因此只剩一个节点可以作为 TaskManager。</p><p>任务的运行结果和 Standalone 模式下完全一样。</p><h3><span id="single-flink-job-on-yarn">Single Flink job on YARN</span></h3><p>下面这条命令会为 wordcount 任务启动一个独占的 Flink 集群，任务结束集群即被回收。其中 -m 选项指定 Flink 集群的启动模式，-yn 选项指定 TaskManager 的数目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -m YARN-cluster -yn 2 ./examples/batch/WordCount.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>任务的运行结果和 Standalone 模式下完全一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 集群搭建教程</title>
      <link href="/2020/03/04/hadoop/installation/"/>
      <url>/2020/03/04/hadoop/installation/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这篇文章介绍了搭建一个三节点Hadoop集群时的顺序，三台机为内网IP。对应的hostname分别为huawei-01，huawei-03，huawei-03。其中第一台作为master，后面两台作为slaves。</p><h2><span id="先决条件">先决条件</span></h2><p>在安装Hadoop之前，请确认集群的每台机器上均安装JDK，以及搭配环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Java Environment</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64/</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>另外，需要在三台机器<code>/etc/hosts</code>写入对应机器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 三台机的私有网络IP</span><br><span class="line"></span><br><span class="line">192.168.0.125huawei-02</span><br><span class="line">192.168.0.160huawei-01</span><br><span class="line">192.168.0.56huawei-03</span><br></pre></td></tr></table></figure><p>还要修改对应hostname，因为DataNode上的日志文件后解释hostname（不知是不是这原因）。</p><h2><span id="下载二进制文件">下载二进制文件</span></h2><p>Hadoop有很多版本选择，考虑会后续Hadoop会部署其它应用，所以选择兼容性最好的2.7.7版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz</span><br><span class="line">tar -zxvf hadoop-2.7.7.tar.gz -C .</span><br></pre></td></tr></table></figure><h2><span id="修改配置文件">修改配置文件</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> Flink Environment</span></span><br><span class="line">export HADOOP_HOME=/opt/hadoop-2.7.7</span><br><span class="line">export PATH=$PATH:$&#123;HADOOP_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/sbin</span><br></pre></td></tr></table></figure><h3><span id="core-sitexml">core-site.xml</span></h3><p>指定NameNode的IP地址和端口号，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://huawei-01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="hdfs-sitexml">hdfs-site.xml</span></h3><p><code>dfs.replication</code> 指定备份数目为 3，<code>dfs.name.dir</code> 指定 NameNode 的文件存储路径，<code>dfs.data.dir</code> 指定 DataNode 的文件存储路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/opt/hadoop-2.7.7/data/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/opt/hadoop-2.7.7/data/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="mapred-sitexml">mapred-site.xml</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p>然后修改<code>mapred-site.xml</code>的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="yarn-sitexml">yarn-site.xml</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8025<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8050<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="slaves">slaves</span></h3><p>添加slave节点的hostname到该文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huawei-02</span><br><span class="line">huawei-03</span><br></pre></td></tr></table></figure><h3><span id="hadoop-envsh"></span></h3><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64/</span><br></pre></td></tr></table></figure><h2><span id="分发配置文件">分发配置文件</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/hadoop-2.7.7 huawei-02:/opt/hadoop-2.7.7</span><br><span class="line">scp -r /opt/hadoop-2.7.7 huawei-03:/opt/hadoop-2.7.7</span><br></pre></td></tr></table></figure><h2><span id="启动集群">启动集群</span></h2><h3><span id="格式化hdfs">格式化HDFS</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><h3><span id="启动集群">启动集群</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><p>使用jps命令查看服务运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master节点中运行的服务</span></span><br><span class="line">25928 SecondaryNameNode</span><br><span class="line">25742 NameNode</span><br><span class="line">26387 Jps</span><br><span class="line">26078 ResourceManager</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slave节点中运行的服务</span></span><br><span class="line">24002 NodeManager</span><br><span class="line">23899 DataNode</span><br><span class="line">24179 Jps</span><br></pre></td></tr></table></figure><h2><span id="提交示例任务">提交示例任务</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/hadoop-2.7.7</span><br><span class="line">hdfs dfs -mkdir /wordcount/input</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把当前路径下的 LICENSE.txt 文件复制到 HDFS 中</span></span><br><span class="line">hadoop fs -put ./LICENSE.txt /wordcount/input</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交任务，最后两个参数分别指定任务的输入和输出</span></span><br><span class="line">hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /wordcount/input /wordcount/output</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看输出路径</span></span><br><span class="line">hadoop fs -ls /wordcount/output</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果一切正常，该路径下包含两个文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个文件是空文件，表示任务运行成功</span></span><br><span class="line">/wordcount/output/_SUCCESS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个文件是输出文件，统计了 LICENSE.txt 中每个单词出现的次数</span></span><br><span class="line">/wordcount/output/part-r-00000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka Typed 协议和行为</title>
      <link href="/2020/01/03/akka/typed/akka-typed/"/>
      <url>/2020/01/03/akka/typed/akka-typed/</url>
      
        <content type="html"><![CDATA[<p>2019年11月6号LightBend公司发布了AKKA 2.6版本，带来了类型安全的actor，新的Akka Cluster底层通信设施——Artery，带来了更好的稳定性，使用Jackson进行消息序列化，支持SLF4J日志接口。</p><h2><span id="why-akka-typed">Why Akka Typed</span></h2><p>actor编程模型是一个强有力的抽象模型，尤其擅长解决真实世界建模，容错、并发、分布式系统问题。actor抽象编程模型构建于在互相独立的actor之间发送消息的基础之上，actor可以创建子actor，并负责监管，当子actor出现错误的时候可以重启或者重新创建，这套容错机制给整个actor系统带来了自愈能力。</p><p>经典的Akka actor API非常简单，就是提供一组处理和接收消息的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the Actor trait (AbstractActor class in Java) is the entry point for using the API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// receive方法处理消息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> order @ <span class="type">OrderProcessor</span>.<span class="type">ProcessOrder</span> =&gt;</span><br><span class="line">  <span class="comment">// actor方法繁衍新的actor</span></span><br><span class="line">  <span class="keyword">val</span> connection = context.actorOf(</span><br><span class="line">    <span class="type">BankConnection</span>.props(order.bankIndentifier)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// !方法表示即发即弃</span></span><br><span class="line">  connection ! <span class="type">BankConnection</span>.<span class="type">ExecuteOrder</span>(order)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编程模型和API在多线程环境中具有显著的优势，每个actor顺序处理接收到的消息，actor的内部状态也只有它本身可以修改，这比并发的修改共享状态容易多了。</p><p>天下没有免费的午餐，actor编程模型也有它的缺点，槽点在这篇文章中有提到：<a href="https://manuel.bernhardt.io/2017/05/29/akka-anti-patterns-overview/">Akka anti-patterns series</a></p><p>这些年来我在一些稍微大一些的Akka工程中见到的最大的问题是actor系统随着业务越做越大，并且非常难以扩展。根本原因是这套Akka API没有强制用户采用“协议优先”的规范。实际上Akka官方教程里最先讲述的就是清晰的定义组件之间的通信协议（也就是消息），并使用全路径访问消息。已上面的例子来说，OrderProcessor的通信协议定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伴生对象存放了消息的定义</span></span><br><span class="line"><span class="comment">// 对于集群或持久化系统，消息定义需要使用合适的序列化机制，譬如protobuf</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessOrder</span>(<span class="params">bank: <span class="type">BankId</span>, fromAccount: <span class="type">AccountId</span>, toAccount: <span class="type">AccountId</span>, amount: <span class="type">Amount</span></span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便你遵照Akka最佳实践，但还是无法保证给actor发送一些它不支持消息，actor的receive方法会接受任意类型的消息，当它收到不支持的消息时，便自动转给unhandled方法，此方法默认只会打日志记录一下（需要正确的配置日志打印机制），这对新人来说太坑了，你找不到任何错误，但是系统就是无法正常工作。</p><p>更深层次的原因在于缺少一种机制来帮助我们维护actor之间的通信协议。随着消息类型增多，很容易忘记这些actor都支持什么类型的消息。通过单元测试和严格的日志级别会有助于缓解这种问题（只要接受到不支持的消息就打warn日志），但是仍然无法完全避免。</p><p>Akka Typed就是为了解决这个问题，新的API是为“协议优先”设计的，在实现功能之前，你必须花一点时间想一想每一个actor要处理哪些消息。经典的Actor API的最佳实践也是如此，但却是可选的，你需要在实现的过程中使要处理消息条理清晰。</p><p>看过许多真实的Akka System分享之后，有一点必须强调一下：开发Akka Typed的目的不仅仅是为了以结构化的方式组织消息以及防止丢失那一点点actor不支持的消息，它的主要目的是引导我们优先考虑系统设计。设计一组恰到好处的actor，适当的通信粒度，正确的消息模式，这样就可以构建一个强大的系统，但是它的核心却非常简单，就像高考一样简单。但是我见到太多过度设计，大家倾向于设计过多的actor以及消息，引入了不必要的复杂度，最后尾大不掉。</p><h2><span id="lets-build-a-payment-processor">Let’s build a payment processor</span></h2><p>前面我们已经讲过使用Akka Typed可以非常容易的定义协议，但什么是“协议”呢？协议仅仅是“消息”吗？简单来说协议就是：定义一组消息，在两个及以上的组件之间按特定的顺序和组合传递。常见的协议有TCP、HTTPS等，而我们定义的是应用层的协议。你可以认为协议就是增强版的API：API只定义了个体之间的调用格式（参数、请求内容、响应内容等），协议描述了怎么通过组件之间的相互调用使系统到达期望的状态。</p><p>在Akka Typed API中，协议由一组消息class和对应类型的actor组成。下面的例子展示了从configuration组件获取配置数据的协议：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrieveConfiguration</span>(<span class="params">merchantId: <span class="type">MerchantId</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">ConfigurationResponse</span>]</span>) <span class="keyword">extends</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationFound</span>(<span class="params">merchantId: <span class="type">MerchantId</span>,  merchantConfiguration: <span class="type">MerchantConfiguration</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationNotFound</span>(<span class="params">merchanId: <span class="type">MerchantId</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchantId</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BankIdentifier</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchantConfiguration</span>(<span class="params">bankIdentifier: <span class="type">BankIdentifier</span></span>)</span></span><br></pre></td></tr></table></figure><p>这个例子遵循了请求-响应的消息设计模式，欲知更多详情，请参见本书：<a href="https://www.manning.com/books/reactive-design-patterns">Reactive Design Patterns</a></p><p>如果你以前用过经典的Actor API，你会发现这里的实现方式有两个不同的地方，第一个是消息发送者的引用包含在消息的定义中，经典的Actor API是通过Akka提供的sender()方法来获取发送者的。第二个是消息class中包含的ActorRef是有类型的，发送者使用它的时候就可以清楚的知道应该发送什么类型的消息。我们使用接口ConfigurationResponse定义了配置数据的返回格式，它有两个实现类，这样发送者就可以发送两种格式的消息。</p><p>看了Actor的定义之后，就能理解为什么Akka Typed比经典的Actor更容易且更安全的解决协议问题，Configuration的定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义的actor继承<code>AbstractBehavior</code>，并带有指定的类型，它只能处理<code>ConfigurationMessage</code>类型的消息，编译器可以帮助我们检查消息的发送者发送的消息是否正确。</p><p>上面的例子中我们使用面向对象的编程方式定义了Actor，稍后我们会展示函数式编程风格。</p><h2><span id="implementing-our-first-typed-actor">Implementing our first typed actor</span></h2><p><code>Configuration</code>提供查询功能：根据商户Id查询支付方式。我们继续使用面向对象的编程方式，如果使用过经典的Akka API，你对这种使用方式应该非常熟悉。</p><p>继承<code>AbstractBehavior</code>就必须实现<code>onMessage</code>方法，它返回一个<code>Behavior</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the AbstractBehavior trait is the entry point for using the object-oriented style API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the mutable state here holds the configuration values of each merchant we know about</span></span><br><span class="line">  <span class="keyword">var</span> configurations: <span class="type">Map</span>[<span class="type">MerchantId</span>, <span class="type">MerchantConfiguration</span>] = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the onMessage method defines the initial behavior applied to a message upon reception</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">ConfigurationMessage</span>): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = msg <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RetrieveConfiguration</span>(merchantId, replyTo) =&gt;</span><br><span class="line">      configurations.get(merchantId) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(configuration) =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationFound</span>(merchantId, configuration)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationNotFound</span>(merchantId)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// lastly, return the Behavior to be applied to the next received message</span></span><br><span class="line">      <span class="comment">// in this case, that&#x27;s just the same Behavior as we already have</span></span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个actor与我们在本文开头使用经典的actor API定义的actor非常相似：覆盖onMessage方法，并根据指定的消息类型做出对应的响应。</p><p>不同点在于onMessage对应的方法返回的是一个Behavior，一个actor接收到消息之后的行为包含如下3个步骤：</p><p>发送一条或多条消息给其他的actor<br>创建子acotr<br>返回一个新的行为，准备接收下一个消息<br>在Akka Typed API中，一个Behavior即代表了处理当前消息的行为，也表明了如何处理下一个消息——通过返回一个新的Behavior。也可以只是返回当前行为（就像上面的例子一样），因为使用面向对象风格的actor继承自AbstractBehavior，它本身就是一个Behavior，所以可以使用return this。</p><p>本系列教程后面会讨论更多关于Behavior的用法，使用Akka Typed API定义的actor的一个优点就是非常容易组合和测试。</p><p>Typed Akka TestKit可以帮助你轻而易举的对actor进行测试：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationSpec</span> <span class="keyword">extends</span> <span class="title">ScalaTestWithActorTestKit</span> <span class="keyword">with</span> <span class="title">WordSpecLike</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;The Configuration actor&quot;</span> should &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;not find a configuration for an unknown merchant&quot;</span> in &#123;</span><br><span class="line">      <span class="comment">// define a probe which allows it to easily send messages</span></span><br><span class="line">      <span class="keyword">val</span> probe = createTestProbe[<span class="type">ConfigurationResponse</span>]()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// spawn a new Configuration actor as child of the TestKit&#x27;s guardian actor</span></span><br><span class="line">      <span class="keyword">val</span> configurationActor = spawn(<span class="type">Configuration</span>())</span><br><span class="line"></span><br><span class="line">      <span class="comment">// send a message to the actor under test with the probe&#x27;s reference as sender</span></span><br><span class="line">      configurationActor ! <span class="type">Configuration</span>.<span class="type">RetrieveConfiguration</span>(<span class="type">MerchantId</span>(<span class="string">&quot;unknown&quot;</span>), probe.ref)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// expect a certain type of message as response. there are many different ways to retrieve</span></span><br><span class="line">      <span class="comment">// or to expect messages</span></span><br><span class="line">      <span class="keyword">val</span> response = probe.expectMessageType[<span class="type">Configuration</span>.<span class="type">ConfigurationNotFound</span>]</span><br><span class="line">      response.merchanId shouldBe <span class="type">MerchantId</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="supervising-and-starting-the-actor">Supervising and starting the actor</span></h2><p>actor System为actor提供运行环境、分配资源、基础设施。在这个系统中，每一个actor都有一个父actor，最顶层的actor叫做根节点（<code>root</code>)，使用<code>/</code>代表，它的两个直接子actor是<code>/user</code>和<code>/system</code>，<code>/user</code>用于在用户空间创建子actor，<code>/system</code>属于akka系统内部管理，所以我们创建的所有的actor都从属于<code>/user</code>。</p><p>Akka Typed与经典的Actor API有一个非常重要的不同点：<code>/user</code>的处理逻辑。在经典的Akka API中，Akka提供的<code>/useractor</code>负责监管一切；但是Akka Typed把这个权力交给了用户。也就是说应用程序的开发者在实现actor的时候同时也必须多考虑一下actor都会有哪些行为。</p><p>在创建<code>Configuration</code> actor的时候，我们大可以直接把它传给<code>ActorSystem</code>并把它作为监管者，但当创建更多actor的时候，这些actor全部都由<code>Configuration</code> actor监管就不合适了。而且在actor模型中父监管机制采用级联的方式处理actor失败的问题：父actor负责决定如何处理子actor（当它抛异常的时候），因此如何对actor分组直接影响了监管策略。同样的我们应该使用一个专用的父actor做为监管actor，由它来决定如何处理子actor的失败问题。Akka Typed API中默认的监管策略是停止失败的子actor（经典的Akka API是重启）。由我们指定监管actor可以开发更灵活的监管策略，根据不同的异常做出相应的决策。综上所述我们决定使用<code>PaymentProcessor</code> actor做为所有actor的监管者，actor层级如下图所示：</p><p>![/img/akka/typed/supervison.png]</p><p><code>PaymentProcessor</code>的功能目前非常简单，启动的时候创建一个子actor——Configuration，它是无状态的，也不接收任何消息，这次我们使用函数式编程的风格，无需继承任何接口，只需要返回一个Behavior：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PaymentProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="type">Behaviors</span>.setup[<span class="type">Nothing</span>] &#123; context =&gt;</span><br><span class="line">    context.log.info(<span class="string">&quot;Typed Payment Processor started&quot;</span>)</span><br><span class="line">    context.spawn(<span class="type">Configuration</span>(), <span class="string">&quot;config&quot;</span>)</span><br><span class="line">    <span class="type">Behaviors</span>.empty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Behaviors.setup()</code>方法是创建<code>Behavior</code>的入口，该方法包含一个<code>ActorContext</code>变量，我们用它打日志，记录actor已经启动，并使用<code>spawn()</code>方法创建了一个<code>Configuration actor</code>，第一个参数用于创建actor，第二个参数是actor的名字，它在actor路径中是<code>/user/config</code>。</p><p>因为<code>PaymentProcessor</code>不处理任何消息，所以这里使用了<code>setup[Nothing]</code>。</p><p><code>Configuration</code> actor使用静态的create函数创建<code>Behavior</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Configuration</span>(context))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在万事俱备，只欠东风，需要启动<code>ActorSystem</code>来创建我们的监管actor。Akka提供了静态方法用来创建监管actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ActorSystem</span>[<span class="type">Nothing</span>](<span class="type">PaymentProcessor</span>(), <span class="string">&quot;typed-payment-processor&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定！现在运行<code>Main</code>方法，就可以看到<code>PaymentProcessor</code>启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[info] Running io.bernhardt.typedpayment.Main</span><br><span class="line">[INFO] [07/10/2019 09:36:42.483] [typed-payment-processor-akka.actor.default-dispatcher-5] [akka://typed-payment-processor/user] Typed Payment Processor started</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> akka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka-typed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章 单元测试</title>
      <link href="/2019/11/27/react-ts/chapter_b_Unit_Testing_with_Jest/"/>
      <url>/2019/11/27/react-ts/chapter_b_Unit_Testing_with_Jest/</url>
      
        <content type="html"><![CDATA[<ul><li>Testing pure functions</li><li>Testing components</li><li>Using Jest snapshot tests</li><li>Mocking dependencies</li><li>Getting code coverage</li></ul><p>重点内容，着重说明</p><span id="more"></span><p>本章内容重现第7章，第9章代码。</p><h2><span id="testing-pure-functions">Testing pure functions</span></h2><p>单元测试会从一个纯函数入手，然后逐步深入。</p><blockquote><p>纯函数的对于给定的一系列入参，总是返回相同的结果。纯函数取决于入参，它不会改变入参的值，也不改变任何外部变量。</p></blockquote><h3><span id="creating-a-basic-pure-function-test">Creating a basic pure function test</span></h3><p>我们将创建第一个单元测试对<code>Form.tsx</code>的函数<code>required</code>进行测试：</p><ol><li>创建单元测试文件<code>Form.test.tsx</code>，对<code>Form.tsx</code>进行测试。</li></ol><blockquote><p><code>test.tsx</code>后缀是一个重要标志，表示Jest会自动查询次后缀的文件并执行。按照约定和习惯，和被测试的文件前缀对应。如这里的<code>Form.test.tsx</code>。</p></blockquote><ol start="2"><li>导入我们希望测试的函数，包括TypeScript类型参数值：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; required, IValues &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>test</code>函数开始我们的单元测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(&quot;When required is called with empty title, &#x27;This must be populated&#x27; should be returned&quot;, () =&gt; &#123;</span><br><span class="line">    // TODO: implement the test</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的<code>test</code>函数接收两个参数：</p><ul><li>第一个参数是告诉我们测试的内容，它会输出到控制台中。</li><li>第二个参数是一个箭头函数，包含我们的测试</li></ul><ol start="4"><li>我们需要调用<code>required</code>函数进行测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(&quot;When required is called with empty title, &#x27;This must be populated&#x27; should be returned&quot;, () =&gt; &#123;</span><br><span class="line">    const values: IValues = &#123;</span><br><span class="line">        title: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    const result = required(&quot;title&quot;, values);</span><br><span class="line">    // TODO: check the result is correct</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>最后一个任务，检测结果是否是我们期望的：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(&quot;When required is called with empty title, &#x27;This must be populated&#x27; should be returned&quot;, () =&gt; &#123;</span><br><span class="line">    const values: IValues = &#123;</span><br><span class="line">        title: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    const result = required(&quot;title&quot;, values);</span><br><span class="line">    expect(result).toBe(&quot;This must be populated&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里链式调用了<code>toBe</code>来检测结果期望值。</p><blockquote><p><code>toBe</code>是Jest matcher检测函数中的其中一个。更多可参考 <a href="https://jestjs.io/docs/en/expect">这里</a></p></blockquote><ol start="6"><li>运行命令进行单元测试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>该命名启动后进入watch mode。意思是每次更改代码，它都持续运行检测更新。</p><p><img src="/img/react-ts/test_pass.png" alt="test pass"></p><ol start="7"><li>如果更改期望值，则测试会报错：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(result).toBe(&quot;This must be populatedX&quot;);</span><br></pre></td></tr></table></figure><p>当报错文件后，Jest会自动执行测试，并打印信息到控制台。如下：</p><p><img src="/img/react-ts/test_fail.png" alt="test fail"></p><p>Jest给出的错误的有用信息，它告诉我们：</p><ul><li>哪个测试失败了</li><li>实际期望的值是什么</li><li>哪行出错了</li></ul><p>这些信息帮助我们快速处理测试失败问题。</p><ol start="8"><li>更改为正确的值：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(result).toBe(&quot;This must be populated&quot;);</span><br></pre></td></tr></table></figure><p>当我们保存更改后，测试通过了。</p><h3><span id="understanding-jest-watch-options">Understanding Jest watch options</span></h3><p>Jest在执行测试后，会提供给我们下面一些选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Press f to run only failed tests.</span><br><span class="line">&gt; Press o to only run tests related to changed files.</span><br><span class="line">&gt; Press p to filter by a filename regex pattern.</span><br><span class="line">&gt; Press t to filter by a <span class="built_in">test</span> name regex pattern.</span><br><span class="line">&gt; Press q to quit watch mode.</span><br><span class="line">&gt; Press Enter to trigger a <span class="built_in">test</span> run.</span><br></pre></td></tr></table></figure><p>这些选项提供了可以特定测试的执行。</p><h3><span id="adding-structure-to-unit-test-results">Adding structure to unit test results</span></h3><p>随着单元测试实现的增加，为了易读性需要添加一些结构处理结果。Jest提供了一个<code>describe</code>函数对测试结果进行分组。使得对测试结果更易读。</p><p>重构原来的代码部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;required&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&quot;When required is called with empty title, &#x27;This must be populated&#x27; should be returned&quot;, () =&gt; &#123;</span><br><span class="line">    const values: IValues = &#123;</span><br><span class="line">      title: &#x27;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">    const result = required(&#x27;title&#x27;, values);</span><br><span class="line">    expect(result).toBe(&#x27;This must be populated&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe函数接收两个参数：</p><ul><li>第一个参数是组名。</li><li>第二个参数是一个箭头函数，包含要执行的测试内容。</li></ul><p>保存文件后，测试自动执行，输出内容如下：</p><p><img src="/img/react-ts/test_group.png" alt="test group"></p><h2><span id="testing-components">Testing components</span></h2><p>对组件进行单元测试是个挑战，因为一个组件会依赖浏览器DOM和React库。</p><h3><span id="creating-a-basic-component-test">Creating a basic component test</span></h3><p>我们对组件测试，从<code>ContactUs</code>表单入手：</p><ol><li>首先在<code>src</code>创建一个<code>ContactUs.test.tsx</code>文件。</li><li>因为<code>ContactUs</code>组件使用了<code>ReactDOM</code>进行渲染。导入相应<code>ReactDOM</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们需要模拟表单提交事件，因此导入<code>Simulate</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Simulate &#125; from &quot;react-dom/test-utils&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>导入测试的组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ContactUs from &quot;./ContactUs&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>导入表单的提交结构数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ISubmitResult &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><ol start="6"><li>创建我们的第一个Jest测试函数，并分组：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;ContactUs&quot;, () =&gt; &#123;</span><br><span class="line">    test(&quot;When submit without filling in fields should display errors&quot;, () =&gt; &#123;</span><br><span class="line">        // TODO - implement the test</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="7"><li>测试的第一个实现是创建DOM：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;ContactUs&quot;, () =&gt; &#123;</span><br><span class="line">    test(&quot;When submit without filling in fields should display errors&quot;, () =&gt; &#123;</span><br><span class="line">        const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                success: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const container = document.createElement(&quot;div&quot;);</span><br><span class="line">        ReactDOM.render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;, container);</span><br><span class="line"></span><br><span class="line">        // TODO - submit the form and check errors are shown</span><br><span class="line"></span><br><span class="line">        ReactDOM.unmountComponentAtNode(container);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先，创建一个<code>div</code>容器标签，将<code>ContactUs</code>组件渲染进去。另外再创建<code>onSubmit</code>属性，它返回success。最后一行则清理DOM元素。</p><ol start="8"><li>接下来，引入表单内容，并提交：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;, container);</span><br><span class="line"></span><br><span class="line">const form = container.querySelector(&quot;form&quot;);</span><br><span class="line">expect(form).not.toBeNull();</span><br><span class="line">Simulate.submit(form!);</span><br><span class="line"></span><br><span class="line">// TODO - check errors are shown</span><br></pre></td></tr></table></figure><p>这一步描述了：</p><ul><li>使用了<code>querySelector</code>函数，获取表单元素。</li><li>使用Jest的<code>expect</code>函数检测表单不为<code>null</code>，<code>not</code>和<code>toBeNull</code>为链式组合。</li><li>通过模拟器<code>Simulate</code>进行表单提交事件。使用了<code>!</code>告知TypeScript编译器<code>form</code>不是空的。</li></ul><ol start="9"><li>最后检测错误信息并展示：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Simulate.submit(form!);</span><br><span class="line"></span><br><span class="line">const errorSpans = container.querySelectorAll(&quot;.form-error&quot;);</span><br><span class="line">expect(errorSpans.length).toBe(2);</span><br><span class="line"></span><br><span class="line">ReactDOM.unmountComponentAtNode(container);</span><br></pre></td></tr></table></figure><p>这一步描述了：</p><ul><li>使用了<code>querySelectorAll</code>获取错误的DOM元素。</li><li>使用<code>expect</code>进行校验</li></ul><ol start="10"><li>执行单元测试后，结果输出：</li></ol><p><img src="/img/react-ts/form_test.png" alt="form test"></p><h3><span id="improving-our-tests-with-react-testing-library">Improving our tests with react-testing-library</span></h3><p>react-testing-library是一系列测试工具集。</p><h3><span id="installing-react-testing-library">Installing react-testing-library</span></h3><p>首先安装该工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev react-testing-library</span><br></pre></td></tr></table></figure><h3><span id="removing-css-class-references-from-our-test">Removing CSS class references from our test</span></h3><ol><li>导入相应的函数:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; render, cleanup &#125; from &quot;react-testing-library&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接使用<code>render</code>函数进行组件的渲染，如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;When submit without filling in fields should display errors&#x27;, () =&gt; &#123;</span><br><span class="line">  const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      success: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  const &#123;container, getAllByText&#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">  const form = container.querySelector(&#x27;form&#x27;);</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们再次获取了DOM容器，不过这次是通过<code>getallByText</code>函数获取引用部分。</p><ol start="3"><li>然后获取错误的span元素长度：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Simulate.submit(form!);</span><br><span class="line">const errorSpans = getAllByText(&quot;This must be populated&quot;);</span><br><span class="line">expect(errorSpans.length).toBe(2);</span><br></pre></td></tr></table></figure><ol start="4"><li>最后一步，我们需要清理DOM元素的内容。相比<code>ReactDOM.unmountComponentAtNode</code>。我们在测试外部执行清理操作。完整的代码如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">afterEach(cleanup);</span><br><span class="line"></span><br><span class="line">describe(&#x27;ContactUs&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&#x27;When submit without filling in fields should display errors&#x27;, () =&gt; &#123;</span><br><span class="line">    const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        success: true,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    const &#123;container, getAllByText&#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">    const form = container.querySelector(&#x27;form&#x27;);</span><br><span class="line">    expect(form).not.toBeNull();</span><br><span class="line">    Simulate.submit(form!);</span><br><span class="line"></span><br><span class="line">    const errorSpans = getAllByText(&#x27;This must be populated&#x27;);</span><br><span class="line">    expect(errorSpans.length).toBe(1);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试自动执行后，发现所有测试已通过。</p><h3><span id="using-fireevent-for-user-interaction">Using fireEvent for user interaction</span></h3><p>接下来，需要测试用户真正的行为。</p><ol><li>首先添加<code>fireEvent</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; render, cleanup, fireEvent &#125; from &quot;react-testing-library&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>继续添加<code>getByText</code>函数对渲染函数<code>render</code>进行解构：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; getAllByText, getByText &#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br></pre></td></tr></table></figure><p>这里把<code>container</code>变量移除了，因为不再需要用到。</p><ol start="3"><li>获取<code>Submit</code>按钮，并使用<code>fireEvent</code>触发按钮的点击。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123;getAllByText, getByText&#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">const submitButton = getByText(&quot;Submit&quot;);</span><br><span class="line">fireEvent.click(submitButton);</span><br><span class="line"></span><br><span class="line">const errorSpans = getAllByText(&#x27;This must be populated&#x27;);</span><br><span class="line">expect(errorSpans.length).toBe(1);</span><br></pre></td></tr></table></figure><p>测试后结果通过了。</p><h3><span id="creating-a-second-test-for-a-valid-form-submission">Creating a second test for a valid form submission</span></h3><p>我们已经领会了如何编写一个健壮的测试。接下来测试表单填写不正确的错误情况。</p><ol><li>新建一个测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;ContactUs&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&#x27;When submit without filling in fields should display errors&#x27;, () =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  test(&#x27;When submit after filling in fields should submit okay&#x27;, () =&gt; &#123;</span><br><span class="line">    // TODO - render component, fill in fields, submit the form and check thre are no erros</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>以相同的解构方式渲染组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;When submit after filling in fields should submit okay&#x27;, () =&gt; &#123;</span><br><span class="line">  const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      success: true</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  const &#123; container, getByText, getByLabelText &#125; = render(</span><br><span class="line">      &lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在：</p><ul><li>需要<code>container</code>对象，以检测有没有错误信息</li><li>需要<code>getByText</code>函数，定义<code>Submit</code>按钮</li><li>需要<code>getByLabelText</code>函数获取输入内容</li></ul><ol start="3"><li>通过<code>getByLabelText</code>获取name输入。之后检测name是否存在：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; container, getByText, getByLabelText &#125; = render(</span><br><span class="line">    &lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class="line">);</span><br><span class="line">const nameField: HTMLInputElement = getByLabelText(&quot;Your name&quot;) as HTMLInputElement;</span><br><span class="line">expect(nameField).not.toBeNull();</span><br></pre></td></tr></table></figure><ol start="4"><li>模拟用户输入内容。这是使用了<code>change</code>事件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const nameField: HTMLInputElement = getByLabelText(&quot;Your name&quot;) as HTMLInputElement;</span><br><span class="line">expect(nameField).not.toBeNull();</span><br><span class="line">fireEvent.change(nameField, &#123;target: &#123;value: &quot;Carl&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里模拟用户输入了<code>Carl</code>。</p><blockquote><p>这里显示指定了nameField的类型为<code>HTMLInputElment</code>以告知编译器，避免编译错误。</p></blockquote><ol start="5"><li>对于邮箱的输入类似：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const nameField: HTMLInputElement = getByLabelText(&quot;Your name&quot;) as HTMLInputElement;</span><br><span class="line">expect(nameField).not.toBeNull();</span><br><span class="line">fireEvent.change(nameField, &#123;target: &#123;value: &quot;Carl&quot;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">const emailField = getByLabelText(&quot;Your email address&quot;) as HTMLInputElement;</span><br><span class="line">expect(emailField).not.toBeNull();</span><br><span class="line">fireEvent.change(emailField, &#123;target: &#123;value: &quot;carl.rippon@testmail.com&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里模拟用户输入了<code>carl.rippon@testmail.com</code>.</p><ol start="6"><li>然后提交表单：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fireEvent.change(emailField, &#123;target: &#123;value: &#x27;carl.rippon@testmail.com&#x27;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">const submitButton = getByText(&#x27;Submit&#x27;);</span><br><span class="line">fireEvent.click(submitButton);</span><br></pre></td></tr></table></figure><ol start="7"><li>我们的首要任务是验证没有错误出现。不幸的是，我们不能使用<code>getAllByText</code>函数，它会查找最少一个元素，我们的情况是希望没有错误出现。因此，测试前转换一下<code>div</code>标签，添加上：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;context.errors[name] &amp;&amp; context.errors[name].length &gt; 0 &amp;&amp; (</span><br><span class="line">&lt;div data-testid=&quot;formErrors&quot;&gt;</span><br><span class="line">  &#123;context.errors[name].map(error =&gt; (</span><br><span class="line">    &lt;span key=&#123;error&#125; className=&quot;form-error&quot;&gt;</span><br><span class="line">      &#123;error&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>给<code>div</code>一个<code>data-testid</code>属性。</p><ol start="8"><li>回到测试。现在可以定位到错误<code>div</code>的元素应该是<code>null</code>的。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fireEvent.click(submitButton);</span><br><span class="line"></span><br><span class="line">const errorsDiv = container.querySelector(&quot;[data-testid=&#x27;formErrors&#x27;]&quot;);</span><br><span class="line">expect(errorsDiv).toBeNull();</span><br></pre></td></tr></table></figure><p>执行测试后，所有测试通过了。</p><p>有没有不引用<code>data-testid</code>的实现？用户不希望看到或不关心<code>data-testid</code>这个属性，这显然违背我们的初衷。</p><h2><span id="using-jest-snapshot-tests">Using Jest snapshot tests</span></h2><p>快照测试，是指Jest会将渲染的所有元素和属性，和前一个渲染组件的快照进行比较。如果没有差异，则测试通过。</p><p>我们将使用快照测试的方法，来校验<code>ContactUs</code>组件是否渲染OK。</p><ol><li>在<code>ContactUs</code>组里面创建一个<code>Renders okay</code>的测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;ContactUs&quot;, () =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    test(&#x27;Renders okay&#x27;, () =&gt; &#123;</span><br><span class="line">const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    success: true</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123; container &#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br><span class="line">// TODO - do the snapshot test</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>添加下面行实现快照测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;Renders okay&#x27;, () =&gt; &#123;</span><br><span class="line">const handleSubmit = async (): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    success: true</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123; container &#125; = render(&lt;ContactUs onSubmit=&#123;handleSubmit&#125; /&gt;);</span><br><span class="line">expect(container).toMatchSnapshot();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>快照测试非常简单。我们将DOM节点和<code>expect</code>函数期望进行比较，然后触发<code>toMatchSnapshot</code>函数检验。</p><p>当测试执行后，可以从控制台看到快照已经被写入 <strong>1 snapshot written</strong>。</p><ol start="3"><li>我们会发现，在<code>src</code>目录，包含有一个<code>__snapshots__</code> 目录。进入目录可以看到有一个<code>ContactUs.test.tsx.snap</code>文件，文件内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><span class="line"></span><br><span class="line">exports[`ContactUs Renders okay 1`] = `</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;form</span><br><span class="line">    class=&quot;form&quot;</span><br><span class="line">    novalidate=&quot;&quot;</span><br><span class="line"> ...</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在这份代码片段，某些内容是被剔除了的。但保留了主要信息：<code>toMatchSnapshot</code>函数，将<code>container</code>中的每个DOM节点(包含attribute)作了一份拷贝。</p><p>这种测试严重耦合在我们的实现上。任何DOM结构或属性的改动都会中断我们的测试。</p><ol start="4"><li>例如，<code>Form.tsx</code>中，我们在<code>Form</code>标签内再添加一个<code>div</code>标签。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form ...&gt;</span><br><span class="line">    &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>当测试执行后，我们可以确定测试被打断了。Jest将前后改动的不同显式了出来。</p><p><img src="/img/react-ts/jest_snapshot.png" alt="jest snapshot"></p><ol start="5"><li>当然这是合法的改动，我们可以键入 <strong>U</strong> 让Jest更新快照。</li></ol><p><img src="/img/react-ts/jest_snapshot_update.png" alt="snapshot update"></p><p>那么，快照测试是好事还是坏事？他们是不稳定的因为它紧紧耦合了一个组件的实现。然后，它们也非常容易实现，当出现问题时，Jest会高亮问题所在让我们高效地修正问题。如果你们项目需要，值得尝试。</p><h2><span id="mocking-dependencies">Mocking dependencies</span></h2><p>模拟组件的依赖可以使得组件更容易测试。然而，如果模拟的数据太多，测试就真的代表了现实场景了吗？</p><p>对于mock什么的测试是非常难写的。它会有很多层概念。例如mock的是REST API、mock的是事件、mock的是组件…</p><p>本小节仅仅介绍REST API的mock调用测试。在此之前，首先介绍mock的特性。</p><h3><span id="using-a-mock-function-in-jest">Using a mock function in Jest</span></h3><p>我们将继续提升表单的测试内容，添加额外的检查，以确保表单输入出现错误时，提交的处理不会执行。</p><ol><li>回到原来的<code>ContactUs.test.tsx</code>的第一个测试，将之前手动创建的一个<code>handleSubmit</code>函数，更改为一个mock函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const handleSubmit = jest.fn();</span><br></pre></td></tr></table></figure><p>测试执行后，运行正常。</p><ol start="2"><li>现在提交时一个mock，我们可以检测它是否被调用了：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const errorSpans = container.querySelectorAll(&quot;.form-error&quot;);</span><br><span class="line">expect(errorSpans.length).toBe(2)</span><br><span class="line">expect(handleSubmit).not.toBeCalled();</span><br></pre></td></tr></table></figure><p>相比从前的写法，不仅简化了submit函数，还额外检查了提交处理是否执行。</p><p>我们继续来到第二个测试的实现中，它会检测一个合法的提交是否ok。</p><ol><li>将它的<code>handleSubmit</code>也更改为jest mock 函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const handleSubmit = jest.fn();</span><br></pre></td></tr></table></figure><ol start="2"><li>这里的表单肯定被提交处理了，我们需要验证的是它提交了多少次：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const errorsDiv = container.querySelector(&quot;[data-testid=&#x27;formErrors&#x27;]&quot;);</span><br><span class="line">expect(errorsDiv).toBeNull();</span><br><span class="line">expect(handleSubmit).toBeCalledTimes(1);</span><br></pre></td></tr></table></figure><p>测试执行后，pass了。</p><ol start="3"><li>还有另外一种非常实用的方法。我们知道了提交请求已经被处理了，但不能确定参数是否正确？这里可以使用<code>toBeCalledWith</code>来检查：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expect(handleSubmit).toBeCalledTimes(1);</span><br><span class="line">expect(handleSubmit).toBeCalledWith(&#123;</span><br><span class="line">    name: &quot;Car&quot;,</span><br><span class="line">    email: &quot;carl.rippon@testmail.com&quot;,</span><br><span class="line">    reason: &quot;Support&quot;,</span><br><span class="line">    notes: &quot;&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试再次pass了。</p><p>通过使用mock函数处理，可以对有价值的数据进行校验审查。</p><h3><span id="mocking-axios-with-axios-mock-adapter">Mocking Axios with axios-mock-adapter</span></h3><p>现在移步到第9章的代码部分。</p><p>我们将测试post请求得到的渲染内容是否正确。我们将mock REST API数据进行测试。</p><ol><li>首先添加依赖包：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios-mock-adapter --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>然后安装<code>react-testing-library</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-testing-library --save-dev</span><br></pre></td></tr></table></figure><ol start="3"><li>该项目早已经有一个测试文件<code>App.test.tsx</code>了。我们删掉已有的测试代码。</li><li>然后倒入额外的测试包，如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;render, cleanup, waitForElement&#125; from &#x27;@testing-library/react&#x27;;</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">import MockAdapter from &#x27;axios-mock-adapter&#x27;;</span><br></pre></td></tr></table></figure><ol start="5"><li>添加清理工具，每次测试后进行清理。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afterEach(cleanup);</span><br></pre></td></tr></table></figure><ol start="6"><li>分组，描述测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;App&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&#x27;When page loads, posts are rendered&#x27;, async () =&gt; &#123;</span><br><span class="line">    // TODO = render the app component with a mock API and check that the posts in the rendered list are as expected</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>箭头函数标记了<code>async</code>。因为我们最终是一个异步请求的测试。</p><ol start="7"><li>第一步要做的是mock REST API：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;When page loads, posts are rendered&#x27;, async () =&gt; &#123;</span><br><span class="line">  const mock = new MockAdapter(axios);</span><br><span class="line">  mock.onGet(&#x27;https://jsonplaceholder.typicode.com/posts&#x27;).reply(200, [</span><br><span class="line">    &#123;</span><br><span class="line">      userId: 1,</span><br><span class="line">      id: 1,</span><br><span class="line">      title: &#x27;title test 1&#x27;,</span><br><span class="line">      body: &#x27;body test 1&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      userId: 1,</span><br><span class="line">      id: 2,</span><br><span class="line">      title: &#x27;title test 2&#x27;,</span><br><span class="line">      body: &#x27;body test 2&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>onGET</code>方法上模拟HTTP的返回内容。</p><ol start="8"><li>接下来检查请求后渲染的内容是否正确。要达到该目的，我们在<code>App.tsx</code>的列表标签添加一个额外的<code>data-testid</code>属性，用作测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;this.state.posts.length &gt; 0 &amp;&amp;(</span><br><span class="line">&lt;ul className=&quot;posts&quot; data-testid=&quot;posts&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>回到原来的测试，对渲染的内容进行解构：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock.onGet(&#x27;https://jsonplaceholder.typicode.com/posts&#x27;).reply(...)</span><br><span class="line">                                                             const &#123;getByTestId&#125; = render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure><ol start="10"><li>我们需要检测渲染的请求是否正确。但由于是异步的，我们需要等待请求。可以使用<code>waitForElement</code>函数处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;getByTestId&#125; = render(&lt;App /&gt;);</span><br><span class="line">const postsList: any = await waitForElement(() =&gt; getByTestId(&#x27;posts&#x27;));</span><br></pre></td></tr></table></figure><p><code>waitForElement</code>函数接收一个箭头函数作为参数，返回我们需要等待的元素。</p><ol start="11"><li>接下来我们可以使用一个快照检测post的内容是否正确：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(postsList).toMatchSnapshot();</span><br></pre></td></tr></table></figure><ol start="12"><li>在测试执行之前，修改一下<code>tsconfig.json</code>文件。让TypeScript编译器知道我们使用了<code>async</code>和<code>await</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;lib&quot;: [&quot;dom&quot;, &quot;es2015&quot;],</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [&quot;src&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行后，快照被创建。查看快照后，我们可以看到请求返回了渲染的内容，其中包含了两个条目。</p><h2><span id="getting-code-coverage">Getting code coverage</span></h2><p>覆盖率会告知我们UT对代码的覆盖情况。我们在编写UT的时候，希望知道哪些代码还没测试的，哪些通过了，以方便进行跟踪。</p><p>Jest带有一个覆盖率工具，以上一节的代码为例。</p><ol><li>要使用Jest的覆盖率工具，需要添加新的脚本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;react-scripts test --env=jest-environment-jsdom-sixteen&quot;,</span><br><span class="line">  &quot;coverage&quot;: &quot;react-scripts test --env=jest-environment-jsdom-sixteen --coverage&quot;,</span><br><span class="line">  &quot;eject&quot;: &quot;react-scripts eject&quot;,</span><br><span class="line">  &quot;eslint&quot;: &quot;eslint src --ext .js,.jsx,.tsx,.ts --fix&quot;,</span><br><span class="line">  &quot;tslint&quot;: &quot;tslint --fix &#x27;./src/**/*&#123;.ts,.tsx&#125;&#x27;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后运行脚本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run coverage</span><br></pre></td></tr></table></figure><p>一会会在控制台输出测试覆盖率统计信息：</p><p><img src="/img/react-ts/test_coverage.png" alt="test coverage"></p><ol start="3"><li>在项目目录结构中，可以看到添加了一个新的<code>coverage</code>文件夹，包含一个子文件夹<code>lcov-report</code>。里面有一个<code>index.html</code>文件，打开文件可以看到更加详细的统计信息。</li><li>我们可以点击链接，查看代码的覆盖情况。</li></ol><h2><span id="summary">Summary</span></h2><p>本章介绍了Jest测试的一些常用函数的使用。譬如<code>expect</code>、<code>toBe</code>，用于验证数据。</p><p>还介绍了如何对组件进行解构测试，通过<code>getByText</code>和<code>getLabelByText</code>获取组件的元素信息。</p><p>还学习了使用<code>waitForElement</code>函数处理异步事件和请求信息。</p><p>其中讨论了快照的测试情况，它会中断我们的测试，我们可以更新快照以跟踪代码的实现。</p><p>对应一些异步的请求，我们可以使用mock的方式进行模拟。我们引进了<code>axios-mock-adapter</code>，并介绍了如何简单的测试异步渲染的内容。</p><p>最后介绍了代码覆盖率工具的使用。</p><p>除此之外，还有两个常见的测试框架：<code>Jasmine</code>和<code>Mocha</code>。Jest的优势在于它已经集成在<code>create-react-app</code>的命令中了。当然你也可以替换这两款的测试框架。</p><p>还有另一个强大的测试框架<code>Enzyme</code>。它是基于Jest的实现。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 GraphQL接口交互</title>
      <link href="/2019/11/27/react-ts/chapter_a_Interacting_with_GraphQL_APIs/"/>
      <url>/2019/11/27/react-ts/chapter_a_Interacting_with_GraphQL_APIs/</url>
      
        <content type="html"><![CDATA[<ul><li>GraphQL query and mutation syntax</li><li>Using axios as a GraphQL client</li><li>Using Apollo GraphQL client</li><li>Working with cached data in Apollo</li></ul><p>GraphQL很少被用到，本章仅作简单介绍和使用。</p><span id="more"></span><p>GraphQL是由Facebook开源的web API数据读写语言。它允许客户端，在一个请求中返回指定的数据内容。</p><h2><span id="graphql-query-and-mutation-syntax">GraphQL query and mutation syntax</span></h2><p>首先介绍一下语法。</p><h3><span id="reading-graphql-data">Reading GraphQL data</span></h3><h3><span id="basic-query">Basic query</span></h3><ol><li>首先打开 .</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.github.com/v4/explorer/</span><br></pre></td></tr></table></figure><ol start="2"><li>输入下面内容并执行 .</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>query</code>关键字开启了查询，它是可选的。</li><li><code>viewer</code>是我们需要获取的对象。</li><li><code>name</code>为<code>viewer</code>的名字，作为返回。</li></ul><p>执行后返回的是JSON对象。</p><ol start="3"><li>我们可以从结果部分查看文档说明。</li><li>从文档得知，我们还可以添加额外的查询字段：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">  name</span><br><span class="line">  avatarUrl</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="returning-nested-data">Returning nested data</span></h3><p>复杂一点，我们希望查询github的start和issue的数量并返回。</p><ol><li>首先输入下面查询：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  repository(owner:<span class="string">&quot;facebook&quot;</span>, name: <span class="string">&quot;react&quot;</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次传递了两个参数，查找<code>owner</code>为Facebook，name为react的仓储.以及将 name 和 description作为返回值。</p><ol start="2"><li>下面希望获取得到star的数量。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  repository(owner:<span class="string">&quot;facebook&quot;</span>,name:<span class="string">&quot;react&quot;</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">    stargazers &#123;</span><br><span class="line">      totalCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>指定别名：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stargazers &#123;</span><br><span class="line">  stars:totalCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行查询语句后，可以看到返回的star已被别名代替：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">             <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A declarative, efficient, and flexible</span></span><br><span class="line"><span class="string">JavaScript library for building user interfaces.&quot;</span>, <span class="attr">&quot;stargazers&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;stars&quot;</span>: <span class="number">114998</span> &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>查找最近的5个issues信息，</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  repository(owner: <span class="string">&quot;facebook&quot;</span>, name:<span class="string">&quot;react&quot;</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">    stargazers &#123;</span><br><span class="line">      stars:totalCount</span><br><span class="line">    &#125;</span><br><span class="line">    issues(last: <span class="number">5</span>) &#123;</span><br><span class="line">      edges &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">          id</span><br><span class="line">          title</span><br><span class="line">          url</span><br><span class="line">          publishedAt</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的查询用<code>edges</code>和<code>node</code>包装了结构，用于cursor-based的分页。</p><h3><span id="query-parameters">Query parameters</span></h3><p>前面的查询是以硬编码的方式，我们希望定义变量查询。</p><ol><li>我们可以在<code>query</code>关键字后面添加查询变量。这些参数需要声明它的类型、变量名。其中变量名要以<code>$</code>开头。类型后要带<code>!</code>。如下：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query ($org: String!, $repo: String!) &#123;</span><br><span class="line">  repository(owner:$org, name:$repo) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在执行之前，我们需要在<strong>Query Variables</strong>面板添加变量入参：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;org&quot;</span>: <span class="string">&quot;facebook&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;repo&quot;</span>: <span class="string">&quot;react&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="writing-graphql-data">Writing GraphQL data</span></h3><p>GraphQL的数据写入需要创建<code>mutation</code>。</p><ol><li>要给github的repo加星，首先需要获得<code>id</code>.</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query($org: String!, $repo: String!) &#123;</span><br><span class="line">  repository(owner:$org, name:$repo) &#123;</span><br><span class="line">    id</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将上面查询的返回<code>id</code>拷贝，该<code>id</code>格式如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==</span><br></pre></td></tr></table></figure><ol start="3"><li>创建第一个<code>mutation</code>：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutation ($repoId: ID!) &#123;</span><br><span class="line">  addStar(input: &#123; starrableId: $repoId &#125;) &#123;</span><br><span class="line">  starrable &#123;</span><br><span class="line">  stargazers &#123;</span><br><span class="line">  totalCount</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>数据变更开始于<code>mutation</code>关键字</li><li>参数可以放在括号内</li><li><code>addStar</code>是一个<code>mutation</code>函数，包含一个<code>input</code>参数</li><li><code>input</code>实际上是一个对象，包含字段<code>starrabledId</code>，即我们需要星标的id，这里传入了<code>$repoId</code></li><li>之后我们指定了它的返回内容</li></ul><ol start="4"><li>在<strong>Query Variables</strong>面板填入参数：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;repoId&quot;</span>: <span class="string">&quot;MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>执行之后发现star数增加了</li></ol><h2><span id="using-axios-as-a-graphql-client">Using axios as a GraphQL client</span></h2><h3><span id="getting-a-github-personal-access-token">Getting a GitHub personal access token</span></h3><p>在此之前，首先需要到GitHub获取一个token。</p><h3><span id="creating-our-app">Creating our app</span></h3><p>(略)</p><h3><span id="querying-the-graphql-server">Querying the GraphQL server</span></h3><p>现在有了TypeScript版的React应用了，下面使用<code>axios</code>来进行GraphQL的查询：</p><ol><li>在<code>Header.tsx</code>，创建两个接口表示GraphQL查询的返回数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface IViewer &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    avatarUrl: string;</span><br><span class="line">&#125;</span><br><span class="line">interface IQueryResult &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        viewer: IViewer;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>Header</code>组件创建一些状态块：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [viewer, setViewer]: [IViewer, (viewer: IViewer) =&gt; void] = React.useState(&#123;name: &quot;&quot;, avatarUrl: &quot;&quot;&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>在组件被挂载时声明周期中开始GraphQL的查询。我们使用了<code>useEffect</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    // TODO - make a GraphQL query</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>第二个参数使用了一个空数组，这样仅在组件被挂载时进行查询，而不是每次都查询。</p><ol start="4"><li>然后使用<code>axios</code>进行GraphQL的查询操作：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    axios.post&lt;IQueryResult&gt;(&quot;https://api.github.com/graphql&quot;, &#123;</span><br><span class="line">        query: `query &#123;</span><br><span class="line">viewer &#123;</span><br><span class="line">name</span><br><span class="line">avatarUrl</span><br><span class="line">&#125;</span><br><span class="line">&#125;`</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>GraphQL要求使用HTTP <code>POST</code>方法，因为查询语句在方法体内。</p><ol start="5"><li>另外还需要在标头带上bearer token进行认证。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">axios.post&lt;IQueryResult&gt;(</span><br><span class="line">  &#x27;https://api.github.com/graphql&#x27;,</span><br><span class="line">  &#123;</span><br><span class="line">    query: `query &#123;</span><br><span class="line">      viewer &#123;</span><br><span class="line">      name</span><br><span class="line">      avatarUrl</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;`</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      Authorization: &#x27;bearer our-bearer-token&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里 token用前面申请的真实token。</p><ol start="6"><li>现在还没有对返回内容做处理，因此：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.post&lt;IQueryResult&gt;(</span><br><span class="line">  ...,</span><br><span class="line">).then(response =&gt; &#123;</span><br><span class="line">  setViewer(response.data.data.viewer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>现在数据已经存入了state，对页面内容渲染即可：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&#123;viewer.avatarUrl&#125; className=&quot;avatar&quot; /&gt;</span><br><span class="line">    &lt;div className=&quot;viewer&quot;&gt;&#123;viewer.name&#125;&lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;GitHub Search&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="8"><li>添加一些样式到<code>App.css</code>:</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到运行的页面，可以看到我们的头像和标题。</p><p>我们发现，所有的GraphQL的请求都是HTTP POST，所有请求都指向同一个地址，请求的参数不是在URL地址，而是来源于请求体。因此，当我们使用诸如<code>axios</code>这种HTTP标准库会觉得怪怪的。</p><p>我们希望有一种更自然的方式。</p><h2><span id="using-apollo-graphql-client">Using Apollo GraphQL client</span></h2><p>Apollo是一个用于交互GraphQL服务端的客户端库。相比<code>axios</code>它有更多的优势，譬如对数据的读写缓存。</p><h3><span id="installing-apollo-client">Installing Apollo client</span></h3><ol><li>首先安装相应的包：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install apollo-boost react-apollo graphql</span><br></pre></td></tr></table></figure><ul><li><code>apollo-boost</code>包含了Apollo客户端的所有内容</li><li><code>react-apollo</code>包含有用于交互GraphQL服务的React 组件</li><li><code>graphql</code>是个用于解析GraphQL查询的核心包</li></ul><ol start="2"><li>另外需要安装一些TypeScript的类型：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/graphql --save-dev</span><br></pre></td></tr></table></figure><ol start="3"><li>还需要确保编译时，应该包含<code>es2015</code>和<code>esNext</code>的依赖库。在<code>tsconfig.json</code>添加<code>lib</code>中:</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;es2015&quot;</span>, <span class="string">&quot;dom&quot;</span>, <span class="string">&quot;esnext&quot;</span>],</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="migrating-from-axios-to-apollo">Migrating from axios to Apollo</span></h3><p>迁移到apollo上。</p><h3><span id="adding-an-apollo-provider">Adding an Apollo provider</span></h3><p>首先从<code>App.tsx</code>入手，将会定义我们的Apollo客户端，并_提供_给<code>App</code>所有子组件下使用。</p><ol><li>在<code>App.tsx</code>，导入依赖：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import ApolloClient from &quot;apollo-boost&quot;；</span><br><span class="line">import&#123; ApolloProvider &#125; from &quot;react-apollo&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>App</code>类组件前面，创建客户端<code>ApolloClient</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const client = new ApolloClient(&#123;</span><br><span class="line">    uri: &quot;https://api.github.com/graphql&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        authorization: `Bearer our-bearer-token`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>最后一步是使用<code>ApolloProvider</code>组件并传入<code>ApolloClient</code>参数即可。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ApolloProvider client=&#123;client&#125;&gt;</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">          &lt;Header /&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/ApolloProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>ApolloClient</code>已经设置好了，下面开始交互内容。</p><h3><span id="using-the-query-component-to-query-graphql">Using the query component to query GraphQL</span></h3><p>我们现在使用<code>Query</code>组件来获取GitHub的名字和头像，替换掉<code>axios</code>代码：</p><ol><li>导入下面依赖，并删掉原来的<code>axios</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import gql from &quot;graphql-tag&quot;;</span><br><span class="line">import &#123; Query &#125; from &quot;react-apollo&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>IViewer</code>接口内容保留，但需要和<code>IQueryResult</code>拧在一起：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IQueryResult &#123;</span><br><span class="line">    viewer: IViewer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义查询：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const GET_VIEWER = gql`</span><br><span class="line">&#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">    name</span><br><span class="line">    avatarUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>我们字面量声明了<code>GET_VIEWER</code>查询。在前面带有<code>gql</code>看起来有些古怪。这个模板字面量不应该用括号吗？实际上<code>gql</code>是一个函数，它会解析该函数后面的查询语句。</p><ol start="4"><li>为了Type safety，创建一个新的组件<code>GetViewerQuery</code>，并定义结果的返回类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class GetViewerQuery extends Query&lt;IQueryResult&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>我们不再需要状态，因此移除<code>viewer</code>和<code>setViewer</code>变量。</li><li>因为不需要<code>axios</code>查询了，<code>useEffect</code>也删掉。</li><li>我们使用<code>GetViewerQuery</code>组件进行查询：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;GetViewerQuery query=&#123;GET_VIEWER&#125;&gt;</span><br><span class="line">    &#123;(&#123;data&#125;) =&gt; &#123;</span><br><span class="line">      if (!data || !data.viewer) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;img src=&#123;data.viewer.avatarUrl&#125; className=&quot;avatar&quot;  alt=&#123;&quot;avatar&quot;&#125;/&gt;</span><br><span class="line">          &lt;div className=&quot;viewer&quot;&gt;&#123;data.viewer.name&#125;&lt;/div&gt;</span><br><span class="line">          &lt;h1&gt;GitHub Search&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &lt;/Query&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="8"><li>如果我们希望获取其它信息内容。例如查询数据是否正在加载中。可以改为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">    &lt;GetViewerQuery query=&#123;GET_VIEWER&#125;&gt;</span><br><span class="line">        &#123;(&#123; data, loading&#125;) =&gt; &#123;</span><br><span class="line">            if (loading) &#123;</span><br><span class="line">                return &lt;div className=&quot;viewer&quot;&gt;Loading...&lt;/div&gt;;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;/GetViewerQuery&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="9"><li>又或者想要获取错误信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">    &lt;GetViewerQuery query=&#123;GET_VIEWER&#125;&gt;</span><br><span class="line">        &#123;(&#123; data, loading, error&#125;) =&gt; &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                return &lt;div className=&quot;viewer&quot;&gt;&#123;error.toString()&#125;&lt;/div&gt;;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;/GetViewerQuery&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Apollo的实现非常优雅。它可以确保<code>Query</code>组件在正确的位置获取得到对应的数据。</p><h3><span id="adding-a-repository-search-component">Adding a repository search component</span></h3><p>根据已有的查询功能，我们希望有一个搜索repository的选框。</p><ol><li>首先创建一个<code>RepoSearch.tsx</code>，导入相应的依赖：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import gql from &quot;graphql-tag&quot;;</span><br><span class="line">import &#123; ApolloClient &#125; from &quot;apollo-boost&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>由于需要带入<code>ApolloClient</code>作为prop，添加一个接口实现：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">    client: ApolloClient&lt;any&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>架设组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const RepoSearch: React.FC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">export default RepoSearch;</span><br></pre></td></tr></table></figure><ol start="4"><li>导入的<code>App.tsx</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import RepoSearch from &quot;./RepoSearch&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>添加到<code>ApolloClient</code>下面：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ApolloProvider client=&#123;client&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">    &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;RepoSearch client=&#123;client&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/ApolloProvider&gt;</span><br></pre></td></tr></table></figure><h3><span id="implementing-the-search-form">Implementing the search form</span></h3><p>实现一个表单，允许用户输入组织名和仓储名：</p><ol><li>在<code>RepoSearch.tsx</code>，定义搜索字段接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ISearch &#123;</span><br><span class="line">    orgName: string;</span><br><span class="line">    repoName: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个变量来装载<code>search</code>状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const RepoSearch: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">    const [search, setSearch]: [ISearch, (search: ISearch) =&gt; void] = React.useState(&#123;orgName: &quot;&quot;, repoName: &quot;&quot;&#125;);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义<code>search</code>表单：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">&lt;div className=&quot;repo-search&quot;&gt;</span><br><span class="line">  &lt;form onSubmit=&#123;handleSearch&#125;&gt;</span><br><span class="line">    &lt;label&gt;Organization&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; onChange=&#123;handleOrgNameChange&#125; value=&#123;search.orgName&#125; /&gt;</span><br><span class="line">    &lt;label&gt;Repository&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; onChange=&#123;handleRepoNameChange&#125; value=&#123;search.repoName&#125; /&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="4"><li>添加样式：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.repo-search</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.repo-search</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#676666</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.repo-search</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>实现表单事件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const handleOrgNameChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">  setSearch(&#123;...search, orgName: e.currentTarget.value&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleRepoNameChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">  setSearch(&#123;...search, repoName: e.currentTarget.value&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li>最后一个操作是实现<code>search</code>的处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  // TODO - make GraphQL query</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，表单的创建已经完成。</p><h3><span id="implementing-the-search-query">Implementing the search query</span></h3><p>现在的关键问题是，如何查询。</p><ol><li>首先创建返回接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface IRepo &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  description: string;</span><br><span class="line">  viewerHasStarred: boolean;</span><br><span class="line">  stargazers: &#123;</span><br><span class="line">    totalCount: number;</span><br><span class="line">  &#125;;</span><br><span class="line">  issues: &#123;</span><br><span class="line">    edges: [</span><br><span class="line">      &#123;</span><br><span class="line">        node: &#123;</span><br><span class="line">          id: string;</span><br><span class="line">          title: string;</span><br><span class="line">          url: string;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构跟GitHub GraphQL Explorer的返回一样。</p><ol start="2"><li>需要一个默认的初始化值：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const defaultRepo: IRepo = &#123;</span><br><span class="line">  id: &#x27;&#x27;,</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  description: &#x27;&#x27;,</span><br><span class="line">  viewerHasStarred: false,</span><br><span class="line">  stargazers: &#123;</span><br><span class="line">    totalCount: 0,</span><br><span class="line">  &#125;,</span><br><span class="line">  issues: &#123;</span><br><span class="line">    edges: [</span><br><span class="line">      &#123;</span><br><span class="line">        node: &#123;</span><br><span class="line">          id: &#x27;&#x27;,</span><br><span class="line">          title: &#x27;&#x27;,</span><br><span class="line">          url: &#x27;&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义查询结果接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IQueryResult &#123;</span><br><span class="line">    repository: IRepo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建查询模板字面量(tagged template literal)：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const GET_REPO = gql`</span><br><span class="line">  query GetRepo($orgName: String!, $repoName: String!) &#123;</span><br><span class="line">    repository(owner: $orgName, name: $repoName) &#123;</span><br><span class="line">      id</span><br><span class="line">      name</span><br><span class="line">      description</span><br><span class="line">      viewerHasStarred</span><br><span class="line">      stargazers &#123;</span><br><span class="line">        totalCount</span><br><span class="line">      &#125;</span><br><span class="line">      issues(last: 5) &#123;</span><br><span class="line">        edges &#123;</span><br><span class="line">          node &#123;</span><br><span class="line">            id</span><br><span class="line">            title</span><br><span class="line">            url</span><br><span class="line">            publishedAt</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>不同的是，此次查询带有参数。</p><ol start="5"><li>另外需要存储返回的数据到状态中。因此创建变量<code>repo</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [repo, setRepo]: [IRepo, (repo: IRepo) =&gt; void] = React.useState(defaultRepo);</span><br></pre></td></tr></table></figure><ol start="6"><li>存储一些错误信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [searchError, setSearchError]: [string, (searchError: string) =&gt; void] = React.useState(&quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="7"><li>更新<code>handleSearch</code>箭头函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">setSearchError(&quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="8"><li>传入<code>ApolloClient</code>进行查询：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  setSearchError(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">  props.client</span><br><span class="line">    .query&lt;IQueryResult&gt;(&#123;</span><br><span class="line">      query: GET_REPO</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>将参数传入给query语句：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  setSearchError(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">  props.client</span><br><span class="line">    .query&lt;IQueryResult&gt;(&#123;</span><br><span class="line">      query: GET_REPO,</span><br><span class="line">      variables: &#123;orgName: search.orgName, repoName: search.repoName&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li>处理返回内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  setSearchError(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">  props.client</span><br><span class="line">    .query&lt;IQueryResult&gt;(...)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">      setRepo(response.data.repository);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="11"><li>处理异常信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const handleSearch = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  setSearchError(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">  props.client</span><br><span class="line">    .query&lt;IQueryResult&gt;(...)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">      setSearchError(error.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="rendering-the-result">Rendering the result</span></h3><p>既然数据已经获取到了，需要将数据展现出来：</p><ol><li>渲染github点赞部分：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;repo-search&quot;&gt;</span><br><span class="line">  &lt;form ...&gt;</span><br><span class="line">      ...</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &#123;repo.id &amp;&amp; (</span><br><span class="line">    &lt;div className=&quot;repo-item&quot;&gt;</span><br><span class="line">      &lt;h4&gt;</span><br><span class="line">        &#123;repo.name&#125;</span><br><span class="line">        &#123;repo.stargazers ? ` $&#123;repo.stargazers.totalCount&#125; stars` : &#x27;&#x27;&#125;</span><br><span class="line">      &lt;/h4&gt;</span><br><span class="line">      &lt;p&gt;&#123;repo.description&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>渲染repository的列表：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;p&gt;&#123;repo.description&#125;&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Last 5 issues:</span><br><span class="line">    &#123;repo.issues &amp;&amp; repo.issues.edges ? (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;repo.issues.edges.map(item =&gt; (</span><br><span class="line">          &lt;li key=&#123;item.node.id&#125;&gt;&#123;item.node.title&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    ) : null&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>显示错误信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#123;repo.id &amp;&amp; (</span><br><span class="line">   ...</span><br><span class="line">  &#123;searchError &amp;&amp; &lt;div&gt;&#123;searchError&#125;&lt;/div&gt;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>添加<code>App.css</code>样式：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.repo-search</span> <span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="implementing-a-mutation-with-apollo">Implementing a mutation with Apollo</span></h3><p>我们可以在React中使用GraphQL的<code>mutation</code>。</p><ol><li>首先导入<code>Mutation</code>组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Mutation &#125; from &quot;react-apollo&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>mutation</code>的查询：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const STAR_REPO = gql`</span><br><span class="line">  mutation($repoId: ID!) &#123;</span><br><span class="line">    addStar(input: &#123;starrableId: $repoId&#125;) &#123;</span><br><span class="line">      starrable &#123;</span><br><span class="line">        stargazers &#123;</span><br><span class="line">          totalCount</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><ol start="3"><li>在渲染代码部分，加入<code>Mutation</code>组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;repo.description&#125;&lt;/p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;!repo.viewerHasStarred &amp;&amp; (</span><br><span class="line">    &lt;Mutation mutation=&#123;STAR_REPO&#125;</span><br><span class="line">              variables=&#123;&#123; repoId: repo.id &#125;&#125;</span><br><span class="line">              &gt;</span><br><span class="line">      &#123;() =&gt; (</span><br><span class="line">        // render Star button that invokes the mutation when clicked</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Mutation&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Last 5 issues:</span><br></pre></td></tr></table></figure><ul><li>对<code>mutation</code>的渲染在<code>viewer</code>没有被点赞的repo</li><li><code>Mutation</code>组件接收repository 的<code>id</code>作为入参</li></ul><ol start="4"><li><code>Mutation</code>组件有一个子函数<code>addStar</code>允许我们访问点赞数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mutation</span><br><span class="line">    ...</span><br><span class="line">    &gt;</span><br><span class="line">    &#123;(addStar) =&gt; (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; addStar()&#125;&gt;</span><br><span class="line">                Star!</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/Mutation&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>loading</code>属性作为第二参数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mutation</span><br><span class="line">...</span><br><span class="line">&gt;</span><br><span class="line">&#123;(addStar, &#123; loading &#125;) =&gt; (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button disabled=&#123;loading&#125; onClick=&#123;() =&gt; addStar()&#125;&gt;</span><br><span class="line">&#123;loading ? &quot;Adding ...&quot; : &quot;Star!&quot;&#125;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&lt;/Mutation&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>处理错误信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;(addStar, &#123; loading, error&#125;) =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button disabled=&#123;loading&#125; onClick=&#123;() =&gt; addStar()&#125;&gt;</span><br><span class="line">      &#123;loading? &quot;Adding ...&quot;: &quot;Star!&quot;&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &#123;error &amp;&amp; &lt;div&gt;&#123;error.toString()&#125;&lt;/div&gt;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h2><span id="working-with-cached-data-in-apollo">Working with cached data in Apollo</span></h2><p>前面发现点击按钮后，数据并没有刷新，需要清理掉浏览器的缓存数据。</p><h3><span id="clearing-the-caching-using-refetchqueries">Clearing the caching using refetchQueries</span></h3><p>每次发生<code>mutation</code>操作时，需要清理掉缓存信息。一种方式是使用<code>refetchQueries</code>：</p><ol><li><code>refetchQueries</code>接收一个数组对象，该对象的查询变量会被从缓存中删除。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mutation</span><br><span class="line">  mutation=&#123;STAR_REPO&#125;</span><br><span class="line">  variables=&#123;&#123;repoId: repo.id&#125;&#125;</span><br><span class="line">  refetchQueries=&#123;[</span><br><span class="line">    &#123;</span><br><span class="line">      query: GET_REPO,</span><br><span class="line">      variables: &#123;</span><br><span class="line">        orgName: search.orgName,</span><br><span class="line">        repoName: search.repoName,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]&#125;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>如果给一个repo点赞，点赞的数字并没有立即更新。然而，点击<code>Search</code>按钮后才更新。</li></ol><p>因此，数据也并没有立即更新，这种方式也不是很好，用户体验不太理想。</p><h3><span id="updating-the-cache-after-a-mutation">Updating the cache after a Mutation</span></h3><p>幸运的是，<code>Mutation</code>组件还有另外一个方法<code>update</code>，我们可以对缓存信息进行更新。</p><ol><li>删掉之前的<code>refetchQueries</code>。</li><li>实现<code>update</code>操作：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mutation</span><br><span class="line">    mutation=&#123;STAR_REPO&#125;</span><br><span class="line">    udpate=&#123;cache=&gt; &#123;</span><br><span class="line">        // Get the cached data</span><br><span class="line">        // update the cached data</span><br><span class="line">        // update our state</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>更新缓存：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mutation</span><br><span class="line">    ...</span><br><span class="line">    update=&#123;cache =&gt; &#123;</span><br><span class="line">        const data: &#123; repository: IRepo &#125; | null = cache.readQuery(&#123;</span><br><span class="line">            query: GET_REPO,</span><br><span class="line">            variables: &#123;</span><br><span class="line">                orgName: search.orgName,</span><br><span class="line">                repoName: search.repoName</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (data === null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果没有缓存数据，我们直接return，不做任何处理。</p><ol start="4"><li>现在有了一份来自缓存的数据了，直接对这份数据操作。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">update=&#123;cache =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (data === null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">const newData = &#123;</span><br><span class="line">        ...data.repository,</span><br><span class="line">        viewerHasStarred: true,</span><br><span class="line">        stargazers: &#123;</span><br><span class="line">            ...data.repository.stargazers,</span><br><span class="line">            totalCount: data.repository.stargazers.totalCount + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>然后使用<code>writeQuery</code>函数来更新缓存信息。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">update=&#123;cache =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        const newData=&#123;</span><br><span class="line">        ...</span><br><span class="line">       &#125;;</span><br><span class="line">cache.writeQuery(&#123;</span><br><span class="line">    query: GET_REPO,</span><br><span class="line">    variable: &#123;</span><br><span class="line">        orgName: search.orgName,</span><br><span class="line">        repoName: search.repoName,</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123; repository: newData &#125;</span><br><span class="line">&#125;)</span><br><span class="line">       &#125;&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>最后一步是更新本地的state数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update=&#123;cache =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        cache.writeQuery(...);</span><br><span class="line">setRepo(newData);</span><br><span class="line">       &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样，当给某个repo点赞，可以看到数据立即刷新了。</p><h2><span id="summary">Summary</span></h2><p>GraphQL目前不是很少用，虽然某些情况下很灵活，提供了树形结构的数据。查询和返回结构一致。只有一个请求地址。请求方法只有一个POST。查询参数灵活多变。</p><p>这里还介绍了<code>Apollo</code>客户端的实现，相比于<code>axios</code>。只需要在顶层组件实现一个<code>provider</code>即可，类似于Router的实现。</p><p>还介绍了<code>Mutation</code>组件的实现，以及对内存的处理。</p><p>不常用的原因也可想而知，不便于维护，没有版本，对于简单的接口来说有点臃肿。</p><p>鉴于GraphQL很少出现，此处不作习题演练。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 RESTful 接口交互</title>
      <link href="/2019/11/27/react-ts/chapter_9_Interacting_with_RESTful_APIs/"/>
      <url>/2019/11/27/react-ts/chapter_9_Interacting_with_RESTful_APIs/</url>
      
        <content type="html"><![CDATA[<ul><li>Writing asynchronous code</li><li>Using fetch</li><li>Using axios with class components</li><li>Using axios with function components</li></ul><h2><span id="writing-asynchronous-code">Writing asynchronous code</span></h2><p>默认下TypeScript的代码是同步执行的。既是一行一行代码执行。TypeScript也可以实现异步功能。调用REST API就是一个异步实现的例子。</p><h3><span id="callbacks">Callbacks</span></h3><p>回调指的是将函数作为参数，传入到一个异步函数中调用，当该异步函数完成时执行该传参函数的内容。</p><h3><span id="callback-execution">Callback execution</span></h3><p>下面以一个例子阐述在TypeScript环境下的异步回调实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName: <span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  firstName = <span class="string">&quot;Fred&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;firstName in callback&quot;</span>, firstName);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;firstName aftr setTimeout&quot;</span>, firstName);</span><br></pre></td></tr></table></figure><p>代码中调用了JavaScript的异步函数<code>setTimeout</code>。第一个参数是一个回调函数，第二个参数是执行等待的时间。</p><p>这里的回调函数，形式上使用<code>() =&gt;&#123;&#125;</code> 表述，回调函数会将<code>firstName</code>变量更改为<code>Fred</code>，并输出到控制台。</p><p>执行代码，可以看到回调函数并没有执行，而是等待1000毫秒后再触发控制台打印信息。</p><p>异步函数的执行不会等待函数内部的完成。这种方式一方面不便于阅读，另一方面容易造成回调地狱(callback hell)。因为开发者容易在回调中内嵌更复杂的回调或异步函数实现。那么我们如何处理这种异步回调的错误？</p><h3><span id="handling-callback-erros">Handling callback erros</span></h3><p>本小节将探索如何处理异步代码的错误信息。</p><ol><li>首先有如下代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    throw new Error(&quot;Someting went wrong&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125; catch (ex) &#123;</span><br><span class="line">  console.log(&quot;An error has occurred&quot;, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次使用了<code>try / catch</code>方式来处理异步出现的错误信息。</p><ol start="2"><li>错误信息必须被处理。更改为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface IResult &#123;</span><br><span class="line">  success: boolean;</span><br><span class="line">  error?: any;</span><br><span class="line">&#125;</span><br><span class="line">let result: IResult = &#123; success: true &#125;;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;Something went wrong&quot;);</span><br><span class="line">  &#125; catch (ex) &#123;</span><br><span class="line">    result.success = false;</span><br><span class="line">    result.error = ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>这里将<code>try / catch</code>放置在回调函数的内部。以及使用了变量<code>result</code>来表述执行的成功或失败。</p><p>至此，回调引发的错误已经被处理了。幸运的是，有更好的方式来处理这种挑战。</p><h2><span id="promises">Promises</span></h2><p>promise是JavaScript里面的对象。它表述了一个异步操作的最终结果(成功或失败).</p><h3><span id="consuming-a-promised-based-function">Consuming a promised-based function</span></h3><p>下面是一个promised-based的API</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">.catch(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, json));</span><br></pre></td></tr></table></figure><ul><li>这里的函数<code>fetch</code>是javascript本地函数，用于处理RESTful API。</li><li>入参是一个URL</li><li><code>then</code>方法处理返回</li><li><code>catch</code>方法处理错误信息</li></ul><p>相比来说代码更易于阅读和理解。我们不需要在<code>then</code>方法中处理错误信息。</p><h3><span id="creating-a-promised-based-function">Creating a promised based function</span></h3><p>本小节会创建一个<code>wait</code>函数来处理异步等待信息。</p><ol><li>首先实现一个简单的回调：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function">(<span class="params">ms: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">      reject(<span class="string">&quot;Too long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;Successfully waited&quot;</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>该函数返回一个<code>Promise</code>对象，该对象包含有一个需要异步执行的构造器入参。</li><li><code>promise</code>构造入参<code>resolve</code>是一个函数，表示当函数执行完成后要处理的动作。</li><li><code>promise</code>构造入参<code>reject</code>是一个函数，表示出现错误后需要处理的动作。</li><li>函数体内部则使用了<code>setTimeout</code>以及一个回调处理等待动作。</li></ul><ol start="2"><li>消费这个<code>promised-based</code>函数：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(<span class="number">500</span>)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;then &gt;&quot;</span>, result))</span><br><span class="line">.then(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;catch &gt;&quot;</span>, error));</span><br></pre></td></tr></table></figure><p>等待500毫秒后，函数将输出正确或失败信息。</p><ol start="3"><li>将等待时间延长，大于1000，<code>catch</code>方法被调用。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(<span class="number">1500</span>)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;then &gt;&quot;</span>, result))</span><br><span class="line">.then(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;catch &gt;&quot;</span>, error));</span><br></pre></td></tr></table></figure><p><code>Promise</code>对于异步代码有一个很好的处理机制。致辞，还有另一种异步处理的实现方式。</p><h2><span id="async-and-awit">async and awit</span></h2><p><code>async</code>和<code>await</code>是JavaScript的关键字。</p><ol><li>首先从<code>wait</code>函数的例子开始：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someWork = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> wait(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">someWork();</span><br></pre></td></tr></table></figure><ul><li>这里创建了一个箭头函数<code>someWork</code>，使用关键字<code>async</code>标注为异步。</li><li>使用关键字<code>await</code>在<code>wait</code>前面声明。<code>wait</code>下一行的执行将被暂停(halt)直到这个异步操作完成。</li><li><code>try / catch</code>将捕获任何异常信息。</li></ul><p>该方法有点像是一个异步操作的管理者。执行代码后，控制台打印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then &gt; Successfully waited</span><br></pre></td></tr></table></figure><ol start="2"><li>将等待时间改为1500毫秒：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> wait(<span class="number">1500</span>);</span><br></pre></td></tr></table></figure><p>控制台打印错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Too long</span><br></pre></td></tr></table></figure><p>因此，使用<code>async</code>和<code>await</code>使得代码更易于阅读。另一个奖励是，这种实现在旧的浏览器中仍然支持。</p><p>到目前为止，我们已经对如何编写更好的异步代码有更好的理解，下面会就RESTful API的实现进行练习。</p><h2><span id="using-fetch">Using fetch</span></h2><p><code>fetch</code>函数是一个JavaScript本地函数。本小节会对一些常见的RESTful API通过<code>fetch</code>进行交互。</p><h3><span id="geting-data-with-fetch">Geting data with fetch</span></h3><p>首先开始从GET请求开始。</p><h3><span id="baisc-get-request">Baisc GET request</span></h3><p>打开 TypeScript playground，输入如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>fetch</code>函数的第一个参数是一个URL请求地址</li><li><code>fetch</code>是一个promised-base函数</li><li>第一个<code>then</code>方法处理返回</li><li>第二个<code>then</code>方法处理当返回body是JSON</li></ul><h3><span id="getting-response-status">Getting response status</span></h3><p>通常，我们需要处理返回的status code：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status, respons.ok);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>返回的<code>status</code>给出了HTTP的状态信息</li><li><code>ok</code>返回一个<code>boolean</code>值表示200的状态码</li></ul><p>另一个404的不存在的示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1001&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status, response.ok);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3><span id="handling-errors">Handling errors</span></h3><p>通过<code>catch</code>方法处理错误信息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">.catch(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, json));</span><br></pre></td></tr></table></figure><p>然而，<code>catch</code>并没有捕获非200状态的机制。所以对于非200的错误返回请求时，可以在第一个<code>then</code>方法中处理。</p><p>那么<code>catch</code>方法是干嘛的？它是用来捕获网络异常的，非200返回并不是一种网络异常。</p><h3><span id="creating-data-with-fetch">Creating data with fetch</span></h3><p>本小节将使用<code>fetch</code>来创建一些数据。</p><h3><span id="basic-post-request">Basic POST request</span></h3><p>通常情况下，调用<code>post</code>请求来创建数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Interesting post&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;This si an interesting post abount ...&quot;</span>,</span><br><span class="line">    <span class="attr">userId</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><p><code>fetch</code>函数的第二个参数是一个可选对象。包含请求的method和body信息。</p><h3><span id="request-http-headers">Request HTTP headers</span></h3><p>通常，请求信息需要包含标头(header)。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="attr">Authorization</span>: <span class="string">&quot;bearer some-bearer-token&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Interesting post&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;This is an interesting post about ...&quot;</span>,</span><br><span class="line">    <span class="attr">userId</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><p>对于<code>GET</code>请求，可以用如下形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="attr">Authorization</span>: <span class="string">&quot;bearer some-bearer-token&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(...);</span><br></pre></td></tr></table></figure><h3><span id="changing-data-with-fetch">Changing data with fetch</span></h3><h3><span id="basic-put-request">Basic PUT request</span></h3><p>通常情况下，对于数据的更改是用<code>PUT</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Corrected post&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;This is corrected post about ...&quot;</span>,</span><br><span class="line">    <span class="attr">userId</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><h3><span id="basic-patch-request">Basic PATCH request</span></h3><p>某些情况下，<code>PATCH</code>的请求用于部分请求的更改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;PATCH&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Corrected post&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><h3><span id="deleting-data-with-fetch">Deleting data with fetch</span></h3><p>通常情况下，RESTful接口都是用<code>DELETE</code>方法删除数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到目前为止，我们已经学习了如何使用<code>fetch</code>函数来操作RESTful API。</p><h2><span id="using-axios-with-class-components">Using axios with class components</span></h2><p><code>axios</code>是一个流行的开源JavaScript HTTP客户端。我们会创建一个React App包含有create,read,upate,delete等操作。并探索<code>axios</code>相比<code>fetch</code>有哪些优势。</p><h3><span id="installing-axios">Installing axios</span></h3><p>首先新建一个应用：</p><ol><li>在控制台通过命令新建一个TypeScript的React项目：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app crud-api --typescript</span><br></pre></td></tr></table></figure><p>注意我们使用的React版本至少是<code>16.7.0-alpha.0</code>。我们可以在<code>package.json</code>里面检查。如果低于<code>16.7.0-alpha.0</code>，可以使用下面命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react@16.7.0-alpha.0</span><br><span class="line">npm install react@16.7.0-alpaha.0</span><br></pre></td></tr></table></figure><ol start="2"><li>项目创建后，添加TSLint到项目中，并带有某些规则：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crud-api</span><br><span class="line">npm install tslint tslint-react tslint-config-prettier --save-dev</span><br></pre></td></tr></table></figure><ol start="3"><li>新建<code>tslint.json</code>包含下面规则：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [&quot;tslint:recommended&quot;, &quot;tslint-react&quot;, &quot;tslint-config-prettier&quot;],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;ordered-imports&quot;: false,</span><br><span class="line">    &quot;object-literal-sort-keys&quot;: false,</span><br><span class="line">    &quot;jsx-no-lambda&quot;: false,</span><br><span class="line">    &quot;no-debugger&quot;: false,</span><br><span class="line">    &quot;no-console&quot;: false,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;linterOptions&quot;: &#123;</span><br><span class="line">    &quot;exclude&quot;: [</span><br><span class="line">      &quot;config/**/*.js&quot;,</span><br><span class="line">      &quot;node_modules/**/*.ts&quot;,</span><br><span class="line">      &quot;converage/lcov-report/*.js&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>打开<code>App.tsx</code>文件，会有一个linting错误。在<code>render()</code>方法中添加<code>public</code>关键字处理该问题：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    public render() &#123;</span><br><span class="line">        return ( ... );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>axios</code>：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>注意<code>axios</code>内已经包含TypeScript类型了，不需要额外安装。</p><ol start="6"><li>运行我们的应用。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3><span id="getting-data-with-axios">Getting data with axios</span></h3><h3><span id="basic-get-request">Basic GET request</span></h3><p>首先从GET请求开始。</p><ol><li>打开<code>App.tsx</code>，导入：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &quot;axios&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建接口类型，表示JSONPlaceholder返回的内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IPost &#123;</span><br><span class="line">    userId: number;</span><br><span class="line">    id?: number;</span><br><span class="line">    title: string;</span><br><span class="line">    body: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们需要存储上述的邮件信息到state中，因此添加下面这个接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">    posts: IPost[];</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component&lt;&#123;&#125;, IState&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在构造器生命周期中初始化state：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component&lt;&#123;&#125;, IState&gt; &#123;</span><br><span class="line">    public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            posts: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>通常是在<code>componentDidMount</code>生命周期函数中获取REST API数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">    axios</span><br><span class="line">    .get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        this.setState(&#123; posts: response.data &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是使用<code>get</code>函数表述<code>GET</code>请求，它跟<code>fetch</code>一样，是一个promised-based函数。</li><li>这里是一个泛型函数，泛型参数为返回消息数据类型。</li><li>URL地址作为传入参数。</li><li>在<code>then</code>方法处理返回信息。</li><li>通过<code>data</code>对象属性获取请求的返回对象。</li></ul><p>因此，相比<code>fetch</code>有两点好处：</p><ul><li>可以定义返回的数据类型</li><li>只需要一步即可获取返回体</li></ul><ol start="6"><li>在<code>render</code>方法渲染：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">            &lt;url className=&quot;posts&quot;&gt;</span><br><span class="line">                &#123;this.state.posts.map(post =&gt; (</span><br><span class="line">                    &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">                        &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">                        &lt;p&gt;&#123;post.body&#125;&lt;/p&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">            &lt;/url&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>posts</code>数组的<code>map</code>函数来展现数据。</p><ol start="7"><li>在<code>index.css</code>添加CSS属性，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.posts</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，使用<code>axios</code>来处理请求更简单方便。以及我们需要在<code>componentDidMount</code>生命周期函数中调用。</p><p>那么对于网络错误如何处理？</p><h3><span id="handling-errors">Handling errors</span></h3><ol><li>首先添加一个错误的URL，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/postsX&quot;)</span><br></pre></td></tr></table></figure><ol start="2"><li>我们希望出现网络错误的情况下，依然给用户以反馈内容。可以用<code>catch</code>方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/postsX&quot;)</span><br><span class="line">  .then( ... )</span><br><span class="line">  .catch(ex =&gt; &#123;</span><br><span class="line">        const error = </span><br><span class="line">        ex.response.status === 404 ? &quot;Resource not found&quot; : &quot;An unexpected error has occurred&quot;;</span><br><span class="line">        this.setState(&#123; error &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>和<code>fetch</code>不同，HTTP status错误返回码可以在<code>catch</code>方法处理。错误信息包含有一个属性<code>response</code>表示请求的返回内容。</p><ol start="3"><li>另外修改该部分渲染，我们希望将错误信息显示出来：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">    posts: IPost[];</span><br><span class="line">    error: string;</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component&lt;&#123;&#125;, IState&gt; &#123;</span><br><span class="line">    public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            posts: [],</span><br><span class="line">            error: &quot;&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>渲染错误内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=&quot;posts&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;this.state.error &amp;&amp; &lt;p className=&quot;error&quot;&gt;&#123;this.state.error&#125;&lt;/p&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>添加错误的样式：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行应用，可以看到红色的 <strong>Resource not found</strong> 字体。</p><ol start="6"><li>将URL更改为原来有效的地址，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;)</span><br></pre></td></tr></table></figure><h3><span id="request-http-headers">Request Http headers</span></h3><p>有时候我们希望带上header请求信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因此，我们在HTTP请求时定义了<code>headers</code>属性。</p><h3><span id="timeouts">Timeouts</span></h3><p>超时机制用于提高用户体验。</p><ol><li>在我们的app添加一个请求超时：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout: 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的单位是毫秒。表示期望请求在1毫秒内做出响应。</p><ol start="2"><li>在<code>catch</code>方法处理超时：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.catch(ex =&gt; &#123;</span><br><span class="line">    const error = </span><br><span class="line">          ex.code === &quot;ECONNABORTED&quot;</span><br><span class="line">    ? &quot;A timeout has occurred&quot;</span><br><span class="line">    : ex.response.status === 404 </span><br><span class="line">    ? &quot;Resource not found&quot;</span><br><span class="line">    : &quot;An unexpected error has occurred&quot;;</span><br><span class="line">    this.setState(&#123; error &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们检测<code>code</code>属性来判断是否发生了超时。</p><p>再次执行应用，可以看到红色<strong>A timeout has occurred</strong>字体。</p><ol start="3"><li>将超时更改为合适的值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">    ...</span><br><span class="line">    timeout: 5000</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3><span id="canceling-requests">Canceling requests</span></h3><p>允许用户取消请求可以提升用户体验效果。</p><ol><li>首先，导入<code>CancelTokenSource</code>类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios, &#123; CancelTokenSource &#125; from &quot;axios&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 cancel token和加载flag到state中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  posts: IPost[];</span><br><span class="line">  error: string;</span><br><span class="line">  cancelTokenSource?: CancelTokenSource;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在构造器初始化：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">  posts: [],</span><br><span class="line">  error: &quot;&quot;,</span><br><span class="line">  loading: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>在<code>GET</code>请求之前，生成token资源：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">  const cancelToken = axios.CancelToken;</span><br><span class="line">  const cancelTokenSource = cancelToken.source();</span><br><span class="line">  this.setState(&#123; cancelTokenSource &#125;);</span><br><span class="line">  axios</span><br><span class="line">    .get&lt;IPost[]&gt;(...)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>然后在GET请求中使用这个token：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">  cancelToken: cancelTokenSource.token,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>我们可以在<code>catch</code>方法处理取消的情况。并设置<code>loading</code>状态为<code>false</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.catch((ex) =&gt; &#123;</span><br><span class="line">  const error =</span><br><span class="line">    ex.code === &quot;ECONNABORTED&quot;</span><br><span class="line">      ? &quot;A timeout has occurred&quot;</span><br><span class="line">      : ex.response.status === 404</span><br><span class="line">      ? &quot;Resource not found&quot;</span><br><span class="line">      : &quot;An unexpected error has occurred&quot;;</span><br><span class="line">  this.setState(&#123; error &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因此我们使用<code>axios</code>里面的<code>isCancel</code>函数来检测请求是否已经被取消。</p><ol start="7"><li>在<code>componentDidMount</code>方法里面，在<code>then</code>方法设置<code>loading</code>的状态为<code>false</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123; posts: response.data, loading: false &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="8"><li>在<code>render</code>方法中，添加一个<code>Cancel</code>按钮，允许用户取消请求：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;this.state.loading &amp;&amp; (</span><br><span class="line">    &lt;button onClick=&#123;this.handleCancelClick&#125;&gt;Cancel&lt;/button&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&lt;url className=&quot;posts&quot;&gt;...&lt;/url&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>实现取消处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private handleCancelClick = () =&gt; &#123;</span><br><span class="line">    if (this.state.cancelTokenSource) &#123;</span><br><span class="line">        this.state.cancelTokenSource.cancel(&quot;User cancelled operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="10"><li>现在有点难测，因为请求一般很快。为了可以看到取消请求的动作。我们可以在<code>componentDidMount</code>方法内立即取消请求动作：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get&lt;IPost[]&gt;(...)</span><br><span class="line">  .then(response =&gt; &#123;...&#125;)</span><br><span class="line">  .catch(ex =&gt; &#123;...&#125;);</span><br><span class="line">cancelTokenSource.cancel(&quot;User cancelled operation&quot;);</span><br></pre></td></tr></table></figure><p>回到浏览器可以看到红色字体的<strong>Request cancelled</strong>字样。</p><h3><span id="creating-data-with-axios">Creating data with axios</span></h3><p>使用POST请求创建数据：</p><ol><li>首先添加状态属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">    ...</span><br><span class="line">    editPost: IPost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在构造器初始化：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        ...,</span><br><span class="line">        editPost: &#123;</span><br><span class="line">          body: &quot;&quot;,</span><br><span class="line">          title: &quot;&quot;,</span><br><span class="line">          userId: 1</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建表单内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;post-eidt&quot;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            placeholder=&quot;Enter title&quot;</span><br><span class="line">            value=&#123;this.state.editPost.title&#125;</span><br><span class="line">            onChange=&#123;this.handleTitleChange&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        &lt;textarea</span><br><span class="line">            placeholder=&quot;Enter body&quot;</span><br><span class="line">            value=&#123;this.state.editPost.body&#125;</span><br><span class="line">            onChange=&#123;this.handleBodyChange&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleSaveClick&#125;&gt;Save&lt;/button&gt;</span><br><span class="line">        &#123;this.state.loading &amp;&amp; (</span><br><span class="line">            &lt;button onClick=&#123;this.handleCancelClick&#125;&gt;Cancel&lt;/button&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>下面是对状态的更新处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private handleTitleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        editPost: &#123;</span><br><span class="line">            ...this.state.editPost,</span><br><span class="line">            title: e.currentTarget.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private handleBodyChange = (e: React.ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        editPost: &#123;</span><br><span class="line">            ...this.state.editPost,</span><br><span class="line">            body: e.currentTarget.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>index.css</code>中添加一些CSS样式让它看起来更合理：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-edit</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-edit</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: inherit;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-edit</span> <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: inherit;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-edit</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: inherit;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>然后在点击时，触发<code>POST</code>请求：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private handleSaveClick = () =&gt; &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post&lt;IPost&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">        body: this.state.editPost.body,</span><br><span class="line">        title: this.state.editPost.title,</span><br><span class="line">        userId: this.state.editPost.userId</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ).then(response =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            posts: this.state.posts.concat(response.data)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>post</code>函数的结构和<code>get</code>非常相似。实际上，可以像<code>get</code>方法一样，添加错误处理、超时、取消等动作。</p><h3><span id="updating-data-with-axios">Updating data with axios</span></h3><p>我们希望用户可以点击<strong>Update</strong>按钮来更新数据。</p><ol><li>首先创建一个<code>Update</code>按钮。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">  &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;&#123;post.body&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button onClick=&#123;() =&gt; this.handleUpdateClick(post)&#125;&gt;</span><br><span class="line">    Update</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现<strong>Update</strong>按钮的事件处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleUpdateClick = (post:IPost) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; editPost: post &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>在原来的保存点击句柄，需要实现两个分支：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private handleSaveClick = () =&gt; &#123;</span><br><span class="line">  if (this.state.editPost.id) &#123;</span><br><span class="line">    // TODO - make a PUT request</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post&lt;IPost&gt;( ... )</span><br><span class="line">      .then ( ... );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>实现<code>PUT</code>请求分支：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (this.state.editPost.id) &#123;</span><br><span class="line">  axios</span><br><span class="line">  .put&lt;IPost&gt;(</span><br><span class="line">    `https://jsonplaceholder.typicode.com/posts/$&#123;this.state.editPost.id&#125;`, this.state.editPost, &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ).then(() =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      editPost: &#123;</span><br><span class="line">        body: &quot;&quot;,</span><br><span class="line">        title: &quot;&quot;,</span><br><span class="line">        userId: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      posts: this.state.posts</span><br><span class="line">        .filter(post =&gt; post.id !== this.state.editPost.id)</span><br><span class="line">        .concat(this.state.editPost)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="delete-data-with-axios">Delete data with axios</span></h3><p>添加<code>Delete</code>按钮以允许用户删除数据：</p><ol><li>首先创建一个<code>Delete</code>按钮：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">  &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;&#123;post.body&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button onClick=&#123;() =&gt; this.handleUpdateClick(post)&#125;&gt;</span><br><span class="line">    Update</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button onClick=&#123;() =&gt; this.handleDeleteClick(post)&#125;&gt;</span><br><span class="line">    Delete</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加删除的事件处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private handleDeleteClick = (post: IPost) =&gt; &#123;</span><br><span class="line">  axios</span><br><span class="line">  .delete(`https://jsonplaceholder.typicode.com/posts/$&#123;post.id&#125;`)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      posts: this.state.posts.filter(p =&gt; p.id !== post.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="using-axios-with-function-components">Using axios with function components</span></h3><p>本小节将实现函数组件(function component)版本的<code>axios</code>调用。我们将重构上一节的<code>App</code>的代码：</p><ol><li>首先声明<code>defaultPosts</code>常量，它包含了邮箱的初始状态。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const defaultPosts: IPost[] = [];</span><br></pre></td></tr></table></figure><ol start="2"><li>删除<code>IState</code>接口，因为状态被构造为独立的块。</li><li>移除先前的<code>App</code>类组件。</li><li>接下来，在常量<code>defaultPosts</code>下开始我们的<code>App</code>函数组件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const App: React.FC = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>下面创建独立的状态块，包括post、error、cancel token、loading falg、editpost。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const App: React.FC = () =&gt; &#123;</span><br><span class="line">  const [posts, setPosts]: [IPost[], (posts: IPost[]) =&gt; void] = React.useState(defaultPosts);</span><br><span class="line">  const [error, setError]: [string, (error: string) =&gt; void] = React.useState(&#x27;&#x27;);</span><br><span class="line">  const cancelToken = axios.CancelToken;</span><br><span class="line"></span><br><span class="line">  const [cancelTokenSource, setCancelTokenSource]: [</span><br><span class="line">    CancelTokenSource,</span><br><span class="line">    (cancelSourceToken: CancelTokenSource) =&gt; void,</span><br><span class="line">  ] = React.useState(cancelToken.source());</span><br><span class="line"></span><br><span class="line">  const [loading, setLoading]: [boolean, (loading: boolean) =&gt; void] = React.useState&lt;boolean&gt;(false);</span><br><span class="line">  const [editPost, setEditPost]: [IPost, (post: IPost) =&gt; void] = React.useState(&#123;</span><br><span class="line">    body: &#x27;&#x27;,</span><br><span class="line">    title: &#x27;&#x27;,</span><br><span class="line">    userId: 1,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们使用了<code>useState</code>函数来定义和初始化所有这些状态块。</p><ol start="6"><li>我们希望在组件首次被挂载时调用REST API以获取邮箱信息。我们可以使用<code>useEffect</code>函数，在状态定义下添加：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">  // TODO - get posts</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ol start="7"><li>在arrow function调用REST API获取邮件数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">  axios</span><br><span class="line">  .get&lt;IPost[]&gt;(&quot;https://jsonplaceholder.typicode.com/posts&quot;, &#123;</span><br><span class="line">    cancelToken: cancelTokenSource.token,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout: 5000</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ol start="8"><li>处理返回数据，设置邮箱数据和加载状态：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">  axios</span><br><span class="line">  .get&lt;IPost[]&gt;(...)</span><br><span class="line">.then(response =&gt; &#123;</span><br><span class="line">    setPosts(response.data);</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><ol start="9"><li>处理错误状态信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">  axios</span><br><span class="line">    .get&lt;IPost[]&gt;(...)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(ex =&gt; &#123;</span><br><span class="line">      const err = axios.isCancel(ex)</span><br><span class="line">        ? &#x27;Request cancelled&#x27;</span><br><span class="line">        : ex.code === &#x27;ECONNABORTED&#x27;</span><br><span class="line">        ? &#x27;A timeout has occurred&#x27;</span><br><span class="line">        : ex.response.status === 404</span><br><span class="line">        ? &#x27;Resource not found&#x27;</span><br><span class="line">        : &#x27;An unexpected error has occurred&#x27;;</span><br><span class="line">      setError(err);</span><br><span class="line">      setLoading(false);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li>接下来处理事件。事件的处理并没有多大变化，只是使用<code>const</code>来声明，以及用前面声明的状态块来设置状态。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleCancelClick = () =&gt; &#123;</span><br><span class="line">  if (cancelTokenSource) &#123;</span><br><span class="line">    cancelTokenSource.cancel(&quot;User cancelled operation&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>输入变更事件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const handleTitleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">  setEditPost(&#123; ...editPost, title: e.currentTarget.value &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">const handleBodyChange = (e: React.ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; &#123;</span><br><span class="line">  setEditPost(&#123; ...editPost, body: e.currentTarget.value &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="12"><li><strong>Save</strong>按钮事件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const handleSaveClick = () =&gt; &#123;</span><br><span class="line">  if (editPost.id) &#123;</span><br><span class="line">    axios</span><br><span class="line">      .put&lt;IPost&gt;(`https://jsonplaceholder.typicode.com/posts/$&#123;editPost.id&#125;`, editPost, &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">          &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(() =&gt; &#123;</span><br><span class="line">        setEditPost(&#123;</span><br><span class="line">          body: &#x27;&#x27;,</span><br><span class="line">          title: &#x27;&#x27;,</span><br><span class="line">          userId: 1,</span><br><span class="line">        &#125;);</span><br><span class="line">        setPosts(posts.filter(post =&gt; post.id !== editPost.id).concat(editPost));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post&lt;IPost&gt;(</span><br><span class="line">        &#x27;https://jsonplaceholder.typicode.com/posts&#x27;,</span><br><span class="line">        &#123;</span><br><span class="line">          body: editPost.body,</span><br><span class="line">          title: editPost.title,</span><br><span class="line">          userId: editPost.userId,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          headers: &#123;</span><br><span class="line">            &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br><span class="line">      .then(response =&gt; &#123;</span><br><span class="line">        setPosts(posts.concat(response.data));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="13"><li><strong>Update</strong> 按钮：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const handleUpdateClick = (post: IPost) =&gt; &#123;</span><br><span class="line">  setEditPost(post);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="14"><li><strong>Delete</strong>按钮：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleDeleteClick = (post: IPost) =&gt; &#123;</span><br><span class="line">  axios.delete(`https://jsonplaceholder.typicode.com/posts/$&#123;post.id&#125;`).then(() =&gt; &#123;</span><br><span class="line">    setPosts(posts.filter(p =&gt; p.id !== post.id));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="15"><li>最后的任务是实现返回语句。和原来的没有太大改变，只是删掉了<code>this</code>引用。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">    &lt;div className=&quot;post-edit&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; placeholder=&quot;Enter title&quot; value=&#123;editPost.title&#125; onChange=&#123;handleTitleChange&#125; /&gt;</span><br><span class="line">      &lt;textarea placeholder=&quot;Enter body&quot; value=&#123;editPost.body&#125; onChange=&#123;handleBodyChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleSaveClick&#125;&gt;Save&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &#123;loading &amp;&amp; &lt;button onClick=&#123;handleCancelClick&#125;&gt;Cancel&lt;/button&gt;&#125;</span><br><span class="line">    &lt;ul className=&quot;posts&quot;&gt;</span><br><span class="line">      &#123;posts.map(post =&gt; (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;&#123;post.body&#125;&lt;/p&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; handleUpdateClick(post)&#125;&gt;Update&lt;/button&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; handleDeleteClick(post)&#125;&gt;Delete&lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &#123;error &amp;&amp; &lt;p className=&quot;error&quot;&gt;&#123;error&#125;&lt;/p&gt;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>主要不同的地方是，我们使用了<code>useEffect</code>函数来调用REST API，替换原来的<code>componentDidMount()</code>。</p><h2><span id="summary">Summary</span></h2><p>Callback-based异步代码难于阅读和维护。谁会花几个小时，从根节点开始去追踪Callback-based异步代码的bug呢？又或者花好几个小时来逐步理解每个回调的意思？幸运的是，我们有Promise-based的写法。</p><p>Promise-based函数相比基于回调的写法有很大提升。更易于阅读、错误更易处理。结合关键字<code>async</code>和<code>await</code>后的使用相比原来代码有更大的阅读性。</p><p>现代浏览器有一个很好的<code>fetch</code>函数来处理REST请求。它是一个Promise-based的函数，提供对异步请求很好的处理。</p><p><code>axios</code>是相对<code>fetch</code>的另一种选择。它的API更清晰，TypeScript更友好，错误处理更方便。</p><p>最后我们还对异步请求的实现做了两个不同的版本。一个是class component，另一个是function component(FC)。在类组件，异步的处理要放在<code>componentDidMount</code>生命周期函数中。在函数组件，使用<code>useEffect</code>函数来处理每次的渲染。两种方式，你会选择哪种？</p><p>REST API并不是唯一会交互的API。GraphQL是另一种流行的API服务。将在下个章节学习。</p><h2><span id="questions">Questions</span></h2><p>问题时间。</p><ol><li>下面程序执行后，会在console输出什么？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        throw new Error(&quot;Oops&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch (ex) &#123;</span><br><span class="line">    console.log(&quot;Sorry, there is a problem&quot;, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>假设没有9999这个邮箱，下面程序会输出什么？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(&quot;https://jsonplaceholder.typicode.com/posts/999&quot;)</span><br><span class="line">.then(response =&gt; &#123;</span><br><span class="line">    console.log(&quot;HTTP status code&quot;, response.status);</span><br><span class="line">    return response.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(data =&gt; console.log(&quot;Response body&quot;, data))</span><br><span class="line">.catch(error =&gt; console.log(&quot;Error&quot;, error));</span><br></pre></td></tr></table></figure><ol start="3"><li>下面程序执行后，console会输出什么？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">.get(&quot;https://jsonplaceholder.typicode.com/posts/9999&quot;)</span><br><span class="line">.then(response =&gt; &#123;</span><br><span class="line">    console.log(&quot;HTTP status code&quot;, response.status);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">    console.log(&quot;Error&quot;, error.response.status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>使用<code>fetch</code>和<code>axios</code>有什么好处？</li><li>下面程序如何添加一个bearer token？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&quot;https://jsonplaceholder.typicode.com/posts/1&quot;)</span><br></pre></td></tr></table></figure><ol start="6"><li>我们使用下面程序来更新邮箱的标题？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.put(&quot;https://jsonplaceholder.typicode.com/posts/1&quot;, &#123;</span><br><span class="line">    title: &quot;corrected title&quot;,</span><br><span class="line">    body: &quot;some stuff&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="7"><li>如果要用到<code>PATCH</code>请求，怎么改更高效。</li><li>我们实现了一个FC来显示邮箱，下面代码在执行时会有什么错误？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    axios</span><br><span class="line">    .get(`https://jsonplaceholder.typicode.com/posts/$&#123;id&#125;`)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 React Redux</title>
      <link href="/2019/11/27/react-ts/chapter_8_React_Redux/"/>
      <url>/2019/11/27/react-ts/chapter_8_React_Redux/</url>
      
        <content type="html"><![CDATA[<ul><li>Principles and key concepts</li><li>Installing Redux</li><li>Creating reducers</li><li>Creating actions</li><li>Creating a store</li><li>Connecting our React App to the store</li><li>Managing state with use Reducer</li></ul><h2><span id="principles-and-key-concepts">Principles and key concepts</span></h2><h3><span id="principles">Principles</span></h3><p>Redux的三大原则：</p><ul><li><strong>Single source of truth</strong>：意味着整个项目的状态被存储在一个单一对象。在一个真实应用系统中，这个对象很可能包含了一个复杂的内嵌对象树。</li><li><strong>State is read-only</strong>：意味着状态不能被直接改变。就是说不能通过组件来改变状态。在Redux中，唯一能改变状态的方法是通过action进行传递(dispatch)。</li><li><strong>Changes are made with pure functions</strong>：那些能够改变状态的函数被称为“<code>reducer</code>”。</li></ul><p>接下来的环节，会深入介绍action和reducer以及消息的store内容。</p><h3><span id="key-concepts">Key concepts</span></h3><p>Redux内存活的整个应用的状态被称为一个<code>store</code>。状态被存储在一个JavaScript对象中，形式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  products: [&#123; id: <span class="number">1</span>, name: <span class="string">&quot;Table&quot;</span>, ...&#125;, &#123;...&#125;, ...],</span><br><span class="line">  productsLoading: <span class="literal">false</span>,</span><br><span class="line">  currentProduct: &#123; id: <span class="number">2</span>, xname: <span class="string">&quot;Chair&quot;</span>, ... &#125;,</span><br><span class="line">  basket: [&#123; product: &#123; id: <span class="number">2</span>, xname: <span class="string">&quot;Chair&quot;</span> &#125;, quantity: <span class="number">1</span> &#125;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态不会包含有任何函数、setter或者getter。它就是一个简单的JavaScript对象。</p><p>要更新一个store中的state，就是派遣一个<strong>action</strong>。其中action又是另外一个简单的JavaScript对象，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&quot;PRODUCTS/LOADING&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type</code>属性决定了哪种action需要被处理。<code>type</code>是必须的，否则reducer不知道如何改变状态。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&quot;PRODUCTS/GETSINGLE&quot;</span>,</span><br><span class="line">  product: &#123; id: <span class="number">1</span>, name: <span class="string">&quot;Table&quot;</span>, ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个带有一个额外的属性值，因为reducer除了要知道action的类型外，还要获取更新的内容。</p><p>因此，reducer是纯函数。</p><blockquote><p>纯函数就是不依赖于外部自由变量的函数，对于给定的输入，总能得到相同的结果。</p></blockquote><p>下面是reducer的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export const productsReducer = (state = initialProductState, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;PRODUCTS/LOADING&quot;: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...state,</span><br><span class="line">productsLoading: true</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;PRODUCTS/GETSINGLE&quot;: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...state,</span><br><span class="line">currentProduct: action.product,</span><br><span class="line">productsLoading: false</span><br><span class="line">  &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">default:</span><br><span class="line">  &#125;</span><br><span class="line">  return state || initialProductState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于reducer有几点：</p><ul><li>reducer接收两个参数，current state 和要处理的action</li><li>reducer第一次被调用时，state参数默认为一个初始化状态对象</li><li>这里需要使用switch语句处理不同的action类型</li><li>返回语句表示创建一个新的状态覆盖原来已有的状态属性</li><li>reducer返回新的(更新的)状态</li></ul><p>你会注意action和reducer都不是TypeScript类型的。下面开始实战。</p><h2><span id="installing-redux">Installing Redux</span></h2><p>在使用Redux之前，需要安装依赖项。另外还需要安装一个库<code>redux-thunk</code>，以实现异步的ation:</p><ol><li>安装redux,</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux</span><br></pre></td></tr></table></figure><ol start="2"><li>安装具体的redux的关联框架，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add rect-redux</span><br></pre></td></tr></table></figure><ol start="3"><li>对应TS，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @types/react-redux</span><br></pre></td></tr></table></figure><ol start="4"><li>安装<code>redux-thunk</code>，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux-thunk</span><br><span class="line">yarn add -D @types/redux-thunk</span><br></pre></td></tr></table></figure><h2><span id="creating-actions">Creating actions</span></h2><p>这里将沿用前面章节使用的代码，将Redux集成到产品页面上。本小节，我们会创建action获取产品内容。以及使用另外一个action更改新的状态。</p><p>在此之前，首先在<code>ProductsData.ts</code>创建一个假的API，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts = <span class="keyword">async</span> (): <span class="built_in">Promise</span>&lt;IProduct[]&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数异步等待返回的产品信息。</p><h3><span id="creating-state-and-action-types">Creating state and action types</span></h3><p>下面使用Redux来增强React shop。首先，创建一些state类型，以及action类型。</p><ol><li>在<code>src</code>文件夹创建一个新的文件<code>ProductsTypes.ts</code>，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IProduct &#125; <span class="keyword">from</span> <span class="string">&quot;./ProductsData&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加两种不同类型的action枚举，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ProductsActionTypes &#123;</span><br><span class="line">  GETALL = <span class="string">&quot;PRODUCTS/GETALL&quot;</span>,</span><br><span class="line">  LOADING = <span class="string">&quot;PRODUCTS/LOADING&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redux并没有要求action类型为字符串形式。这里我们选择用字符串来表述。同时要确保字符串是全局唯一的。我们定义的字符串中包含了两点重要信息：</p><ul><li>存储的action被关联。这里它是<code>PRODUCTS</code>。</li><li>特定的具体操作被指示。这里，<code>GETALL</code>表示获取所有商品，<code>LOADING</code>表示商品正在获取中。</li></ul><p>当然我们也可以写成类似<code>PRODUCTS-GETALL</code>或者<code>Get All Products</code>。我们只需要确保字符串是唯一的。</p><ol start="3"><li>下面为上述两种Action定义接口：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsGetAllAction &#123;</span><br><span class="line">  <span class="attr">type</span>: ProductsActionTypes.GETALL,</span><br><span class="line">  <span class="attr">products</span>: IProduct[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsLoadingAction &#123;</span><br><span class="line">  <span class="attr">type</span>: ProductsActionTypes.LOADING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IProductsGetAllAction</code>用作获取商品时的派遣动作。<code>IProductsLoadingAction</code>用作加载状态。</p><ol start="4"><li>组合为一个新的union type:</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ProductsActions = </span><br><span class="line">  | IProductsGetAllAction</span><br><span class="line">  | IProductsLoadingAction</span><br></pre></td></tr></table></figure><p>该类型将被传递在reducer的参数上。</p><ol start="5"><li>最后，为这种存储状态创建一个接口：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsState &#123;</span><br><span class="line">  <span class="keyword">readonly</span> products: IProduct[];</span><br><span class="line">  <span class="keyword">readonly</span> productsLoading: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的state将包含了一组商品信息，以及商品是否正在加载。</p><p>注意到属性前面引入了<code>readonly</code>关键字。它帮助我们避免对状态的直接修改。</p><p>有了state和action的类型后，接下来创建一些具体的action。</p><h3><span id="creating-actions">Creating actions</span></h3><p>本小节，将创建两个action。获取商品的action，商品处于加载的action。</p><ol><li>创建一个<code>ProductsActions.ts</code>文件，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ActionCreator, AnyAction, Dispatch &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里用到几个action类型需要实现。</p><ol start="2"><li>其中一个action用作异步操作。需要导入<code>redux-thunk</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThunkAction &#125; <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外导入之前的模拟API。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getProducts <span class="keyword">as</span> getProductsFromAPI &#125; <span class="keyword">from</span> <span class="string">&quot;./ProductsData&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里需要重命名<code>getProductsFromAPI</code>，避免和<code>getProducts</code>的action冲突。</p><ol start="4"><li>将先前定义的action类型导入。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IProductsGetAllAction, IProductsLoadingAction, IProductsState, ProductsActionTypes &#125; <span class="keyword">from</span> <span class="string">&quot;./ProductsTypes&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>接下来，创建一个action creator，顾名思义：它是一个函数，创建并返回一个action！</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading: ActionCreator&lt;IProductsLoadingAction&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: ProductsActionTypes.LOADING</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>我们使用了泛型<code>ActionCreator</code>作为函数签名</li><li>函数仅仅返回要求的action对象</li></ul><p>还可以使用隐式返回语句另函数更为简洁</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading: ActionCreator&lt;IProductsLoadingAction&gt; = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">type</span>: ProductsActionTypes.LOADING,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们将用到这个简短语法用于action creator的实现。</p><ol start="6"><li>添加另一个action creator的实现，这稍微更复杂一些：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>因为这里的action是异步的，需要进行一层包装。这里使用了<code>ThunkAction</code>泛型类型来包装同步action，它包含4个参数：</p><ul><li>第一个参数是返回类型，理想上应该是<code>Promise&lt;IProductsGetAllAction&gt;</code>。然而，TypeScript编译器无法处理，因此折中放宽为<code>Promise&lt;AnyAction&gt;</code>类型。</li><li>第二个参数为关联的state接口。</li><li>第三个参数是传递给到action creator的函数参数的类型，因为我们的action creator没有定义参数，这里传递null。</li><li>最后一个参数是action的类型。</li></ul><p>我们对这些action creator进行暴露，因为最终会被<code>ProductsPage</code>组件调用。</p><ol start="7"><li>异步action需要返回一个异步函数，最终派遣我们的action：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，函数第一件事是返回另一个函数，使用<code>async</code>关键字标记为异步的。内部函数以Dispatcher作为回调参数。</p><ol start="8"><li>下面实现内部函数：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">    dispatch(loading());</span><br><span class="line">    <span class="keyword">const</span> products = <span class="keyword">await</span> getProductsFromAPI();</span><br><span class="line">    <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">      products,</span><br><span class="line">      <span class="attr">type</span>: ProductsActionTypes.GETALL,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>首先做的，dispatch 启动action，以得到最终的loading state。</li><li>然后异步的方式，从模拟API获取商品信息</li><li>最后一步dispatch 要求的action。</li></ul><p>目前创建了好几个action了，接下来创建相应的reducer。</p><h3><span id="creating-reducers">Creating reducers</span></h3><p>一个reducer，就是一个传入给定的action，产生新的state的一个函数。因此，这个函数在当前state，接收了一个action，返回新的state。</p><ol><li>在<code>src</code>目录新建文件<code>ProductsReducer.ts</code>：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Reducer &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IProductsState, ProductsActions, ProductsActionTypes &#125; <span class="keyword">from</span> <span class="string">&quot;./ProductsTypes&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里导入了<code>Reducer</code>依赖，以及前面定义的action和state。</p><ol start="2"><li>定义初始state：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialProductState: IProductsState = &#123;</span><br><span class="line">  <span class="attr">products</span>: [],</span><br><span class="line">  <span class="attr">productsLoading</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始状态下，商品信息为空数组，处于非加载状态。</p><ol start="3"><li>接下来创建reducer函数：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> productsReducer: Reducer&lt;IProductsState, ProductsActions&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  state = initialProductState,</span></span></span><br><span class="line"><span class="params"><span class="function">  action</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line"><span class="comment">// TODO - change the state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>该函数返回<code>Reducer</code>，包含有state和action。</li><li>函数接收的参数由Redux提供。</li><li>状态默认为初始化时的状态。</li><li>对于不能识别的switch语句，返回默认的state。</li></ul><ol start="4"><li>实现我们商品的reducer：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ProductsActionTypes.LOADING: &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line"><span class="attr">productsLoading</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ProductsActionTypes.GETALL: &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line"><span class="attr">products</span>: action.products,</span><br><span class="line"><span class="attr">productsLoading</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为每个action实现了对应的reducer，合并旧的state，并返回一个新的state。</p><p>这样，我们的第一个reducer完成了。接下来创建我们的store。</p><h3><span id="creating-a-store">Creating a store</span></h3><p>本小节，将创建一个store，用于存放我们的state并管理这些action和reducer：</p><ol><li>新建文件<code>Store.tsx</code>文件，导入相应的需要的组件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; applyMiddleware, combineReducers, createStore, Store &#125; from &quot;redux&quot;;</span><br></pre></td></tr></table></figure><ul><li><code>createStore</code> 创建store的函数</li><li>我们需要<code>applyMiddleware</code>函数，因为我们使用了redux thunk中间件来管理异步action。</li><li><code>combineReducers</code>函数用于合并reducer</li><li><code>Store</code>是一个TypeScript版的store对象</li></ul><ol start="2"><li>导入<code>redux-thunk</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import thunk from &quot;redux-thunk&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后，导入reducer和state，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; productsReducer &#125; from &quot;./ProductsReducer&quot;;</span><br><span class="line">import &#123; IProductsState &#125; from &quot;./ProductsTypes&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>store的关键部分是state。因此，定义一个接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export interface IApplicationState &#123;</span><br><span class="line">  products: IProductsState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口仅仅包含了商品的state。</p><ol start="5"><li>将reducer添加到Redux的<code>combineReducer</code>函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const rootReducer = combineReducers&lt;IApplicationState&gt;(&#123;</span><br><span class="line">  products: productsReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>定义好state和reducer后，我们可以创建我们的store了。实际上我们是创建一个函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default function configureStore(): Store&lt;IApplicationState&gt; &#123;</span><br><span class="line">  const store = createStore(rootReducer, undefined, applyMiddleware(thunk));</span><br><span class="line">  return store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>configureStore</code>返回泛型<code>Store</code></li><li>Redux中的函数<code>createStore</code>，我们传入定义的reducer以及Redux Thunk中间件，传递<code>undefined</code>作为初始化状态。</li></ul><p>接下来，如何连接到我们创建的store？</p><h2><span id="connecting-our-react-app-to-the-store">Connecting our React app to the store</span></h2><p>在本小节，我们将<code>Products</code>页面连接到store。第一件要做的工作室添加React Redux的<code>Provider</code>组件。</p><h3><span id="adding-the-store-provider-component">Adding the store Provider component</span></h3><p><code>Provider</code>组件可以在它任意下层的组件传递store。因此，本小节，需要将<code>Provider</code>添加到组件的最高层级，这样其它组件都可以访问。</p><ol><li>打开原先的<code>index.tsx</code>，导入<code>Provider</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from &quot;react-redux&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>另外把<code>Store</code>也导入进来。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Store &#125; from &quot;redux&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>其它用到的store和state也导入进来。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import configureStore from &quot;./Store&quot;;</span><br><span class="line">import &#123; IApplicationState &#125; from &quot;./Store&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建一些功能组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  store: Store&lt;IApplicationState&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Root: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  return();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>Root</code>组件将会成为我们新的root element。它将store作为一个prop。</p><ol start="5"><li>这样一来，我们需要导入旧的根元素，<code>Routes</code>，放置在新的root组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Root: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Routes /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外还要把<code>Provider</code>组件加进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;Provider store=&#123;props.store&#125;&gt;</span><br><span class="line">    &lt;Routes /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在已经将<code>Provider</code>组件的最上层，以及将store传递进去。</p><ol start="7"><li>另外还要更改根部渲染函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const store = configureStore();</span><br><span class="line">ReactDOM.render(&lt;Root store=&#123;store&#125; /&gt;, document.getElementById(&quot;root&quot;) as HTMLElement);</span><br></pre></td></tr></table></figure><p>首先通过<code>configureStore</code>函数创建了全局的store，并将它传递给<code>Root</code>组件。</p><p>这样一来，所有组件都已经连接到了这个store。接下来，需要需要在其它子层组件中对其进行连接。</p><h3><span id="connecting-components-to-the-store">Connecting components to the store</span></h3><h4><span id="connecting-productspage-to-the-store">Connecting ProductsPage to the store</span></h4><p>首先连接的组件是<code>ProductsPage</code>,</p><p>下面开始对其进行重构，</p><ol><li>导入<code>connect</code>函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &quot;react-redux&quot;;</span><br></pre></td></tr></table></figure><p>我们将使用<code>connect</code>将<code>ProductsPage</code>连接到store。</p><ol start="2"><li>导入store的state，以及<code>getProducts</code>action creator。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IApplicationState &#125; from &quot;./Store&quot;;</span><br><span class="line">import &#123; getProducts &#125; from &quot;./ProductsActions&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>组件<code>ProductPage</code>不再包含任何state，因为将由Redux store装载。因此，需要将组件原有的state接口、静态方法<code>getDerivedStateFromProps</code>、以及构造器进行整改。<code>ProductsPage</code>原来的外形是：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;RouteComponentProps&gt; &#123;</span><br><span class="line">  public async componentDidMount() &#123; ... &#125;</span><br><span class="line">  public render() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>组件的数据将通过props从store获得。一次，重构props接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IProps extends RouteComponentProps &#123;</span><br><span class="line">  getProducts: typeof getProducts;</span><br><span class="line">  loading: boolean;</span><br><span class="line">  products: IProduct[];</span><br><span class="line">&#125;</span><br><span class="line">class ProductsPage extends React.Component&lt;IProps&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>因此，我们会将下面信息经由store传递给该组件：</p><ul><li><p><code>getProducts</code> action creator</p></li><li><p><code>loading</code>标志，表示当前是否在获取商品信息</p></li><li><p>商品列表数组</p></li></ul><ol start="5"><li>接下来调整组件的生命周期方法<code>componentDidMount</code>，通过调用<code>getProducts</code> 这个action creator来获取商品信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">  this.props.getProducts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在不再直接从<code>ProductsData.ts</code>中获取<code>products</code>商品列表了。将导入语句移除掉：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IProduct &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>还有一个未使用的<code>search</code>state也不需要了。如下，我们原来仅仅是将它放置在<code>render</code>方法，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const searchParams = new URLSearchParams(this.props.location.search);</span><br><span class="line">  const search = searchParams.get(&quot;search&quot;) || &quot;&quot;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>现在需要替换掉原来对<code>state</code>的引用：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">  &#123;this.props.products.map(product =&gt; &#123;</span><br><span class="line">    if (!search || (search &amp;&amp; product.name.toLowerCase().indexOf(search.toLowerCase()) &gt; -1)) &#123; ... &#125;</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>在export语句之前，class语句之后，创建一个函数来映射store和组件props的state：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (store: IApplicationState) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    loading: store.products.productsLoading,</span><br><span class="line">    products: store.products.products</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们可以得知商品是否在loading，以及从store存储的商品信息传递到我们的props中。</p><ol start="10"><li>由前面得知，还有一个prop属性需要进行映射，即<code>getProducts</code>。因此创建另外一个函数来关联这种关系：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (dispath: any) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    getProducts: () =&gt; dispatch(getProducts())</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>剩下最后一件事，需要在该文件最后。包装React Redux的<code>connect</code> HOC（钩子）到<code>ProductsPage</code>中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default connect (</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(ProductsPage);</span><br></pre></td></tr></table></figure><p><code>connect</code>钩子将组件和Redux存储连接起来，由最高层的<code>Provider</code>提供。<code>connect</code>钩子会调用映射函数进行两者的state状态传递。</p><ol start="12"><li>最后验证我们的结果：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>我们会发现页面的行为并没有跟原来的有差异。唯一不同的是state现在由Redux store进行管理。</p><p>接下来的小节，我们将商品页面添加加载进度条。</p><h3><span id="connecting-productspage-to-the-loading-store-state">Connecting ProductsPage to the loading store state</span></h3><p>本小节将添加一个加载进度条。在此之前，需要将商品信息进行萃取。然后添加<code>withLoader</code>HOC到组件中：</p><ol><li>首先为抽取的组件创建一个新文件<code>ProductsList.tsx</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &#x27;react&#x27;;</span><br><span class="line">import &#123;Link&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import &#123;IProduct&#125; from &#x27;./ProductsData&#x27;;</span><br><span class="line">import withLoader from &#x27;./withLoader&#x27;;</span><br></pre></td></tr></table></figure><ol start="2"><li>该组件props作为商品数组信息和查询字符串的入参：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  products?: IProduct[];</span><br><span class="line">  search: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们将调用<code>ProductList</code>组件作为一个SFC。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ProductsList: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  const search = props.search;</span><br><span class="line">  return ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>现在将来自组件<code>ProductsPage</code>组件的 <code>ul</code>标签语句迁移到<code>ProductList</code>组件的return语句中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">    &#123;props.products &amp;&amp;</span><br><span class="line">      props.products.map(product =&gt; &#123;</span><br><span class="line">        if (!search || (search &amp;&amp; product.name.toLowerCase().indexOf(search.toLowerCase()) &gt; -1)) &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">              &lt;Link to=&#123;`/products/$&#123;product.id&#125;`&#125;&gt;&#123;product.name&#125;&lt;/Link&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>要注意的是，我们移除了原来this`的引用。</p><ol start="5"><li>另外，还需要将组件暴露给钩子<code>withLoader</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default withLoader(ProductsList);</span><br></pre></td></tr></table></figure><ol start="6"><li>修改原来<code>ProductsPage.tsx</code>组件的返回语句，用新提取的组件替代：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Welcome to React Shop where you can get all your tools for ReactJS!&lt;/p&gt;</span><br><span class="line">    &lt;ProductsList search=&#123;search&#125; products=&#123;this.props.products&#125; loading=&#123;this.props.loading&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="7"><li>以及在组件中引入引用：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ProductsList from &quot;./ProductsList&quot;;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>最后，移除在<code>ProductsPage.tsx</code>组件中的<code>Link</code>引用。</p><p>运行应用，进入<code>Products</code>页面，可以看到一个加载spinner：</p><p>现在，我们的<code>Products</code>页面已经接入到Redux store。下个小节会将`Product也接入到store中。</p></li></ol><h3><span id="adding-product-stte-and-actions-to-the-store">Adding product stte and actions to the store</span></h3><p>要将<code>ProductPage</code>组件连接到Redux存储中，需要创建额外的state，表示商品是否被添加到购物车。另外，需要额外的action和reducer，来表述获取商品、添加到购物篮的行为。</p><ol><li>首先，在<code>ProductsTypes.ts</code>添加相应的state，表述“当前”商品：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export interface IProductsState &#123;</span><br><span class="line">  readonly currentProduct: IProduct || null;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>为获取商品的行为添加相应action：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> ProductsActionTypes &#123;</span><br><span class="line">  GETALL = <span class="string">&quot;PRODUCTS/GETALL&quot;</span>,</span><br><span class="line">  GETSINGLE = <span class="string">&quot;PRODUCTS/GETSINGLE&quot;</span>,</span><br><span class="line">  LOADING = <span class="string">&quot;PRODUCTS/LOADING&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>为获取商品的行为添加action type：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsGetSingleAction &#123;</span><br><span class="line">  <span class="attr">type</span>: ProductsActionTypes.GETSINGLE;</span><br><span class="line">  product: IProduct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加到联合类型(union actions type)：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ProductsActions = IProductsGetAllAction | IProductsGetSingleAction | IProductsLoadingAction;</span><br></pre></td></tr></table></figure><ol start="5"><li>接着创建新的action creator。首先，导入假的api，用于表示获取商品：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getProduct <span class="keyword">as</span> getProductFromAPI, getProducts <span class="keyword">as</span> getProductsFromAPI &#125; <span class="keyword">from</span> <span class="string">&quot;./ProductsData&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="6"><li>接着为action creator导入需要用到的类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IProductsGetAllAction, IPrudctsGetSingleAction, IProductsLoadingAction, IProductsState, ProductsActionType &#125; from &quot;./productsTypes&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>实现action creator：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const getProduct: ActionCreator&lt;ThunkAction&lt;Promise&lt;any&gt;, IProductsState, null, IProductsGetSingleAction&gt;&gt; = (</span><br><span class="line">  id: number,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  return async (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">    dispatch(loading());</span><br><span class="line">    const product = await getProductFromAPI(id);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      product,</span><br><span class="line">      type: ProductsActionTypes.GETSINGLE,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个和<code>getProducts</code>非常相似。不同的是这里的入参是商品id。</p><ol start="8"><li>在<code>ProductsReducer.ts</code>中，首先设置初始状态为null：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const initialProductState: IProductsState = &#123;</span><br><span class="line">  currentProduct: null,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>在<code>productReducer</code>函数中，添加相应新的分支语句：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (action.type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    case ProductsActionTypes.GETSINGLE: &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        currentProduct: action.product,</span><br><span class="line">        productsLoading: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="adding-basket-state-and-actions-to-the-store">Adding basket state and actions to the store</span></h3><p>这里需要为购物篮添加状态管理。</p><ol><li>首先，创建一个新文件<code>BasketTypes.ts</code>，内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123;IProduct&#125; from &#x27;./ProductsData&#x27;;</span><br><span class="line"></span><br><span class="line">export enum BasketActionTypes &#123;</span><br><span class="line">  ADD = &#x27;BASKET/ADD&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface IBasketState &#123;</span><br><span class="line">  readonly products: IProduct[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface IBasketAdd &#123;</span><br><span class="line">  type: BasketActionTypes.ADD;</span><br><span class="line">  product: IProduct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export type BasketActions = IBasketAdd;</span><br></pre></td></tr></table></figure><ul><li>这里仅一个state，代表购物篮中的商品数组信息。</li><li>这里仅一个action，表示向购物篮添加商品。</li></ul><ol start="2"><li>新建一个文件<code>BasketActions.ts</code>，包含下面内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;BasketActionTypes, IBasketAdd&#125; from &#x27;./BasketTypes&#x27;;</span><br><span class="line">import &#123;IProduct&#125; from &#x27;./ProductsData&#x27;;</span><br><span class="line"></span><br><span class="line">export const addToBasket = (product: IProduct): IBasketAdd =&gt; (&#123;</span><br><span class="line">  product,</span><br><span class="line">  type: BasketActionTypes.ADD,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是商品添加到购物篮的action creator。该函数接收一个商品入参，返回相应的action。</p><ol start="3"><li>在reducer中，创建文件<code>BasketReducer.ts</code>，内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Reducer&#125; from &#x27;redux&#x27;;</span><br><span class="line">import &#123;BasketActions, BasketActionTypes, IBasketState&#125; from &#x27;./BasketTypes&#x27;;</span><br><span class="line"></span><br><span class="line">const initialBasketState: IBasketState = &#123;</span><br><span class="line">  products: [],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const basketReducer: Reducer&lt;IBasketState, BasketActions&gt; = (state = initialBasketState, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case BasketActionTypes.ADD: &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        products: state.products.concat(action.product),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return state || initialBasketState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有趣的地方是，如何优雅地向<code>products</code>数组添加<code>product</code>，而不改变原来的数组变量信息。我们使用了JavaScript的<code>concat</code>函数，它会创建一个新的arrary，并将原来的数组以参数形式合并。</p><ol start="6"><li>现在编译<code>Store.ts</code>，导入新的reducer和state：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; basketReducer &#125; <span class="keyword">from</span> <span class="string">&quot;./BasketReducer&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IBasketState &#125; <span class="keyword">from</span> <span class="string">&quot;./BasketTypes&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="7"><li>将购物篮的state添加到store中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export interface IApplicationState &#123;</span><br><span class="line">  basket: IBasketState;</span><br><span class="line">  products: IProductsState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>现在有两个reducer。因此，添加购物篮reducer到<code>combineReducers</code>的函数调用中：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rootReducer = combineReducers&lt;IApplicationState&gt;(&#123;</span><br><span class="line">  <span class="attr">basket</span>: basketReducer,</span><br><span class="line">  <span class="attr">products</span>: productsReducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在可以从Store连接到<code>ProductPage</code>组件了。</p><h3><span id="connecting-productpage-to-the-store">Connecting ProductPage to the store</span></h3><ol><li>首先在<code>ProductPage.tsx</code>导入相应的组件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;connect&#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import &#123;addToBasket&#125; from &#x27;./BasketActions&#x27;;</span><br><span class="line">import &#123;getProduct&#125; from &#x27;./ProductsActions&#x27;;</span><br><span class="line">import &#123;IApplicationState&#125; from &#x27;./Store&#x27;;</span><br></pre></td></tr></table></figure><ol start="2"><li>因为是通过<code>getProduct</code>从获取商品信息，<code>ProductsData.ts</code>不再需要用到。移除该导入：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IProduct &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>接着，将state挪到props属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IProps extends RouteComponentProps&lt;&#123;id: string&#125;&gt; &#123;</span><br><span class="line">  addToBasket: typeof addToBasket;</span><br><span class="line">  getProduct: typeof getProduct;</span><br><span class="line">  loading: boolean;</span><br><span class="line">  product?: IProduct;</span><br><span class="line">  added: boolean;</span><br><span class="line">&#125;</span><br><span class="line">class ProductPage extends React.Component&lt;IProps&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>我们可以移除掉构造函数，因为它不再需要初始化任何状态。</li><li>以及，需要在<code>componentDidMount</code>生命周期函数中调用相应的action creator获取商品信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">  if (this.props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(this.props.match.params.id, 10);</span><br><span class="line">    this.props.getProduct(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们也移除了<code>async</code>关键字，因为该方法不再是异步的。</p><ol start="6"><li>移步到<code>render</code>函数，修改为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const product = this.props.product;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">      &lt;Prompt when=&#123;!this.props.added&#125; message=&#123;this.navAwayMessage&#125; /&gt;</span><br><span class="line">      &#123;product || this.props.loading ? (</span><br><span class="line">        &lt;Product</span><br><span class="line">          loading=&#123;this.props.loading&#125;</span><br><span class="line">          product=&#123;product&#125;</span><br><span class="line">          inBasket=&#123;this.props.added&#125;</span><br><span class="line">          onAddToBasket=&#123;this.handleAddClick&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;p&gt;Product not found!&lt;/p&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>在点击句柄中，对其重构为通过调用action creator来表示添加商品。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private handleAddClick = () =&gt; &#123;</span><br><span class="line">  if (this.props.product) &#123;</span><br><span class="line">    this.props.addToBasket(this.props.product);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="8"><li>最后一步。需要实现对应的<code>mapDispatchToProps</code>，映射关联store和组件的props。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (dispath: any) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    addToBasket: (product: IProduct) =&gt; dispatch(addToBasket(product)),</span><br><span class="line">    getProduct: (id: number) =&gt; dispatch(getProduct(id))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>以及添加state的映射。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (store: IApplicationState) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    basketProducts: store.basket.products,</span><br><span class="line">    loading: store.products.productsLoading,</span><br><span class="line">    product: store.proucts.currentProduct || undefined</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，我们将null的<code>currentProduct</code>映射为<code>undefined</code>。</p><ol start="10"><li>剩余的需要映射的属性是<code>added</code>。我们需要检测当前商品对应的store中，是否为“已添加至购物篮”，这里用到<code>some</code>函数对数组进行处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (store: IApplicationState) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    added: store.basket.products.some(p =&gt; store.products.currentProduct ? p.id === store.products.currentProduct.id : false),</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>剩余步骤是，使用<code>connect</code>钩子连接<code>ProductPage</code>组件到store中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default connect (</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(ProductPage);</span><br></pre></td></tr></table></figure><p>现在回到页面App，尝试点击按钮，添加商品到购物篮看看效果，已添加的商品，再次进入商品的页面时，添加按钮会消失。</p><h3><span id="creating-and-connecting-basketsummary-to-the-store">Creating and connecting BasketSummary to the store</span></h3><p>在该小节，我们将创建新的组件<code>BasketSummary</code>。它会显示购物篮中商品的个数，并显示在右上角。</p><ol><li>首先创建一个新的文件<code>BasketSummary.tsx</code>，内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  count: number;</span><br><span class="line">&#125;</span><br><span class="line">const BasketSummary: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  return &lt;div className=&quot;basket-summary&quot;&gt;&#123;props.count&#125;&lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line">export default BasketSummary;</span><br></pre></td></tr></table></figure><p>这是一个简单组件，props入参为商品个数，并显示值。</p><ol start="2"><li>在<code>index.class</code>添加对应的CSS类，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.basket-summary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: white solid <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们需要将该组件添加到header component中。因此，在<code>Header.tsx</code>添加：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import BasketSummary from &quot;./BasketSummary&quot;;</span><br><span class="line">import &#123; connect &#125; from &quot;react-redux&quot;;</span><br><span class="line">import &#123; IApplicationState &#125; from &quot;./Store&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>在<code>IProps</code>添加一个number属性：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IProps extends RouteComponentProps &#123;</span><br><span class="line">  basketCount: number;</span><br><span class="line">&#125;</span><br><span class="line">class Header extends React.Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  public constructor(props: IProps) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>BasketSummary</code>组件到<code>Header</code>组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;header className=&quot;header&quot;&gt;</span><br><span class="line">  &lt;div className=&quot;search-container&quot;&gt;</span><br><span class="line">    &lt;input ... /&gt;</span><br><span class="line">    &lt;BasketSummary count=&#123;this.props.basketCount&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>最后一步就是添加映射：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (store: IApplicationState) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    basketCount: store.basket.products.length</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="7"><li>以及通过钩子暴露连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default connect(mapStateToProps)(withRouter(Header));</span><br></pre></td></tr></table></figure><p>现在<code>Header</code>组件消费<code>BasketSummary</code>组件信息，并连接到store中。尝试在页面中添加商品信息，可以看到数字增加了。</p><h2><span id="managing-state-with-usereducer">Managing state with useReducer</span></h2><p>Redux对于状态管理带来很大的帮助。但如果仅仅为了管理存在的单一组件的状态，则显得有点笨重。显然，我们，单一的组件直接使用<code>setState(for class compoents)</code>或<code>useState(for function compoents)</code>就可以了。然而，对于复杂的组件状态会怎样？有一大堆的state信息，并且这些state的交互可能涉及很多操作，某些甚至可能是异步的。</p><p>在本小节，我们将探索使用<code>useReduder</code>函数来管理这些状态的方法。我们的例子将尽量人性化和简单，以理解这种管理方法。</p><p>我们希望添加一个_<code>Like</code>_ 按钮到*<code>Product</code>* 页面。用户可以多次点击这个like按钮。<code>Product</code>组件会跟踪点击这个按钮的次数、最后一次like的时间，并显示。</p><ol><li>首先打开<code>Product.tsx</code>，创建一个接口，它包含了“like”的次数、最后“like”的时间：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ILikeState &#123;</span><br><span class="line">  likes: number;</span><br><span class="line">  lastLike: Date | null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个变量表述初始状态：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const initialLikeState: ILikeState = &#123;</span><br><span class="line">  likes: 0,</span><br><span class="line">  lastLike: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建action类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum LikeActionTypes &#123;</span><br><span class="line">  LIKE = &quot;LIKE&quot;</span><br><span class="line">&#125;</span><br><span class="line">interface ILikeAction &#123;</span><br><span class="line">  type: LikeActionTypes.LIKE;</span><br><span class="line">  now: Date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建一个联合类型包含所有这些action。在我们的例子中，虽然仅只有一个action type，先理解这种方式带来的扩展性的好处：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LikeAction = ILikeAction;</span><br></pre></td></tr></table></figure><ol start="5"><li>在组件<code>Product</code>内部，让我们调用<code>useReducer</code>函数获取state和<code>dispatch</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch]: [ILikeState, (action: ILikeAction) =&gt; void] = React.useReducer(reducer, initialLikeState);</span><br></pre></td></tr></table></figure><p>让我们分解下：</p><ul><li>我们向<code>useReducer</code>传入一个函数<code>reducer</code>函数参数。</li><li>另外也传入了<code>useReducer</code>初始状态。</li><li><code>useReducer</code>返回一个数组包含两个元素。第一个元素为当前state，另一个是<code>dispatch</code>用于调用一个action。</li></ul><ol start="6"><li>让我们重构该行，对state进行解构，这样我们就可以直接引用一系列state：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [&#123; likes, lastLike &#125;, dispatch]: [</span><br><span class="line">  ILikeState,</span><br><span class="line">  (action: ILikeAction) =&gt; void</span><br><span class="line">] = React.useReducer(reducer, initialLikeState);</span><br></pre></td></tr></table></figure><ol start="7"><li>在<code>Product</code>组件的底部，添加相应的“like”信息和按钮：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;!props.inBasket &amp;&amp; &lt;button onClick=&#123;handleAddClick&#125;&gt;Add to basket&lt;/button&gt;&#125;</span><br><span class="line">&lt;div className=&quot;like-container&quot;&gt;</span><br><span class="line">  &#123;likes &gt; 0 &amp;&amp; &lt;div&gt;&#123;`I like this x $&#123;likes&#125;, last at $&#123;lastLike&#125;`&#125;&lt;/div&gt;&#125;</span><br><span class="line">  &lt;button onClick=&#123;handleLikeClick&#125;&gt;&#123;likes &gt; 0 ? &#x27;Like again&#x27; : &#x27;Like&#x27;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>添加CSS样式：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.like-container &#123;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.like-container button &#123;</span><br><span class="line">  margin-top: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>为<code>Like</code>按钮实现点击事件处理：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const handleLikeClick = () =&gt; &#123;</span><br><span class="line">  dispatch(&#123; type: LikeActionTypes.LIKE, now: new Date() &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>最后一步，在<code>Product</code>组件外部实现reducer函数，即在<code>LikeActions</code>类型下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const reducer = (state: ILikeState = initialLikeState, action: LikeAction) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case LikeAtionTypes.LIKE:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        likes: state.likes + 1,</span><br><span class="line">        lastLike: action.now </span><br><span class="line">      &#125;;</span><br><span class="line">      return state;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现方式和实现action、reducer相似，不同的是所有操作都在一个组件内实现。</p><h2><span id="summary">Summary</span></h2><p>下面是几个关键点：</p><ul><li>枚举类型的action type，在引用时能给我们更好的提示。</li><li>使用接口来定义action带来更好的类型安全等级，这样允许我们创建联合类型(union type)，提供给reducer使用。</li><li>使用readonly定义的state属性，帮助我们避免对state的直接更改。</li><li>synchronous action creator返回action 对象。</li><li>Asynchronous action creator返回一个function，该function最终返回action对象。</li><li>reducer包含一系列的action type逻辑。</li><li>Redux提供的<code>createStore</code>创建实际的store。</li></ul><p>要将组件衔接到store中，下面是几个关键点：</p><ul><li><code>Provider</code>组件需要放置在所有消费组件的顶部。它拥有一个prop定义了store。</li><li><code>connect</code>钩子可以将独立的组件衔接到store中。它接收两个参数，用于将state和action creator映射到组件的props中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 表单</title>
      <link href="/2019/11/27/react-ts/chapter_7_Working_with_Forms/"/>
      <url>/2019/11/27/react-ts/chapter_7_Working_with_Forms/</url>
      
        <content type="html"><![CDATA[<ul><li>creating a form with controlled components</li><li>Reducing boilerplate code with generic components</li><li>Validating forms</li><li>Form submission</li></ul><h2><span id="creating-a-form-with-controlled-components">Creating a form with controlled components</span></h2><p>表单是大部分应用的常见内容。在React中，创建表单的标准方式是使用被称为 <em>controlled component</em> 的组件。</p><h3><span id="adding-a-contact-us-page">Adding a Contact Us page</span></h3><p>在src目录添加一个新的文件<code>ContactUsPage.tsx</code>，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class ContactUsPage extends React.Component &#123;</span><br><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">If you enter your details we&#x27;ll get back to you as soon as we can.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ContactUsPage;</span><br></pre></td></tr></table></figure><p>该组件需要包含状态，目前首先创建了header相关信息。接下来，导入该组件到页面中，打开<code>Routes.tsx</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ContactUsPage from &quot;./ContactUsPage&quot;;</span><br></pre></td></tr></table></figure><p>在<code>Routes</code>组件的<code>render</code>方法中，添加新的路由，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">&lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&quot;&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; compoent=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;contactus&quot; component=&#123;ContactUsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">&lt;Route path=&quot;/login&quot; compoent=&#123;LoginPage&#125; /&gt;</span><br><span class="line">&lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>打开<code>Header.tsx</code>，添加新的导航信息，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">&lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Products</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/contactus&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Contact Us</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Admin</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><p>现在，页面已经创建了，下面创建表单输入框。</p><h2><span id="creating-controlled-inputs">Creating controlled inputs</span></h2><p>在src目录下创建一个新文件<code>ContactUs.tsx</code>，包含下面内容，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ContactUs: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default ContactUs;</span><br></pre></td></tr></table></figure><p>这是一个功能组件，渲染一个表单包含label和用户名的输入框。</p><p>现在需要添加对应的css样式，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> auto <span class="number">0px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">input</span>, select, <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: lightgray solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在我们页面<code>ContactUsPage.tsx</code>添加并渲染表单，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ContactUs from &quot;./ContactUs&quot;;</span><br></pre></td></tr></table></figure><p>在<code>render</code>方法中添加，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;If you enter your details we&#x27;ll get back to you as soon as we can.&lt;/p&gt;</span><br><span class="line">  &lt;ContactUs /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>表单已经创建好了，但需要创建一个状态类型到<code>ContactUsPage</code>页面中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  email: string;</span><br><span class="line">  reason: string;</span><br><span class="line">  notes: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContactUsPage extends React.Component&lt;&#123;&#125;, IState&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在构造器中初始化状态，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    email: &quot;&quot;,</span><br><span class="line">name: &quot;&quot;,</span><br><span class="line">notes: &quot;&quot;,</span><br><span class="line">reason: &quot;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要将<code>ContactUsPage</code>中的状态传递到<code>ContactUs</code>组件中。在<code>ContactUs</code>组件中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  email: string;</span><br><span class="line">  reason: string;</span><br><span class="line">  notes: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>将表单名name绑定到<code>name</code>属性中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&#123;props.name&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>将表单状态传递给<code>ContactUsPage</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs</span><br><span class="line">  name=&#123;this.state.name&#125;</span><br><span class="line">  emial=&#123;this.state.email&#125;</span><br><span class="line">  reason=&#123;this.state.reason&#125;</span><br><span class="line">  notes=&#123;this.state.notes&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>添加事件监听，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&#123;props.name&#125; onChange=&#123;handleNameChange&#125; /&gt;</span><br></pre></td></tr></table></figure><p>创建对应的handler，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  const handleNameChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">    props.onNameChange(e.currentTarget.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是使用到了<code>React.ChangeEvent</code>。我们需要添加<code>onNameChange</code>函数到IProps中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  onNameChange: (name: string) =&gt; void;</span><br><span class="line">  email: string;</span><br><span class="line">  onEmailChange: (email: string) =&gt;void;</span><br><span class="line">  reason: string;</span><br><span class="line">  onReasonChange: (reason: string) =&gt; void;</span><br><span class="line">  notes: string;</span><br><span class="line">  onNotesChange: (notes: string) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要将来自<code>ContactUsPage</code>的Props传递到<code>ContactUs</code>中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs</span><br><span class="line">  name=&#123;this.state.name&#125;</span><br><span class="line">  onNameChange=&#123;this.handleNameChange&#125;</span><br><span class="line">  email=&#123;this.state.email&#125;</span><br><span class="line">  onEmailChange=&#123;this.handleEmailChange&#125;</span><br><span class="line">  reason=&#123;this.state.reason&#125;</span><br><span class="line">  onReasonChange=&#123;this.handleReasonChange&#125;</span><br><span class="line">  notes=&#123;this.state.notes&#125;</span><br><span class="line">  onNotesChange=&#123;this.handleNotesChange&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建对应的handlers方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private handleNameChange = (name: string =&gt; &#123;</span><br><span class="line">  this.setState(&#123; name &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleEmailChange = (email: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; email &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleReasonChange = (reason: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; reason &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleNotesChange = (notes: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; notes &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来在<code>ContactUs</code>中补充其它表单内容，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      id=&quot;name&quot;</span><br><span class="line">      value=&#123;props.name&#125;</span><br><span class="line">      onChange=&#123;handleNameChange&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;email&quot;&gt;Your email address&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;email&quot; value=&#123;props.email&#125; onChange=&#123;handleEmailChange&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;reason&quot;&gt;Reason you need to contact us&lt;/label&gt;</span><br><span class="line">    &lt;select id=&quot;reason&quot; value=&#123;props.reason&#125; onChange=&#123;handleReasonChange&#125;&gt;</span><br><span class="line">      &lt;option value=&quot;Marketing&quot;&gt;Marketing&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Support&quot; selected=&#123;true&#125;&gt;Support&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Feedback&quot;&gt;Feedback&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Jobs&quot;&gt;Jobs&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Other&quot;&gt;Other&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;notes&quot;&gt;Additional notes&lt;/label&gt;</span><br><span class="line">    &lt;textarea id=&quot;notes&quot; value=&#123;props.notes&#125; onChange=&#123;handleNotesChange&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>现在创建这些handler的函数属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleEmailChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;)</span><br><span class="line">=&gt; &#123;</span><br><span class="line">props.onEmailChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line">const handleReasonChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; &#123;</span><br><span class="line">props.onReasonChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line">const handleNotesChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; &#123;</span><br><span class="line">props.onNotesChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="reducing-boilerplate-code-with-generic-components">Reducing boilerplate code with generic components</span></h2><p>通用表单组件将有利于减少表单代码的重复实现。我们重构上面的<code>ContactUs</code>组件来实现generic form components。</p><p>假设我们希望，理想情况下消费组件<code>ContactUs</code>内容的generic component组件的形式如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form</span><br><span class="line">defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;email&quot; label=&quot;Your email address&quot; type=&quot;Email&quot; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;reason&quot; label=&quot;Reason you need to contact us&quot;</span><br><span class="line">type=&quot;Select&quot; options=&#123;[&quot;Marketing&quot;, &quot;Support&quot;, &quot;Feedback&quot;, &quot;Jobs&quot;,</span><br><span class="line">&quot;Other&quot;]&#125; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;notes&quot; label=&quot;Additional notes&quot; type=&quot;TextArea&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，有两个通用合成组件：<code>Form</code>和<code>Field</code>。它们有某些特点，</p><ul><li><code>Form</code>组件是用于合成、管理状态和交互的。</li><li><code>Fomr</code>组件使用<code>defaultValues</code>属性来传递默认值。</li><li><code>Field</code>组件渲染label和每个字段的一个编辑器。</li><li>每个字段包含一个<code>name</code>属性，并被存储在对应的state属性名内。</li><li>每个字段有一个<code>label</code>属性用于展示每个字段的标签。</li><li>特殊字段用<code>type</code>属性标识。默认的属性为文本类型<code>input</code>。</li><li>如果编辑器类型是<code>Select</code>，我们可以通过<code>options</code>属性指定。</li></ul><p>新版本的<code>ContactUs</code>组件相比原来的更简短、更易用。状态的管理和事件的处理被隐藏和封装在<code>Form</code>组件内。</p><h3><span id="creating-a-basic-form-component">Creating a basic form component</span></h3><p>下面开始构建我们的通用<code>Form</code>组件；</p><ol><li>在<code>src</code>文件夹下创建一个新的文件<code>Form.tsx</code>，包含下面内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;&#125;</span><br><span class="line"></span><br><span class="line">export class Form extends React.Component&lt;IFormProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IFormProps) &#123;&#125;</span><br><span class="line">  public render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Form</code>是一个基类组件，因为它需要管理状态。我们将属性接口命名为<code>IFormProps</code>，因为之后我们将需要一个字段属性的接口。</p><ol start="2"><li>添加一个<code>defaultValues</code>属性到<code>IFormProps</code>接口中，它为每个字段提供默认值，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface IValues &#123;</span><br><span class="line">  [key: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个额外的接口<code>IValues</code>，它是一个索引的key/value类型<code>[key: string]: any</code>，key是字段名，value是字段值。</p><p>因此，<code>defaultValues</code>属性可以是，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: <span class="string">&quot;&quot;</span>, email: <span class="string">&quot;&quot;</span>, reason: <span class="string">&quot;Support&quot;</span>, notes: <span class="string">&quot;&quot;</span> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对于表单的state，需要存储这个接口类型，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来需要在构造方法中初始化组件的状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state =  &#123;</span><br><span class="line">    values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后一步，实现<code>render</code>方法，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  return (</span><br><span class="line">  &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &#123;this.props.children&#125;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>form</code>标签中渲染子组件，使用了<code>children</code>属性。</p><p>接下来，我们需要实现我们的<code>Field</code>组件。</p><h3><span id="adding-a-basic-field-component">Adding a basic Field component</span></h3><p><code>Field</code>组件需要渲染一个标签(label)和一个编辑框(editor)。</p><ol><li>首先在<code>Form.tsx</code>中创建一个接口属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IFieldProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  label: string;</span><br><span class="line">  type?: &quot;Text&quot; | &quot;Email&quot; | &quot;Select&quot; | &quot;TextArea&quot;;</span><br><span class="line">  options?: string[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>表示字段名</li><li><code>label</code>是展示标签</li><li><code>type</code>输入类型，可选</li><li><code>options</code>，仅作用于当<code>type</code>是<code>Select</code>时，可选</li></ul><ol start="2"><li>现在添加<code>Field</code>属性字段的骨架，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Field: React.SFC&lt;IFieldProps&gt; = props =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外，首先添加<code>type</code>字段的默认属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Form.Field.defaultProps = &#123;</span><br><span class="line">  type: &quot;Text&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，默认的<code>type</code>是一个文本类型，</p><ol start="4"><li>现在，渲染它的内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Field: React.SFC&lt;IFieldProps&gt; = props =&gt; &#123;</span><br><span class="line">  const &#123; name, label, type, options &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &lt;input type=&#123;type.toLowerCase()&#125; id=&#123;name&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这虽然是好的开头，但是，仅使用<code>Text</code>和<code>Email</code>类型。</p><ol start="5"><li>因此，需要添加合适的条件进行渲染，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;type === &quot;TextArea&quot; ... &#125;</span><br><span class="line"></span><br><span class="line">&#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">  &lt;select&gt;</span><br><span class="line">    &#123;options &amp;&amp;</span><br><span class="line">      options.map(option =&gt; (</span><br><span class="line">        &lt;option key=&#123;option&#125; value=&#123;option&#125;&gt;</span><br><span class="line">          &#123;option&#125;</span><br><span class="line">        &lt;/option&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h3><span id="sharing-state-with-react-context">Sharing state with React context</span></h3><p><code>Form</code>组件内的字段值状态，需要在<code>Field</code>组件内共享，即可以通过<code>Field</code>组件访问和修改。</p><ol><li>首先在<code>Form.tsx</code>创建一个接口，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>IFormContext</code>下使用<code>React.createContext</code>创建一个上下文创建(context component)，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const FormContext = React.createContext&lt;IFormContext&gt;(&#123;</span><br><span class="line">  values: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>Form</code>的<code>render</code>方法中，创建包含上下文的值，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>包装表单标签，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Provider value=&#123;context&#125;&gt;</span><br><span class="line">  &lt;form ... &gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/FormContext.Provider&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>Field</code>上下文进行消费，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Consumer&gt;</span><br><span class="line">  &#123;context =&gt; (</span><br><span class="line">    &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/FormContext.Consumer&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在可以访问这些上下文了，下面补充剩余的输入框，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">     &lt;input type=&#123;type.toLowerCase() id=&#123;name&#125; value=&#123;context.values[name]&#125; /&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">   </span><br><span class="line">   &#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">     &lt;textarea id=&#123;name&#125; value=&#123;context.values[name]&#125; /&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">   </span><br><span class="line">   &#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">     &lt;select value=&#123;context.values[name]&#125;&gt;</span><br><span class="line"> ...</span><br><span class="line"> &lt;/select&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>目前还没有添加事件用于更新上下文的状态，需要实现相应的事件处理机制。</p><ol start="7"><li>在<code>Form</code>类中创建一个<code>setValue</code>方法，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private setValue = (fieldName: string, value: any) =&gt; &#123;</span><br><span class="line">  const newValues = &#123; ...this.state.values, [fieldName]: value &#125;;</span><br><span class="line">  this.setState(&#123; values: newValues &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法包含有：</p><ul><li>该方法接收fieldName和value作为参数。</li><li>状态被更新为<code>newValues</code>，旧的值被更新，没有则添加。</li><li>新值被更新了。</li></ul><ol start="8"><li>接下来在<code>Field</code>组件中创建该方法的一个上下文属性，以实现访问，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>对应地，在<code>Form</code>组件也创建一个上下文属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const context: IFormContext = &#123;</span><br><span class="line">  setValue: this.setValue,</span><br><span class="line">  values: this.state.values</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="10"><li>现在可以在<code>Field</code>组件中访问该方法了。在<code>Field</code>中，即在解构(destucture)对象props后面，创建对应的事件Hnadler，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name, label, type, options &#125; = props;</span><br><span class="line"></span><br><span class="line">const handleChange = (</span><br><span class="line">  e:</span><br><span class="line">    | React.ChangeEvent&lt;HTMLInputElement&gt;</span><br><span class="line">    | React.ChangeEvent&lt;HTMLTextAreaElement&gt;</span><br><span class="line">    | React.ChangeEvent&lt;HTMLSelectElement&gt;,</span><br><span class="line">  context: IFormContext</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  if (context.setValue) &#123;</span><br><span class="line">    context.setValue(props.name, e.currentTarget.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法有几个关键的地方：</p><ul><li>TypeScript的事件改变类型是<code>ChangeEvent&lt;T&gt;</code>，其中<code>T</code>是被处理的元素。</li><li>该方法的第一个参数<code>e</code>，对应事件类型，组合(union)了所有不同的输入框事件，方便对事件进行统一处理。</li><li>该方法的第二个参数是表单上线文。</li><li>方法体内加入了条件语句，以确保编译顺利。</li><li>调用<code>setValue</code>方法更新或添加新值。</li></ul><ol start="11"><li>现在可以为<code>input</code>输入框添加这个事件处理，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input </span><br><span class="line">  type=&#123;type.toLowerCase() &#125;</span><br><span class="line">  id=&#123;name&#125;</span><br><span class="line">  value=&#123;context.values[name] &#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="12"><li>对于<code>textarea</code>标签，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea</span><br><span class="line">  id=&#123;name&#125;</span><br><span class="line">  value=&#123;context.values[name]&#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="13"><li>对于<code>select</code>标签，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select</span><br><span class="line">  value=&#123;context.values[name] &#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>现在，我们的<code>Form</code>和<code>Field</code>组件可以组合在一起工作了。</p><h3><span id="implementing-our-new-contactus-component">Implementing our new ContactUs component</span></h3><p>接下来，我们使用<code>Form</code>和<code>Field</code>重新实现我们的<code>ContactUs</code>组件。</p><ol><li><p>首先删除<code>ContactUs.tsx</code>中的props，</p></li><li><p>重新定义<code>ContactUs</code>的SFC，</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC = () =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>ContactUs.tsx</code>中导入<code>Form</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>现在引用<code>Form</code>组件，带上默认值，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> return (</span><br><span class="line">   &lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">&lt;/Form&gt;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>name</code>输入框，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  &lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>注意这个没有写<code>type</code>属性，则默认使用<code>text</code>填充，</p><ol start="6"><li>下面补充<code>email</code>，<code>reason</code>和<code>notes</code>字段，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  &lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">  &lt;Form.Field name=&quot;email&quot; label=&quot;Your email address&quot; type=&quot;Email&quot; /&gt;</span><br><span class="line">  &lt;Form.Field</span><br><span class="line">    name=&quot;reason&quot;</span><br><span class="line">label=&quot;Reason you need to contact us&quot;</span><br><span class="line">type=&quot;Select&quot;</span><br><span class="line">options=&#123;[&quot;Marketing&quot;, &quot;Support&quot;, &quot;Feedback&quot;, &quot;Jobs&quot;, &quot;Other&quot;]&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Form.Field name=&quot;notes&quot; label=&quot;Additional notes&quot; type=&quot;TextArea&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>接下来的<code>ContactUsPage</code>就变得简单了。它不需要包含任何状态(state)，因为状态的维护已经交由<code>Form</code>组件管理。我们也不需要传递任何属性(props)到<code>ContactUs</code>组件中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ContactUsPage extends React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123;</span><br><span class="line">  public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">  &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  If you enter your details we&#x27;ll get back to you as soon as we can.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;ContactUs /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止这个通用组件变得易用并减少我们的重复代码，但还需添加表单验证的实现。</p><h2><span id="validating-forms">Validating forms</span></h2><p>为了提升用户体验，需要在表单中实现校验功能。</p><p>在<code>ContactUs</code>组件中我们需要实现的校验规则是：</p><ul><li>name和email应该被填充</li><li>name字段不少于2个字符</li></ul><h3><span id="adding-a-validatio-rules-prop-to-form">Adding a validatio rules prop to form</span></h3><p>首先思考如何在表单中指定校验规则。我们需要为一个字段指定一个或多个规则。某些规则可能会有参数，例如最小长度。以如下形式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form</span><br><span class="line">  ...</span><br><span class="line">  validationRules=&#123;&#123;</span><br><span class="line">    email: &#123; validator: required &#125;,</span><br><span class="line">name: [&#123; validator: required &#125;, &#123; validator: minLength, arg: 3 &#125;]</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>首先在<code>Form</code>组件实现一个<code>validationRules</code>属性，</p><ol><li>在<code>Form.tsx</code>中定义一个<code>Validator</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export type Validator= (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  args?: any</span><br><span class="line">) =&gt; string;</span><br></pre></td></tr></table></figure><p>一个<code>Validator</code>函数包含字段名、值、以及一个可选参数，并返回string的字符串消息。如果输入内容合法，则返回空字符串。</p><ol start="2"><li>下面使用该类型创建一个<code>required</code>函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const required: Validator = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  args?: any</span><br><span class="line">): string =&gt;</span><br><span class="line">  values[fieldName] === undefined ||</span><br><span class="line">  values[fieldName] === null ||</span><br><span class="line">  values[fieldName] === &quot;&quot;</span><br><span class="line">    ? &quot;This must be populated&quot;</span><br><span class="line">: &quot;&quot;;</span><br></pre></td></tr></table></figure><p>这里需要将这个函数对外暴露使用。该函数会检测字段值是<code>undefined</code>、<code>null</code>还是空字符串，如果是则返回<code>This must be populated</code>的错误信息。</p><ol start="3"><li>类似地，创建一个长度判断的函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export const minLength: Validator = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  length: number</span><br><span class="line">): string =&gt;</span><br><span class="line">  values[fieldName] &amp;&amp; values[fieldName].length &lt; length ? `This must be at least $&#123;length&#125; characters`</span><br><span class="line">  : &quot;&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来需要创建传递这些规则的props，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface IValidation &#123;</span><br><span class="line">  validator: Validator;</span><br><span class="line">  arg?: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IValidationProp &#123;</span><br><span class="line">  [key: string]: IValidation | IValidation[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">  validationRules: IValidationProp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>validationRules</code>是一个索引key/value类型，其中key是字段名，value是一个或多个验证规则。</li><li>一个校验规则包含函数类型和一个参数。</li></ul><ol start="5"><li>有了<code>validationRules</code>后，在<code>ContactUs</code>中添加，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form, minLenght, requied &#125; from &quot;./Forma&quot;;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在，添加校验规则到<code>ContactUs</code>组件中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  valiationRules=&#123;&#123;</span><br><span class="line">    email: &#123; validator: required &#125;,</span><br><span class="line">name: [&#123; validator: required &#125;, &#123; validator: minLength, arg: 2 &#125;]</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><h3><span id="tracking-validation-error-messages">Tracking validation error messages</span></h3><p>有必要跟踪用户的不合法输入信息，提供友好的用户体验。</p><p><code>Form</code>组件的职责用于管理表单状态，因此将错误信息添加到state中，</p><ol><li>定义错误信息类型，添加到<code>IState</code>中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IErrors &#123;</span><br><span class="line">  [key: string]: string[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>errors</code>是一个key/value键值对，key为字段名，value为一组错误消息。</p><ol start="2"><li>在构造器中初始化<code>errors</code>的状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  const errors: IErrors = &#123;&#125;;</span><br><span class="line">  Object.keys(props.defaultValues).forEach(fieldName =&gt; &#123;</span><br><span class="line">    errors[fieldName] = [];</span><br><span class="line">  &#125;);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    errors,</span><br><span class="line">    values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的<code>defaultValues</code>包含了所有字段名。当<code>Form</code>组件初始化，所有字段的错误信息为空。</p><ol start="3"><li><code>Field</code>组件最终被用于渲染校验的错误信息，因此需要将这些信息添加到表单上下文。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  values: IValues;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加一个空白的<code>error</code>字面量作为默认值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const FormContext = React.createContext&lt;IFormContext&gt;(&#123;</span><br><span class="line">  errors: &#123;&#125;,</span><br><span class="line">  values: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>现在加入到context中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    errors: this.state.errors,</span><br><span class="line">setValue: this.setValue,</span><br><span class="line">values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，校验错误信息被设置在state中，并且可以被<code>Field</code>组件访问。接下来要创建一个方法来调用这些校验规则。</p><h3><span id="invoking-validation-rules">Invoking validation rules</span></h3><p>前面定义了校验规则，并且将校验信息关联到state中。但这些规则还没被调用。接下来我们要实现：</p><ol><li>我们需要在<code>Form</code>组件内创建一个方法，使用这些规则来校验字段。我们创建一个<code>validate</code>方法，它接收字段名和它的值。该方法会返回一个error message的数组信息，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private validate = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  value: any</span><br><span class="line">): string[] =&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法内，需要获取校验规则，并初始化返回信息<code>errors</code>。我们会收集校验的错误信息并存储在<code>errors</code>中。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private validate = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  value: any</span><br><span class="line">): string[] =&gt; &#123;</span><br><span class="line">  const rules = this.props.validationRules[fieldName];</span><br><span class="line">  const errors: string[] = [];</span><br><span class="line">  </span><br><span class="line">  // TODO - execute all the validators</span><br><span class="line">  return errors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>上下文获取的规则可能是一个<code>IValidation</code>数组，也可能是一个<code>IValidation</code>对象。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const errors: string[] = [];</span><br><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  // TODO - execute all the validators in the array of rules</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  if (rules) &#123;</span><br><span class="line">    const error = rules.validator(fieldName, this.state.values, rules.arg);</span><br><span class="line">if (error) &#123;</span><br><span class="line">  errors.push(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="4"><li>有多个校验规则时，我们可以使用<code>forEach</code>函数迭代执行，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  rules.forEach(rule =&gt; &#123;</span><br><span class="line">    const error = rule.validator(</span><br><span class="line">  fieldNmae,</span><br><span class="line">  this.state.values,</span><br><span class="line">  rule.arg</span><br><span class="line">    );</span><br><span class="line">if (error) &#123;</span><br><span class="line">  errors.push(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="5"><li>剩下的代码部分是，将校验的结果存储到表单状态<code>errors</code>中。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">const newErrors = &#123; ...this.state.errors, [fieldName]: errors &#125;;</span><br><span class="line">this.setState(&#123; errors: newErrors &#125;);</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="6"><li>表单<code>Field</code>组件需要调用到这个<code>validate</code>方法。首先添加到<code>IFormContext</code>接口，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">  validate?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>现在将它添加到<code>Form</code>渲染内容中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    errors: this.state.errors,</span><br><span class="line">setValue: this.setValue,</span><br><span class="line">validate: this.validate,</span><br><span class="line">values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单的校验和方法的调用已经完成了。但没有事件触发这个动作，</p><h3><span id="triggering-validation-rule-execution-from-field">TRiggering validation rule execution from field</span></h3><p>当用户输入表单内容后，我们希望校验规则在blur时触发，</p><ol><li>首先创建一个函数处理这些输入框触发的<code>blur</code>事件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = (</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleBlur = (</span><br><span class="line">  e:</span><br><span class="line">    | React.FocusEvent&lt;HTMLInputElement&gt;</span><br><span class="line">| React.FocusEvent&lt;HTMLTextAreaElement&gt;</span><br><span class="line">| React.FocusEvent&lt;HTMLSelectElement&gt;,</span><br><span class="line">  context: IFormContext</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  if (context.validate) &#123;</span><br><span class="line">    context.validate(props.name, e.currentTarget.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return ( ... )</span><br></pre></td></tr></table></figure><ul><li>TypeScript的blur事件是<code>FocusEvent&lt;T&gt;</code>，其中<code>T</code>是被处理的元素。</li><li>参数<code>e</code>作为事件对象。</li><li>第二个参数是表单上下文。</li><li>需要使用条件语句判断<code>validate</code>方法是否定义。</li><li>方法体内调用<code>valdiate</code>方法。</li></ul><ol start="2"><li>将事件引入，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">&lt;input</span><br><span class="line">type=&#123;type.toLowerCase()&#125;</span><br><span class="line">id=&#123;name&#125;</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类似地，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">&lt;textarea</span><br><span class="line">id=&#123;name&#125;</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">&lt;select</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>输入框字段会在失去焦点时触发校验动作。</p><h3><span id="rendering-validation-error-messages">Rendering validation error messages</span></h3><p>在此之前，需要将错误信息展示或者隐藏。</p><ol><li>添加<code>form-error</code>样式控制，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">  &#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">  &#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">&#123;context.errors[name] &amp;&amp;</span><br><span class="line">  context.errors[name].length &gt; 0 &amp;&amp;</span><br><span class="line">  context.errors[name].map(error =&gt; (</span><br><span class="line">    &lt;span key=&#123;error&#125; className=&quot;form-error&quot;&gt;</span><br><span class="line">       &#123;error&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>首先检测有错误的字段，再将错误信息渲染出来。</p><ol start="2"><li>下面是css样式，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.form-error &#123;</span><br><span class="line">font-size: 13px;</span><br><span class="line">color: red;</span><br><span class="line">margin: 3px auto 0px 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="form-submission">Form submission</span></h2><p>表单触发提交动作时，同样也需要进行校验。</p><ol><li>首先添加提交按钮，在<code>Form</code>组件中添加，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Provider value=&#123;context&#125;&gt;</span><br><span class="line">  &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">    &#123;this.props.children&#125;</span><br><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/FormContext.Provider&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>给按钮添加样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">border</span>: black solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">button</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: gray solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="adding-a-onsubmit-form-prop">Adding a onSubmit form prop</span></h3><p>在我们的<code>Form</code>组件中，需要一个新的属性来消费表单的提交动作。</p><ol><li>在<code>Form</code>组件中创建一个prop函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export interface ISubmitResult &#123;</span><br><span class="line">  success: boolean;</span><br><span class="line">  errors?: IErrors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">  validationRules: IValidationProp;</span><br><span class="line">  onSubmit: (values: IValues) =&gt; Promise&lt;ISubmitResult&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onSubmit</code>函数会接收filed的值，并异步返回提交的信息。</p><ol start="2"><li>另外需要添加状态记录表单的提交动作，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  submitting: boolean;</span><br><span class="line">  submitted: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外需要在构造器初始化，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    errors,</span><br><span class="line">submitted: false,</span><br><span class="line">submitting: false,</span><br><span class="line">values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>表单提交后按钮不可用，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;</span><br><span class="line">  disabled=&#123;this.state.submitting || this.state.submitted&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在表单中添加事件控制，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form className=&quot;form&quot; noValidate=&#123;true&#125; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>下面模拟这个提交动作，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用了<code>preventDefault</code>避免浏览器自动提交。</p><ol start="7"><li>接下来就是重点，表单验证！</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private validateForm(): boolean &#123;</span><br><span class="line">  const errors: IErrors = &#123;&#125;;</span><br><span class="line">  let haveError: boolean = false;</span><br><span class="line">  Object.keys(this.props.defaultValues).map(fieldName =&gt; &#123;</span><br><span class="line">    errors[fieldName] = this.validate(</span><br><span class="line">      fieldName,</span><br><span class="line">      this.state.values[fieldName]</span><br><span class="line">    );</span><br><span class="line">    if (errors[fieldName].length &gt; 0) &#123;</span><br><span class="line">      haveError = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  this.setState(&#123; errors &#125;);</span><br><span class="line">  return !haveError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  if (this.validateForm()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表单的状态会更新到最新的校验错误信息，</p><ol start="8"><li>实现剩余的代码，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; </span><br><span class="line">  e.preventDefault();</span><br><span class="line">  if (this.validateForm()) &#123;</span><br><span class="line">    this.setState(&#123; submitting: true &#125;);</span><br><span class="line">    const result = await this.props.onSubmit(this.state.values);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      errors: result.errors || &#123;&#125;,</span><br><span class="line">      submitted: result.success,</span><br><span class="line">      submitting: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="consuming-the-onsubmit-form-prop">Consuming the onSubmit form prop</span></h3><p>在本小节，将实现如何消费表单的提交内容。</p><ol><li>首先在<code>ContactUs</code>组件中导入<code>ISubmitResult</code>和<code>IValues</code>，用于处理提交的内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form, ISubmitResult, IValues, minLength, required &#125; from &quot;./Form&quot;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  onSubmit: (values: IValues) =&gt; Promise&lt;ISubmitResult&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个<code>handleSubmit</code>函数，它将会调用<code>onSubmit</code>属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  const handleSubmit = async (values: IValues): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">    const result = await props.onSubmit(values);</span><br><span class="line">return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>onSubmit</code>属性是异步的，因此需要函数前缀带<code>async</code>以及<code>onSubmit</code>前面带<code>await</code>。</p><ol start="3"><li>绑定这个属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;Form ... onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/Form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="4"><li>现在移步到<code>ContactUsPage</code>组件，创建提交处理，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (values: IValues): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">  await wait(1000); // simulate asynchronous web API call</span><br><span class="line">  return &#123;</span><br><span class="line">    errors: &#123;</span><br><span class="line">  email: [&quot;Some is wrong with this&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">success: false</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>接着创建<code>wait</code>函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const wait = (ms: number): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li>在<code>ContactUs</code>组件中加上，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs onSubmit=&#123;this.handleSubmit&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>导入暴露的属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ISubmitResult, IValues &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><h2><span id="summary">Summary</span></h2><p>本章讨论了控制组件，通过实现自定义表单组件描述。我们构建了一个通用型的<code>Form</code>和<code>Field</code>组件，并实现了状态控制、事件处理、表单提交等操作。</p><h2><span id="questions">Questions</span></h2><p>问题练习：</p><ol><li>扩展<code>Field</code>组件内容，包含<code>number</code>属性。</li><li>实现一个的输入框，该输入框响应紧急的程度，用数字表示。</li><li>实现一个新的校验函数，检测输入的数字是否在区间范围内。</li><li>合并实现2和3的功能。</li><li>为这个输入框添加事件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 Component Patterns</title>
      <link href="/2019/11/27/react-ts/chapter_6_Component_Patterns/"/>
      <url>/2019/11/27/react-ts/chapter_6_Component_Patterns/</url>
      
        <content type="html"><![CDATA[<ul><li>Container and presentational components</li><li>Compound compoents</li><li>Render props pattern</li><li>Higher-order components</li></ul><h2><span id="container-and-presentational-components">container and presentational components</span></h2><p>容器和表述组件。就是将复杂组件的属性内容进行抽取成为一个新的组件。</p><p>(略)</p><h2><span id="compound-components">Compound components</span></h2><p>合成组件，就是将一系列组件一起工作。</p><p>(略)</p><h2><span id="higher-order-components">Higher-order components</span></h2><p><strong>A higher-order component(HOC)</strong> 是一个函数组件，接收一个组件参数，返回该组件的增强版本。这样看起来没什么意义，下面通过一个例子<code>withLoader</code>组件来阐述。最终效果类似延迟加载动态圈。</p><h3><span id="adding-asynchronous-data-fetching">Adding asynchronous data fetching</span></h3><p>下面构造一份延迟数据来模拟真实的网络环境，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const wait = (ms: number): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">    return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const getProduct = async (id: number): Promise&lt;IProduct | null&gt; =&gt; &#123;</span><br><span class="line">    await wait(1000);</span><br><span class="line">    const foundProducts = products.filter(customer =&gt; customer.id === id);</span><br><span class="line">    return foundProducts.length === 0 ? null : foundProducts[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着在原来的<code>ProductPage</code>页面导入<code>getProduct</code>函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getProduct, IProduct &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><p>在<code>ProductPage</code>状态中加入一个新的属性<code>loading</code>，表示数据是否已经加载，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">product?: IProduct;</span><br><span class="line">added: boolean;</span><br><span class="line">loading: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中初始化状态属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public constructor(props: Props) &#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state = &#123;</span><br><span class="line">added: false,</span><br><span class="line">loading: true</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件加载时使用<code>getProduct</code>函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public async componentDidMount() &#123;</span><br><span class="line">  if (this.props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(this.props.match.params.id, 10);</span><br><span class="line">    const product = await getProduct(id);</span><br><span class="line">    if (product !== null) &#123;</span><br><span class="line">      this.setState(&#123; product, loading: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>await</code>关键字异步调用<code>getProduct</code>。另外还要修改生命周期方法<code>componentDidMount</code>带上<code>async</code>关键字。</p><h3><span id="implementing-the-withloader-hoc">Implementing the withLoader HOC</span></h3><p>我们将会创建<code>withLoader</code>加载组件，被用于指示组件处于繁忙状态。</p><ol><li>创建一个新文件，<code>withLoader.tsx</code>，内容如下，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const withLoader = &lt;P extends object&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P&gt;</span><br><span class="line">): React.SFC&lt;P &amp; IProps&gt; =&gt; (props: P &amp; IProps) =&gt;</span><br><span class="line">  props.loading ? (</span><br><span class="line">    &lt;div className=&quot;loader-overlay&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;loader-circle-wrap&quot;&gt;</span><br><span class="line">        &lt;div className=&quot;loader-circle&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ) : (</span><br><span class="line">    &lt;Component &#123;...props&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">export default withLoader;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>withLoader</code>是一个函数，接收一个类型是<code>P</code>的组件</li><li><code>withLoader</code>调用一个函数组件</li><li>函数组件的属性定义是<code>P &amp; IProps</code>，它是一个交集类型</li><li>组件的所有属性会通过SFC传入，并带上一个新的属性<code>loading</code></li><li>props被解构为一个<code>loading</code>变量，剩余的其它属性作为rest参数</li></ul><ol start="2"><li>添加加载转轮的CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader-overlay</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10004</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loader-circle-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loader-circle</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">4px</span> solid <span class="number">#899091</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: loader-circle-spin <span class="number">0.7s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="consuming-the-withloader-hoc">Consuming the withLoader HOC</span></h3><p>要消费这个高阶组件，只需要简单包装原来的组件即可。</p><p>原来的<code>Product.tsx</code>文件修改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import withLoader from &quot;./withLoader&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">export default withLoader(Product);</span><br></pre></td></tr></table></figure><p>在引用的页面部分修改为，即<code>ProductPage</code>页面，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;product || this.state.loading ? (</span><br><span class="line">  &lt;Product</span><br><span class="line">loading=&#123;this.state.loading&#125;</span><br><span class="line">product=&#123;product&#125;</span><br><span class="line">inBasket=&#123;this.state.added&#125;</span><br><span class="line">onAddToBasket=&#123;this.handleAddClick&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;p&gt;Product not found!&lt;/p&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>修改原来Props的属性选项为可选的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  product?: IProduct;</span><br><span class="line">  added: boolean;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要处理空值的情况，修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handleAddClick = () =&gt; &#123;</span><br><span class="line">props.onAddToBasket();</span><br><span class="line">&#125;;</span><br><span class="line">if (!product) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return (</span><br><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/React.Fragment&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>HOC非常适用于对原来组件的增强处理。比较常见的是React Router中使用了非常多这种HOC模式。React Router自身也实现了<code>withRouter</code>组件函数。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 高级类型</title>
      <link href="/2019/11/27/react-ts/chapter_5_Advanced_Types/"/>
      <url>/2019/11/27/react-ts/chapter_5_Advanced_Types/</url>
      
        <content type="html"><![CDATA[<ul><li>Union Types</li><li>Type guards</li><li>Generics</li><li>Overload signatures</li><li>Lookup and mapped types</li></ul><h2><span id="union-types">Union types</span></h2><p>顾名思义，联合类型就是将类型组合的一种形式。</p><h3><span id="string-literal-types">String literal types</span></h3><p>字符串字面量类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot;</span><br></pre></td></tr></table></figure><p>这个类型的值仅能是<code>&quot;Textbox&quot;</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let notes: Control;</span><br><span class="line">notes = &quot;Textbox&quot;;</span><br></pre></td></tr></table></figure><p>用其它值表示则会报错，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notes = &quot;DropDown&quot;;// &quot;DropDown&quot; is not assignable to type &quot;Textbox&quot;</span><br></pre></td></tr></table></figure><p>和其它TypeScript类型一样，<code>null</code>和<code>undefined</code>是有效的值，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notes = null;</span><br><span class="line">notes = undefined;</span><br></pre></td></tr></table></figure><p>字符串字面量类型自身没有多大用处，它的用处在于结合到联合类型中。</p><h3><span id="string-literal-union-types">String literal union types</span></h3><p>字符串字面量联合类型就是将多个字符串字面类型组合在一起。例如，将原先的<code>Control</code>类型增强为联合类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot; | &quot;DropDown&quot;</span><br></pre></td></tr></table></figure><p>设置值为二选一，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notes: Control;</span><br><span class="line">notes = &quot;Textbox&quot;;</span><br><span class="line">notes = &quot;DropDown&quot;;</span><br></pre></td></tr></table></figure><p>扩展更多的字面量，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot; | &quot;DropDown&quot; | &quot;DatePicker&quot; | &quot;NumberSlider&quot;;</span><br></pre></td></tr></table></figure><h3><span id="discriminated-union-pattern">Discriminated union pattern</span></h3><p>区分联合模式(discriminated union pattern)允许我们从不同联合类型中处理逻辑，以一个例子说明，</p><ol><li>首先创建三个不同的接口分别表示textbox、date picker、number slider，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface ITextbox &#123;</span><br><span class="line">control: &quot;TextBox&quot;;</span><br><span class="line">value: string;</span><br><span class="line">multiline: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDatePicker &#123;</span><br><span class="line">control: &quot;DatePicker&quot;;</span><br><span class="line">value: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface INumberSlider &#123;</span><br><span class="line">control: &quot;NumberSlider&quot;;</span><br><span class="line">value: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都有一个属性<code>control</code>，会成为模式的判别准则，</p><ol start="2"><li>我们将这些接口组合成为一个联合类型叫做<code>Field</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Field = ITextbox | IDatePicker | INumberSlider;</span><br></pre></td></tr></table></figure><ol start="3"><li>接着创建一个函数来初始化<code>Field</code>类型的值，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function intializeValue(field: Field) &#123;</span><br><span class="line">switch (field.control) &#123;</span><br><span class="line">case &quot;Textbox&quot;:</span><br><span class="line">field.value = &quot;&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;DatePicker&quot;:</span><br><span class="line">field.value = new Date();</span><br><span class="line">break;</span><br><span class="line">case &quot;NumberSlier&quot;:</span><br><span class="line">filed.value = 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">const shouldNotReach: never = field;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化值的设置取决于这个区分属性<code>control</code>。因此我们需要使用<code>switch</code>语句进行分岔处理。</p><p>其中<code>default</code>分支在<code>switch</code>语句中应该从不达到，对于不可达语句，使用<code>never</code>类型表述。</p><ol start="4"><li>随着时间的推移，新增了一个checkbox字段需求，接着实现这个接口，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ICheckbox &#123;</span><br><span class="line">control: &quot;Checkbox&quot;;</span><br><span class="line">value: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>将这个field添加到联合<code>Field</code>类型中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Field = ITextbox | IDatePicker | INumberSlider | ICheckbox;</span><br></pre></td></tr></table></figure><p>我们将会立即看到<code>initializeValue</code>函数在<code>never</code>声明中抛出编译错误，</p><ol start="6"><li>增加一个分支即可，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function intializeValue(field: Field) &#123;</span><br><span class="line">switch (field.control) &#123;</span><br><span class="line">case &quot;Textbox&quot;:</span><br><span class="line">field.value = &quot;&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;DatePicker&quot;:</span><br><span class="line">field.value = new Date();</span><br><span class="line">break;</span><br><span class="line">case &quot;NumberSlider&quot;:</span><br><span class="line">field.value = 0;</span><br><span class="line">break;</span><br><span class="line">case &quot;Checkbox&quot;:</span><br><span class="line">field.value = false;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">const shouldNotReach: never = field;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，联合类型允许我们组合任何类型成为另外一种类型。</p><h2><span id="type-guards">Type guards</span></h2><p>类型守卫，允许我们在一个代码条件分支上缩小一个对象的具体类型。对于联合类型来说可以在代码分支对不同具体类型进行处理。</p><p>例如上面的<code>intializeValue</code>函数，通过<code>switch</code>语句控制分支<code>control</code>来对不同设值类型进行处理。</p><p>下面介绍另外一种不同的方式。</p><h3><span id="using-the-typeof-keyword">Using the typeof keyword</span></h3><p><code>typeof</code>关键字是JavaScript的关键字，它会返回改类型的一个字符串。因此可以使用它缩小类型。</p><p>例如，有一个包含字符串和一个字符串数组的类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type StringOrStringArray = string | string[];</span><br></pre></td></tr></table></figure><p>我们需要实现一个<code>first</code>的函数，它接收类型为<code>StringOrStringArray</code>的参数并返回一个字符串，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function first(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求函数，如果是一个字符串，则返回第一个字符，如果是一个字符串数组则返回数组第一个元素，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function first(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测是否生效，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(first(&quot;The&quot;));</span><br><span class="line">console.log(first([&quot;The&quot;, &quot;cat&quot;]));</span><br></pre></td></tr></table></figure><p>因为<code>typeof</code>关键字仅能被用于JavaScript类型。为了说明这一点，对原来的函数做了增强。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function firstEnhanced(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else if (typeof stringOrArray === &quot;string[]&quot;) &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">const shouldNotReach: never = stringOrArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时TypeScript编译器在第二个分支报错，<code>typeof</code>关键字仅作用于JavaScript类型，即<code>string</code>、<code>number</code>、<code>boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>object</code>以及<code>function</code>；错误信息告诉我们<code>string[]</code>类型和JavaScript的类型<code>object</code>重合了，因此第二个分支实际上返回的是<code>object</code>。</p><p>修改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function firstEnhanced(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else if (typeof stringOrArray === &quot;object&quot;) &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">const shouldNotReach: never = stringOrArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>typeof</code>对于JavaScript类型是良好的，但对于TypeScript的具体类型却无从入手。</p><h3><span id="using-the-instanceof-keyword">Using the instanceof keyword</span></h3><p><code>instanceof</code>关键字还是JavaScript的，典型地被用于决定一个对象是否是某个类的实例。</p><p>例如，有两个类<code>Person</code>和<code>Company</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class company &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及定义一个联合类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonOrCompany = Person | Company;</span><br></pre></td></tr></table></figure><p>现在编写一个函数，接收一个<code>Person</code>或<code>Company</code>，并输出名字到控制台，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function logName(personOrCompany: PersonOrCompany) &#123;</span><br><span class="line">if (personOrCompany instanceof Person) &#123;</span><br><span class="line">console.log(`$&#123;personOrCompany.firstName&#125; $&#123;personOrCompany.surname&#125;`);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.log(personOrCompany.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof</code>虽然缩小了类的类型，但它仍然是JavaScript类型，有许多TypeScript类型不能处理。</p><h3><span id="using-the-in-keyword">Using the in keyword</span></h3><p><code>in</code>关键字是另外一个JavaScript关键字，被用于检测一个属性是否是一个对象。</p><p>例如，取代原来类的定义，使用接口对<code>Person</code>和<code>Company</code>进行声明，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICompany &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及创建一个联合类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonOrCompany = IPerson | ICompany;</span><br></pre></td></tr></table></figure><p>重写原来的方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function logName(personOrCompany: PersonOrCompany) &#123;</span><br><span class="line">if (&quot;firstName&quot; in personOrCompany) &#123;</span><br><span class="line">console.log(`$&#123;personOrCompany.firstName&#125; $&#123;personOrCompany.surname&#125;`);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.log(personOrCompany.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>关键字比较灵活，可以被用于任何对象类型。</p><h3><span id="using-a-user-defined-type-guard">Using a user-defined type guard</span></h3><p>自定义类型守卫，这部分属于TypeScript3特性，改写原来的代码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICompany &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PersonOrCompany = IPerson | ICompany;</span><br></pre></td></tr></table></figure><p>然后实现类型守卫函数，返回boolean，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isPerson(personOrCompany: PersonOrCompany): personOrCompany is IPerson &#123;</span><br><span class="line">return &quot;firstName&quot; in personOrCompany;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="generics">Generics</span></h2><p>泛型可以作用于一个函数或类中。</p><h3><span id="generic-functions">Generic functions</span></h3><p>下面通过一个例子描述泛型函数。我们将创建一个包装函数围绕<code>fetch</code>函数获取web servcie的数据，</p><ol><li>首先创建函数的方法签名，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function getData&lt;T&gt;(url: string): Promise&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要转变为arrow function的形式，我们可以…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getData = &lt;T&gt;(url: string): Promise&lt;T&gt; =&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>现在让我们实现我们的函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getData&lt;T&gt;(url: string): Promise&lt;T&gt; &#123;</span><br><span class="line">return fetch(url).then(response =&gt; &#123;</span><br><span class="line">if (!response.ok) &#123;</span><br><span class="line">throw new Error(response.statusText);</span><br><span class="line">&#125;</span><br><span class="line">return response.json();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后，消费这个函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;IPerson&gt;(&quot;/people/1&quot;).then(person =&gt; console.log(person));</span><br></pre></td></tr></table></figure><h3><span id="generic-classes">Generic classes</span></h3><p>泛型类，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class List&lt;T&gt; &#123;</span><br><span class="line">private data: T[] = [];</span><br><span class="line"></span><br><span class="line">public getList(): T[] &#123;</span><br><span class="line">return this.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public add(item: T) &#123;</span><br><span class="line">this.data.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public remove(item: T) &#123;</span><br><span class="line">this.data = this.data.filter(dataItem: T) =&gt; &#123;</span><br><span class="line">return !this.equals(item, dataItem);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">private equals(obj1: T, obj2: T) &#123;</span><br><span class="line">return Object.keys(obj1).every(key =&gt; &#123;</span><br><span class="line">return obj1[key] === obj2[key];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对应的消费接口，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line">const billy: IPerson = &#123; id: 1, name: &quot;Billy&quot; &#125;;</span><br></pre></td></tr></table></figure><p>然后创建一个泛型类实例，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const people = new List&lt;IPerson&gt;();</span><br></pre></td></tr></table></figure><p>调用泛型方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.add(billy);</span><br><span class="line">people.remove(billy);</span><br></pre></td></tr></table></figure><p>获取条目信息，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const items = people.getList();</span><br></pre></td></tr></table></figure><p>其中<code>React.Component</code>包含有两个泛型参数，分别是props和state。</p><h2><span id="overload-signatures">Overload signatures</span></h2><p>方法签名重载。</p><p>首先有两个函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function condenseString(string: string): string &#123;</span><br><span class="line">return string.split(&quot; &quot;).join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function condenseArray(array: string[]): string[] &#123;</span><br><span class="line">return array.map(item -&gt; item.split(&quot; &quot;).join(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在将这两个函数组合为一个函数。我们可以使用联合类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function condense(stringOrArray: string | string[]): string| string[] &#123;</span><br><span class="line">return typeof stringOrArray === &quot;string&quot; ? stringOrArray.split(&quot; &quot;).join(&quot;&quot;) : stringOrArray.map(item =&gt; item.split(&quot; &quot;).join(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const condensedText = condense(&quot;the cat sat on the mat&quot;);</span><br></pre></td></tr></table></figure><p>如果我们将鼠标放在<code>condensedText</code>上，我们会发现它是个联合类型，</p><p>现在添加两个重载的方法签名，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function condense(string: string): string;</span><br><span class="line">function condense(array: string[]): string[];</span><br><span class="line">function condense(stringOrArray: string | string[]): string | string[] &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>再次消费重载的函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const moreCondensedText = condense(&quot;The cat sat on the mat&quot;);</span><br></pre></td></tr></table></figure><p>将鼠标悬浮在<code>moreCondensedText</code>上，可以得到一个更好的确定类型是<code>string</code>。可以看到重载方法签名可以得到更好的类型推断。</p><h2><span id="lookup-and-mapped-types">Lookup and mapped types</span></h2><p>TypeScript中提供了一个关键字<code>keyof</code>用于为一个对象中的所有属性创建联合类型。这种被创建的类型被称为查询类型(lookup type)。它允许我们基于已有的类型的属性，动态地创建类型。</p><p>以一个例子为例，我们有下面这些接口，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用关键字<code>keyof</code>创建该接口的查询类型(lookup type)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonProps = keyof IPerson;</span><br></pre></td></tr></table></figure><p>如果将光标悬浮在<code>PersonProps</code>类型上，我们可以看到它是个联合类型，包含<code>&quot;id&quot;</code>和<code>&quot;name&quot;</code>属性，</p><p>在原来的<code>IPerson</code>上添加一个新的属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">age: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>PersonProps</code>类型包含了一个新的扩展属性<code>&quot;age&quot;</code>，</p><p>因此<code>PersonProps</code>类型是个lookup type，顾名思义它总是会查询它需要的字面量。</p><p>接下来我们看看这种查询类型的某些有用的地方，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field &#123;</span><br><span class="line">name: string;</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这仅是开始，我们可以让<code>name</code>属性更强，并使原来的类是个泛型类，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field&lt;T, K extends keyof T&gt; &#123;</span><br><span class="line">name: K,</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在该类创建了两个泛型参数。第一个泛型参数是对象类型，第二个是对象类型的属性类型。</p><p>然后我们创建这个类的实例，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const idField: Field&lt;IPerson, &quot;id&quot;&gt; = new Field();</span><br></pre></td></tr></table></figure><p>尝试引用不存在于<code>IPerson</code>的属性会发生报错，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const addressField: Field&lt;IPerson, &quot;address&quot;&gt; = new Field();</span><br></pre></td></tr></table></figure><p>另外，<code>defaultValue</code>不是类型安全的，譬如可以设置值为字符串，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idField.defaultValue = &quot;2&quot;;</span><br></pre></td></tr></table></figure><p>可以改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field&lt;T, K extends keyof T&gt; &#123;</span><br><span class="line">name: K;</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: T[K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询<code>T[K]</code>的类型，对于<code>idField</code>。它会处理到<code>IPerson</code>的属性<code>id</code>，即<code>number</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idFiled.defaultValue = 2;</span><br></pre></td></tr></table></figure><p>接下来创建一个映射类型。映射类型就是映射已存在类型的属性。</p><p>首先创建一个类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个只读版本的新类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReadonlyPerson = &#123; readonly [P in keyof IPerson]: IPerson[P] &#125;;</span><br></pre></td></tr></table></figure><p>其中重要的是创建这个映射<code>[P in keyof IPerson]</code>。这里将<code>IPerson</code>的所有属性迭代指派给<code>P</code>。因此，这个类型实际上是，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReadonlyPerson = &#123;</span><br><span class="line">readonly id: number</span><br><span class="line">readonly name: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在visual studio code中，它的实际定义会被解析为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Readonly&lt;T&gt; = &#123;</span><br><span class="line">readonly [P in keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以尝试创建我们自己呃泛型映射类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Stringify&lt;T&gt; = &#123; [P in keyof T]: string &#125;;</span><br></pre></td></tr></table></figure><p>然后消费我们的映射类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tim: Stringify&lt;IPerson&gt; = &#123;</span><br><span class="line">id: &quot;1&quot;,</span><br><span class="line">name: &quot;Time&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>映射类型适用于需要从已有的类型创建一个新的类型的场景。在TypeScript中，除了<code>Radonly&lt;T&gt;</code>类型外，还有<code>Partial&lt;T&gt;</code>，它会创建一个所有属性都是optional的映射类型。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 React Router</title>
      <link href="/2019/11/27/react-ts/chapter_4_Routing_with_React_Router/"/>
      <url>/2019/11/27/react-ts/chapter_4_Routing_with_React_Router/</url>
      
        <content type="html"><![CDATA[<ul><li>安装React Router</li><li>声明路由</li><li>创建向导</li><li>路由参数</li><li>处理not found路由</li><li>实现页面重定向</li><li>查询参数</li><li>路由提示符</li><li>内嵌路由</li><li>动画转换</li><li>lazy loading 路由</li></ul><h2><span id="安装路由">安装路由</span></h2><p>将React Router添加进项目中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><p>以及将TypeScript版本的React Router添加到devDependency的开发依赖中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @types/react-router-dom</span><br></pre></td></tr></table></figure><h2><span id="声明路由">声明路由</span></h2><p>在页面我们需要使用<code>BrowserRouter</code>和<code>Route</code>组件。<code>BrowserRouter</code>是top-level组件，会寻找下层的<code>Route</code>组件以决定不同的页面路径。</p><p>在引入<code>BrowserRouter</code>和<code>Route</code>之前，首先创建两个页面，</p><ol><li>创建一个<code>ProductsData.ts</code>文件，内容如下，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProduct &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> products: IProduct[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;A collection of navigational components that compose declaratively with your app&quot;</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;React Router&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;A library that helps manage state across your app&quot;</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;React Redux&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;A library that helps you interact with a GraphQL backend&quot;</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;React Apollo&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>创建另外一个<code>ProductsPage.tsx</code>文件导入这些数据，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; IProduct, products &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>因为需要在组件引用数据，创建一个接口，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">products: IProduct[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建类组件，初始化状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;&#123;&#125;, IState&gt; &#123;</span><br><span class="line">    public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            products: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ProductsPage;</span><br></pre></td></tr></table></figure><ol start="5"><li>实现<code>componentDidMount</code>生命周期方法，更新组件的State，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">this.setState(&#123; products &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>实现对应的<code>render</code>方法进行渲染，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&lt;p&gt;Welcome to React Shop where you can get all your tools for ReactJS!&lt;/p&gt;</span><br><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">&#123;this.state.products.map(product =&gt; (</span><br><span class="line">&lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">&#123;product.name&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">))&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>对应CSS样式为，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page-container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: large;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.product-list</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.product-list-item</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>实现第二个页面，文件名为<code>AdminPage.tsx</code>，它是个无状态组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const AdminPage: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;You should only be here if you have logged in&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default AdminPage;</span><br></pre></td></tr></table></figure><ol start="9"><li>现在我们有两个页面了，需要为其定义两个路由。首先创建一个<code>Routes.tsx</code>的文件，包含下面的内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import AdminPage from &quot;./AdminPage&quot;;</span><br><span class="line">import ProductsPage from &quot;./ProductsPage&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li>渲染路由页面，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">                &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Routes;</span><br></pre></td></tr></table></figure><ol start="11"><li>最后一步，把<code>Routes</code>添加到根组件<code>index.tsx</code>中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line">import Routes from &quot;./Routes&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Routes /&gt;, </span><br><span class="line">    document.getElementById(&#x27;root&#x27;) as HTMLElement);</span><br></pre></td></tr></table></figure><ol start="12"><li>目前页面上是什么也没有看到的，需要我们在浏览器直接输入地址，“<code>/products</code>”，或者访问另一个页面&quot;<code>/admin</code>&quot;,</li></ol><h2><span id="创建路由向导">创建路由向导</span></h2><p>非常幸运的是，React Router有一些组件提供了向导的功能。</p><h3><span id="using-the-link-component">Using the Link component</span></h3><p>使用<code>Link</code>组件实现向导功能，</p><ol><li>创建一个<code>Header.tsx</code>文件，包含以下内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; Link &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">import logo from &quot;./logo.svg&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着创建两个<code>Link</code>链接，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Header: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;header className=&quot;header&quot;&gt;</span><br><span class="line">            &lt;img src=&#123;logo&#125; className=&quot;header-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">            &lt;h1 className=&quot;header-title&quot;&gt;React Shop&lt;/h1&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;Link to=&quot;/products&quot; className=&quot;header-link&quot;&gt;Products&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/admin&quot; className=&quot;header-link&quot;&gt;Admin&lt;/Link&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应的CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-logo</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: header-logo-spin infinite <span class="number">20s</span> linear;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> header-logo-spin &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-link</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>把<code>Header</code>添加到我们的<code>Routes.tsx</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Header from &quot;./Header&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>加入导航，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><h2><span id="使用navlink组件">使用NavLink组件</span></h2><p>React Router还提供了另外一个组件用于页面链接，称为<code>NavLink</code>。下面我们用<code>NavLink</code>重构一下原来的<code>Header</code>组件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; NavLink &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">import logo from &quot;./logo.svg&quot;;</span><br><span class="line"></span><br><span class="line">const Header: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;header className=&quot;header&quot;&gt;</span><br><span class="line">            &lt;img src=&#123;logo&#125; className=&quot;header-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">            &lt;h1 className=&quot;header-title&quot;&gt;React Shop&lt;/h1&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">                &lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot;&gt;Admin&lt;/NavLink&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>NavLink</code>暴露了一个<code>activeClassName</code>属性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;Admin&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.header-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">#ebebeb</span> solid <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>NavLink</code>主要让我们导航带上样式功能。</p><h3><span id="路由参数">路由参数</span></h3><p>路由参数是路径变量的部分，用于决定目标组件的渲染逻辑。</p><p>我们需要添加另外一个页面，来展示商品的描述内容和价格，我们想要让页面导向使用&quot;<code>/products/&#123;id&#125;</code>&quot;路径，其中<code>id</code>对应商品ID。</p><ol><li>首先在原来的<code>Routes.tsx</code>添加路由路径和参数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建对应的<code>ProductPage</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#123; IProduct, products &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>这里的关键点是，我们需要用到<code>RouteComponentProps</code>来访问路径上的参数<code>id</code>。另外需要定义类型别名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Props = RouteComponentProps&lt;&#123;id: string&#125;&gt;;</span><br></pre></td></tr></table></figure><ol start="4"><li>另外还需要有个状态记录商品被添加到购物篮中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">    product?: IProduct;</span><br><span class="line">    added: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>初始化该状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ProductPage extends React.Component&lt;Props, IState&gt; &#123;</span><br><span class="line">    public constructor(props: Props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.setState(&#123; added: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ProductPage;</span><br></pre></td></tr></table></figure><ol start="6"><li>当组件被加载进DOM，会通过路径参数上的id查找商品。<code>RouteComponentProps</code>给我们提供了一个<code>match</code>对象，以访问路径上的参数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">        if (this.props.match.params.id) &#123;</span><br><span class="line">          const id: number = parseInt(this.props.match.params.id, 10);</span><br><span class="line">          const product = products.filter(p =&gt; p.id === id)[0];</span><br><span class="line">          this.setState(&#123; product &#125;);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，路径参数id是个字符串，需要使用<code>parseInt</code>进行转换，</p><ol start="7"><li>初始化好商品和组件状态后，我们进入到<code>render</code>函数，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">const product = this.state.product;</span><br><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&#123;product ? (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">&lt;h1&gt;&#123;product.name&#125;&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&#123;product.description&#125;&lt;/p&gt;</span><br><span class="line">&lt;p className=&quot;product-price&quot;&gt;</span><br><span class="line">&#123;new Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">currency: &quot;USD&quot;,</span><br><span class="line">style: &quot;currency&quot;</span><br><span class="line">&#125;).format(product.price)&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&#123;!this.state.added &amp;&amp; (</span><br><span class="line">&lt;button onClick=&#123;this.handleAddClick&#125;&gt;Add to basket&lt;/button&gt;</span><br><span class="line">)&#125;</span><br><span class="line">  &lt;/React.Fragment&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;p&gt;Product not found!&lt;/p&gt;</span><br><span class="line">)&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一些新东西，</p><ul><li>第一行创建了常量<code>product</code>；</li><li>三元运算符</li><li>使用了<code>React.Fragment</code>，类似实现单独一个parent的功能</li><li>使用了<code>Intl.NumberFormat</code>装换货币符号</li></ul><ol start="8"><li>另外还需要添加<code>handleAddClick</code>方法处理按钮事件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleAddClick = () =&gt; &#123;</span><br><span class="line">this.setState(&#123; added: true &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="9"><li>现在，将我们实现好的<code>ProductPage</code>组件，导入到<code>Routes.tsx</code>中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ProductPage from &quot;./ProductPage&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>直接浏览器键入&quot;<code>/products/2</code>&quot;查看新路由页面，但有个问题是&quot;<code>/products</code>&quot;和&quot;<code>/products/:id</code>&quot;都被渲染了</p></li><li><p>为了解决这个问题，修改为，</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="12"><li>进一步，我们需要为每个条目添加链接，回到原来的<code>ProductsPage.tsx</code>组件，修改相应部分内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Link &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          Welcome to React Shop where you can get all your tools for ReactJS!</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">          &#123;this.state.products.map(product =&gt; (</span><br><span class="line">            &lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">              &lt;Link to=&#123;`/products/$&#123;product.id&#125;`&#125;&gt;&#123;product.name&#125;&lt;/Link&gt;</span><br><span class="line">              &#123;product.name&#125;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="13"><li>补充CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.product-list-item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="handling-not-found-routes">Handling not found routes</span></h3><p>如果用户输入的路径不存在怎么处理？例如，我们尝试键入&quot;/tools&quot;，但路由中没有找到任何匹配的路由，我们希望提示该路径不存在。</p><ol><li>首先创建一个新的文件<code>NotFoundPage.tsx</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const NotFoundPage: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Sorry, this page cannot be found&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default NotFoundPage;</span><br></pre></td></tr></table></figure><ol start="2"><li>在路由组件中，导入，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import NotFoundPage from &quot;./NotFoundPage&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加到路由，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">&lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>但其他页面也一同渲染了，我们希望如果没有找到对应路由页面，仅渲染<code>NotFoundPage</code>，这是需要用到<code>Switch</code>组件。</p><ol start="4"><li>首先导入<code>Swith</code>组件到<code>Routes.tsx</code>中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>Route</code>包一层<code>Switch</code>组件即可，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p><code>Switch</code>组件仅渲染第一个匹配到的<code>Route</code>组件。在我们案例中，当找不到页面是，第一个匹配到的就是<code>NotFoundPage</code>，这样就解决了我们的问题。</p><h2><span id="实现页面重定向">实现页面重定向</span></h2><p>页面重定向使用了<code>Redirect</code>组件实现</p><h3><span id="simple-redirect">Simple redirect</span></h3><p>如果我们访问<code>/</code>路径，我们注意到它是个not found页面。我们希望当路径是<code>/</code>时，重定向到<code>/products</code>。</p><ol><li>首先，需要在<code>Routes.tsx</code>导入<code>Redirect</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter as Router, Redirect, Route, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后使用<code>Redirect</code>组件进行重定向，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h3><span id="conditional-redirect">Conditional redirect</span></h3><p>另外我们可以用<code>Redirect</code>组件对为授权用户进行保护访问。例如，我们的shop例子中，我们仅确保登录用户可以访问我们的<code>Admin</code>页面。</p><ol><li>创建一个<code>LoginPage</code>路由，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/login&quot; component=&#123;LoginPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个登录页<code>LoginPage.tsx</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const LoginPage: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Login&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;You need to login... &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default LoginPage;</span><br></pre></td></tr></table></figure><ol start="3"><li>回到原来的<code>Routes.tsx</code>导入<code>LoginPage</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import LoginPage from &quot;./LoginPage&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>在重定向到&quot;<code>admin</code>&quot;之前，我们需要在<code>Routes.tsx</code>中添加一些状态值，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC = () =&gt; &#123;</span><br><span class="line">const [loggedIn, setLoggedIn] = React.useState(false);</span><br><span class="line">return (</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后一步是添加条件判断，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? &lt;AdminPage /&gt; : &lt;Redirect to=&quot;/login&quot; /&gt;&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>如果我们将<code>loggedIn</code>状态修改为true，我们就可以再次访问我们的Admin页面了，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [loggedIn, setLoggedIn] = React.useState(true);</span><br></pre></td></tr></table></figure><h2><span id="query-parameters">Query parameters</span></h2><p>查询参数是URL地址的一部分，例如&quot;<code>/products?search=redux</code>&quot;。让我们实现一个商品查询功能。</p><ol><li>在原来的<code>ProductsPage.tsx</code>中，添加一个状态变量<code>search</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  products: IProduct[];</span><br><span class="line">  search: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>我们需要用到<code>RouteComponentProps</code>作为属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;RouteComponentProps, IState&gt; &#123;</span><br><span class="line">  public constructor(props: RouteComponentProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      products: [],</span><br><span class="line">      search: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>我们需要在<code>componentDidMount</code>确定好<code>search</code>的值，因此，实现<code>getDerivedStateFromProps</code>方法获取URL参数，并更新state，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static getDerivedStateFromProps(</span><br><span class="line">    props: RouteComponentProps,</span><br><span class="line">    state: IState</span><br><span class="line">  ) &#123;</span><br><span class="line">    const searchParams = new URLSearchParams(props.location.search);</span><br><span class="line">    const search = searchParams.get(&quot;search&quot;) || &quot;&quot;;</span><br><span class="line">    return &#123;</span><br><span class="line">      products: state.products,</span><br><span class="line">      search</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>不幸的是，<code>URLsearchParams</code>没有在所有浏览器中实现，所以我们需要用到<code>url-search-params-polyfill</code>，</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D url-search-params-polyfill</span><br></pre></td></tr></table></figure><ol start="6"><li>导入到<code>ProductPages.tsx</code>中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;url-search-params-polyfill&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>在渲染部分使用<code>search</code>状态，并包装一个<code>if</code>语句，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">  &#123;this.state.products.map(product =&gt; &#123;</span><br><span class="line">  if(</span><br><span class="line">  !this.state.search || </span><br><span class="line">  (this.state.search &amp;&amp;</span><br><span class="line">product.name.toLowerCase().indexOf(this.state.search.toLowerCase()) &gt; -1)</span><br><span class="line">  ) &#123;</span><br><span class="line">  return (</span><br><span class="line">&lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">  &lt;Link to=&#123;`/products/$&#123;product.id&#125;`&#125;&gt;&#123;product.name&#125;&lt;/Link&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>替换为搜索框搜索的方式… 我们需要，</p><ol start="8"><li>在<code>Header.tsx</code>文件中创建state，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [search, setSearch] = React.useState(&quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="9"><li>另外需要获取搜索参数，需要导入，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NavLink, RouteComponentProps, withRouter&#125; from &quot;reactrouter-</span><br><span class="line">dom&quot;;</span><br><span class="line">import &quot;url-search-params-polyfill&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li>添加<code>props</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Header: React.SFC&lt;RouteComponentProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>组件首次渲染时，从路径参数获取值并设置<code>search</code>的状态，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [search, setSearch] = React.useState(&quot;&quot;);</span><br><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">const searchParams = new</span><br><span class="line">URLSearchParams(props.location.search);</span><br><span class="line">setSearch(searchParams.get(&quot;search&quot;) || &quot;&quot;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ol start="12"><li>将<code>search</code>添加到<code>redner</code>方法中，让用户进行输入，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">&lt;header className=&quot;header&quot;&gt;</span><br><span class="line">&lt;div className=&quot;search-container&quot;&gt;</span><br><span class="line">&lt;input </span><br><span class="line">type=&quot;search&quot;</span><br><span class="line">placeholder=&quot;search&quot;</span><br><span class="line">value=&#123;search&#125;</span><br><span class="line">onChange=&#123;handleSearchChange&#125;</span><br><span class="line">onKeyDown=&#123;handleSearchKeydown&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="13"><li>添加<code>search-container</code>CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.search-container</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line"><span class="attribute">margin-bottom</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>回到原来的<code>Header.tsx</code>，添加对应的事件处理方法，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handleSearchChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">setSearch(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleSearchKeydown = (e:</span><br><span class="line">React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">if (e.key === &quot;Enter&quot;) &#123;</span><br><span class="line">props.history.push(`/products?search=$&#123;search&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="15"><li>另外我们需要用<code>withRouter</code>包装<code>Header</code>暴露接口，以使<code>this.props.history</code>可以生效，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default withRouter(Hader);</span><br></pre></td></tr></table></figure><h3><span id="route-prompts">Route prompts</span></h3><p><code>react-router-dom</code>组件中还有一个<code>Prompt</code>组件，顾名思义就是弹出框…</p><ol><li>我们希望用户离开商品页面时，如果没有购物，则弹出提示，首先，在<code>ProductPage.tsx</code>中导入<code>Prompt</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Prompt, RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加对应触发条件即可，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;Prompt when=&#123;!this.state.added&#125; message=&#123;this.navAwayMessage&#125; /&gt;</span><br><span class="line">  ...</span><br><span class="line">    private navAwayMessage = () =&gt; &quot;Are you sure you leave without buying this product?&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="nested-routes">Nested routes</span></h2><p>内嵌路由就是在某一个一级URL下渲染多个组件。</p><p>譬如我们想要创建一个3层渲染，</p><ul><li>第一层包含<code>Users</code>和<code>Products</code>的链接</li><li><code>Users</code>层又包含所有用户</li><li>点击每个用户可以看到具体信息</li></ul><ol><li>首先修改<code>AdminPage.tsx</code>，导入向导组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NavLink, Route, RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ul><li>我们将会使用<code>NavLink</code>组件渲染菜单</li><li><code>Route</code>用于内嵌路由</li><li><code>RouteComponentProps</code>类型将会获取URL的参数id</li></ul><ol start="2"><li>将<code>p</code>标签内容替换为下面…</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">  &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">&lt;li key=&quot;users&quot; &gt;</span><br><span class="line">&lt;NavLink to=&#123;`/admin/user`&#125; activeClassName=&quot;admin-link-active&quot;&gt;Users&lt;/NavLink&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;products&quot;&gt;</span><br><span class="line">&lt;NavLink to=&#123;`/admin/products`&#125; activeClassName=&quot;admin-link-active&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应样式…</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.admin-sections &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  margin: 0px 0px 20px 0px;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-sections li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-sections li a &#123;</span><br><span class="line">  color: #222;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-link-active &#123;</span><br><span class="line">  border-bottom: #6f6e6e solid 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>回到原来的<code>AdminPage.tsx</code>，添加两个路由组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">  &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin/users/:id&quot; component=&#123;AdminUsers&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin/products&quot; component=&#123;AdminProducts&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建这两个路由组件，在<code>AdminPage.tsx</code>内添加，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const AdminProducts: React.SFC = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;Some options to administer products&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li>接下来的<code>AdminUsers</code>组件可能会复杂一些。首先定义一种数据结构，在<code>AdminPage.tsx</code>的组件<code>AdminProducts</code>下，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface IUser &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  isAdmin: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const adminUsersData: IUser[] = [</span><br><span class="line">  &#123; id: 1, name: &quot;Fred&quot;, isAdmin: true &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;Bob&quot;, isAdmin: false &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;Jane&quot;, isAdmin: true &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这样一来就有3个用户了。</p><ol start="7"><li>接下来实现<code>AdminUsers</code>组件的内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const AdminUsers: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">        &#123;adminUsersData.map(user =&gt; (</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;NavLink</span><br><span class="line">              to=&#123;`/admin/users/$&#123;user.id&#125;`&#125;</span><br><span class="line">              activeClassName=&quot;admin-link-active&quot;</span><br><span class="line">            &gt;</span><br><span class="line">              &#123;user.name&#125;</span><br><span class="line">            &lt;/NavLink&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该组件会渲染每个用户名的链接。它是一个内嵌路径，</p><ol start="8"><li>另外，还需要定义另外一个路由展示用户详细信息。添加一个路由，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;Route path=&quot;/admin/users/:id&quot; component=&#123;AdminUser&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>这个<code>AdminUser</code>也还没有实现，因此，在<code>AdminUsers</code>组件下面添加上，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们用到了<code>RouteComponentProps</code>通过<code>id</code>来获取可用的属性。</p><ol start="10"><li>然后通过<code>id</code>获取定义的<code>adminUsersData</code>中的记录，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  let user: IUser;</span><br><span class="line">  if (props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(props.match.params.id, 10);</span><br><span class="line">    user = adminUsersData.filter(u =&gt; u.id === id)[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>有了<code>user</code>对象后，渲染其内容，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  let user: IUser;</span><br><span class="line">  if (props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(props.match.params.id, 10);</span><br><span class="line">    user = adminUsersData.filter(u =&gt; u.id === id)[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;Id: &lt;/b&gt;</span><br><span class="line">        &lt;span&gt;&#123;user.id.toString()&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;Is Admin: &lt;/b&gt;</span><br><span class="line">        &lt;span&gt;&#123;user.isAdmin.toString()&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="12"><li>再次运行，进入到<code>Admin</code>页面，点击<code>Products</code>… 点击<code>Users</code>…</li></ol><p>因此，如果需要实现内嵌路由，需要用到<code>NavLink</code>或<code>Link</code>组件，以及使用<code>Route</code>组件渲染这些内容。</p><h2><span id="animated-transitions">Animated transitions</span></h2><p>本小节将给不同的导航添加动画。我们会使用<code>react-transition-group</code>中的<code>TransitionGroup</code>和<code>CSSTransition</code>组件，步骤如下，</p><ol><li>首先安装对应这些包，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react-transition-group</span><br><span class="line">npm install @types/react-transition-group --save-dev</span><br></pre></td></tr></table></figure><p><code>TransitionGroup</code> 会持续跟踪它内部本地state的子组，并计算子组进入和退出。<code>CSSTransition</code>则在<code>TransitionGroup</code>子组离开或退出时，提供CSS类来表示一种状态。</p><p>因此，<code>TransitionGroup</code>和<code>CSSTransition</code>可以包装我们的路由，并调用CSS类，</p><ol start="2"><li>首先我们需要在我们的<code>Routes.tsx</code>中导入这些组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CSSTransition, TransitionGroup &#125; from &quot;react-transition-group&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们还需要路由属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Redirect, Route, RouteComponentProps, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>作用我们的<code>Route</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC&lt;RouteComponentProps&gt; = props =&gt; &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li>用<code>CSSTransition</code>和<code>TransitionGroup</code>来包装我们的路由，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;TransitionGroup&gt;</span><br><span class="line">  &lt;CSSTransition</span><br><span class="line">key=&#123;props.location.key&#125;</span><br><span class="line">timeout=&#123;500&#125;</span><br><span class="line">classNames=&quot;animate&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? &lt;AdminPage /&gt; : &lt;Redirect to=&quot;/login&quot; /&gt;&#125;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">  &lt;Route path=&quot;/login&quot; component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line">  &lt;/CSSTransition&gt;</span><br><span class="line">&lt;/TransitionGroup&gt;</span><br></pre></td></tr></table></figure><p><code>TransitionGroup</code>要求子组要有一个唯一的<code>key</code>决定退出和进入的动作。因此我们在<code>CSSTransition</code>上指定<code>key</code>属性为<code>RouteComponentProps</code>上的<code>location.key</code>。我们设置了transtion的timeout属性为半秒，以及它的样式类。</p><ol start="6"><li>接下来，我们需要添加这些CSS类到<code>index.css</code>中，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animate-enter</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animate-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">450ms</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animate-exit</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当它的<code>key</code>改变时，<code>CSSTransition</code>会调用这些CSS样式。</p><ol start="7"><li>因为我们不能在<code>Router</code>组件外部使用高阶组件<code>withRouter</code>。要解决这个问题，可以添加一个新的组件<code>RoutesWrap</code>进行包装，在原来的<code>Routes.tsx</code>中添加，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const RoutesWrap: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route component=&#123;Routes&#125; /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Routes extends React.Component&lt;RouteComponentProps,</span><br><span class="line">IState&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">export default RoutesWrap;</span><br></pre></td></tr></table></figure><ol start="8"><li>在<code>Routes</code>组件中移除<code>Router</code>，让<code>div</code>标签作为它的根。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;TransitionGroup&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/TransitionGroup&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次执行程序，可以看到进入不同页面是有一种渐退效果。</span><br><span class="line"></span><br><span class="line">## Lazy loading routes</span><br><span class="line"></span><br><span class="line">截至目前为止，所有JavaScript会在app第一次加载时全部加载。包括`Admin`这些我们不需要的页面。这一点会造成一些资源浪费。所以需要用到一种称为“lazy loading”的组件。</span><br><span class="line"></span><br><span class="line">1. 首先我们需要导入`Suspense`这个组件，</span><br><span class="line"></span><br><span class="line">```tsx</span><br><span class="line">import &#123; Suspense &#125; from &quot;react&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着以另一种方式导入这个<code>AdminPage</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ADminPage = React.lazy(() =&gt; import(&quot;./AdminPage&quot;));</span><br></pre></td></tr></table></figure><p>我们使用了React的一个函数<code>lazy</code>，它接收一个函数并返回一个动态导入，换句话说就是指派了一个<code>AdminPage</code>组件变量。</p><ol start="3"><li>上面步骤会获得一个lint错误，<strong>A dynamic import call in ES5/ES3 requires the ‘Promise’ constructor. Make sure you have a declaration for the ‘Promise’ constructor or include ‘ES2015’ in your <code>--lib</code> option.</strong> 需要在<code>tsconfig.json</code>中添加<code>lib</code>选项。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来的内容是，使用<code>Suspense</code>组件包装这个<code>AdminPage</code>组件，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? (</span><br><span class="line">&lt;Suspense fallback=&#123;&lt;div className=&quot;pagecontainer&quot;&gt;</span><br><span class="line">Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">&lt;AdminPage /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">) : (</span><br><span class="line">&lt;Redirect to=&quot;/login&quot; /&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p><code>Suspense</code>组件会在<code>AdminPage</code>被加载时，展示这个<code>div</code>部分内容。有点说明的是，组件加载非常快，可能实际浏览器看了没效果，需要进入<strong>Network</strong>选择<strong>Slow 3G</strong>网络环境模式。刷新页面便可看到出现Loading…</p><h2><span id="总结">总结</span></h2><p>React Router给我们一套全面的组件管理导航页。最先学习的是底层组件<code>Router</code>，它会查找下游的<code>Route</code>组件并根据路径进行渲染。</p><p><code>Link</code>组件让我们在应用中链接到不同的页面。我们学习了<code>NavLinke</code>和<code>Link</code>相似，但提供了对不同激活路径的样式功能。因此<code>NavLink</code>最大好处用在侧边栏或标头横幅，<code>Link</code>用在内嵌页面跳转。</p><p><code>RouteComponentProps</code>是一种泛型类型，它提供了访问路径参数的能力。我们还发现了React Router并不能解析路径参数，但可以使用本地的JavaScript的<code>URLSearchParams</code>实现。</p><p><code>Redirect</code>组件提供了路径重定向的功能。这非常适用于对权限页面的控制。</p><p><code>Prompt</code>组件提供了弹窗的能力。</p><p>我们还学习了通过使用<code>TransitionGroup</code>和<code>CSSTransition</code>组件，通过包装我们的<code>Route</code>组件实现一种渐退的效果。</p><p>另外我们还学习了使用<code>Suspense</code>组件配合React的<code>lazy</code>函数，对不同的页面实现延迟加载，帮助我们提升应用的性能效果。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 开始在React中使用TS</title>
      <link href="/2019/11/27/react-ts/chapter_3_Getting_Started_with_React_and_TypeScript/"/>
      <url>/2019/11/27/react-ts/chapter_3_Getting_Started_with_React_and_TypeScript/</url>
      
        <content type="html"><![CDATA[<ul><li>创建一个React和TypeScript项目</li><li>创建一个类组件</li><li>处理类组件的事件</li><li>类组件的状态</li><li>类组件声明周期方法</li><li>创建一个函数组件</li></ul><h2><span id="创建一个react和typescript项目">创建一个React和TypeScript项目</span></h2><h3><span id="使用create-react-app">使用<code>create-react-app</code></span></h3><p><code>create-eract-app</code>是一个npm包的命令行工具，用于快速创建React和TypeScript应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-react-ts-app --typescript</span><br></pre></td></tr></table></figure><p>项目创建后，添加TSLint，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-react-ts-app</span><br><span class="line">npm install tslint tslint-react tslint-config-prettier --save-dev</span><br></pre></td></tr></table></figure><p>添加文件<code>tslint.json</code>，包含一些规则，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;tslint:recommended&quot;</span>, <span class="string">&quot;tslint-react&quot;</span>, <span class="string">&quot;tslintconfig-prettier&quot;</span>],</span><br><span class="line"><span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;ordered-imports&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;object-literal-sort-keys&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;no-debugger&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;no-console&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;linterOptions&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line"><span class="string">&quot;config/**/*.js&quot;</span>,</span><br><span class="line"><span class="string">&quot;node_modules/**/*.ts&quot;</span>,</span><br><span class="line"><span class="string">&quot;coverage/lcov-report/*.js&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3><span id="创建一个简单的react-component">创建一个简单的React component</span></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.SFC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> My React App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.SFC</code>是一个TypeScript的React类型，它不包含任何内部状态。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App: React.SFC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My React App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> HTMLElement);</span><br></pre></td></tr></table></figure><h3><span id="添加webpack">添加webpack</span></h3><p>(略)</p><h3><span id="项目目录结构">项目目录结构</span></h3><p>(略)</p><h3><span id="创建一个基本的类组件">创建一个基本的类组件</span></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Confirm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Confirm;</span><br></pre></td></tr></table></figure><p><code>render</code>方法决定了该组件需要展示的内容。我们用JSX来定义需要展示的内容。简单来说，JSX就是HTML和JavaScript的混合。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-wrapper confirm-visible&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-title-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is where our title should go<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-content-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is where our content should go<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-buttons-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;confirm-cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;confirm-ok&quot;</span>&gt;</span>Okay<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么使用<code>Confirm</code>组件？在<code>App.tsx</code>中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Confirm from &#x27;./Confirm&#x27;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">&lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/header&gt;</span><br><span class="line">&lt;Confirm /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2><span id="jsx">JSX</span></h2><p>JSX看起来很像HTML，它不是有效的JavaScript，我们需要一个处理步骤将其转换为JavaScript。</p><p>打开浏览器，进入<a href="https://babeljs.io/repl">https://babeljs.io/repl</a>，输入下面内容，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is where our title should go<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>右侧会获得编译之后的JS文件，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;span&quot;</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;This is where our title should go&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement</code>有三个参数，</p><ul><li>元素类型，可以是一个HTML标签，一个React组件类型，或一个React 代码段</li><li>属性对象</li><li>子类或内容</li></ul><p>例如，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;confirm-title-container&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is where our title should go<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>最终会被编译为，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;div&quot;</span>,</span><br><span class="line">&#123; <span class="attr">className</span>: <span class="string">&quot;confirm-title-container&quot;</span> &#125;,</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;span&quot;</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;This is where our title should go&quot;</span></span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在看是有意义的，但目前仅由HTML构筑。加点JavaScript代码看看，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;React and TypeScript&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-title-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>它会被编译为，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> props = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;React and TypeScript&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;div&quot;</span>,</span><br><span class="line">&#123; <span class="attr">className</span>: <span class="string">&quot;confirm-title-container&quot;</span> &#125;,</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;span&quot;</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">props.title</span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>更进一步，让字面量<code>props</code>为空，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;confirm-title-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props.title ? props.title : &quot;React and TypeScript&quot;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>内嵌调用原封不变，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">&quot;span&quot;</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">props.title ? props.title : <span class="string">&quot;React and TypeScript&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>因此，为什么我们使用<code>className</code>属性而不是<code>class</code>？现在知道JSX会编译为JavaScript，由于<code>class</code>是JavaScript的关键字，在JSX包含<code>class</code>属性会发生冲突。因此React使用<code>className</code>代替CSS引用。</p></blockquote><h2><span id="component-props">Component props</span></h2><p>目前，组件<code>Confirm</code>的标题和内容是硬编码的。需要将这些引用属性以组件形式接收</p><ol><li>首先，我们需要为我们的props定义个TypeScript类型。我们将会用到一个接口，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将该<code>IProps</code>类型以尖括号引入定义中，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Confirm extends React.Component&lt;IProps&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>React.Component</code>被称为泛型类。泛型类允许类型允许在内部传递使用。在我们的例子中，我们传递了<code>IProps</code>接口。</p></blockquote><ol start="3"><li>然后我们的类内使用<code>this.props.propName</code>。在我们的JSX文件中，可以直接引用这些属性，取代硬编码的方式：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;div className=&quot;confirm-title-container&quot;&gt;</span><br><span class="line">&lt;span&gt;&#123;this.props.title&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div className=&quot;confirm-content-container&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前编译不过，因为<code>Confirm</code>组件现在要求传入<code>title</code>和<code>content</code>属性，</p><p>修改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">title=&quot;React and TypeScript&quot;</span><br><span class="line">content=&quot;Are you sure you want to learn React and TypeScript?&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="optional-props">Optional props</span></h3><p>接口Props的内容可以定义为可选属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">cancelCaption?: string;</span><br><span class="line">okCaption?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="default-prop-values">Default prop values</span></h3><blockquote><p>当组件被初始化，可以被组件添加默认props属性值。它通过一个称为<code>defaultProps</code>的静态对象字面量实现。</p></blockquote><ol><li>创建默认的<code>cancelCaption</code>和<code>okCaption</code>，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Confirm extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">public static defaultProps = &#123;</span><br><span class="line">cancelCaption: &quot;Cancel&quot;,</span><br><span class="line">okCaption: &quot;Okay&quot;</span><br><span class="line">&#125;;</span><br><span class="line">public render() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要覆盖默认属性，补充具体属性值即可，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">title=&quot;React and TypeScript&quot;</span><br><span class="line">content=&quot;Are you sure you want to learn React and TypeScript?&quot;</span><br><span class="line">cancelCaption=&quot;No way&quot;</span><br><span class="line">okCaption=&quot;Yes please!&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>带有默认值的可选属性便于组件使用，这样大部分通用的配置可以自动装配起来，不用逐个指定。</p></blockquote><h2><span id="处理类组件事件">处理类组件事件</span></h2><p>事件存在于多数编程语言中。以允许我们执行特定逻辑。</p><h3><span id="基础事件句柄">基础事件句柄</span></h3><blockquote><p>所有的本地JavaScript事件都可以在JSX中处理。JSX允许我们通过属性来调用这些事件函数。本地事件名会被带上前缀<code>on</code>以峰驼方式传递。因此，例如在JS中的属性事件是<code>click</code>，在JSX则对应<code>onClick</code>。</p></blockquote><p><strong>要查看所有可用事件列表，可以前往<code>node_modules/@types/react</code>文件夹的<code>index.d.ts</code>文件</strong></p><ol><li>首先是我们需要处理按钮上的<code>click</code>事件，对应上为，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button className=&quot;confirm-ok&quot; onClick=&#123;this.handleOkClick&#125;&gt;...&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建这个<code>handleOkClick</code>方法，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick() &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="the-this-problem">The this problem</span></h3><p>在事件的处理上承受来自JavaScript的经典<code>this</code>问题。我们在事件处理上获取不到引用，譬如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick() &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;, this.props):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮，会出现undefined！！原因是<code>this</code>代表的是当前这个事件，而不是我们的类！</p><p>一种解决方法是，将<code>handleOkClick</code>方法改为箭头函数(arrow function)。</p><blockquote><p>arrow function相当于一个表达式。它不会创建自身的<code>this</code>——这样解决了<code>this</code>的问题。</p></blockquote><p>我们把原来的方法改一改，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick = () =&gt; &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;, this.props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再次点击按钮，程序正常了。</p><h3><span id="function-props">Function props</span></h3><p>有时候需要在组件消费者(component)中传递事件处理逻辑。</p><ol><li>修改对应的IProps接口，对应函数类型属性，</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">cancelCaption?: string;</span><br><span class="line">okCaption?: string;</span><br><span class="line">onOkClick: () =&gt; void;</span><br><span class="line">onCancelClick: () =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在消费方引用函数属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">...</span><br><span class="line">onCancelClick=&#123;this.handleCancelConfirmClick&#125;</span><br><span class="line">onOkClick=&#123;this.handleOkConfirmClick&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="类组件状态">类组件状态</span></h3><p>状态是一个对象，它决定了组件的行为和渲染。我们需要在我们的app中引入状态，以管理我们Confirm窗口打开或关闭。</p><p>State的定义和Props类型，首先我们需要创建一个接口，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">confirmOpen: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着传递<code>React.Component</code>的第二个泛型参数中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component&lt;&#123;&#125;, IState&gt;</span><br></pre></td></tr></table></figure><h3><span id="initializing-the-state">Initializing the state</span></h3><p>定义的状态需要被初始化，初始化动作在构造函数中实现，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: &#123;&#125;) &#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state = &#123;</span><br><span class="line">confirmOpen: true,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state被存放在组件类内的一个私有属性中。以及可以在组件内被使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">open=&#123;this.state.confirmOPen&#125;</span><br><span class="line">...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="changing-state">Changing state</span></h3><p>状态的改变不能直接访问控制，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkConfirmClick = () =&gt; &#123;</span><br><span class="line">this.state.confirmOpen = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它会出现错误消息说状态是read-only!的。我们需要使用<code>setState</code>方法来改变状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkConfirmClick = () =&gt; &#123;</span><br><span class="line">this.setState(&#123; confirmOpen: false &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们仅能在构造函数中初始化State，其它类组件任何地方都不能初始化状态。以及，状态的更改，仅能在该组件内调用<code>setState</code>实现。</p><h2><span id="class-component-life-cycle-methods">Class component life cycle methods</span></h2><p>生命周期允许我们在特定点做某些处理。</p><h3><span id="componentdidmount">componentDidMount</span></h3><p>当一个组件被插入到DOM中时，<code>componentDidMount</code>被调用。下面是一些该方法常见的用例：</p><ul><li>调用web service以获取某些数据</li><li>添加事件监听</li><li>初始化计时</li><li>初始化第三方库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private timer: number = 0;</span><br><span class="line"></span><br><span class="line">public componentDidMount() &#123;</span><br><span class="line">this.timer = window.setInterval(() =&gt; this.handleTimerTick(), 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="componentwillunmount">componentWillUnmount</span></h3><p>当组件从DOM内被移除时触发<code>componentWillUnmount</code>，下面是常见的用例，</p><ul><li>移除事件监听器</li><li>取消激活的网络请求</li><li>移除计时器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentWillUnmount() &#123;</span><br><span class="line">clearInterval(this.timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="getderivedstatefromprops">getDerivedStateFromProps</span></h3><p>每次组件被渲染时，触发<code>getDerivedStateFromProps</code>。它是一个组件的静态方法，返回改变的状态或返回null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static getDerivedStateFromProps(props: &#123;&#125;, state: IState) &#123;</span><br><span class="line">console.log(&quot;getDerivedStateFromProps&quot;, props, state);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="getsnapshotbeforeupdate-and-componentdidupdate">getSnapshotBeforeUpdate and componentDidUpdate</span></h3><h3><span id="shouldcomponentupdate">shouldComponentUpdate</span></h3><h2><span id="creating-a-function-component">Creating a function component</span></h2><p>函数组件是从JavaScript函数实现的。</p><h3><span id="creating-a-basic-function-component">Creating a basic function component</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Confirm: React.SFC&lt;IProps&gt; = (props) =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整示例如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ComponentName: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">const handler = () =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">&lt;div&gt; Our JSX&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ComponentName.defaultProps = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default ComponentName;</span><br></pre></td></tr></table></figure><h3><span id="stateful-function-components">Stateful function components</span></h3><p>富状态函数组件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Confirm: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">const [cancelClickCount, setCancelClickCount] = React.useState(0);</span><br><span class="line"></span><br><span class="line">const handleOkClick = () =&gt; &#123;</span><br><span class="line">props.onOkClick();</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 TypeScript3的新特性</title>
      <link href="/2019/11/27/react-ts/chapter_2_TypeScript_3/"/>
      <url>/2019/11/27/react-ts/chapter_2_TypeScript_3/</url>
      
        <content type="html"><![CDATA[<ul><li>Tuples</li><li>The unknown type</li><li>Project references</li><li>Default JSX properties</li></ul><h2><span id="tuples">Tuples</span></h2><p>元组类型用中括号表示，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">product = [<span class="string">&quot;Table&quot;</span>, <span class="number">500</span>];</span><br></pre></td></tr></table></figure><h2><span id="javascript-的rest扩展语法">JavaScript 的rest扩展语法</span></h2><p>在JavaScript中，一个<code>rest</code>参数就是汇集多个参数以一个参数表示。因此它称为<code>rest</code>(剩余的、)。不要跟RESTful混淆。</p><p>TS中用三个点表示这种<code>rest</code>参数，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">...scores</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="open-ended-tuples">Open-ended tuples</span></h3><p>结合rest的扩展，tuple可以写成，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">string</span>, ...number[]];</span><br><span class="line"><span class="keyword">const</span> billyScores: Scores = [<span class="string">&quot;Billy&quot;</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>];</span><br></pre></td></tr></table></figure><h3><span id="tuple-function-parameters">Tuple function parameters</span></h3><p>除了rest扩展写法，TS3支持带上参数类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">...scores: [...<span class="built_in">number</span>[]]</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">string</span>, ...number[]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndScores</span>(<span class="params">...scores: Scores</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br><span class="line">logNameAndScores(<span class="string">&quot;Sally&quot;</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">70</span>);</span><br></pre></td></tr></table></figure><h3><span id="spread-expressions">Spread expressions</span></h3><p>TS3中允许使用扩展语法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScore</span>(<span class="params">score1: <span class="built_in">number</span>, score2: <span class="built_in">number</span>, score3: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(score1, score2, score3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scores: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">75</span>, <span class="number">65</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">logScore(...scores);</span><br></pre></td></tr></table></figure><p>但不支持open-ended tuples，因此下面代码编译出错，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scoresUnlimited: [...number[]] = [<span class="number">75</span>, <span class="number">65</span>, <span class="number">80</span>];</span><br><span class="line">logScore(...scoresUnlimited);</span><br></pre></td></tr></table></figure><h3><span id="empty-tuples">Empty tuples</span></h3><p>TS3中可以定义空tuple，</p><p>对于类型别名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty = [];</span><br></pre></td></tr></table></figure><p>声明该类型的一个变量，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> empty: Empty = [];</span><br></pre></td></tr></table></figure><p>如果尝试给该类型指派一个非空值，会出现编译错误，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notEmpty: Empty = [<span class="string">&quot;Billy&quot;</span>];</span><br></pre></td></tr></table></figure><p>空tuple可能没什么用，它的主要用处在于作为联合类型(union type)的一部分。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [] | [<span class="built_in">number</span>] | [<span class="built_in">number</span>, <span class="built_in">number</span>] | [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> benScores: Scores = [];</span><br><span class="line"><span class="keyword">const</span> samScores: Scores = [<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> bobScores: Scores = [<span class="number">95</span>, <span class="number">75</span>];</span><br><span class="line"><span class="keyword">const</span> jayneScores: Scores = [<span class="number">65</span>, <span class="number">50</span>, <span class="number">70</span>];</span><br><span class="line"><span class="keyword">const</span> sarahScores: Scores = [<span class="number">95</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">75</span>];<span class="comment">// illegal </span></span><br></pre></td></tr></table></figure><h3><span id="可选tuple元素">可选tuple元素</span></h3><p>TS中用<code>?</code>表示一个可选元素，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?];</span><br></pre></td></tr></table></figure><p>这样就可以创建带一个到三个元素的变量，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> samScores: Scores = [<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> bobScores: Scores = [<span class="number">95</span>, <span class="number">75</span>];</span><br><span class="line"><span class="keyword">const</span> jayneScores: Scores = [<span class="number">65</span>, <span class="number">50</span>, <span class="number">70</span>];</span><br></pre></td></tr></table></figure><p>严格来说，TypeScript是把类型看做是“真实的”，因此对应Type Safe的层次也是看做是类型安全的，不匹配的类型将发生编译错误，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sarahScores: Scores = [<span class="number">95</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">75</span>];<span class="comment">// illegal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> benScores: Scores = [];<span class="comment">// illegal</span></span><br></pre></td></tr></table></figure><h3><span id="unknown-type">Unknown type</span></h3><p>TS中对未知类型使用<code>unknow</code>表示，<code>unknown</code>类型通常和<code>any</code>类型交替地使用，编译器不会对这种类型进行检查，因此，下面写法是正确的，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">scores: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(scores.scores);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call this function</span></span><br><span class="line">logScores(&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;Billy&quot;</span>,</span><br><span class="line"><span class="attr">scores</span>: [<span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但如果改为，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScoresBetter</span>(<span class="params">socres: unknown</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(scores.scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即获得一个编译器警告，带程序依然有效。</p><h3><span id="type-checking-with-a-type-redicate">Type checking with a type redicate</span></h3><p>顾名思义，就是用“谓语”对类型作检查，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scoresCheck = (</span><br><span class="line">scores: <span class="built_in">any</span></span><br><span class="line">): scores is &#123; <span class="attr">name</span>: <span class="built_in">string</span>; scores: <span class="built_in">number</span>[] &#125; =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> socres &amp;&amp; <span class="string">&quot;scores&quot;</span> <span class="keyword">in</span> scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>scores</code>参数带有类型谓语，<code>scores is &#123; name: string; scores: number[] &#125;</code>，以确保它包含类型属性<code>name</code>和<code>scores</code>。</p><p>可以结合类型别名，提高可读性，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; scores: <span class="built_in">number</span>[] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scoresCheck = (</span><br><span class="line">scores: <span class="built_in">any</span></span><br><span class="line">): scores is Scores =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> scores &amp;&amp; <span class="string">&quot;scores&quot;</span> <span class="keyword">in</span> scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类型谓语属于type guard的一种方式，还有其它几种实现type guard的方式。</p><h3><span id="type-narrowing-with-a-type-assertion">Type narrowing with a type assertion</span></h3><p>类型收缩(type narrowing)类似于Java的强制转换，通过类型断言的方式，使用<code>as</code>关键实现，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">scores: <span class="built_in">number</span>[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">scores: unknown</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log((scores <span class="keyword">as</span> scores).name);</span><br><span class="line"><span class="built_in">console</span>.log((scores <span class="keyword">as</span> Scores).scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="project-reference">Project reference</span></h3><p>(略) 参考网上tsconfig.json内容，</p><h3><span id="default-jsx-properties">Default JSX properties</span></h3><p>在TS3之前，我们必须设置默认的Props属性，并检查是否为null，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line"><span class="attr">text</span>: <span class="built_in">string</span>;</span><br><span class="line">delimiter?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitText</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">IProps</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"><span class="attr">delimiter</span>: <span class="string">&quot;,&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> bits = <span class="built_in">this</span>.props.text.split(<span class="built_in">this</span>.props.delimiter!);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;bits.map((bit: string) =&gt; (</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;bit&#125;</span>&gt;</span>&#123;bit&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">))&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">SplitText</span> <span class="attr">text</span>=<span class="string">&quot;Fred,Jane,Bob&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>TS3之后，可以不必要将<code>delimiter</code>属性设置为optional的，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line"><span class="attr">text</span>: <span class="built_in">string</span>;</span><br><span class="line">delimiter: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitText</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">IProps</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"><span class="attr">delimiter</span>: <span class="string">&quot;,&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> bits = <span class="built_in">this</span>.props.text.split(<span class="built_in">this</span>.props.delimiter);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;bits.map((bit: string) =&gt; (</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;bit&#125;</span>&gt;</span>&#123;bit&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">))&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="问题">问题</span></h3><ol><li>怎么调用<code>drawPoint</code>这个函数，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPoint</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, z: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line">drawPoint(...point);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建另外一个版本的<code>drawPoint</code>，参数用<code>[number, number, number]</code>实现，</p></li><li><p>在问题2中，让<code>z</code>是可选的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 基础</title>
      <link href="/2019/11/27/react-ts/chapter_1_TypeScript_Basics/"/>
      <url>/2019/11/27/react-ts/chapter_1_TypeScript_Basics/</url>
      
        <content type="html"><![CDATA[<ul><li>TypeScript 的好处</li><li>基础类型</li><li>接口，类型alias，类</li><li>模块结构</li><li>配置</li><li>TypeScript lint</li><li>代码格式化</li></ul><h2><span id="技术前提">技术前提</span></h2><ul><li><p>TypeScript 背景： <a href="https://www.typescriptlang.org/play/">https://www.typescriptlang.org/play/</a></p></li><li><p>Node.js 以及npm：Node &gt;= 8.2， npm &gt;= 5.2</p></li><li><p>TypeScript安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></li><li><p>Visual Studio Code：前端开发利器</p></li></ul><h2><span id="typescript-带来了什么">TypeScript 带来了什么</span></h2><p>TypeScript解决了JavaScript代码增长带来难于阅读和难于维护的痛点。比起JavaScript，</p><ul><li>开发前期可以捕获代码错误</li><li>静态类型允许开发工具提升开发者的经验和生产力</li><li>兼容各种浏览器，以及一些非浏览器平台</li></ul><h2><span id="基础类型">基础类型</span></h2><h3><span id="原生类型">原生类型</span></h3><ul><li><code>string</code>: Unicode字符串</li><li><code>number</code>: 表达整数和浮点数</li><li><code>boolean</code>: 逻辑true或false</li><li><code>undefined</code>: 未定义值</li><li><code>null</code>: null</li></ul><h3><span id="类型标注">类型标注</span></h3><p>TypeScript在变量声明时带有类型，语法为<code>:Type</code>。</p><h3><span id="类型推断">类型推断</span></h3><p>TypeScript可以简单地有赋值推断出其类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4><span id="any">Any</span></h4><p>既没有值，也没有指定类型的变量，它的类型是<code>any</code>，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag;</span><br></pre></td></tr></table></figure><p>它用于动态声明，表示其值的类型会随后被确定。</p><h4><span id="void">Void</span></h4><p>用于函数的返回表示，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function logText(text: string): void &#123;</span><br><span class="line">console.log(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常不带return语句体的函数，返回值类型会自动推断为<code>void</code>。</p><h4><span id="never">Never</span></h4><p>表示“从不”，用于指定该代码不可达</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foreverTask(taskName: string): never &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">console.log(`Doing $&#123;taskName&#125; over and over again ...`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数一直循环，永不返回，所以需要给定类型<code>never</code>。</p><h4><span id="enumerations">Enumerations</span></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> OrderStatus &#123;</span><br><span class="line">Paid,</span><br><span class="line">Shipped,</span><br><span class="line">Completed,</span><br><span class="line">Cancelled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标访问，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let status = OrderStatus.Paid</span><br></pre></td></tr></table></figure><p>TypeScript的枚举，遵循自动下标的语法，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum OrderStatus &#123;</span><br><span class="line">Paid = 1,</span><br><span class="line">Shipped,</span><br><span class="line">Completed,</span><br><span class="line">Cancelled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不声明的部分按顺序逐个递增，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let status = OrderStatus.Shipped;</span><br><span class="line">console.log(status);// print 2</span><br></pre></td></tr></table></figure><h4><span id="objects">Objects</span></h4><p>TS的object和JS是共享的，是一种非原生类型。例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和JS一样，可以通过下标，直接修改和访问其值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customer.turnover = 123,</span><br></pre></td></tr></table></figure><p>不同的是，它有类型，所以下面会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customer.turnover = &quot;500,500&quot;,</span><br></pre></td></tr></table></figure><h4><span id="arrays">Arrays</span></h4><p>数组需要带类型，其它地方用法和JS差不多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers: number[] = [];</span><br><span class="line">number.push(1);</span><br></pre></td></tr></table></figure><p>另外可以通过类型推断来声明，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 3, 5];</span><br></pre></td></tr></table></figure><p>迭代方式有几种，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i in numbers) &#123;</span><br><span class="line">console.log(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.forEach(function (num)&#123;</span><br><span class="line">console.log(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="创建接口类型别名类">创建接口，类型别名，类</span></h3><p>常量的定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是改为下面会出现编译错误，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let customer: Object;</span><br><span class="line">customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;;</span><br><span class="line">customer.turnover = 20002000;// error</span><br></pre></td></tr></table></figure><p>Typescript 编译器不知道<code>customer</code>有哪些属性，所以需要引入结构化特性。</p><h3><span id="interfaces">Interfaces</span></h3><p>接口用<code>interface</code>关键字声明，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="properties">Properties</span></h3><p>结构的属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的属性必须声明了才能访问，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是类型，所以可以在其它接口引用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tableOrder: OrderDetail = &#123;</span><br><span class="line">product: table,</span><br><span class="line">quantity: 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="方法签名">方法签名</span></h3><p>接口可以包含方法签名而没有具体实现，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal(idscount: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体对象需要实现接口的方法签名，方法签名必须一致，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const tableOrder: OrderDetail = &#123;</span><br><span class="line">product: table,</span><br><span class="line">quantity: 1,</span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口中的方法签名，参数部分可以不用声明类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">....</span><br><span class="line">getTotal(number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但省略的参数类型使得阅读难于理解，我们不知道具体参数是什么类型？</p><h3><span id="可选属性可选参数">可选属性，可选参数</span></h3><p>和大部分现代语言类似，TypeScript中使用<code>?</code>表示属性或参数是个optional 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">dateAdded?: Date,</span><br><span class="line">getTotal(discount: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法签名的参数也可以是可选的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">dateAdded?: Date,</span><br><span class="line">getTotal(discount?: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法签名的实现可以改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getTotal(discount?: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * (discount || 0);</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在方法调用时，可以不传参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableOrder.getTotal();</span><br></pre></td></tr></table></figure><h3><span id="readonly-属性">Readonly 属性</span></h3><p><code>readonly</code>属性，顾名思义只能读取，不能修改，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">readonly name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，下面操作发生编译错误，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;;</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">table.name = &quot;Better Table&quot;;</span><br></pre></td></tr></table></figure><h3><span id="接口继承">接口继承</span></h3><p>接口继承使用<code>extends</code>关键字，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode [</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ProductWithDiscountCodes extends Product &#123;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实例可以简单创建，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const table: ProductWithDiscountCodes = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500,</span><br><span class="line">discountCodes: [</span><br><span class="line">&#123; code: &quot;SUMMER10&quot;, percentage: 0.1 &#125;,</span><br><span class="line">&#123; code: &quot;BFRI&quot;, percentage: 0.2 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="类型别名">类型别名</span></h3><p>类型别名就是给指定类型标准一个新的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type GetTotal = (discount: number) =&gt; number;</span><br><span class="line"></span><br><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal: GetTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名和接口相似，不同的是类型别名不能有extends，也不能implemented。</p><h3><span id="类">类</span></h3><p>相比接口，类有更多的特性，</p><h3><span id="基础类">基础类</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">name: stirng;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分概念和Java类型，可以通过<code>new</code>关键字声明实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const table = new Product();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br></pre></td></tr></table></figure><p>可以调用对应的成员方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对应实例，调用成员方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const table = new Product();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br><span class="line"></span><br><span class="line">const orderDtail = new OrderDetail();</span><br><span class="line">orderDetail.product = table;</span><br><span class="line">orderDetail.quantity = 2;</span><br><span class="line"></span><br><span class="line">const total = orderDetail.getTotal(0.1);</span><br><span class="line">console.log(total);</span><br></pre></td></tr></table></figure><h3><span id="接口继承">接口继承</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal(discount: number): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="构造器">构造器</span></h3><p>TS中的构造函数概念和Java一样，形式不一样，TS中需要使用<code>constructor</code>私有成员，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">constructor(product: Product, quantity: number) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例时，会强制要求传递参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const orderDetail = new OrderDetail(table, 2);</span><br></pre></td></tr></table></figure><p>某些情况下，可以使用默认值，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(product: Product, quantity: number = 1) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantitty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明实例时可以不写，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const orderDetail = new OrderDetail(table);</span><br></pre></td></tr></table></figure><p>可以少写点代码，在构造参数前引入<code>public</code>关键字，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">constructor(public product: Product, public quantity: number = 1) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="类继承">类继承</span></h3><p>类之间可以继承，使用关键字<code>extends</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode &#123;</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProductWithDiscountCodes etends Product &#123;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类型实例的创建如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const table = new ProductWithDiscountCodes();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br><span class="line">table.discountCodes = [</span><br><span class="line">&#123; code: &quot;SUMMER10&quot;, percentage: 0.1 &#125;,</span><br><span class="line">&#123; code: &quot;BFRI&quot;, percentage: 0.2 &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>父类包含构造函数，子类也必须包含构造函数的实现，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">constructor(public: name: string; public unitPrice: number) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode &#123;</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProductWithDiscountCodes extends Product &#123;</span><br><span class="line">constructor(public name: string, public unitPrice: number) &#123;</span><br><span class="line">super(name, unitPrice);</span><br><span class="line">&#125;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="抽象类">抽象类</span></h3><p>抽象类使用<code>abstract</code>关键字声明，表示没有实例化能力的成员</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">uitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bread = <span class="keyword">new</span> Procut();<span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>抽象方法需要带有<code>abstract</code>关键字，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">uitPrice: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">delete</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有子类都要实现这个抽象方法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fond</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="attr">deleted</span>: <span class="built_in">boolean</span>;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> bestBefore: <span class="built_in">Date</span></span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">delete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.deleted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="访问修改器">访问修改器</span></h3><p>按照访问作用域划分，目前有以下几种，</p><ul><li><code>public</code>:</li><li><code>private</code>:</li><li><code>protected</code>:</li><li><default>:</default></li></ul><h3><span id="setter和getter">Setter和Getter</span></h3><p>和Java不同，TS中有关键字<code>get</code>和<code>set</code>，语法和方法类似，其中<code>get</code>不带参数；<code>set</code>带一个参数，一般用于私有方法的操作处理，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> _unitPrice: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">get</span> <span class="title">unitPrice</span>(): <span class="title">number</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>._unitPrice || <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title">unitPrice</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>._unitPrice = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> table = <span class="keyword">new</span> Product();</span><br><span class="line">table.name = <span class="string">&quot;Table&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(table.unitPrice);</span><br><span class="line">table.unitPrice = -<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(table.unitPrice);</span><br></pre></td></tr></table></figure><h3><span id="static">Static</span></h3><p>静态声明的方法或属性，作用于类自身而不是类的对象实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line"><span class="attr">product</span>: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">static</span> getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = <span class="built_in">this</span>.product.unitPrice * <span class="built_in">this</span>.quantity;<span class="comment">// compile error</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态作用域里面的访问成员要求也必须是静态的，因此不能在静态方法中使用<code>this.properties</code>进行访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getTotal(unitPrice: <span class="built_in">number</span>, <span class="attr">quantity</span>: <span class="built_in">number</span>, <span class="attr">discount</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = unitPrice * quantity;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = OrderDetail.getTotal(<span class="number">500</span>, <span class="number">2</span>, <span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br></pre></td></tr></table></figure><h2><span id="结构化-转变-为模块">结构化 转变 为模块</span></h2><p>由于TypeScript是最终编译成为JavaScript，并且其作用域的是全局的。这样就带来一个问题是，同名的条目会在不同文件中造成冲突，因此需要实现模块化来解决这个问题，使得代码更容易组织，更高的重用性。</p><h3><span id="模块化格式">模块化格式</span></h3><p>模块化是属于ES6的JavaScript的部分特性。简要描述一下TypeScript的不同模块化格式：</p><ul><li><code>AMD(Asynchronous Module Definition)</code>: 最常见，对目标浏览器，用一个<code>define</code>函数来定义模块。</li><li><code>CommonJS</code>: 用于Node.js程式，使用<code>module.exports</code>来定义模块，用<code>require</code>来定义依赖。</li><li><code>UMD(Universal Module Definition)</code>: 可以用于浏览器app和Node.js程式。</li><li><code>ES6</code>: 使用<code>export</code>关键字来定义模块，<code>import</code>来定义依赖。</li></ul><p>笔者这里使用ES6。</p><h3><span id="exporting">Exporting</span></h3><p>从一个module进行export以允许在其它module中被使用。使用<code>export</code>关键字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Product &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者重命名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Product <span class="keyword">as</span> Stock &#125;</span><br></pre></td></tr></table></figure><h3><span id="importing">Importing</span></h3><p>有export就需要在其它模块进行import，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&quot;./product&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line"><span class="attr">product</span>: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line">getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者重命名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product <span class="keyword">as</span> Stock &#125; <span class="keyword">from</span> <span class="string">&quot;./product&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line"><span class="attr">product</span>: Stock;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="default-exports">default exports</span></h3><p>带有<code>default</code> 语句的export不需要花括号，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Product <span class="keyword">from</span> <span class="string">&quot;./product&quot;</span>;</span><br></pre></td></tr></table></figure><h2><span id="编译配置">编译配置</span></h2><p>TypeScript的编译器是<code>tsc</code>，它会将对应的<code>TS</code>文件编译为<code>JS</code>文件，</p><p>新建文件，<code>orderDetail.ts</code>，内容如下，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Product &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line"><span class="attr">product</span>: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line">getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = <span class="built_in">this</span>.product.unitPrice * <span class="built_in">this</span>.quantity;</span><br><span class="line"><span class="keyword">const</span> discountAmount = priceWithoutDiscount * discount;</span><br><span class="line"><span class="keyword">return</span> priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开终端，输入如下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc orderDetail</span><br></pre></td></tr></table></figure><p>不出错的话，在对应目录会生成一个文件<code>orderDetail.js</code>，里面是转换的JavaScript内容，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> OrderDetail = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OrderDetail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">OrderDetail.prototype.getTotal = <span class="function"><span class="keyword">function</span> (<span class="params">discount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> priceWithoutDiscount = <span class="built_in">this</span>.product.unitPrice * <span class="built_in">this</span>.quantity;</span><br><span class="line"><span class="keyword">var</span> discountAmount = priceWithoutDiscount * discount;</span><br><span class="line"><span class="keyword">return</span> priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> OrderDetail;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="built_in">exports</span>.OrderDetail = OrderDetail;</span><br></pre></td></tr></table></figure><h3><span id="常见编译选项">常见编译选项</span></h3><ul><li><code>--target</code>: 目标，默认是<code>ES3</code>，</li><li><code>--outDir</code>: 输出目录</li><li><code>--module</code>: 指定模块格式，<code>--target</code>是ES3或ES5时，默认是<code>CommonJS</code></li><li><code>--allowJS</code>: 告诉编译器处理JavaScript文件，应对那些TypeScript无法应对时候，需要JavaScript的情况。</li><li><code>--watch</code>: watch mode模式，修改文件后保存后立即编译输出。</li><li><code>--noImplicitAny</code>: 强制显式指定<code>any</code>类型。</li><li><code>--noImplicitReturns</code>: 强制显式返回。即对于不是<code>void</code>返回类型，所有case必须有返回值。</li><li><code>--sourceMap</code>: development模式中，生成<code>*.map</code>文件，以允许调试</li><li><code>--moduleResolution</code>: 告诉编译器如何处理模块，有两个选项<code>classic</code>或<code>node</code>，如果不指定，默认是<code>classic</code>，会要求使用第三方包，所以需要显式设置为<code>node</code>，编译器会查找<code>node_modules</code>模块。</li></ul><h3><span id="tsconfigjson">tsconfig.json</span></h3><p><code>tsconfig.json</code>文件是上面这些开关的几种配置文件，样例如下，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line"><span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line"><span class="string">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,</span><br><span class="line"><span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line"><span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="指定编译文件">指定编译文件</span></h3><p>在<code>tsconfig.json</code>中可以指定编译那些TypeScript文件，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;files&quot;</span>: [<span class="string">&quot;product.ts&quot;</span>, <span class="string">&quot;orderDetail.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者指定目录，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="typescript-linting">TypeScript linting</span></h3><p>linting是一种检查规则，用于加强语法或优化编译，参考TSLint官网。</p><h3><span id="code-formatting">Code Formatting</span></h3><p>代码格式化有很多种，常见的是<code>prettier</code>，另外还有less、css等等。</p><h2><span id="本章回归">本章回归</span></h2><ol><li>TS的5中原生类型是那些？// string, number, boolean, undefined, null</li><li>下面变量<code>flag</code>类型推断的类型是什么？// boolean</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>接口和类型别名的区别是什么？// type alias不能继承</li><li>下面代码有什么错误？如何处理？</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> unitPrice: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> table = <span class="keyword">new</span> Product();</span><br><span class="line">table.name = <span class="string">&quot;Table&quot;</span>;</span><br><span class="line">table.unitPrice = <span class="number">700</span>;</span><br></pre></td></tr></table></figure><p>// 要么编写IProduct接口，继承成员属性；要么在Product中写上成员name，unitPrice；要么带上setter/getter方法；</p><ol start="5"><li>如果想要我们的TS支持IE11，编译选项<code>--target</code>应该带什么？</li><li>如何转换为ES6版本的<code>.js</code>文件？// --target ES6</li><li>如何阻止代码中出现<code>console.log</code>语句？// tslint.yml 带<code>no-console</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jira 快速安装</title>
      <link href="/2019/10/21/jira/jira-install/"/>
      <url>/2019/10/21/jira/jira-install/</url>
      
        <content type="html"><![CDATA[<p>JIRA是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件，开发者是澳大利亚的Atlassian。JIRA这个名字并不是一个缩写，而是截取自“<strong>Gojira</strong>”，日文的哥斯拉发音。</p><p>采用Docker实现破解版的Jira安装。</p><span id="more"></span><ol><li>下载镜像</li></ol><p>一定要安装<code>jira-software</code>(不是jira)，否则没有agile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dchevell/jira-software:7.13.0</span><br></pre></td></tr></table></figure><ol start="2"><li>运行容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it -p  8080:8080  --privileged  -m 4096M -v /data/jira-data:/var/atlassian/application-data/jira  -v /etc/localtime:/etc/localtime --name jira dchevell/jira-software:7.13.0</span><br></pre></td></tr></table></figure><ol start="3"><li>拷贝文件到容器内</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/mysql-connector-java-5.1.25-bin.jar</span><br><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/atlassian-universal-plugin-manager-plugin-2.22.4.jar</span><br><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/atlassian-extras-3.2.jar</span><br></pre></td></tr></table></figure><p>拷贝mysql-connector</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp mysql-connector-java-5.1.25-bin.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</span><br></pre></td></tr></table></figure><p>进入容器修改mysql-connector的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/mysql-connector-java-5.1.25-bin.jar</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jira</span><br></pre></td></tr></table></figure><ol start="3"><li>安装MySQL</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -v /data/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --restart=unless-stopped -d mysql:5.7</span><br></pre></td></tr></table></figure><ol start="4"><li>设置</li></ol><p>浏览器访问JiraWeb，语言可以设为中文，选择「我将设置它自己」——「下一步」</p><p>数据库设置，数据库类型选择「MySQL」，接着填入你的MySQL连接信息（需要你在你的MySQL数据库中创建数据库，数据库的字符类型必须是utf8），测试可以连接之后点击「下一步」</p><p>设置应用程序的属性——「下一步」</p><p>申请许可证关键字，点击「生成Jira试用许可证」</p><p>需要注册账号，注册完之后重新回到这个页面，选择相关信息，点击「Generate License」</p><p>点击「Yes」</p><p>页面就会带着你的许可证关键字回到Jira的设置页面，接着点击「下一步」</p><p>等待一会就进入设置管理员页面，填入一些信息即可，接着「下一步」</p><p>点击「完成」即完成设置</p><ol start="5"><li>拷贝文件到容器内</li></ol><p>拷贝atlassian-extras到容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp atlassian-extras-3.2.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</span><br></pre></td></tr></table></figure><p>进入容器设置atlassian-extras的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/atlassian-extras-3.2.jar</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jira</span><br></pre></td></tr></table></figure><p>拷贝插件到容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp atlassian-universal-plugin-manager-plugin-2.22.4.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/atlassian-universal-plugin-manager-plugin-2.22.4.jar</span><br></pre></td></tr></table></figure><p>删除另一个插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/atlassian-universal-plugin-manager-plugin-2.22.9.jar</span><br></pre></td></tr></table></figure><p>破解结束，进入jira下载任意插件，申请试用，自动破解</p><ol start="6"><li>下面来下载一个收费软件试试</li></ol><p>安装完了点击「获取许可证」</p><p>接着在「管理应用」中可以看到，该插件已经破解了</p>]]></content>
      
      
      
        <tags>
            
            <tag> jira </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机算法关于生日悖论的求值</title>
      <link href="/2019/02/26/algorithm/probabilistic/birthday-paradox-problem/"/>
      <url>/2019/02/26/algorithm/probabilistic/birthday-paradox-problem/</url>
      
        <content type="html"><![CDATA[<p>In probability theory, the birthday problem, or birthday paradox This not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naive intuition: most people estimate that the chance is much lower than 50%. pertains to the probalility that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probalility that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reachese 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap yeas). The mathematics behind this problem lead to a well-known cryptographic attack call the birthday attack.</p><span id="more"></span><p>Using simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 &amp; 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive…</p><h2><span id="calculating-the-probalility">Calculating the probalility</span></h2><p>数学概率推导方法，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">probe</span></span>(n: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> probe: <span class="built_in">f64</span> = <span class="number">0</span>.;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> k &lt; n &#123;</span><br><span class="line">        k += <span class="number">1</span>;</span><br><span class="line">        probe = <span class="number">1.0</span> - ((<span class="number">1.0</span> - probe) * ((<span class="number">365</span> - (k - <span class="number">1</span>)) <span class="keyword">as</span> <span class="built_in">f64</span>) / (<span class="number">365</span> <span class="keyword">as</span> <span class="built_in">f64</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Number of people: &#123;&#125;, \tProb. of same birthday: &#123;&#125;&quot;</span>, k, probe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="birthday-attack">Birthday Attack</span></h2><p>生日悖论可以描述为：在N个人中，想使至少由两个人生日相同的概率大于50%，问N的最小值是多少？答案是23人。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DAYS_IN_YEAR: <span class="built_in">usize</span> = <span class="number">365</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">equal_birthdays</span></span>(n_sharers: <span class="built_in">usize</span>, group_size: <span class="built_in">usize</span>, n_repetitions: <span class="built_in">usize</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rng = rand::thread_rng();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> eq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..n_repetitions &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> group = <span class="built_in">vec!</span>[<span class="number">0</span>; DAYS_IN_YEAR];</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..group_size &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = rng.gen_range(<span class="number">0</span>, group.len());</span><br><span class="line">            group[idx] = group[idx] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> group.iter() &#123;</span><br><span class="line">            <span class="keyword">if</span> *k &gt;= n_sharers &#123;</span><br><span class="line">                eq = eq + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (eq <span class="keyword">as</span> <span class="built_in">f64</span> * <span class="number">100.0</span>) / n_repetitions <span class="keyword">as</span> <span class="built_in">f64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> group_est = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> sharers <span class="keyword">in</span> <span class="number">2</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="comment">// Coarse.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> group_size = group_est + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> equal_birthdays(sharers, group_size, <span class="number">100</span>) &lt; <span class="number">50.0</span> &#123;</span><br><span class="line">            group_size = group_size + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finer.</span></span><br><span class="line">        <span class="keyword">let</span> inf = ((group_size - (group_size - group_est)) <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="number">4.0</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">for</span> gs <span class="keyword">in</span> inf..(group_size + <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eq = equal_birthdays(sharers, group_size, <span class="number">250</span>);</span><br><span class="line">            <span class="keyword">if</span> eq &gt; <span class="number">50.0</span> &#123;</span><br><span class="line">                group_size = gs;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> gs <span class="keyword">in</span> (group_size - <span class="number">1</span>)..(group_size + <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eq = equal_birthdays(sharers, gs, <span class="number">50_000</span>);</span><br><span class="line">            <span class="keyword">if</span> eq &gt; <span class="number">50.0</span> &#123;</span><br><span class="line">                group_est = gs;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; independent people in a group of &#123;&#125; share a common birthday. &#123;&#125;&quot;</span>, sharers, gs, eq);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> probabilistic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在CentOS7快速构建Ceph集群</title>
      <link href="/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/"/>
      <url>/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/</url>
      
        <content type="html"><![CDATA[<p>Ceph是一个分布式、可扩展、高可用、性能优异的存储系统平台，支持块设备、文件系统和REST三种存储接口。它是一个高度可配置的系统，并提供了一个命令行界面用于监视和控制其存储集群。Ceph还包含认证和授权功能，可兼容多种存储网关接口，如OpenStack Swift和Amazon S3。</p><span id="more"></span><h2><span id="ceph-cluster">Ceph cluster</span></h2><p>机器准备，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ceph    10.10.51.200</span><br><span class="line">mon1    10.10.51.201</span><br><span class="line">mon2    10.10.51.202</span><br><span class="line">mon3    10.10.51.203</span><br><span class="line">osd1    10.10.51.211   (10.10.110.211)</span><br><span class="line">osd2    10.10.51.212   (10.10.110.212)</span><br><span class="line">osd3    10.10.51.213   (10.10.110.213)</span><br><span class="line">osd4    10.10.51.214   (10.10.110.214)</span><br></pre></td></tr></table></figure><p>因为ceph-deploy工具是通过主机名与其他节点通信，所以要通过hostnamectl修改主机名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl --static set-hostname ceph</span><br><span class="line">hostnamectl --static set-hostname mon1</span><br><span class="line">hostnamectl --static set-hostname mon2</span><br><span class="line">hostnamectl --static set-hostname mon3</span><br><span class="line">hostnamectl --static set-hostname osd1</span><br><span class="line">hostnamectl --static set-hostname osd2</span><br><span class="line">hostnamectl --static set-hostname osd3</span><br><span class="line">hostnamectl --static set-hostname osd4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每个节点执行以下命令，</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">useradd -d /home/cephuser -m cephuser</span><br><span class="line">passwd cephuser</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cephuser ALL = (root) NOPASSWD:ALL&quot;</span> | sudo tee /etc/sudoers.d/cephuser</span><br><span class="line">chmod 0440 /etc/sudoers.d/cephuser</span><br><span class="line">yum install -y ntp ntpdate ntp-doc</span><br><span class="line">ntpdate 0.us.pool.ntp.org</span><br><span class="line">hwclock --systohc</span><br><span class="line">systemctl <span class="built_in">enable</span> ntpd.service</span><br><span class="line">systemctl start ntpd.service</span><br><span class="line">yum install -y open-vm-tools <span class="comment">## If you run the nodes as virtual machines, otherwise remove this line</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class="line">sed -i s<span class="string">&#x27;/Defaults requiretty/#Defaults requiretty&#x27;</span>/g /etc/sudoers</span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure><p>每个节点建立cephuser用户的ssh连接，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id cephuser@osd1</span><br></pre></td></tr></table></figure><p>在每个节点执行下面命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br><span class="line">Host osd1</span><br><span class="line">Hostname osd1</span><br><span class="line">User cephuser</span><br><span class="line">Host osd2</span><br><span class="line">Hostname osd2</span><br><span class="line">User cephuser</span><br><span class="line">Host osd3</span><br><span class="line">Hostname osd3</span><br><span class="line">User cephuser</span><br><span class="line">Host osd4</span><br><span class="line">Hostname osd4</span><br><span class="line">User cephuser</span><br><span class="line">Host mon1</span><br><span class="line">Hostname mon1</span><br><span class="line">User cephuser</span><br><span class="line">Host mon2</span><br><span class="line">Hostname mon2</span><br><span class="line">User cephuser</span><br><span class="line">Host mon3</span><br><span class="line">Hostname mon3</span><br><span class="line">User cephuser</span><br></pre></td></tr></table></figure><p>更改权限，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 440 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>每个OSD节点准备磁盘，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parted -s /dev/sdc mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sdc -f</span><br><span class="line">parted -s /dev/sdd mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sdd -f</span><br><span class="line">parted /dev/sde mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sde -f</span><br><span class="line">parted -s /dev/sdb mklabel gpt mkpart primary 0% 33% mkpart primary 34% 66% mkpart primary 67% 100%</span><br></pre></td></tr></table></figure><p><img src="/img/ceph/osd-disk.png" alt></p><p>使用cephuser账号登录管理节点(即ceph node)，创建一个专用目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ceph-deploy</span><br><span class="line"><span class="built_in">cd</span> ceph-deploy/</span><br></pre></td></tr></table></figure><p>在监控节点安装和创建新集群，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uhv http://download.ceph.com/rpm-jewel/el7/noarch/ceph-release-1-1.el7.noarch.rpm</span><br><span class="line">sudo yum update -y &amp;&amp; sudo yum install ceph-deploy -y</span><br></pre></td></tr></table></figure><p>初始化配置，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi ceph.conf</span><br><span class="line">public network = 10.10.51.0/24</span><br><span class="line">cluster network = 10.10.110.0/24</span><br><span class="line"><span class="comment">#Choose reasonable numbers for number of replicas and placement groups.</span></span><br><span class="line">osd pool default size = 2 <span class="comment"># Write an object 2 times</span></span><br><span class="line">osd pool default min size = 1 <span class="comment"># Allow writing 1 copy in a degraded state</span></span><br><span class="line">osd pool default pg num = 256</span><br><span class="line">osd pool default pgp num = 256</span><br><span class="line"><span class="comment">#Choose a reasonable crush leaf type</span></span><br><span class="line"><span class="comment">#0 for a 1-node cluster.</span></span><br><span class="line"><span class="comment">#1 for a multi node cluster in a single rack</span></span><br><span class="line"><span class="comment">#2 for a multi node, multi chassis cluster with multiple hosts in a chassis</span></span><br><span class="line"><span class="comment">#3 for a multi node cluster with hosts across racks, etc.</span></span><br><span class="line">osd crush chooseleaf <span class="built_in">type</span> = 1</span><br></pre></td></tr></table></figure><p>然后，在为个节点安装ceph，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install ceph mon1 mon2 mon3 osd1 osd2 osd3 osd4</span><br><span class="line">ceph-deploy mon create-initial</span><br><span class="line">ceph-deploy gatherkeys mon1</span><br></pre></td></tr></table></figure><p>在每个OSD节点创建OSD磁盘，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy disk zap osd1:sdc osd1:sdd osd1:sde</span><br><span class="line">ceph-deploy osd create osd1:sdc:/dev/sdb1 osd1:sdd:/dev/sdb2 osd1:sde:/dev/sdb3</span><br></pre></td></tr></table></figure><p>集群创建完后，发现OSD没有开启，这时新版ceph-deploy一个issue，执行下面命令解决，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sgdisk -t 1:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br><span class="line">sgdisk -t 2:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br><span class="line">sgdisk -t 3:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br></pre></td></tr></table></figure><p>重启每个节点，给每个monitor加入systemd，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> ceph-mon.target</span><br></pre></td></tr></table></figure><p>最后，给所有节点部署密钥，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy admin ceph mon1 mon2 mon3 osd1 osd2 osd3 osd4</span><br><span class="line">sudo chmod +r /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure><p>一切如果正常，使用<code>ceph -v</code>和<code>ceph -s</code>会看到，</p><p><img src="/img/ceph/ceph-cluster.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 设计理念及主要概念之Volume(四)</title>
      <link href="/2019/02/08/kubernetes/kubernetes-04-theory-and-concpetion-md/"/>
      <url>/2019/02/08/kubernetes/kubernetes-04-theory-and-concpetion-md/</url>
      
        <content type="html"><![CDATA[<h2><span id="kubernetes存储卷">Kubernetes存储卷</span></h2><p>默认情况下容器的数据都是非持久化的，在容器消亡以后数据也跟着丢失，所以Docker提供了Volume机制以便将数据持久化存储。类似的，Kubernetes提供了更强大的Volume机制和丰富的插件，解决了容器数据持久化和容器间共享数据的问题。</p><p>与Docker不同，Kubernetes Volume的生命周期与Pod绑定</p><ul><li>容器挂掉后Kubelet再次重启容器时，Volume的数据依然还在</li><li>而Pod删除时，Volume才会清理。数据是否丢失取决于具体的Volume类型，比如emptyDir的数据会丢失，而PV的数据不会丢失</li></ul><span id="more"></span><ol><li>Volume类型</li></ol><p>目前，Kubernetes支持以下Volume类型：</p><ul><li>emptyDir</li><li>hostPath</li><li>gcePersistentDisk</li><li>awsElasticBlokStore</li><li>nfs</li><li>iscsi</li><li>flocker</li><li>glusterfs</li><li>rbd</li><li>cephfs</li><li>gitRepo</li><li>secret</li><li>persistentVolumeClaim</li><li>downwardAPI</li><li>azureFileVolume</li><li>vsphereVolume</li><li>Quobyte</li><li>PortworxVolume</li><li>ScaleIO</li><li>FlexVolume</li><li>StorageOS</li><li>local</li></ul><p>这些Volume并非全部都是持久化的，emptyDir与hostPath数据节点级别的卷类型，emptyDir的生命周期与Pod资源相同，而使用hostPath卷的Pod一旦被重新调度至其他节点，那么它将无法再使用此前的数据。</p><p>再如，Secret和ConfigMap算得上是两种特殊的卷类型。</p><ul><li><p>Secret用于向Pod传递敏感信息、如密码、私钥、证书文件等，这些信息如果直接定义在镜像中很容易导致泄露，有了Secret资源，用户可以将这些信息存储于集群中而后再由Pod进行挂载，从而实现将敏感数据与系统解耦。</p></li><li><p>ConfigMap资源则用于向Pod注入非敏感数据，使用时，用户将数据直接存储于ConfigMap对象中，而后直接在Pod中使用ConfigMap卷引用它即可，它可以帮助实现容器配置文件集中化定义和管理。</p></li></ul><p>因此，类似于emptyDir、hostPath、secret、gitRepo等，这些Volume会随着Pod的消亡而消失。</p><ol start="2"><li>Volume的使用</li></ol><p>在Pod中定义Volume由两部分组成：一是<code>.spec.valumes</code>，用于支持不同的Volume类型；二是<code>.spec.containers.volumeMounts</code>，用于定义挂载列表。</p><p>在Pod级别定义Volume，<code>.spec.volumes</code>字段可以定义多个Volume，例如下面定义了emptyDir类型和gitRepo类型，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logdata</span></span><br><span class="line">  <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">gitRepo:</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">https://github.com/barudisshu/kubernetes-pratise.git</span></span><br><span class="line"> <span class="attr">revision:</span> <span class="string">master</span></span><br><span class="line"> <span class="attr">directory:</span> <span class="string">.</span></span><br></pre></td></tr></table></figure><p>定义好的Volume可以共享。当Pod中只有一个容器时，使用存储卷通常用于数据持久化。</p><p><code>.spec.containers.volumeMounts</code>字段定义了Volume的挂载列表。它的挂载格式是固定的，如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">spec:</span></span><br><span class="line">   <span class="string">...</span></span><br><span class="line">   <span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;String&gt;</span></span><br><span class="line"> <span class="string">...</span></span><br><span class="line"> <span class="attr">volumeMounts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span> <span class="string">-required-</span></span><br><span class="line">   <span class="string">mountPath</span> <span class="string">&lt;string&gt;</span> <span class="string">-required-</span></span><br><span class="line"><span class="string">readOnly</span> <span class="string">&lt;boolean&gt;</span></span><br><span class="line"><span class="string">subPath</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="string">montPropagation</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name<string>：指定要挂载的存储的名称，必选</string></li><li>mountPath<string>：挂载点路径，容器文件系统上的路径，必选</string></li><li>readOnly<boolean>：是否挂载为只读</boolean></li><li>subPath<string>：子路径，即mountPath指定的路径下的一个字路径</string></li></ul><p>例如，容器myapp将logdata存储卷挂载在/var/log/myapp，将example挂载到/webdata/example目录，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ikubernetes/myapp:v7</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logdata</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/var/log/myapp/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/webdata/example/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>emptyDir</li></ol><p>emptyDir，如果Pod设置了emptyDir类型Volume，Pod被分配到Node上时候，会创建emptyDir，只要Pod运行在Node上，emptyDir都会存在(容器挂掉不会导致emptyDir丢失数据)，但是如果Pod从Node上被删除(Pod被删除，或者Pod发生迁移)，emptyDir也会被删除，并且永久丢失。</p><p><code>.spec.volumes.emptyDir</code>嵌套字段包含有，</p><ul><li>medium：存储介质的类型，默认为default,表示为使用节点默认存储介质；另一种是Memory，表示使用RAM的临时文件系统tmpfs，空间受限于内存，但性能非常好，通常用于作为缓存。</li><li>sizeLimit：当前Volume的空间限额，默认为nil，表示不限制；不过如果medium字段值为Memory时建议定义限额。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-emptydir-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-emptydir-pod</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.12-alpine</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pagegen</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/html</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">$(hostname)</span> <span class="string">$(date)</span> <span class="string">&gt;&gt;</span> <span class="string">/html/index.html;</span></span><br><span class="line">            <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line">          <span class="string">done</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>容器pagegen每隔10秒向Volume上的index.html文件追加一行信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods vol-emptydir-pod</span><br></pre></td></tr></table></figure><p>创建Service或直接在集群访问Pod的信息，可看到，</p><p><img src="/img/kubernetes/pagegen-vol.png" alt></p><p>边车(sidecar)容器pagegen每隔10秒生成一行信息追加到Volume上的index.html文件。另外emptyDir存储卷可以基于RAM创建tmpfs文件系统的存储卷，常用于缓存，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache</span></span><br><span class="line">  <span class="attr">emptyDir:</span></span><br><span class="line"> <span class="attr">medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure><ol start="4"><li>gitRepo</li></ol><p>gitRepo存储卷是emptyDir的实际应用，它看做是将一份Git仓储中的数据克隆(clone)到创建的空目录(emptyDir)，而后再创建容器并挂载该存储卷。</p><p>gitRepo存储卷自Kubernetes1.12开始已经废弃，所以这里不再陈述。</p><ol start="5"><li>hostPath</li></ol><p>hostPath运行挂载Node上的文件系统到Pod里面去。如果Pod需要使用Node上的文件，可以使用hostPath。因为它独立于Pod资源的生命周期，因而具有持久性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ikubernetes/filebeat:5.6.7-alpine</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">redis.kubernetes.io:6379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LOG_LEVEL</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">info</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><p>这类Pod资源通常受控于daemonset类型的Pod控制器，它运行于集群中的每个工作节点之上，负责收集工作节点上系统级的相关数据，因此使用hostPath存储卷。这里的filebeat应用架构中，通过Redis进行资源收集，这些收集的日志信息会发往ELK进行统计展示。</p><p>hostPath上如果是不受控于Daemonset的无状态应用，重新调度节点运行时，无法确保此前创建的文件或目录是否存在。因此，hostPath虽能持久化数据，但对调度器来说并不适用，这时需要用到独立于集群节点的持久化存储卷，即网络存储卷。</p><blockquote><p>网络存储卷，就是类似于NAS或SAN设备、分布式存储(GlusterFS、RBD)、云端存储(gcePersistentDisk、azureDisk、cinder和awsElasticBlockStore)以及构建在各类存储系统之上的抽象管理层(flocker、portworx Volume和vsphere Volume)等这类网络服务存储。</p></blockquote><ol start="6"><li>NFS</li></ol><p>NFS，即Network File System，网络文件系统。Kubernetes中通过简单配置可以挂在NFS到Pod中，而NFS中的数据是可以永久保存的，同时NFS支持同时写操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:4-alpine</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redisport</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redisdata</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redisdata</span></span><br><span class="line">      <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/data/redis</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">nfs.kubernetes.io</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>RBD</li></ol><p>Ceph RBD<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是一个分布式、弹性可扩展的、高可靠的、性能优异的存储系统平台。要配置Pod资源使用RBD存储卷，前提条件要满足：</p><ul><li>Ceph RBD存储集群，</li><li>Ceph RBD集群中创建有满足Pod资源数据用到的存储image</li><li>Kubernetes集群内各个节点需要安装Ceph客户端程序包(ceph-common)</li></ul><p>它的字段信息有，</p><ul><li><code>monitors&lt;[]string&gt;</code>：Ceph存储监视器，逗号分隔的字符串列表；必选字段</li><li><code>image&lt;string&gt;</code>：rados image的名称，必选字段</li><li><code>pool&lt;string&gt;</code>：rados存储池名称，默认为RBD</li><li><code>user&lt;string&gt;</code>：rados用户名，默认为admin</li><li><code>keyring&lt;string&gt;</code>：RBD用户认证时使用的keyring文件路径，默认为<code>/etc/ceph/keyring</code></li><li><code>secretRef&lt;Object&gt;</code>：RBD用户认证时使用的保存有相应认证信息的Secret对象，会覆盖由keyring字段提供的密钥信息</li><li><code>readOnly&lt;boolean&gt;</code>：是否以只读的方式进行访问</li><li><code>fsType</code>：要挂载的存储卷的文件系统类型，至少应该是节点操作系统支持的文件系统，如ext4、xfs、ntf等，默认为ext4</li></ul><p>下面是使用RBD存储卷的Pod资源示例，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ceph-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;kubernetes.io/rbd&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">QVFENnNsNWMrQm52T2hBQXVYclJVeVNuUzBhOXVUVk00WnpiVFE9PQ==</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ceph-rbd</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">monitors:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.32</span><span class="string">,192.168.50.33,192.168.50.34</span></span><br><span class="line">  <span class="attr">adminId:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">adminSecretName:</span> <span class="string">ceph-secret</span></span><br><span class="line">  <span class="attr">pool:</span> <span class="string">kube</span></span><br><span class="line">  <span class="attr">userId:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">userSecretName:</span> <span class="string">ceph-secret</span></span><br><span class="line">  <span class="attr">fsType:</span> <span class="string">xfs</span></span><br><span class="line">  <span class="attr">imageFormat:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">  <span class="attr">imageFeatures:</span> <span class="string">&quot;layering&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:4-alpine</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redisport</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redis-rbd-vol</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-rbd-vol</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">ceph-claim</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ceph-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOne</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure><p>该示例依赖于事先存在的一个Ceph存储集群，这里假设其监视器的地址为192.168.50.32、192.168.50.33、192.168.50.34三个主机，并且集群上的存储池kube中存在创建好的映像Redis，此映像拥有xfs文件系统。Ceph客户端访问集群时需要事先完成认证之后才能进行后续访问操作，认证信息保存于名为ceph-secret的Secret资源对象中。</p><p>更多关于reph的配置方式，参考<a href="https://jimmysong.io/kubernetes-handbook/practice/using-ceph-for-persistent-storage.html">这里</a>。</p><ol start="8"><li>GlusterFS 存储卷</li></ol><p>GlusterFS(Gluster File System)是一个开源的分布式文件系统，是水平扩展存储解决方案Gluster的核心，具有强大的横向扩展能力，GlusterFS通过扩展能够支持数PB存储容量和处理数千客户端。要配置Pod资源使用GlusterFS存储卷，需要事先满足以下前提条件。</p><ul><li>存在某个可用集群，</li><li>在GlusterFS集群创建了Pod需要使用的Volume，</li><li>Kubernetes集群各个节点安装GlusterFS客户端程序包(glusterfs和glusterfs-fuse),</li></ul><p>Pod定义GlusterFS类型Volume，包含的字段有，</p><ul><li><code>endpoint&lt;string&gt;</code>：访问入口，必选字段，</li><li><code>path&lt;string&gt;</code>：用到GlusterFS集群的卷路径，</li><li><code>readOnly&lt;boolean&gt;</code>：是否为只读卷，</li></ul><p>下面是一个定义在vol-glusterfs.yaml配置文件中的Pod资源示例，它使用了GlusterFS存储卷持久保存应用数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-glusterfs-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">vol-glusterfs-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redisport</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">redisdata</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redisdata</span></span><br><span class="line">      <span class="attr">glusterfs:</span></span><br><span class="line">        <span class="attr">endpoints:</span> <span class="string">glusterfs-endpoints</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">kube-redis</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>另外创建Endpoints资源glusterfs-endpoints，以用于Pod资源访问，</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/">Ceph集群安装</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 设计理念及主要概念之Service(三)</title>
      <link href="/2019/02/06/kubernetes/kubernetes-03-theory-and-concpetion-md/"/>
      <url>/2019/02/06/kubernetes/kubernetes-03-theory-and-concpetion-md/</url>
      
        <content type="html"><![CDATA[<h2><span id="服务发现与负载均衡">服务发现与负载均衡</span></h2><p>Kubernetes提供有服务发现和负载均衡机制，提供了Service资源，并通过kube-proxy配合cloud provider来适应不同的应用场景。</p><p>目前，Kubernetes中的负载均衡大致可以分为以下几种机制，每种机制都有其特定的应用场景：</p><ul><li>Service：直接用Service提供cluster内部的负载均衡，并借助cloud provider提供的LB提供外部访问</li><li>Ingress Controller：还是用Service提供cluster内部的负载均衡，但是通过自定义LB提供外部访问</li><li>Service Load Balancer：把load balancer直接跑在容器中，实现Bare Metal的Service Load Balancer</li><li>Custom Load Balancer：自定义负载均衡，并替代kube-proxy，一般在物理部署Kubernetes时使用，方便接入公司已有的外部服务</li></ul><span id="more"></span><h2><span id="service">Service</span></h2><p><img src="/img/kubernetes/service.svg" alt="service"></p><p>Kubernetes设计了Service的抽象：逻辑上的一组Pod，一种可以访问它们的策略。这一组Pod能够被Service访问，并为它们提供一个统一的入口。通常是通过Label Selector实现的。借助Service，应用可以方便的实现服务发现与负载均衡，实现应用的零宕机升级。</p><p>Service通过标签选取服务后端，一般配合Replication Controller或者Deployment来保证后端容器的正常运行。这些匹配标签的Pod IP和端口列表组成endpoints，由kube-proxy负责将服务IP负载均衡到这些endpoints上。</p><p>Service由四种类型：</p><ul><li>ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li><li>NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过<code>&lt;NodeIP&gt;:NodePort</code>来访问该服务</li><li>LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到<code>&lt;NodeIP&gt;:NodePort</code></li><li>ExternalName：将服务通过DNS CNAME记录方式转发到指定的域名(通过<code>spec.externalName</code>设定)。需要kube-dns版本在1.7以上。</li></ul><p>另外，也可以将已有的服务以Service的形式加入到Kubernetes集群中来，只需要在创建Service的时候不指定Label selector，而是在Service创建好后手动为其添加endpoint。</p><ol><li>Service定义</li></ol><p>通过yaml或json定义，比如下面定义一个名为nginx的服务，将服务的80端口转发到default namespace中带有标签<code>run=nginx</code>的Pod的80端口，</p><p>在此之前，首先要部署Pod，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>其次再定义Service，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure><p>Service自动分配了Cluster IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> kubectl get service nginx-app       </span><br><span class="line">NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">nginx-app   ClusterIP   10.108.166.254   &lt;none&gt;        80/TCP    22s</span><br></pre></td></tr></table></figure><p>自动创建的endpoint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints nginx-app</span><br><span class="line">NAME        ENDPOINTS                       AGE</span><br><span class="line">nginx-app   10.244.1.38:80,10.244.3.28:80   82s</span><br></pre></td></tr></table></figure><p>自动关联endpoint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe service nginx-app  </span><br><span class="line">Name:              nginx-app</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            run=nginx-app</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          run=nginx-app</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.108.166.254</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.38:80,10.244.3.28:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不指定Selectors服务</li></ol><p>在创建Service的时候，也可以不指定Selectors，用来将Service转发到Kubernetes集群外部的服务(而不是Pod)。目前有两种方法</p><p>一是， 自定义endpoint，即创建同名的service和endpoint，在endpoint中设置外部服务的IP和端口</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><p>二是，通过DNS转发，在Service定义中指定externalName。此时DNS服务会给<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>创建一个CNAME记录，其值为<code>my.database.example.com</code>。并且，该服务不会自动分配Cluster IP，需要通过Service的DNS来访问(这种服务也称为Headless Service)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Headless服务</li></ol><p>Headless服务即不需要Cluster IP的服务，即在创建Service的时候，指定<code>spec.clusterIP=None</code>，包括两种类型，</p><ul><li>不指定Selectors，但设置externalName，通过CNAME记录处理</li><li>指定Selectors，通过DNS A记录设置后端endpoint列表</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp-80-80-3b6tl</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>查询构建的nginx服务，可以看到Cluster IP是None</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service --all-namespaces=<span class="literal">true</span></span><br><span class="line">NAMESPACE     NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">default       kubernetes             ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP         36h</span><br><span class="line">default       nginx-app              ClusterIP   None            &lt;none&gt;        80/TCP          43s</span><br><span class="line">kube-system   kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP   36h</span><br><span class="line">kube-system   kubernetes-dashboard   NodePort    10.96.197.202   &lt;none&gt;        443:31234/TCP   27h</span><br></pre></td></tr></table></figure><p>查询部署的Pod信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> kubectl get pods -n default -o wide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE    IP            NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-app-7d77b84f86-rsmrp   1/1     Running   0          2m1s   10.244.3.30   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-app-7d77b84f86-snx4p   1/1     Running   0          2m1s   10.244.2.19   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @10.96.0.10 nginx-app.default.svc.cluster.local</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/dig-nginx.png" alt="dig-nginx"></p><p>这类Headless Service资源，一般通过Ingress Controller进行负载，</p><ol start="4"><li>服务暴露</li></ol><p>Service的IP地址仅在集群内可达，然而有些服务需要暴露外部网络。此时需要在集群边缘为其添加一层转发机制，以实现将外部请求流量接入到集群Service资源上，</p><p>Kubernetes的Service共有四种类型， ClusterIP、NodePort、LoadBalancer和ExternalName：</p><ul><li>ClusterIP Service：使用iptables模式，集群内部的源IP会保留(不做SNAT)。如果client和server pod在同一个Node上，那源IP就是client pod的IP地址；如果在不同的Node上，源IP则取决于网络插件是如何处理的，比如使用flannel时，源IP是node flannel IP地址。</li><li>NodePort Service：源IP会做SNAT，server pod看到的源IP是Node IP。为了避免这种情况，可以给service加上annotation <code>service.beta.kubernetes.io/external-traffic=OnlyLocal</code>，让service只代理本地endpoint的请求(如果没有本地endpoint则直接丢包)，从而保留源IP。</li><li>LoadBalancer Service：源IP会做SNAT，server pod看到的源IP是Node IP。在GKE/GCE中，添加annotation <code>service.beta.kubernetes.io/external-traffic=OnlyLocal</code>后可以自动从负载均衡器中删除没有本地endpoint的Node。</li><li>ExternalName：主机名被DNS服务解析至CNAME类型的记录。它并不是由Kubernetes集群提供的服务，而是把集群外部的某服务以DNS CNAME记录的方式映射到集群。因此这种类型的Service没有ClusterIP、NodePort、label、也不会有endpoint。</li></ul><blockquote><p>为了减缓IP地址空间枯竭问题，NAT被引入提出，主要有两种方式，</p></blockquote><blockquote><p>SNAT，源地址转换，Source Network Address Translation，在NAT路由中，将ipv4的源地址转换为公网可访问的IP<br>DNAT，目标地址转换，Destination Network Address Translation，在NAT路由中，将ipv4的目标地址转换为私有网络的可访问IP</p></blockquote><ol start="5"><li>Ingress Controller</li></ol><p>Service虽然解决了服务发现和负载均衡的问题，但它在使用上还是有一些限制，比如</p><ul><li>只支持4层负载均衡，没有7层功能</li><li>对外访问的时候，NodePort类型需要在外部搭建额外的负载均衡，而LoadBalancer要求Kubernetes必须跑在支持的cloud provider上面</li></ul><p>Ingress就是为了解决这些限制而引入的新资源，主要用来将服务暴露到cluster外面，并且可以自定义服务的访问策略。比如想要通过负载均衡器实现不同子域名到不同服务的访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com --|                |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132 |</span><br><span class="line">bar.foo.com --|                |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></figure><p>可以这样来定义Ingress：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/nginx</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-app</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>注意Ingress本身并不会自动创建负载均衡器，cluster中需要运行一个ingress controller来根据Ingress的定义来管理负载均衡器。目前设计提供了nginx和gce的参考实现。</p><p>Kubernetes中，Service资源和Pod资源的IP地址仅能用于集群网络内部的通信，所有的网络流量都无法穿透边界路由器(Edge Router)以实现集群内外通信。即使Service中使用NodePort或LoadBalancer通过节点引入外部流量，它依然是4层流量转发，可用的负载均衡器也为传输层负载均衡机制。</p><p>Ingress是Kubernetes API的标准资源类型之一，Ingress控制器可以由任何具有反向代理(HTTP/HTTPS)功能的服务程序实现，例如Nginx、Envoy、HAProxy、Vulcand和Traefik等。</p><p>Traefik提供了易用的Ingress Controller，使用方法见<a href="https://docs.traefik.io/user-guide/kubernetes/">https://docs.traefik.io/user-guide/kubernetes/</a>。</p><p>不管怎样，你都需要先安装Ingress Controller，</p><p>首先确保nginx-ingress是否部署，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br><span class="line">NAME               REVISIONUPDATED                 STATUS  CHART              APP VERSIONNAMESPACE</span><br><span class="line">rolling-rattlesnake1       Wed Feb  6 05:09:06 2019DEPLOYEDnginx-ingress-0.9.50.10.2     default  </span><br></pre></td></tr></table></figure><p>如果没有安装，部署一份，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br></pre></td></tr></table></figure><p>另外还需要手动创建一份Service为其创建相关的NodePort或LoadBalancer，并明确指定端口和IP地址，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30443</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.99</span><span class="number">.99</span><span class="number">.99</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>这是因为Ingress规则需要由一个Service资源对象辅助识别相关的所有Pod对象，但ingress-nginx控制器可经由<code>host</code>规则的定义直接将流量调度，</p><p>下面动手实践一下，部署两份Ingress，负载到这个nginx-ingress-controller下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deploy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">testing</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.kubernetes.io</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">tomcat-svc</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.kubernetes.io</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">nginx-app</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/ingress-controller-service.png" alt></p><p>通常情况下，servcie和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其它地方。从概念上讲，可能是，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internet</span><br><span class="line">      |</span><br><span class="line">------------</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>Ingress是授权入站连接到达集群服务的规则集合，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>Ingress控制器自身也是运行于集群中的Pod资源对象，它与被代理的运行为Pod资源的应用运行在同一网络中，</p><p><img src="/img/kubernetes/ingress-controller.svg" alt></p><p>在实际使用中，在集群之外应该存在一个用于调度用户请求至个节点上Ingress控制器相关的NodePort的负载均衡器。如果不具有LBaaS的使用条件，用户也可以基于Nginx、Haproxy、LVS等手动构建，并通过Keepalived等解决方案实现其服务的高可用配置。</p><p><img src="/img/kubernetes/nginx-lb.png" alt="nginx-lb"></p><ol start="6"><li>Service Load Balancer</li></ol><p>在Ingress出现以前，Service Load Blancer是推荐的解决Service局限性的方式。Service Load Balancer将haproxy跑在容器中，并监控service和endpoint的变化，通过容器IP对外提供4层和7层负载均衡服务。</p><p>社区提供的Service Load Balancer支持四种负载均衡协议：TCP、HTTP、HTTPS和SSL TERMINATION，并支持ACL访问控制。</p><ol start="7"><li>Custom Load Balancer</li></ol><p>虽然Kubernetes提供了丰富的负载均衡机制，但在实际使用的时候，还是会碰到一些复杂的场景是它不能支持的，比如</p><ul><li>接入已有的负载均衡设备</li><li>多租户网络情况下，容器网络和主机网络是隔离的，这样<code>kube-proxy</code>就不能正常工作</li></ul><p>这个时候可以自定义组件，并代替kube-proxy来做负载均衡。基本的思路是监控Kubernetes中Service和endpoint的变化，并根据这些变化来配置负载均衡器。比如weave flux、nginx plus、kube2haproxy等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 设计理念及主要概念之Pod(二)</title>
      <link href="/2019/02/04/kubernetes/kubernetes-02-theory-and-concpetion-md/"/>
      <url>/2019/02/04/kubernetes/kubernetes-02-theory-and-concpetion-md/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群时配置Kubernetes的所有组件、功能和工作负载的物理平台。集群中一台服务器(或高可用部署中的一组服务器)作为Master，负责管理整个集群，其余作为Worker Node，集群中的主机可以是物理服务器，也可以是虚拟机(包括云VPS)。</p><span id="more"></span><h2><span id="集群概念">集群概念</span></h2><ol><li>Master节点</li></ol><p>Master是集群的网关和中枢，负责为用户和客户端暴露API、状态信息、管理和调度负责，以及编排其它组件之间的通信等任务。单个Master节点可以完成所有功能，实际生产环境由于负载均衡等目的，需要协同部署多个Master节点。</p><ol start="2"><li>Node节点</li></ol><p>Node节点属于Worker节点，由多个主机构建。Worker节点不暴露任何信息，不对外开发接口。</p><h2><span id="主要概念">主要概念</span></h2><p>Kubernetes由很多技术概念，同时对应很多API对象，API对象是k8s集群中的管理操作单元。</p><p>每个API对象都有3大类属性：元数据metadat、规范spec和状态status。元数据是用来表示API对象的，每个对象至少有3个元数据：namespace、name和uid；除此之外还有各种各样的标签label是用来标识和匹配不同的对象。规范spec描述了用户期望k8s集群中的分布式系统达到的理想状态(desired State)，状态status描述了系统实际当前达到的状态(Status)。</p><p>k8s中的API对象设计理念之一，是所有操作都是声明式的(Declarative)。所以你会发现会有很多yaml配置。声明式操作在分布式系统中的好处是稳定，不怕丢失操作或运行多次。</p><p>下面简述一些常见的API对象。</p><h2><span id="pod">Pod</span></h2><p>Pod是k8s的最小调度单元，同一个Pod中的容器共享网络名称空间和存储资源，这些容器可经本地回环节口lo直接通信，但彼此又在Mount、User及PID等名称空间上保持隔离。</p><p>特性：</p><ul><li>包含多个共享IPC、Network和UTC namespace的容器，可直接本地通信</li><li>所有Pod内容器都可以访问共享的Volume，可以访问共享数据</li><li>Pod一旦调度后就跟Node绑定，即使Node挂掉也不会重新调度，推荐使用Deployments、Daemonsets等控制器来容错</li><li>优雅终止：Pod删除的时候先给其内的进程发送SIGTERM，等待一段时间(grace period)后才强制停止运行的进程</li><li>特权容器(通过SecurityContext配置)具有改变系统配置的权限</li></ul><p><img src="/img/kubernetes/module_03_pods.svg" alt="Pod"></p><p>通过yaml或接送描述Pod和其内Container的运行环境以及期望状态，比如一个最简单的nginx pod可以定义为，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">sepc:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>volume可以为容器提供持久化存储，比如，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-storage</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/data/redis</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-storage</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>重启机制，RestartPolicy</p><p>目前支持三种RestartPolicy</p><ul><li>Always: 只要退出就重启</li><li>OnFailure: 失败退出时重启</li><li>Never: 只要退出就不再重启</li></ul><p>这里的重启指在Pod所在Node本地重启，它不会调度到其它Node上去。</p><p>环境变量为容器提供了一些重要的资源，包括容器和Pod的基本信息以及集群中服务的信息等，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gcr.io/google_containers/busybox</span></span><br><span class="line"><span class="attr">command:</span> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line"><span class="attr">args:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">env</span></span><br><span class="line"><span class="attr">resource:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">&quot;32Mi&quot;</span></span><br><span class="line"><span class="attr">cpu:</span> <span class="string">&quot;125m&quot;</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line"><span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_NODE_NAME</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">sepc.nodeName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAME</span></span><br><span class="line">  <span class="attr">valueFrom:</span></span><br><span class="line">    <span class="attr">fieldRef:</span></span><br><span class="line">  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAMESPACE</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_SERVICE_ACCOUNT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">spec.serviceAccountName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_REQUEST</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line"><span class="attr">resourceFieldRef:</span></span><br><span class="line">  <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_LIMIT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_REQUEST</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_LIMIT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p>ImagePullPolicy策略，</p><ul><li>Always: 不管镜像是否存在都会进行一次拉取。</li><li>Never：不管镜像是否存在都不会进行拉取。</li><li>IfNotPresent: 镜像不存在时，才进行拉取。</li></ul><p>注意，</p><ul><li>默认为IfNotPresent，但<code>:latest</code>标签的镜像默认为<code>Always</code>。</li><li>拉取镜像时docker会进行MD5校验，如果镜像中的MD5没变，不会拉取镜像数据。</li><li>生产环境中应该尽量避免使用<code>:latest</code>标签，而开发环境可以借助<code>:latest</code>标签自动拉取最新的镜像。</li></ul><p>访问DNS策略，</p><p>通过设置dnsPolicy参数，设置Pod中容器访问DNS的策略</p><ul><li>ClusterFirst: 优先基于cluster domain后缀，通过kube-dns查询</li><li>Default：首先从kubelet中配置的DNS查询</li></ul><p>默认是ClusterFirst</p><p>通过hostIPC设置参数为Ture，使用主机的IPC明明空间，默认为False。</p><p>通过hostNetwork设置参数为True，使用主机的命名空间，默认为False。</p><p>通过hostPID设置参数为True，使用主机的PID命名空间，默认为False。</p><p>通过subdomain参数设置Pod的子域名，默认为空</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">busybox2</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">busybox-2</span></span><br><span class="line"><span class="attr">subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;3600&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure><p>kubernetes通过cgroups限制容器的CPU和内存等计算资源，包括requests和limits等：</p><ul><li><code>spec.containers[].resources.limits.cpu</code>：CPU上限，可以短暂超过，容器也不会被停止</li><li><code>spec.containers[].resources.limits.memory</code>：内存上限，不可以超过；如果超过，容器可能会被停止或调度到其它资源充足的机器上</li><li><code>spec.containers[].resources.requests.cpu</code>：CPU请求，可以超过</li><li><code>spec.containers[].resources.requests.memory</code>：内存请求，可以超过；但如果超过，容器可能会在Node内存不足时清理</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiServersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">&quot;300m&quot;</span></span><br><span class="line"><span class="attr">memory:</span> <span class="string">&quot;56Mi&quot;</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line"><span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br></pre></td></tr></table></figure><p>为了保证容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针(probe，支持exec、tcp和httpGet方式)来探测容器的状态：</p><ul><li>LivenessProbe：探测应用是否处于健康状态，如果不健康则删除重建容器</li><li>ReadinessProbe：探测应用是否启动完成并且处于正常服务状态，如果不正常则更新容器状态</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/ping</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>initContainers在容器执行前运行，常用来初始化容器操作，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">init-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busygox</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">wget</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;-O&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;/work-dir/index.html&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">http://kubernetes.io</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">&quot;/work-dir&quot;</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>容器生命周期钩子(Container Lifecycle Hooks)监听容器生命周期的特定事件，并在事件发生时执行已注册的回调函数。支持两种钩子：</p><ul><li>postStart：容器启动后执行，注意由于一步执行，它无法保证一定在ENTRYPOINT之后运行。如果失败，容器会被杀死，并根据RestartPolicy决定是否重启</li><li>preStop：容器停止前执行，常用于资源清理。如果失败，容器同样也会被杀死</li></ul><p>钩子的回调函数支持两种方式：</p><ul><li>exec: 在容器内执行命令</li><li>httpGet：向指定URL发起GET请求</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line">  <span class="attr">postStart:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</span><br><span class="line">  <span class="attr">preStop:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure><p>默认情况下，容器都是以非特权容器方式运行。比如，不能再容器中创建虚拟网卡、配置虚拟网络。</p><p>Kubernetes提供了修改Capabilities的机制，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">friendly-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;alpine:3.4&quot;</span></span><br><span class="line"><span class="attr">command:</span> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]</span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">capabilities:</span></span><br><span class="line">    <span class="attr">add:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line"><span class="attr">drop:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>可以通过给Pod增加 <code>kubernetes.io/ingressbandwidth</code> 和 <code>kubernetes.io/egress-bandwidth</code> 这两个annotation来限制Pod的网络带宽</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qos</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress-bandwidth:</span> <span class="string">3M</span></span><br><span class="line"><span class="attr">kubernetes.io/egress-bandwidth:</span> <span class="string">4M</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">iperf3</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">networkstatic/iperf3</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">iperf3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">-s</span></span><br></pre></td></tr></table></figure><p>可以通过nodeSelector、nodeAffinity、podAffinity以及Taints和tolerations等来讲Pod调度到需要的Node上。</p><p>也可以通过设置nodeName参数，将Pod调度到制定node节点上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>默认情况下，容器的<code>/etc/hosts</code>时kubelet自动生成的，并且仅包含localhost和podName等。不建议直接修改<code>/etc/hosts</code>文件，因为在Pod启动或重启时会被覆盖。</p><p>默认的<code>/etc/hosts</code>文件格式如下，其中<code>nginx-4217019353-fb2c5</code>是podName：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> nginx-app-5dd4f9fd4d-nm4sx -- cat /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/cat-etc-hosts.png" alt="executor"></p><p>从v1.7开始，可以通过<code>pod.Spec.HostAliases</code>来增加hosts内容，如，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hostaliases-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;foo.local&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;bar.local&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">&quot;10.1.2.3&quot;</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;foo.remote&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;bar.remote&quot;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-hosts</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;/etc/hosts&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs hostaliases-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes-managed hosts file.</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">fe00::0ip6-mcastprefix</span><br><span class="line">fe00::1ip6-allnodes</span><br><span class="line">fe00::2ip6-allrouters</span><br><span class="line">10.244.1.35hostaliases-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># Entries added by HostAliases.</span></span><br><span class="line">127.0.0.1foo.localbar.local</span><br><span class="line">10.1.2.3foo.remotebar.remote</span><br></pre></td></tr></table></figure><h2><span id="namespace">Namespace</span></h2><p>Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的pods，services，replication controller和deployments等都是属于某一个namespace的(默认是default)，而node，persistentVolumes等则不属于任何namespace。</p><p>Namespace常用来隔离不同的用户，比如Kubernetes自带的服务一般运行在<code>kube-system namespace</code>中。</p><ol><li>查询</li></ol><p>名称空间的选项可以用<code>--namespace</code>或<code>-n</code>来指定，不指定默认就是<code>default</code>。也可以通过<code>--all-namespace=true</code>来查看所有namespace下的资源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br><span class="line">NAME          STATUS   AGE</span><br><span class="line">default       Active   32h</span><br><span class="line">kube-public   Active   32h</span><br><span class="line">kube-system   Active   32h</span><br></pre></td></tr></table></figure><p>注意：<code>kubectl get namespace</code>等效；namespace包含两种状态“Active”和“Terminating”。在namespace删除过程中，namespace状态被设置成“Terminating”。</p><ol start="2"><li>创建</li></ol><p>命令行直接创建，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace new-namespace</span><br></pre></td></tr></table></figure><p>通过文件创建，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">new-namespace</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ./my-namespace.yaml</span><br></pre></td></tr></table></figure><p>注意：namespace的name满足正则表达式<code>[a-z0-9]([-a-z0-9]*[a-z0-9])?</code>，最大长度为63位，</p><ol start="3"><li>删除</li></ol><ul><li>删除一个namespace会自动删除所有属于该namespace的资源</li><li><code>default</code>和<code>kube-system</code>名称空间不可删除</li><li>PersistentVolumes是不属于任何namespace的，但PersistentVolumeClaim是属于某个特定namespace的</li><li>Events是否属于namespace取决于产生events的对象</li></ul><h2><span id="node">Node</span></h2><p>Node是Pod真正运行的主机，可以是物理机，也可以是虚拟机。为了管理Pod，每个Node节点上至少运行container runtime(比如docker或rkt)、<code>kubelet</code>和<code>kube-proxy</code>服务。</p><p><img src="/img/kubernetes/module_03_nodes.svg" alt="nodes"></p><ol><li>Node管理</li></ol><p>不像其它的资源(如Pod和Namespace)，Node本质上不是Kubernetes来创建的，Kubernetes只是管理Node上的资源。虽然可以通过Manifest创建一个Node对象(如下json)，但Kubernetes也只是去检查是否真的是有这么一个Node，如果检查失败，也不会往上调度Pod。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Node&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;10.240.79.157&quot;</span>,</span><br><span class="line"><span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-first-k8s-node&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个检查是由Node Controller来完成的。Node Controller负责</p><ul><li>维护Node状态</li><li>与Cloud Provider同步Node</li><li>给Node分配容器CIDR</li><li>删除带有<code>NoExecute</code> taint的Node上的Pods</li></ul><p>默认情况下，kubelet在启动时会向master注册自己，并创建Node资源。</p><ol start="2"><li>Node的状态</li></ol><p>每个Node都包括以下状态信息</p><ul><li>地址：包括hostname、外网IP和内网IP</li><li>条件(Condition)：包括OutOfDisk、Ready、MemoryPressure和DiskPressure</li><li>容量(Capacity)：Node上的可用资源，包括CPU、内存和Pod总数</li><li>基本信息(Info)：包括内核版本、容器引擎版本、OS类型等</li></ul><ol start="3"><li>Taints和tolerations</li></ol><p>Taints和tolerations用于保证Pod不被调度到不合适的Node上，Taint应用于Node上，而toleration则应用于Pod上(Toleration是可选的)。</p><p>比如，可以使用taint命令给node1添加taints：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br><span class="line">kubectl taint nodes node2 key1=value2:NoExecutte</span><br></pre></td></tr></table></figure><ol start="4"><li>Node维护模式</li></ol><p>标识Node为不可调度，但不影响其上正在运行的Pod，这种维护Node时时非常有用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon <span class="variable">$NODENAME</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 简介以及安装安装高可用v1.13.1集群(一)</title>
      <link href="/2019/02/03/kubernetes/kubernetes-01-centos-installation/"/>
      <url>/2019/02/03/kubernetes/kubernetes-01-centos-installation/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/kubernetes/kubernetes-kubectl-cheatsheet.png" alt="kubectl-cheatsheet"></p><p>Kubernetes是谷歌开源的容器集群管理系统，是Google多年大规模容器管理技术Borg的开源版本，也是CNCF最重要的项目之一，主要功能包括：</p><ul><li>基于容器的应用部署、维护和滚动升级</li><li>负载均衡和服务发现</li><li>跨机器和跨地区的集群调度</li><li>自动伸缩</li><li>无状态服务和有状态服务</li><li>广泛的Volumn支持</li><li>插件机制保证扩展性</li></ul><span id="more"></span><h2><span id="kubernetes架构">Kubernetes架构</span></h2><p>Kubernetes主要由以下几个核心组件组成：</p><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume(CVI)和网络(CNI)的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行(CRI)；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡</li></ul><h2><span id="kubeadm-113-安装高可用-kubernetes-v1131-集群">Kubeadm 1.13 安装高可用 kubernetes v1.13.1 集群</span></h2><p><img src="/img/kubernetes/dashboard.png" alt="kubernetes-dashboard"></p><p>先上图给个肯定信心。</p><h2><span id="部署">部署</span></h2><p>以CentOS7为基础，搭建一个Master主机和三个Node主机，各个Node主机的配置方式基本相同。</p><ul><li>OS: CentOS 7.5 x86_64</li><li>Container runtime: Docker 18.06.ce</li><li>Kubernetes: 1.13</li></ul><table><thead><tr><th style="text-align:left">IP 地址</th><th style="text-align:left">主机名</th><th style="text-align:left">角色</th></tr></thead><tbody><tr><td style="text-align:left">192.168.50.71</td><td style="text-align:left">master, <a href="http://master.kubernetes.io">master.kubernetes.io</a></td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.50.72</td><td style="text-align:left">node01, <a href="http://node01.kubernetes.io">node01.kubernetes.io</a></td><td style="text-align:left">node</td></tr><tr><td style="text-align:left">192.168.50.73</td><td style="text-align:left">node02, <a href="http://node02.kubernetes.io">node02.kubernetes.io</a></td><td style="text-align:left">node</td></tr><tr><td style="text-align:left">192.168.50.74</td><td style="text-align:left">node03, <a href="http://node03.kubernetes.io">node03.kubernetes.io</a></td><td style="text-align:left">node</td></tr></tbody></table><p>这里需要使用常规的域名格式，因为后面需要为集群配置Kubernetes Dashboard要求有SSL数字签名。</p><h2><span id="系统配置">系统配置</span></h2><p>配置host，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">192.168.50.71mastermaster.kubernetes.io</span><br><span class="line">192.168.50.72node1node01.kubernetes.io</span><br><span class="line">192.168.50.73node2node02.kubernetes.io</span><br><span class="line">192.168.50.74node3node03.kubernetes.io</span><br></pre></td></tr></table></figure><p>关闭防火墙，选择iptable加入端口或禁用防火墙服务两种方式。这里简单起见，禁用防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>禁用SELINUX，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo setenfore 0</span><br><span class="line">sudo vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>所有节点关闭交换分区，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line">sudo vi /etc/fstab</span><br></pre></td></tr></table></figure><p>将交换区注释掉，使用<code>free -m</code>查看交换分区是否关闭。</p><p>创建<code>/etc/sysctl.d/k8s.conf</code>文件，添加如下内容，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>执行命令使修改生效，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe br_netfilter</span><br><span class="line">sudo sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><p>kube-proxy开启ipvs，Kubernetes 1.11之后的版本默认支持使用ipvs代理模式的Service资源，但它依赖ipvs相关的内核模块，这些模块默认不会自动载入。kube-proxy开启ipvs的前提需要加载以下模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><p>创建<code>/etc/sysconfig/modules/ipvs.modules</code>文件，内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ipvs_mods_dir=<span class="string">&quot;/usr/lib/modules/<span class="subst">$(uname -r)</span>/kernel/net/netfilter/ipvs&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$ipvs_mods_dir</span> | grep -o <span class="string">&quot;^[^.]*&quot;</span>); <span class="keyword">do</span></span><br><span class="line">/sbin/modinfo -F filename <span class="variable">$i</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">/sbin/modprobe <span class="variable">$i</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>修改文件权限，并加载内核模块，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">sudo /etc/sysconfig/modules/ipvs.modules</span><br></pre></td></tr></table></figure><p>注意该步骤不是必须的，因为ipvs仅负责负载均衡相关任务，它无法完成kube-proxy中的包过滤机SNAT等功能，这些仍需要由iptables实现。也就是说，如果条件不满足，即使kube-proxy开启了ipvs模式，也会回退到iptables模式。</p><h2><span id="安装docker">安装Docker</span></h2><p>Docker的安装可以参考阿里云的docker-ce的安装方法，目前Kubernetes推荐的最新支持的docker版本为18.06，注意不要使用不兼容的版本。</p><p>如果你有阿里云账号，可以参考<a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors">镜像加速器</a>方法。</p><p>另外，如果想通过外网访问Docker，可以在Systemd加入启动参数配置sock进行访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>其它细节可以参考阿里docker相关文档。</p><h2><span id="配置外网访问ss">配置外网访问SS</span></h2><p>首先，你得先有一个SS，<a href="http://xn--k8s-628d2hjq96ozubb9tvvf3u9geh9blx1ac9a.gcr.io">因为大陆内目前访问不了k8s.gcr.io</a>。虽然有人做了镜像同步，对同步的镜像进行retag也是可行的方式，但我有SS！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-pip epel-release -y</span><br><span class="line">sudo pip install shadowsocks</span><br><span class="line">cat &gt; /etc/shadowsocks.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;server&quot;:&quot;xx.xx.xx.xx&quot;,</span></span><br><span class="line"><span class="string">&quot;server_port&quot;: 443,</span></span><br><span class="line"><span class="string">&quot;local_port&quot;: 1080,</span></span><br><span class="line"><span class="string">&quot;password&quot;:&quot;xxx&quot;,</span></span><br><span class="line"><span class="string">&quot;timeout&quot;:600,</span></span><br><span class="line"><span class="string">&quot;method&quot;:&quot;aes-256-cfb&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sslocal -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure><p>SS主要是配给Docker用的，编辑<code>/lib/systemd/system/docker.service</code>文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Environment=<span class="string">&quot;HTTP_PROXY=socks5://127.0.0.1:1080/&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;HTTPS_PROXY=socks5://127.0.0.1:1080/&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;NO_PROXY=localhost,127.0.0.0/8,guqcep47.mirror.aliyuncs.com&quot;</span></span><br></pre></td></tr></table></figure><h2><span id="kubeletkubeadmkubectl安装">kubelet，kubeadm，kubectl安装</span></h2><p>首先要设定组件的仓储，编辑<code>/etc/yum.repos.d/kubernetes.repo</code>，内容如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure><p>执行如下命令安装程序包，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><p>kubernetes自1.8版本开始，强制要求关闭系统swap，编辑kubelet配置文件<code>/etc/sysconfig/kubelet</code>，忽略禁止使用Swap限制，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=<span class="string">&quot;--fail-swap-on=false&quot;</span></span><br></pre></td></tr></table></figure><p>加入启动服务，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start kubelet</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure><h2><span id="集群初始化">集群初始化</span></h2><p>集群初始化动作需要在Master进行，然后在其它Node节点使用<code>join</code>加入，所以这里的命令行需要在各个主机单独敲命令了。</p><p>有两种初始化方式，一种是命令带参数方式；另一种是使用配置文件，两种方式是等效的，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --kubernetes-version=v1.13.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --apiserver-advertise-address=0.0.0.0 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>简单说一下这几个重要的参数，</p><ul><li><code>--kubernetes-version</code>：Kubernete的版本</li><li><code>--pod-network-cidr</code>：Pod网络地址范围，其值为CIDR格式的网络地址；使用flannel网络插件是，默认地址为10.244.0.0/16。</li><li><code>--service-cidr</code>：Service的网络地址范围，其值为CIDR格式的网络地址，默认地址为10.96.0.0/12。</li><li><code>--apiserver-advertise-address</code>：API server通告给其他组件的IP地址，一般应该为Master节点的IP地址，0.0.0.0表示节点上的所有可用地址。</li><li><code>--ignore-preflight-errors</code>：忽略哪些运行时的错误信息，其值为Swap时，表示忽略因swap未关闭而导致的错误。</li></ul><p>一般情况下，都是使用配置文件的方式，可以通过下面的命令查看一份完整的kubeadm配置示例，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm config <span class="built_in">print</span> init-defaults --component-configs KubeProxyConfiguration</span><br></pre></td></tr></table></figure><p>存储输出的内容为<code>kubeadm-config.yaml</code>，根据自己需求修改，执行命令初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --config kubeadm-config.yaml --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>初始化如果成功，会打印两个重要信息，一是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOEM</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>照着写便是，默认情况下kubectl会从当前用户主目录的.kube下的config读取配置信息，包括Kubernetes集群、证书或令牌等。集群初始化时，kubeadm会自动生成一个用于此类功能的配置文件<code>/etc/kubernetes/admin.conf</code>，将它复制为<code>$HOME/.kube/config</code>文件即可直接使用。</p><p>kubectl有非常多的子命令，其中“<code>get compontsstatuses</code>”可显示集群组件当前的状态，简写为<code>get cs</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok                   </span><br><span class="line">scheduler            Healthy   ok                   </span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">&quot;health&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若命令结果的STATUS字段为“Healthy”，表示组件处于健康运行状态，否则需要检查其错误所在，必要时使用“kubeadm reset”命令重置重新进行初始化。</p><p>另外使用<code>kubectl get nodes</code>，获取集群节点的相关状态信息，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   NotReady master   7d5h   v1.13.2</span><br></pre></td></tr></table></figure><p>为Kubernetes提供的Pod网络插件非常多，目前流行的有flannel和Calico。flannel运行为Kubernetes集群的附件，它以Pod的形式部署运行与每个集群节点上以接受Kubernetes集群管理。事实上，flannel也可以以守护进程方式运行在各个节点，即以非托管的方式运行。部署命令使<code>kubectl apply</code>或<code>kubectl crreate</code>，下面是使用在线的方式进行flannel部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>部署成功会出现created字样，配置flannel网络插件时，Master节点上的Docker首先会去获取flannel镜像文件，而后根据镜像文件启动相应的Pod对象。现在再次查看Master已经变为“Ready”状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   Ready    master   7d5h   v1.13.2</span><br></pre></td></tr></table></figure><p>可通过，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system | grep flannel</span><br></pre></td></tr></table></figure><p>显示网络插件flannel的Pod状态情况。</p><p>集群初始化时，另一个信息是产生一段token信息，这段信息用于Node节点加入Master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join kubernetes-master:6443 --token 0qpyy8.iv5v2uhhrjy3wsri --discovery-token-ca-cert-hash sha256:c8ad1e333b6e2e1185ea2ab7beb97b90022f8285e79a1cc6a7e71ad772748f42 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>每个节点加入到Master之后，再次通过<code>kubectl get nodes</code>查看节点信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   Ready    master   7d5h   v1.13.2</span><br><span class="line">kubernetes-node1    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br><span class="line">kubernetes-node2    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br><span class="line">kubernetes-node3    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br></pre></td></tr></table></figure><p>至此，Kubernetes集群的部署已经完成，后续有更多节点加入时，均可使用此方式。</p><p>Kubernetes的命令非常多，在文章最前面的大图已经描述清楚。由于这里仅介绍集群安装内容，下面简单了解下关于集群方面的命令，</p><p>获取集群信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.50.71:6443</span><br><span class="line">KubeDNS is running at https://192.168.50.71:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use <span class="string">&#x27;kubectl cluster-info dump&#x27;</span>.</span><br></pre></td></tr></table></figure><p>版本信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl version --short=<span class="literal">true</span></span><br><span class="line">Client Version: v1.13.2</span><br><span class="line">Server Version: v1.13.2</span><br></pre></td></tr></table></figure><p>移除节点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain NODE_ID --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node NODE_ID</span><br></pre></td></tr></table></figure><p>重置节点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2><span id="部署高可用coredns">部署高可用CoreDNS</span></h2><p>默认安装的CoreDNS存在单点问题。在Master节点查看<code>kubectl get pods -n kube-system -owide</code>分布如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide </span><br><span class="line">NAME                                           READY   STATUS              RESTARTS   AGE   IP              NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-86c58d9df4-6j2m6                       0/1     ContainerCreating   0          90m   &lt;none&gt;          master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-86c58d9df4-glvnp                       0/1     ContainerCreating   0          90m   &lt;none&gt;          master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-master.kubernetes.io                      1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-master.kubernetes.io            1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-master.kubernetes.io   1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-czh7z                    1/1     Running             0          80m   192.168.50.73   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-gcqkk                    1/1     Running             0          80m   192.168.50.74   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-lk5dw                    1/1     Running             0          81m   192.168.50.72   node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-xp5xf                    0/1     PodInitializing     0          83m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-b82sn                               1/1     Running             0          80m   192.168.50.73   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-ql6hp                               1/1     Running             0          81m   192.168.50.72   node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-sh87s                               1/1     Running             0          80m   192.168.50.74   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-w2kv4                               0/1     ContainerCreating   0          90m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-master.kubernetes.io            1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>删除原来的单点CoreDNS，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deploy coredns -n kube-system</span><br></pre></td></tr></table></figure><p>创建一份多实例配置coredns-ha.yaml，内容如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment">#集群规模可自行配置</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">podAffinityTerm:</span></span><br><span class="line">              <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">k8s-app</span></span><br><span class="line">                  <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                  <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">kube-dns</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-conf</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/coredns/Corefile</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.2.6</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9153</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">170Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">70Mi</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">            <span class="attr">drop:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">all</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/coredns</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">serviceAccount:</span> <span class="string">coredns</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">coredns</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">CriticalAddonsOnly</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">Corefile</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">Corefile</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">config-volume</span></span><br></pre></td></tr></table></figure><p>执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f coredns-ha.yaml</span><br></pre></td></tr></table></figure><p>再次查看分布，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE    IP              NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-6c67f849c7-jhqhj                       1/1     Running   0          3m6s   10.244.1.3      node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-6c67f849c7-kxtkw                       1/1     Running   0          3m6s   10.244.3.4      node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-master.kubernetes.io                      1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-master.kubernetes.io            1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-master.kubernetes.io   1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>CoreDNS的Pod落在节点node1和node3上了。</p><h2><span id="安装dashboard">安装dashboard</span></h2><p>Kubernetes dashboard的安装也是在pod上的，所以要在所有节点执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br></pre></td></tr></table></figure><p>下载官方推荐的部署文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p>因为前面我已经将镜像拉取下来了，所以不必要再拉取，修改这个<code>kubernetes-dashboard.yaml</code>文件，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="string">name</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>另外，需要暴露端口以给集群外部访问，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------------------- Dashboard Service ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31234</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>OK，执行命令部署pod，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p>查看一下dashboard的pod是否正常启动，如果正常，说明安装成功，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/kube-system.png" alt="kube-system"></p><p>查看外网暴露的端口，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services -n kube-system                                                                        </span><br><span class="line">NAME                   TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10     &lt;none&gt;        53/UDP,53/TCP   7d5h</span><br><span class="line">kubernetes-dashboard   NodePort    10.104.42.80   &lt;none&gt;        443:31234/TCP   138m</span><br></pre></td></tr></table></figure><p>默认情况下，kubeadm创建集群时已经创建了admin角色，我们直接绑定即可，</p><p>创建一个<code>admin-user-role-binding.yaml</code>文件，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br></pre></td></tr></table></figure><p>执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f admin-user-role-binding.yaml</span><br></pre></td></tr></table></figure><p>获取token，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把Token复制的登录界面，即可。</p><p>这里登录时有个问题，就是HTTPS访问没有证书，chrome直接不让访问！Firefox还好可以绕过。所以需要自己加一个证书，</p><p>首先生成私钥和证书签名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;client-key-data&#x27;</span> ~/.kube/config | head -n 1 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | base64 -d &gt;&gt; dashboard.key</span><br><span class="line">grep <span class="string">&#x27;client-certificate-data&#x27;</span> ~/.kube/config | head -n 1 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | base64 -d &gt;&gt; dashboard.crt</span><br></pre></td></tr></table></figure><p>生成证书，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -inkey dashboard.key -<span class="keyword">in</span> dashboard.crt -out dashboard.p12 -name <span class="string">&quot;kubernetes-client&quot;</span></span><br></pre></td></tr></table></figure><p>将生成的<code>dashboard.key</code>和<code>dashboard.crt</code>放置在路径<code>/certs</code>下， 重新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br><span class="line">kubectl create -f admin-user-role-binding.yaml</span><br></pre></td></tr></table></figure><p>虽然添加了证书，但也仅能通过firefox添加例外访问，chrome根本不信任你。所以生产环境上还是要买一个SSL证书，另外Pod内的service最好也不要直接暴露给外网访问，一般用nginx-ingress做个代理。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">你可能需要安装额外的工具用于Kubernetes管理，参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-software-on-kubernetes-clusters-with-the-helm-package-manager">这里</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 安装、配置、使用PostgreSQL及PostGIS</title>
      <link href="/2019/01/24/postgresql/postgresql-relational-databases-on-centos-7/"/>
      <url>/2019/01/24/postgresql/postgresql-relational-databases-on-centos-7/</url>
      
        <content type="html"><![CDATA[<p>实际开发过程有两种安装方式，一种是编译安装；一种是包安装方式。编译安装需要cmake，gcc以及编译所需要的各种devel，这里仅介绍包安装方式。</p><span id="more"></span><h2><span id="从centos仓储安装">从CentOS仓储安装</span></h2><p>CentOS 7仓储装载有PostgreSQL版本<code>9.2.15</code>，你可以直接通过仓储安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postgresql-server postgresql-contrib</span><br></pre></td></tr></table></figure><p>初始化数据库，启动PostgreSQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo postgresql-setup initdb</span><br><span class="line">sudo systemctl start postgresql</span><br></pre></td></tr></table></figure><p>将PostgreSQL加入Systemd中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql</span><br></pre></td></tr></table></figure><h2><span id="指定仓库的版本">指定仓库的版本</span></h2><p>作为替代，你可以从Postgres仓储安装最新版本，目前CentOS7可用的最高PostgresSQL版本是<code>9.6.3</code>，但需要提供RPM-based的安装方式。</p><blockquote><p>注意：Postgres指定版本后，版本信息会包含在配置目录中。例如<code>/var/lib/pgsql</code>会变成<code>/var/lib/pgsql/9.6</code>。这对于system units也一样，<code>systemctl status postgresql</code>会变成<code>systemctl status postgresql-9.6</code>。</p></blockquote><p>首先需要从Postgres的<a href="https://yum.postgresql.org/repopackages.php">仓储</a>选择希望安装的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装RPM，以及<a href="https://fedoraproject.org/wiki/EPEL">EPEL</a>仓储，用于依赖构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install pgdg-centos96-9.6-3.noarch.rpm epel-release</span><br></pre></td></tr></table></figure><p>安装前需要update一下，不然会有conflict：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install postgresql96-server postgresql96-contrib</span><br></pre></td></tr></table></figure><p>初始化数据库，启动PostgreSQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class="line">sudo systemctl start postgresql-9.6</span><br></pre></td></tr></table></figure><p>加入boot自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql-9.6</span><br></pre></td></tr></table></figure><h2><span id="配置用户信息-数据库">配置用户信息、数据库</span></h2><p>默认地，PostgreSQL为Linux创建了一个无home目录的用户<code>postgres</code>，用于访问数据库软件目录。</p><blockquote><p>小心：<br>这个<code>postgres</code>用户不应该用于其它目的(例如，连接其它网络)。这样会给数据库安全带来风险。</p></blockquote><ol><li>更改<code>postgres</code>密码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd postgres</span><br></pre></td></tr></table></figure><p>下面方式是更改<code>postgres</code>数据库用户密码。确保使用的<code>newpassword</code>是强类型密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">psql -d template1 -c <span class="string">&quot;ALTER USER postgres WITH PASSWORD &#x27;newpassword&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>postgres</code>用户不同于Linux的那个<code>postgres</code>用户。Linux的<code>postgres</code>是用于访问数据库，这个PostgreSQL用户是负责该数据库的管理任务处理。</p><p>上面设置的密码被用于通过网络访问数据库。本机方式使用的<code>peer</code>授权。本章最后介绍如何实现远程访问。</p><h2><span id="postgresql-shell">PostgreSQL Shell</span></h2><p>PostgreSQL client shell允许你在数据库处理SQL命令。首先登录<code>postgres</code>用户，进入shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres</span><br></pre></td></tr></table></figure><p>首先会登录<code>postgres</code>数据库，prompt信息类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql (9.2.15)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>最后一行，<code>postgres=#</code>标示了当前数据库的名称。要查看可用命令，输入<code>\h</code>。退出当前shell，输入<code>\q</code>。</p><h2><span id="数据库工作">数据库工作</span></h2><p>首先，你可以使用<code>createdb</code>命令创建数据库。例如以<code>postgres</code>用户身份创建一个<code>mytestdb</code>数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdb mytestdb</span><br></pre></td></tr></table></figure><p>也可以为该数据库指派角色关系。例如，指派一个<code>examplerole</code>角色：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdb mytestdb -O examplerole</span><br></pre></td></tr></table></figure><p><code>createdb</code>命令有几个操作选项，你可以在<a href="https://www.postgresql.org/docs/9.2/static/app-createdb.html">PostgreSQL documentation</a>查看更多细节。</p><p>连接数据库，可以使用<code>psql</code>命令指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql mytestdb</span><br></pre></td></tr></table></figure><p>出现下面prompt说明连接成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql (9.2.15)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">mytestdb=<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>默认地，数据库的连接是作为<a href="https://www.linode.com/docs/databases/postgresql/how-to-install-postgresql-relational-databases-on-centos-7/#peer-authentication">peer-authenticated</a>用户的方式。当然，你也可以指定本地用户的方式访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql mytestdb -U examplerole</span><br></pre></td></tr></table></figure><p>要查看所有的数据库，使用<code>\l</code>或<code>\list</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \l</span></span><br><span class="line">                          List of databases</span><br><span class="line">Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line">mytestdb  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line">postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line">template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">|         |          |          |             | postgres=CTc/postgres</span><br><span class="line">template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">|         |          |          |             | postgres=CTc/postgres</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure><p>通过<code>\c</code>命令可以展示当前数据库和当前用户信息。要展示其它额外信息，可以使用<code>\conninfo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are connected to database <span class="string">&quot;mytestdb&quot;</span> as user <span class="string">&quot;postgres&quot;</span> via socket <span class="keyword">in</span> <span class="string">&quot;/var/run/postgresql&quot;</span> at port <span class="string">&quot;5432&quot;</span>.</span><br></pre></td></tr></table></figure><p>数据数据库用<code>dropdb</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropdb mytestdb</span><br></pre></td></tr></table></figure><p>注意，删除的数据库不能恢复。</p><h2><span id="表">表</span></h2><p>创建一个<code>employees</code>的表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (employee_id int, first_name varchar, last_name varchar);</span><br></pre></td></tr></table></figure><p>插入一条记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO employees VALUES (1, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br></pre></td></tr></table></figure><p>查看表内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure><p>输出内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employee_id | first_name | last_name</span><br><span class="line">-------------+------------+-----------</span><br><span class="line">          1 | John       | Doe</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>列举当前数据库的所有表信息，可以通过<code>\dt</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mytestdb-<span class="comment"># \dt</span></span><br><span class="line">          List of relations</span><br><span class="line">Schema |   Name    | Type  |  Owner</span><br><span class="line">--------+-----------+-------+----------</span><br><span class="line">public | employees | table | postgres</span><br></pre></td></tr></table></figure><p>删除表通过<code>DROP TABLE</code>命令，例如删除<code>employees</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE employees;</span><br></pre></td></tr></table></figure><p>可以通过逗号分隔方式删除多个表，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE employees1, employees2;</span><br></pre></td></tr></table></figure><p>更改和添加表column，和标准SQL一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees ADD start_date date;</span><br></pre></td></tr></table></figure><p>验证先前的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure><p>你会看到新增的列不包含任何内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employee_id | first_name | last_name | start_date</span><br><span class="line">-------------+------------+-----------+------------</span><br><span class="line">          1 | John       | Doe       |</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>PostgreSQL支持好几种数据库类型，可以在<a href="https://www.postgresql.org/docs/9.2/static/datatype.html">这里</a>查看相关信息。</p><p>你可以使用<code>UPDATE</code>更改记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees SET start_date = <span class="string">&#x27;2016-09-28&#x27;</span> WHERE employee_id = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>或插入一条新的记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO employees VALUES (2, <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;2015-03-09&#x27;</span>);</span><br></pre></td></tr></table></figure><p>验证一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">employee_id | first_name | last_name | start_date</span><br><span class="line">-------------+------------+-----------+------------</span><br><span class="line">          1 | John       | Doe       | 2016-09-28</span><br><span class="line">          2 | Jane       | Smith     | 2015-03-09</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>要删除行和列，例如删除<code>start_date</code>字段，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees DROP start_date;</span><br></pre></td></tr></table></figure><p>删除记录使用<code>DELETE</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM employees WHERE employee_id = <span class="string">&#x27;2&#x27;</span>;</span><br></pre></td></tr></table></figure><p>验证一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">employee_id | first_name | last_name</span><br><span class="line">-------------+------------+-----------</span><br><span class="line">          1 | John       | Doe</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>查询数据库和标准SQL一样，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,employee_id FROM employees;</span><br><span class="line"></span><br><span class="line">last_name | employee_id</span><br><span class="line">-----------+-------------</span><br><span class="line">Doe       |           1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>更多查询选项，可以点击<a href="https://www.postgresql.org/docs/9.2/static/sql-select.html">这里</a></p><h2><span id="角色">角色</span></h2><p>PostgreSQL通过<strong>roles</strong>授权数据库访问，表示某种权限。另外，角色可以由其它一系列角色创建，类似于“group”。PostgreSQL的角色是全局的，所以你不需要为同一个角色创建两次以访问不同数据库。</p><p>创建角色通过<code>createuser</code>命令，例如创建一个<code>examplerole</code>的角色，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createuser examplerole --pwprompt</span><br></pre></td></tr></table></figure><p>授权角色访问，默认以<code>postgres</code>数据连接，再进行授权，这里的<code>postgres</code>相当于一个<code>sa</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON employees TO examplerole;</span><br></pre></td></tr></table></figure><p>罗列所有用户角色，可以通过<code>\du</code>命令查看，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \du</span></span><br><span class="line">                             List of roles</span><br><span class="line">Role name   |                   Attributes                   | Member of</span><br><span class="line">-------------+------------------------------------------------+-----------</span><br><span class="line">examplerole |                                                | &#123;&#125;</span><br><span class="line">postgres    | Superuser, Create role, Create DB, Replication | &#123;&#125;</span><br></pre></td></tr></table></figure><p>为了便于管理，可以将多个角色添加到一个组，这样可以全局管理它们的权限。下面展示如何实现，所有这些命令应该在<code>postgres</code>用户下进行。</p><p>使用<code>createuser</code>创建一个组角色。其中<code>--no-login</code>选项指定了该组不需要登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createuser examplegroup --no-login</span><br></pre></td></tr></table></figure><p>登录并添加角色到组中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql postgres</span><br><span class="line">GRANT examplegroup TO examplerole;</span><br></pre></td></tr></table></figure><p>验证一下，使用<code>\du</code>命令，可以看到<code>examplerole</code>用户现在在<code>examplegroup</code>组中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \du</span><br><span class="line">                                List of roles</span><br><span class="line">Role name    |                   Attributes                   |   Member of</span><br><span class="line">--------------+------------------------------------------------+----------------</span><br><span class="line">examplegroup | Cannot login                                   | &#123;&#125;</span><br><span class="line">examplerole  |                                                | &#123;examplegroup&#125;</span><br><span class="line">group        |                                                | &#123;&#125;</span><br><span class="line">postgres     | Superuser, Create role, Create DB, Replication | &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>createuser</code>命令有几个选项。点击<a href="https://www.postgresql.org/docs/9.2/static/app-createuser.html">这里</a>查看相关信息。</p><p>要更改角色属性，有几个选项，例如，授予<code>examplerole</code>属性<code>CREATEDB</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER ROLE examplerole CREATEDB;</span><br></pre></td></tr></table></figure><p>使用<code>\du</code>验证一下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \du</span><br><span class="line">                             List of roles</span><br><span class="line">Role name   |                   Attributes                   | Member of</span><br><span class="line">-------------+------------------------------------------------+-----------</span><br><span class="line">examplerole | Create DB                                      | &#123;&#125;</span><br><span class="line">group       |                                                | &#123;&#125;</span><br><span class="line">postgres    | Superuser, Create role, Create DB, Replication | &#123;&#125;</span><br></pre></td></tr></table></figure><p>删除角色，使用<code>dropuser</code>命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropuser examplerole</span><br></pre></td></tr></table></figure><h2><span id="peer-authentication">Peer Authentication</span></h2><p>PostgreSQL默认使用对等授权(peer authentication)的方式进行连接。意味着，如何当前授权的本地系统用户和PostgreSQL角色用户名匹配，则授予连接。所以你需要同时创建一个相同的Linux用户和一个对应的PostgreSQL角色。例如，刚刚创建了<code>examplerole</code>角色，Linux中需要创建一个<code>examplerole</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser examplerole &amp;&amp; passwd examplerole</span><br></pre></td></tr></table></figure><h2><span id="secure-postgresql">Secure PostgreSQL</span></h2><p>PostgreSQL默认使用的peer authentication方式，限制了仅能通过本地访问，它的配置信息在<code>/var/lib/pgsql/dta/pg_hba.conf</code>中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local    all        all             peer</span><br></pre></td></tr></table></figure><p>将<code>peer</code>替换为<code>md5</code>，以允许通过MD5哈希密码方式访问。</p><p>也可以指定信任任何服务器的连接，修改为，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># IPv4 local connections:</span><br><span class="line">host    all            all      127.0.0.1/32      trust</span><br><span class="line">host    all            all      0.0.0.0/0    trust</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all            all      ::/0         trust</span><br></pre></td></tr></table></figure><p>退出，重启服务，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart postgresql</span><br><span class="line">su - postgres</span><br></pre></td></tr></table></figure><p>再次登录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql mytestdb -U examplerole</span><br></pre></td></tr></table></figure><p>它会提示你输入密码，用于登录<code>examplerole</code>角色以访问数据库。你可以通过<code>\z</code>命令访问表权限。</p><p>另外，要实现远程访问，还需要修改<code>/var/lib/pgsql/data/postgresql.conf</code>配置，去掉前面注释，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses=<span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>某些情况下，还需要关闭系统防火墙，或直接添加到iptalbe，</p><p>CentOS 防火墙中内置了PostgreSQL服务，配置文件位置在/usr/lib/firewalld/services/postgresql.xml，我们只需以服务方式将PostgreSQL服务开放即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-service=postgresql --permanent  开放postgresql服务</span><br><span class="line">firewall-cmd --reload  重载防火墙</span><br></pre></td></tr></table></figure><p>或干脆关闭防火墙，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>重启postgresql即可。</p><h2><span id="安装postgis">安装PostGIS</span></h2><p>PostGIS可以由CentOS仓储安装，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install postgis.x86_64 postgis-client.x86_64 postgis-debuginfo.x86_64 postgis-devel.x86_64 postgis-docs.x86_64 postgis-utils.x86_64</span><br></pre></td></tr></table></figure><p>查看PostGI相关文件是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/pgsql/share/extension</span><br><span class="line">ls /usr/pgsql/share/contrib/postgis</span><br></pre></td></tr></table></figure><p>加载PostGIS插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">psql -d postgres -U postgres</span><br></pre></td></tr></table></figure><p>在PostgreSQL Shell中，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># create database postgis ;</span></span><br><span class="line">postgres=<span class="comment"># \c postgis</span></span><br><span class="line">postgis=<span class="comment"># select * from pg_extension ;</span></span><br><span class="line">postgis=<span class="comment"># create extension postgis ;</span></span><br><span class="line">postgis=<span class="comment"># \dt</span></span><br><span class="line"></span><br><span class="line">postgis=<span class="comment"># select count(*) from spatial_ref_sys ;</span></span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># \dn</span></span><br><span class="line"></span><br><span class="line">postgis=<span class="comment"># create extension postgis_topology ;</span></span><br><span class="line">CREATE EXTENSION</span><br><span class="line">postgis=<span class="comment"># \dn</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用storybook开发自己的React组件库</title>
      <link href="/2019/01/16/react/react-storybook-live-editing/"/>
      <url>/2019/01/16/react/react-storybook-live-editing/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/cartoon/20190116_225744.925.jpg" alt="ohanahibi"><br>有时候并不希望使用第三方组件库，以及大部分时候需要自己定制一套组件实现，以供公司或项目内部使用。开发自己的组件有如重复造轮子，会花费相当多的精力制造。如果是为了一种长远公司发展，这份努力是值得的，如果不想自己耗费精力，也有许多开源的组件实现，比如<a href="https://material-ui.com/">material-ui</a>。一般都是拿来改造一下，可以避免很多开发或兼容性上的坑。</p><span id="more"></span><h2><span id="architecture">Architecture</span></h2><p>编写这篇文章时，笔者用的都是最新的包以及依赖，坑比较多，比如<a href="https://webpack.js.org/">webpack4</a>，改掉以及删除很多功能；又如<a href="https://babeljs.io/docs/en/v7-migration">babel7</a>弃用了旧的写法，全部带上了<code>scoped packages</code>，即在presets前面带上模块标志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/env&quot;</span>], <span class="comment">// &quot;@babel/preset-env&quot;</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;@babel/transform-arrow-functions&quot;</span>], <span class="comment">// same as &quot;@babel/plugin-transform-arrow-functions&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要关键技术：</p><ul><li>webpack</li><li>typescript</li><li>react</li><li>state management(redux or mobx)</li><li>react-router-4</li><li>component hot reload</li><li>svg icon</li><li>jest</li><li>UI lib</li><li>less</li><li>eslint</li></ul><p>主要库以及版本：</p><ul><li>webpack4.x.x</li><li>typescript2.9.x</li><li>react16.7.x</li><li>react-router-dom4.2.x</li><li>react-hot-loader4.6.x<br>…</li><li>node10.13.x</li></ul><p>注意：react-router v4为第四代react-router，react-dom为v2或v3的旧版本。新版本的react-router v4可以说是重写了路由，react-router v4 被一分为三：<code>react-router-dom</code>(for web)、<code>react-router-native</code>(for native)、<code>react-router</code>(core)。仅在浏览器中使用的话，一般引入<code>react-router-dom</code>即可。如果从旧版本迁移，可以参考<a href="https://github.com/gmfe/Think/issues/6">这里</a>。</p><p>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--.storybook</span><br><span class="line">--public模板目录</span><br><span class="line">--src</span><br><span class="line">  --components 自定义组件</span><br><span class="line">  --docs代码入口&lt;App/&gt;</span><br><span class="line">  --stories文档说明</span><br><span class="line">eslintrc.yml</span><br><span class="line">tsconfig.json</span><br><span class="line">.babelrc</span><br><span class="line">package.json依赖包</span><br><span class="line">webpack.config.js</span><br></pre></td></tr></table></figure><h2><span id="babel">Babel</span></h2><p>Babel用于将浏览器不能识别的ES以及TS转换为JS，首先添加依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @babel/core @babel/cli @babel/preset-env @babel/preset-react @babel/preset-typescript @babel/plugin-proposal-object-rest-spread @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure><p>然后在根目录添加.babelrc，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/preset-env&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;,</span><br><span class="line">    &quot;@babel/preset-typescript&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;@babel/plugin-proposal-object-rest-spread&quot;,</span><br><span class="line">    &quot;@babel/plugin-transform-runtime&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="unit-test">Unit Test</span></h2><p>添加单元测试，单测默认识别目录<code>__tests__</code>，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--src</span><br><span class="line">  --components</span><br><span class="line">    --Link</span><br><span class="line">  --__tests__</span><br><span class="line">    Link.react.test.js</span><br><span class="line">  Link.react.js</span><br><span class="line">    index.js</span><br></pre></td></tr></table></figure><p>首先，使用TypeScript编写一个组件，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  <span class="attr">HOVERED</span>: <span class="string">&#x27;hovered&#x27;</span>,</span><br><span class="line">  <span class="attr">NORMAL</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MLink</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>._onMouseEnter = <span class="built_in">this</span>._onMouseEnter.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>._onMouseLeave = <span class="built_in">this</span>._onMouseLeave.bind(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">class</span>: STATUS.NORMAL,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_onMouseEnter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">class</span>: STATUS.HOVERED &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_onMouseLeave</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">class</span>: STATUS.NORMAL &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">a</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">className</span>=<span class="string">&#123;this.state.class&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">href</span>=<span class="string">&#123;this.props.page</span> || &#x27;#&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseEnter</span>=<span class="string">&#123;this._onMouseEnter&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseLeave</span>=<span class="string">&#123;this._onMouseLeave&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MLink.propTypes = &#123;</span><br><span class="line">  <span class="attr">children</span>: PropTypes.node.isRequired,</span><br><span class="line">  <span class="attr">page</span>: PropTypes.node,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应其<code>__tests__</code>目录添加单元测试，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MLink.react.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MLink &#125; <span class="keyword">from</span> <span class="string">&#x27;../Link.react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">&#x27;react-test-renderer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;MLink changes the class when hovered&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> component = renderer.create(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">MLink</span> <span class="attr">page</span>=<span class="string">&quot;http://www.facebook.com&quot;</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">MLink</span>&gt;</span></span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> tree = component.toJSON();</span><br><span class="line">  expect(tree).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually trigger the callback</span></span><br><span class="line">  tree.props.onMouseEnter();</span><br><span class="line">  <span class="comment">// re-rendering</span></span><br><span class="line">  tree = component.toJSON();</span><br><span class="line">  expect(tree).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually trigger the callback</span></span><br><span class="line">  tree.props.onMouseLeave();</span><br><span class="line">  <span class="comment">// re-rendering</span></span><br><span class="line">  tree = component.toJSON();</span><br><span class="line">  expect(tree).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把单元测试所需的配置补充上，添加单元测试所需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest @types/jest babel-jest ts-jest</span><br></pre></td></tr></table></figure><p>另外还需要一个Enzyme，它是React的测试工具，还需要enzyme-to-json 转换，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest react-test-renderer enzyme enzyme-adapter-react-16 enzyme-to-json</span><br></pre></td></tr></table></figure><p>更新一下package.json，加上对应的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test:watch&quot;</span>: <span class="string">&quot;jest --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test:coverage&quot;</span>: <span class="string">&quot;jest --coverage&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;setupFiles&quot;</span>: [<span class="string">&quot;./test/jestsetup.js&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;snapshotSerializers&quot;</span>: [<span class="string">&quot;enzyme-to-json/serializer&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个test/jestsetup.js文件，自定义测试环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow, render, mount &#125; <span class="keyword">from</span> <span class="string">&#x27;enzyme&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">&#x27;enzyme-adapter-react-16&#x27;</span>;</span><br><span class="line"><span class="comment">// React 16 Enzyme adapter</span></span><br><span class="line">Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"><span class="comment">// Make Enzyme functions available in all test files without importing</span></span><br><span class="line"><span class="built_in">global</span>.shallow = shallow;</span><br><span class="line"><span class="built_in">global</span>.render = render;</span><br><span class="line"><span class="built_in">global</span>.mount = mount;</span><br></pre></td></tr></table></figure><p>对于CSS模块，添加以下配置到package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;moduleNameMapper&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;^.+\\.(css|scss)$&quot;</span>: <span class="string">&quot;identity-obj-proxy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行命令进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest --env=jsdom --coverage --no-cache --detectOpenHandles</span><br></pre></td></tr></table></figure><p>jest可以测试的特性有：</p><ul><li>component render</li><li>props</li><li>events</li><li>event handlers<br>…</li></ul><p>更多例子可以参考<a href="https://jestjs.io/">这里</a>。</p><h2><span id="eslint">ESLint</span></h2><p>首先加入依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev eslint eslint-config-airbnb-base eslint-loader eslint-plugin-import eslint-plugin-react typescript-eslint-parser</span><br></pre></td></tr></table></figure><p>ESLint用于代码检查用，配置也比较无脑，当你用像WebStorm这些开发工具时，工具会自动检测到ESLint，自动为你格式化和检查代码。下面是我自己的一份配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">browser:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">commonjs:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">es6:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">jest:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ecmaFeatures:</span></span><br><span class="line">  <span class="attr">modules:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">spread:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">restParams:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">extends:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;eslint:recommended&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;plugin:react/recommended&#x27;</span></span><br><span class="line"><span class="attr">parser:</span> <span class="string">&#x27;babel-eslint&#x27;</span></span><br><span class="line"><span class="attr">parserOptions:</span></span><br><span class="line">  <span class="attr">ecmaFeatures:</span></span><br><span class="line">    <span class="attr">jsx:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ecmaVersion:</span> <span class="number">2018</span></span><br><span class="line">  <span class="attr">sourceType:</span> <span class="string">module</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">react</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="attr">indent:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">linebreak-style:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">windows</span></span><br><span class="line">  <span class="attr">quotes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">single</span></span><br><span class="line">  <span class="attr">semi:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">comma-dangle:</span> <span class="string">off</span></span><br><span class="line">  <span class="attr">no-unused-vars:</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">no-console:</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">no-unexpected-multiline:</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">import/prefer-default-export:</span> <span class="string">off</span></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">pragma:</span> <span class="string">React</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">detect</span></span><br></pre></td></tr></table></figure><p>像VSCode，可以在首选项 -&gt; 设置 中找到eslint.validate，加入typescript与typescriptreact，分别用于监听ts与tsx文件，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;eslint.validate&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;javascriptreact&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescriptreact&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>更多配置可以自己定制。</p><h2><span id="storybook">Storybook</span></h2><p>storybook的主要作用是为自己实现的组件编写文档，可以在<a href="https://storybook.js.org/">这里</a>查看更多细节。</p><p>安装storybook：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev @storybook/react</span><br></pre></td></tr></table></figure><p>加入package.json的script</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;storybook&quot;</span>: <span class="string">&quot;start-storybook -p 9001 -c .storybook&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认storybook会在.storybook文件夹作为配置，配置文件为config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .storybook/config.js中修改路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; configure &#125; <span class="keyword">from</span> <span class="string">&#x27;@storybook/react&#x27;</span>;</span><br><span class="line"><span class="comment">// src/stories/button.stories.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">&#x27;../src/stories&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.stories\.js$/</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStories</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  req.keys().forEach(<span class="function">(<span class="params">filename</span>) =&gt;</span> req(filename));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configure(loadStories, <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>上面配置指定了创建stories的位置，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// .storybook/config.js中修改路径</span><br><span class="line">import &#123; configure &#125; from &#x27;@storybook/react&#x27;;</span><br><span class="line"></span><br><span class="line">function loadStories() &#123;</span><br><span class="line">  require(&#x27;../src/stories/button.stories.js&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configure(loadStories, module);</span><br><span class="line"></span><br><span class="line">// src/stories/button.stories.js</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; storiesOf &#125; from &#x27;@storybook/react&#x27;;</span><br><span class="line">import &#123;Button&#125; from &#x27;../components/Button&#x27;;</span><br><span class="line"></span><br><span class="line">storiesOf(&#x27;Button&#x27;, module)</span><br><span class="line">  .add(&#x27;基本用法&#x27;,() =&gt; (</span><br><span class="line">    &lt;Button&gt;按钮&lt;/Button&gt;</span><br><span class="line">  ))</span><br><span class="line">  </span><br><span class="line">// src/components/Button.js</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">export class Button extends React.Component&#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button style=&#123;&#123;backgroundColor: &#x27;#fff&#x27;, border: &#x27;1px solid #ccc&#x27;&#125;&#125;&gt;&#123;this.props.children&#125;&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动stroybook服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn storybook</span><br></pre></td></tr></table></figure><p><img src="/img/react/storybook-script.png" alt="storybook"></p><p>默认会自动打开浏览器</p><p><img src="/img/react/storybook.png" alt="storybook"></p><p>出现以上页面说明配置已经成功了。</p><h2><span id="live-editing">Live Editing</span></h2><p>默认地，webpack的development mode在每次更新代码时，会自动刷新页面。但刷新不同于Live Edit，我不希望编写一个CSS还要重新refresh一下，页面直接变化就最好了！有很多工具可以实现这种方式，这里仅介绍react-hot-loader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev react-hot-loader</span><br></pre></td></tr></table></figure><p>在script里面加入一个<code>--hot</code>选项即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;./node_modules/.bin/webpack-dev-server --hot --mode development --progress --colors --config ./webpack.config.js&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>出现以下效果，说明Live Editing功能实现了。</p><video src="/img/react/react-hot-loader.mp4" type="video/mp4" controls="controls" width="100%" height="100%"></video><h2><span id="summary">Summary</span></h2><p>由于使用的东西比较多，而且开发的方式也比较灵活，具体技术细节可以具体深入理解。</p><p>完整代码，可以参考我的<a href="https://github.com/barudisshu/galilei-ui">github</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react, redux, webpack, hot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在IntelliJ创建标签</title>
      <link href="/2018/12/23/ideal/using-intellij-bookmarks/"/>
      <url>/2018/12/23/ideal/using-intellij-bookmarks/</url>
      
        <content type="html"><![CDATA[<p>This is a quick post about IntelliJ’s nice bookmark feature.</p><p>IntelliJ gives you the option to bookmark single lines of code. After a line has been bookmarked, you can use various ways to jump directly back to this line. So it can be a good idea to bookmarks code locations you often work with.</p><span id="more"></span><p>To create a new bookmark you only have to press F11 inside the code editor. Bookmarked lines show a small checkmark next to the line number.</p><p><img src="/img/idea/intellij-bookmark1.png" alt></p><p>Bookmarks can be removed by selecting the bookmarked line and pressing F11 again.</p><p>To see all bookmarks you can press Shift - F11. This opens a small popup window which shows a list of all bookmarks you have created.</p><p><img src="/img/idea/intellij-bookmark5.png" alt></p><p>Note that this window can completely controlled using the keyboard:</p><ul><li>With Up / Down you can browse the list of bookmarks</li><li>With Enter you jump to the selected bookmark</li><li>Esc closes the window</li><li>A bookmark can be moved up or down using Alt - Up / Alt - Down</li></ul><p>Note that you can also add a mnemonic identifier to a bookmark. You do this by selecting a line and pressing Ctrl - F11. This opens a small menu in which you can choose a mnemonic identifier (which is a character or a number).</p><p><img src="/img/idea/intellij-bookmark3.png" alt></p><p>You can choose an identifier by clicking on one of the menu buttons or by simply pressing the corresponding key on your keyboard.</p><p>Bookmark mnemonics are also shown next to the line number. In the following image 1 was choosen as mnemonic.</p><p><img src="/img/idea/intellij-bookmark2.png" alt></p><p>Mnemonics give you the option to move even quicker between bookmarks. You can directly jump to a mnemonic bookmark by opening the bookmark popup (Shift - F11) and pressing the mnemonic key (1 in this example).</p><p>For numerical bookmarks even more shortcuts are available. You can toggle a numeric mnemonic on a selected line by pressing <code>Ctrl - Shift - &lt;number&gt;</code>. If you want to jump to a numeric mnemonic you use the <code>Ctrl - &lt;number&gt;</code> shortcut.</p><p>For example: <code>Ctrl - 5</code> brings you directly to the mnemonic bookmark 5.</p>]]></content>
      
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Akka在事件溯源的若干思考</title>
      <link href="/2018/12/21/pattern/ddd/event-sourcing-feedback/"/>
      <url>/2018/12/21/pattern/ddd/event-sourcing-feedback/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/cartoon/20181231_213606.453.jpg" alt="shana"></p><p>谈及CQRS，一定离不开Event Sourcing的讨论。首先阐明一个问题，Event Sourcing是否是必须的？主要是两点顾虑：</p><ul><li>引入Event Sourcing会带来一定额外开销，因为要将每次的Event按一定顺序存储下来。这样做是因为在分布式并发较大的情况下，可以保证CAP的最终一致性。因为传统数据库事务的回滚操作，在分布式环境操作显然是不切实际的，你不可能让每个请求处理都交给数据库去处理，这样会给数据库带来压力。</li><li>由于领域驱动设计理念，不可避免要记录Entity的状态。Event会改变Entity的State，一方面持久化Event可以方便对State进行回滚，对应PersistenceActor的snapshot；另一方面，Entity的事件需要进行pub-sub通信模式，实现解耦。但State并不是领域驱动设计阐述的内容，它是一种编程模式或一种架构方法。例如React的Redux设计了State，用于描述事件发生，记录已经改变了组件或模型的State。</li></ul><span id="more"></span><div style="float:right"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22727327&auto=1&height=66"></iframe></div><div class="clearfix"></div><h2><span id="ddd是什么">DDD是什么？</span></h2><blockquote><p>领域驱动设计是一种处理<strong>高度复杂域</strong>的设计方法，试图分离技术实现的复杂性，围绕<strong>业务概念</strong>构建<strong>领域模型</strong>来控制业务的复杂性，以解决软件难以理解，难以演化等问题。团队应用它可以成功开发<strong>复杂业务</strong>软件系统，使用系统在演进时任然保持敏捷。</p></blockquote><p>首先必须理解，DDD不是框架，不是架构，不是语言，它是一种设计思想。它可以分离业务复杂度和技术复杂度，DDD也并不是一个新的事物，它是面向对象的拔高，最终目标还是</p><blockquote><p>高内聚，低耦合</p></blockquote><h2><span id="ddd主要解决的问题">DDD主要解决的问题？</span></h2><ol><li><p>如何合理划分业务系统？<br>这为微服务的划分提供了方法论（微服务的粒度的问题，多大算大，多小又算小，在微服务刚兴起时，很多企业或者架构师对它都没有统一且明确的定义，这里给些examples，e.g：代码行数？职责的划分？披萨原则？组织结构？）界限上下文很好的回答了这个问题，这也是DDD最近几年借微服务的东风，火起来的原因之一(领域驱动设计的提出距今已经十多年，但真正火热起来大约是在2013年微服务架构被提出来之后)。</p></li><li><p>如何保持业务架构和系统架构的一致性？<br>与传统的系统相比，DDD里面强调领域专家和技术团队的合作，建立统一语言“普通话”， 聚焦在领域，领域逻辑和业务流程上面，使整体团队对同一个业务术语有统一的认识，避免理解的偏差，并将这些“术语”映射到代码中，随着系统的演进变迁。</p></li></ol><h2><span id="战略建模strategic-modeling和战术建模tractical-modeling">战略建模(Strategic Modeling)和战术建模(Tractical Modeling)</span></h2><blockquote><p>战略建模：</p><p>限界上下文(Bounded Context)<br>上下文映射图(Context Mapping)</p></blockquote><blockquote><p>战术建模：</p><p>聚合(Aggregate)<br>实体(Entity)<br>值对象(Value Objects)<br>资源库(Repository)<br>领域服务(Domain Services)<br>领域事件(Domain Events)<br>模块(Modules)</p></blockquote><h2><span id="ddd战略设计">DDD战略设计？</span></h2><p><img src="/img/pattern/ddd/dddes/ddd.png" alt="ddd"></p><p>这张图几乎覆盖了领域驱动设计的所有概念，它划分了两大部分：战略建模和战术建模。两部分没有明显的对比关系，它属于DDD的两个层面，一个是业务设计层面，一个是逻辑编码划分。可以看到，要实现领域驱动设计的程序代码，你必须既是产品经理，又是核心代码开发人员。</p><blockquote><p>想要完整的图例，可以在这里<a href="/img/pattern/ddd/dddes/dddd.png">下载</a>。</p></blockquote><h2><span id="ddd领域划分">DDD领域划分？</span></h2><p>根据问题域，将问题划分为<code>Core domain</code>，<code>Sub domain</code>，<code>Support subdomain</code> 和 <code>generic subdomian</code>，大概标准如下：</p><ul><li>核心域：核心竞争力，核心业务 (需要投入最好的人力和资源)</li><li>支持子域： 没有，很糟糕; 有，也不足以脱颖而出(可以考虑外包)</li><li>通用子域：都有的东西, 比如认证, 发短信, 客服系统等(可以考虑购买商业解决方案或者采用开源方案)</li></ul><h2><span id="ddd领域建模方法">DDD领域建模方法？</span></h2><p>领域建模的方式很多种，比如四色建模、OOAD还有事件风暴，我们这里只简单聊聊如何使用事件风暴梳理业务流程，建立领域模型，划分边界。</p><h2><span id="限界上下文bounded-context">限界上下文(Bounded Context)</span></h2><p>限界上下文的概念很重要，它由<code>通用语言</code>进行表述。它表述的就是子域，它划分了<code>实体</code>、<code>值对象</code>和<code>领域服务</code>等概念。</p><p>以玩家刷怪升级为例，通用语言描述为，“击杀怪物，掉落经验值，玩家获得经验值，玩家消费经验值，玩家经验值增加”。从这段话，就可以构建几个限界上下文：</p><p><img src="/img/pattern/ddd/dddes/bounded-context.png" alt="bounded-context"></p><p>可以看到，上下文的边界是非常清晰的，并且是唯一的，这种唯一性带来的好处就是解耦。例如，有个货物出仓的方法，它既可能在商品上实现方法，也可能在库存上实现方法。在一个业务项目中出现两个做同一件事情的方法，可以说，开发或维护是非常麻烦的事情！不妨将“出仓”划分到子域限界上下文“仓储”中去。由外部通过命令调用，这就是为什么大部分DDD设计，都是基于CQRS实现的原因。</p><h2><span id="ddd事件风暴">DDD事件风暴？</span></h2><p>事件风暴主要是来自 DDD 社区的一个工作坊，用于快速探索复杂的业务领域。在这个过程中，会使用一面大墙作为建模面，并使用贴纸来代表模型。我们将业务人员和开发人员聚集起来，并采用事件的方式查找领域中所发生的事情。当找到事件时，会尝试沿着一个时间线对它们进行排序。随后，我们会添加触发每个事件的命令。Huehnken 在这里没有基于实体看上去的从属关系创建聚合，而是希望能够根据命令流和事件而生成聚合。这会给聚合带来不同的视角，它会对命令和事件一起进行逻辑分组，他相信这种方式能够为我们带来更好的边界划分，并且有助于将聚合分割到不同的服务中。</p><p>在 Huehnken 的经验中，事件风暴是一个强大的工具，在一些较大规模的场景中更是如此，但是它可以用于不同的级别。他发现我们还可以将其用到一个更加技术化的级别，用于建模服务和聚合。这种方式的一个巨大优势就是能够将模型和实现匹配起来，这在 DDD 中是非常重要的。</p><p>响应式系统指的是构建具备即时响应性、弹性、适应性以及消息驱动特征的系统。实现这些特征的方式是异步消息。对于 Huehnken 来说，微服务的关键点在于隔离、快速反应并且能够在部署新版本服务时不影响系统的其他组成部分，所以对他来说，这两个概念非常具有互补性，我们需要响应式的微服务。</p><p>实现响应式系统的教科书式技术是Actor，但是 Huehnken 认为这种模型并不像他想象中的那样被广泛采用，他相信造成这一点的原因在于从单体模型进行转移所需的思想方式转变。在单体模型中，我们可以访问任何的内容，甚至可以跨越已存的逻辑边界。在真正的分布式系统中，会具有网络边界，我们无法以整体的方式访问系统。涉及到多个聚合的业务进程可能会需要像 sagas 这样的模式。现在，我们还要告别全局状态，在分布式系统中，每个服务是本地化的，已经过去的事情要通过事件来表示。</p><p>Huehnken 认为我们已经有了一个非常有趣的采用 Actor 的实现技术。现在有多个可用的框架，包括Erlang和 Akka。Lagom 是一个更新、更具倾向性的微服务框架，它基于 Akka、CQRS和事件溯源（event sourcing）。因为思维方式的挑战，人们在构建复杂异步解耦的系统时还较为困难，但是如果我们想要将建模技术和实现技术结合起来，这将是一个非常好的机会。</p><p>在 DDD 中，非常重要的一点在于代码要表述模型的概念。Huehnken 认为我们在这一点上已经迷失并且在偏离方向。我们已经开发了实现技术，并且又独立开发了新的建模技术，现在我们必须将它们结合起来，这样来自模型的理念能够直接反射到代码中，这样的话，会在构建分布式系统方面取得真正的突破。</p><p>基于响应式设计理念，对于大量复杂业务需要加速设计。所以事件风暴是以结果为导向的。事件风暴有4个步骤：</p><ol><li>识别领域事件</li></ol><p>事件是对结果进行建模，我们在寻找领域事件时，首先需要明白领域事件具备的几个特征：</p><ul><li>具有业务意义</li><li>过去时，e.g: “XX已XX”</li><li>时序性</li></ul><p>事件风暴以过去发生的事件追溯系统的数据和行为，从而进行合适的建模，e.g：</p><p><img src="/img/pattern/ddd/dddes/event-list.png" alt="Event List"></p><ol start="2"><li>识别命令</li></ol><p>命令可以理解为不同角色用户在界面上面的操作，比如“添加商品”，“编辑库存”，“提交订单”等； 有些命令可能产生多个事件，可以将他们用箭头联系起来; 在进行这个过程中，我们也需要将角色，通过不同的颜色标示出来 e.g:</p><p><img src="/img/pattern/ddd/dddes/event-recognize.png" alt="Event Recognize"></p><ol start="3"><li>寻找聚合</li></ol><p>在DDD中，聚合是一组相关的领域对象，其目的是要确保业务规则在边界内的不变性，聚合根具有全局标识，所有对聚合根内对象的修改，都只能通过聚合根进行，聚合帮助我们简化了复杂的对象网络，逐步做到“高内聚，低耦合”。<br>在识别聚合的时候，我们可以通过对命令和事件的划分找到聚合边界，识别出分布在时间轴上面不同位置的相关命令和事件，e.g：</p><p><img src="/img/pattern/ddd/dddes/event-aggregator.png" alt="Event Aggregator"></p><ol start="4"><li>边界划分</li></ol><p>划分服务的边界，它一定程度上面对应的是“界限上下文”，关于它有一个非常形象的定义：</p><blockquote><p>细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜</p></blockquote><p>一个聚合可能是最小颗粒度的界限上下文，同时，我们常合并业务相关性很高的聚合。e.g:</p><p><img src="/img/pattern/ddd/dddes/event-bound.png" alt="Event Bound"></p><p>最后在领域划分的时候，需要团队一起对业务达成共识，首先建立统一语言，然后识别领域模型，划分子域和界限上下文，在验证界限上下文的时候，如果你发现有过多的角色在同一个子域或者界限上下文时，就需要注意了，这就是典型的坏味道，需要及时调整的讯号。</p><h2><span id="akka的ddd战术设计">Akka的DDD战术设计</span></h2><p>CQRS是一种很好的设计，如果说战略设计是业务上的解耦，那么CQRS就是战术设计的解耦。它把代码层面上的职能进行了划分。这里主要顾虑到是否需要引入PersistenceActor，也就是是否需要在DDD进行事件的持久化的问题讨论。</p><p>一般情况下这样考虑，并发性较高，写入占主要吞吐量的业务，推荐使用Event Sourcing进行事件回溯。比如订单下单、天气预警、紧急消息推送等，这种一次大量写入的业务需要PersistenceActor作一份快照，以便失败时可以恢复(recover)。那么写入数据库的操作应该发生在persist前，还是persist后？</p><p>另外，是否是写入很少，读取很多的操作不推荐使用Event Sourcing？在CQRS设计中，Read的操作被设计为从中间件(Midware)读取，这个中间件可以是Elasticsearch，可以是MongoDB等，所以读操作很多的场景，引入Event Sourcing反而成为性能瓶颈，因为Event需要被保存下来并被序列化。</p><ol><li>PersistenceActor的限界上下文战术</li></ol><p>DDD的Entity被设计为继承了PersistenceActor，Entity实体有唯一标识persistenceId，这样聚合根拥有了全局标识，聚合根的所有操作，都发生在该Entity内。如下：</p><p><img src="/img/pattern/ddd/dddes/aggregate-root.png" alt="aggregate-root"></p><p>实体包含系统的状态(快照)，每次事件的发生都改变Entity的状态。</p><ol start="2"><li>PersistenceActor协作上下文</li></ol><p>DDD中实体拥有自身上下文的所有操作，并且不是共享的，不是RMI形式的。子域间想要调用彼此的操作，有两种方式：</p><ul><li>Pub-Sub事件订阅模式</li><li>领域协作</li></ul><p>事件订阅方式可以由Akka的EventBus处理，这种方式隔离性比较高。子域间的Entity根本不清楚彼此的情况，也不用关心内部的实现。缺点就是额外要维护这个EventBus，并且需要为EventBus配置Supervisor策略。</p><p>领域协作的方式比较直接，即通过上下文，直接获取临域的位置，直接调用。好处是不需要担心消息丢失方面的问题，事件由聚合根处理，实现高聚合、即时反馈。缺点就是要处理好消息的各种情况，在Akka设计方面一般用FSM对消息进行transform。</p><p>本身互联网就是个无状态非阻塞的环境，个人认为第二种方式比较适用这种环境的处理。下面阐述下流程：</p><p><img src="/img/pattern/ddd/dddes/context-associate.png" alt="context-associate"></p><p>根据以往的经验，总结下Actor设计的思想：</p><ul><li>一个Actor只做一件事情，它是无依赖的，原子性的，逻辑上不可再分割的最小单元；</li><li>一个Actor是包含行为的，它是一个对象，也是一个角色，这个行为可能表现为基础属性：邮箱大小，Executor机制，dispather机制；也可能表现为状态、Socket连接、游戏Actor的Exp、消息队列的Size等。</li></ul><p>不妨分析下：</p><blockquote><p>Aggregate Actor只做Aggregate root的角色，其它逻辑跟我无关<br>Pipe Actor只做Pipe的角色，我只担心流量、超时、deadletter，其它逻辑跟我无关<br>Factory Actor是个工厂，它会产生很多factor，至于factor做什么跟我无关</p><p>所以反过来说：凡是“与xxx有关”的Actor，都是设计有问题的，可以再次分割的逻辑，即时TDD也不能覆盖这个缺陷问题。</p></blockquote><p>这种Actor特性和设计思想，与微服务的理念无疑是“天工巧夺”。但同时要明白，微服务的设计，大多是面向容器的，除此之外，还有基于<a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS</a>。有兴趣的可以了解下。</p><h2><span id="ddd与微服务">DDD与微服务</span></h2><p>理想情况下，界限上下文与微服务可以一一对应，在实际项目中，有些调整，比如根据业务的相关度和变化频率，有时候我们会将多个界限上下文进行合并；另外微服务在开发，测试，部署，发布和运维等等时，相比单体应用而言，它面临了所有分布式系统面临的问题，带来了额外的复杂度和开销，所以将微服务粒度拆分过细反而是一种反模式，需要考虑需要解决问题的复杂度，将相对简单的服务合并在一起；在微服务拆分的时候，也要注意：“聚合是服务的最小单元”（一个界限上下文可以包括多个聚合），打破聚合，就很有可能破坏事务一致性和业务约束。</p>]]></content>
      
      
      
        <tags>
            
            <tag> akka, ddd, cqrs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Redux Tutorial for Beginners - The Definitive Guide(2018)</title>
      <link href="/2018/11/19/react/react-redux-tutorial-beginners/"/>
      <url>/2018/11/19/react/react-redux-tutorial-beginners/</url>
      
        <content type="html"><![CDATA[<p>The Simplest <strong>React Redux tutorial</strong> I wish I had when I started learning <a href="https://www.valentinog.com/blog/react-redux-tutorial-beginners/#React_Redux_tutorial_what_you_will_learn">here</a></p><p><img src="/img/react/redux-react-tutorial-beginner-2018.png" alt="redux"></p><span id="more"></span><p>When I first started learning <strong>Redux</strong> I wish I could find the simplest tutorial ever.</p><p>Despite the great resource out there I couldn’t wrap my head around some of the Redux concepts.</p><p>I knew what’s the <strong>state</strong>. But <strong>Actions, action creators, and reducers?</strong> They were obscure for me.</p><p>Last but not least I didn’t know how to glue <strong>React and Redux together</strong>.</p><p>During those days I started writing my own React Redux tutorial and since then I learned a lot.</p><p>I taught myself the Redux fundamentals by writting this guide. I hope it’ll be useful for all those learning React and Redux.</p><h2><span id="react-redux-tutorial-who-this-guide-is-for">React Redux tutorial: who this guide is for</span></h2><p>The following React Redux guide is exactly what you’re looking for if:</p><ul><li>you have a good grasp of Javascript: ES6, and React</li><li>you’re looking forward to learn Redux in the most simple way</li></ul><h2><span id="react-redux-tutorial-what-you-will-learn">React Redux tutorial: what you will learn</span></h2><p>In the following guide you will learn:</p><ul><li>what is Redux</li><li>how to use Redux with React</li></ul><h2><span id="react-redux-tutorial-a-minimal-react-development-environment">React Redux tutorial: a minimal React development environment</span></h2><p>Before starting off <strong>make sure you have a React development environment ready to roll.</strong></p><p>To make one you can follow this tutorial of mine: How to set up React, webpack, and Babel or you can also use create-react-app.</p><h2><span id="react-redux-tutorial-what-is-the-state">React Redux tutorial: what is the state?</span></h2><p>To <strong>understand what is Redux</strong> you must first understand what is the <strong>state</strong>.</p><p>If you have ever worked with React the term state should be no surprise to you.</p><p>I guess you already wrote some <strong>stateful React component</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">articles</span>: [</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">&quot;React Redux Tutorial for Beginners&quot;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">&quot;Redux e React: cos&#x27;è Redux e come usarlo con React&quot;</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; articles &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;articles.map(el =&gt; <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;el.id&#125;</span>&gt;</span>&#123;el.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A <strong>stateful React component</strong> is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Javascript ES6 class</a>.</p><p>Every stateful React component <strong>carries its own state</strong>.</p><p>In a React component the state holds up <strong>data</strong> and the component might render such data to the user.</p><p>The state could also change in response to actions and events: in React you can update the local component’s state with setState.</p><p>But <strong>what is the state</strong> anyway?</p><p>The term state is not tied exclusively to React.</p><p>The <strong>state is all around you</strong>.</p><p>Even <strong>the simplest JavaScript application has a state</strong>.</p><p>Consider the following example:</p><p>the user clicks a button</p><p>a modal appers afterwards</p><p>Guess what, <strong>in this trivial interaction there is a state</strong> we must deal with.</p><p>We could describe the initial state as a plain JavaScript object:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = &#123;</span><br><span class="line">  <span class="attr">buttonClicked</span>: <span class="string">&#x27;no&#x27;</span>,</span><br><span class="line">  <span class="attr">modalOpen</span>: <span class="string">&#x27;no&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And when the user clicks the button we have:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = &#123;</span><br><span class="line">  <span class="attr">buttonClicked</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">  <span class="attr">modalOpen</span>: <span class="string">&#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How do you <strong>keep track of those things in JavaScript</strong> besides storing the state in an object?</p><p>Is there <strong>a library that can help use tracking the state</strong>?</p><h2><span id="react-redux-tutorial-what-problem-does-redux-solve">React Redux tutorial: what problem does Redux solve?</span></h2><p>A typical JavaScript application is full of states. And you didn’t even know.</p><p>Here are some examples of state:</p><ul><li>what the user sees (data)</li><li>what data are we fetching</li><li>what URL are we showing to the user</li><li>what items are selected inside the page</li><li>are there errors in the applications? That’s state too</li></ul><p>State is everywhere in JavaScript.</p><p>As you can see even the simplest JavaScript application has a state.</p><p>But can you imagine <strong>how much state a React application has</strong>?</p><p>Yeah, you can get by with keeping the state within a parent React component.</p><p>As long as the application remains <strong>small</strong>.</p><p>Then things will become tricky.</p><p>Even a silly to-do list could become unmanageable if you starting passing the state up and down.</p><p>Who wants a bloated React component?</p><p>Not only, I’d say that the <strong>frontend shouldn’t know about the business logic</strong>. Ever.</p><p>So what are the alternatives for managing the state of a React component?</p><p><strong>Redux</strong> is one of them.</p><p><strong>Redux solves a problem that might not be clear in the beginning</strong>: it helps giving <strong>each React component</strong> the <strong>exact piece of state</strong> it needs.</p><p>Redux holds up the <strong>state</strong> within a <strong>single location</strong>.</p><p>Also with Redux the <strong>logic for fetching and managing the state</strong> <strong>lives outside React</strong>.</p><p>The benefits of this approach might be not so evident. Things will look clear as soon as you’ll get your feet wet with Redux.</p><p>In the next section we’ll see why you should learn Redux and when to use Redux within your applications.</p><h2><span id="react-redux-tutorial-should-i-learn-redux">React Redux tutorial: should I learn Redux?</span></h2><p>Are you trying to learn Redux but you’re going nowhere?</p><p>Redux literally scares most beginners. But that shouldn’t be your case.</p><p><strong>Redux is not that hard</strong>. The key is: don’t rush learning Redux just because.</p><p>You should <strong>start learning Redux</strong> if you’re <strong>motivated and passionate</strong> about it.</p><p>Take your time.</p><p>I started to learn Redux because:</p><ul><li>I was 100% interested in learning how Redux works</li><li>I was eager to improve my React skills</li><li>the combination React/Redux is ubiquitous</li><li>Redux is <strong>framework agnostic</strong>. Learn it once, use it everywhere (Vue JS, Angular)</li></ul><p>Learning Redux or an equivalent state management library is a must.</p><p>Another truth is: real world JavaScript applications make always use of a state management library.</p><p>State is <strong>so pervasive and hard that state management in JS is still an unsolved problem</strong>.</p><p>The amount of libraries that come out almost daily is a proof.</p><p>Redux is just a library among the others, yet it is one of the most important.</p><p>Will Redux disappear in the future? Maybe.</p><p>But the <strong>patterns will stick forever</strong>.</p><p>Would you neglet learning OOP with PHP just because PHP is not “trendy” anymore?</p><p>I advise not doing so.</p><p>The same with Redux.</p><p>You should <strong>learn the patterns for managing UI state because they will be invaluable in your career</strong>.</p><h2><span id="react-redux-tutorial-should-i-use-redux">React Redux tutorial: should I use Redux?</span></h2><p>Using Redux or Flux (or Mobx) for state management is up to you.</p><p>Maybe you need none of these libraries. They have a cost: they add another layer of abstraction to your application.</p><p>But I prefer thinking about <strong>Redux as an investment</strong>, not as a cost.</p><p>Another common question for Redux beginners is: how do you know <strong>when you’re ready to use Redux in your application</strong>?</p><p>If you think about it there is no rule of thumb for determining when you do need <strong>Redux for managing the state</strong>.</p><p>Redux also offers a lot of convenience for a JavaScript developer. Debugging, action replaying. And much more.</p><p>When I start a new React project I’m always tempted to add Redux straight away. But …</p><p>As developers <strong>we overengineer our code automatically</strong>.</p><p>So, when should you add Redux to a project?</p><p><strong>Before picking Redux take your time to explore alternative patterns</strong>. In particular try to get the most out of React’s state and props.</p><p>Dave Ceddia has a nice writeup with a lot of great insights for using <a href="https://daveceddia.com/context-api-vs-redux/">children props as an alternative before reaching for Redux</a>.</p><p>And don’t forget that a React project can be easily refactored to include Redux later.</p><p>What I found is that you should <strong>consider using Redux</strong> when:</p><ul><li>multiple React components needs to access the same state but do not have any parent/child relationship</li><li>you start to feel awkward passing down the state to multiple components with props</li></ul><p>If that makes still no sense for you do not worry, I felt the same.</p><p>Dan Abramov says “Flux libraries are like glasses: you’ll know when you need them.”</p><p>And in fact it worked like that for me.</p><p>Before going further take your time to understand what problem does Redux solve and whether you’re motivated or not to learn it.</p><p>Be aware that Redux is not useful for smaller apps. It really shines in bigger ones. Anyway, learning Redux even if you’re not involved in something big wouldn’t harm anyone.</p><p>In the next section we’ll start building a proof of concept to introduce:</p><ul><li>the Redux fundamental principles</li><li>Redux alongside with React</li></ul><h2><span id="react-redux-tutorial-getting-to-know-the-redux-store">React Redux tutorial: getting to know the Redux store</span></h2><p>Actions. Reducers. I kind of knew about them. But one thing wasn’t clear to me: <strong>how were all the moving parts glued together</strong>?</p><p>Were there some minions or what?</p><p>In Redux there are no minions (unfortunately).</p><p>The <strong>store orchestrates all the moving parts in Redux</strong>. Repeat with me: the <strong>store</strong>.</p><p>The store in Redux is like the human brain: it’s kind of magic.</p><p>The <strong>Redux store is fundamental</strong>: the <strong>state of the whole application</strong> lives <strong>inside the store</strong>.</p><p>So to start playing with Redux we should <strong>create a store for wrapping up the state</strong>.</p><p>Move into your React development environment and install Redux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux --save-dev</span><br></pre></td></tr></table></figure><p>Create a directory for the store:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/store</span><br></pre></td></tr></table></figure><p>Create a new file named <code>index.js</code> in <code>src/js/store</code> and finally initialize the store:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;../reducers/index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>createStore is the function for creating the Redux store.</p><p>createStore takes a reducer as the first argument, rootReducer in our case.</p><p>You may also pass an initial state to createStore. But most of the times you don’t have to. Passing an initial state is useful for server side rendering. Anyway, <strong>the state comes from reducers</strong>.</p><blockquote><p>NOTE: see <a href="https://stackoverflow.com/questions/36619093/why-do-i-get-reducer-returned-undefined-during-initialization-despite-pr">Reducer returned undefined during initialization</a></p></blockquote><p>So what does exactly a reducer do?</p><p>In Redux <strong>reducers produce the state</strong>. The state is not something you create by hand.</p><p>Armed with that knowledge let’s move on to our first Redux reducer.</p><h2><span id="react-redux-tutorial-getting-to-know-redux-reducers">React Redux tutorial: getting to know Redux reducers</span></h2><p>While an initial state is useful for <a href="https://redux.js.org/docs/recipes/ServerRendering.html">SSR</a>, in Redux <strong>the state must return entirely from reducers</strong>.</p><p>Cool but what’s a reducer?</p><p><strong>A reducer is just a Javascript function</strong>. A reducer <strong>takes two parameters: the current state</strong> and an <strong>action</strong> (more about actions soon).</p><p>The third principle of Redux says that the state is immutable and cannot change in place.</p><p>This is why the reducer must be pure. A pure function is one that returns the exact same output for the given input.</p><p>In plain React the local state changes in place with setState. In Redux you cannot do that.</p><p>Creating a reducer is not that hard. It’s a plain Javascript function with two parameters.</p><p>In our example we’ll be creating a <strong>simple reducer taking the initial state</strong> as the first parameter. As a <strong>second parameter</strong> we’ll provide <strong>action</strong>. As of now the reducer will do nothing than returning the initial state.</p><p>Create a directory for the root reducer:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/reducers</span><br></pre></td></tr></table></figure><p>Then create a new file named <code>index.js</code> in the <code>src/js/reducers</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/reducers/index.js</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">articles</span>: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> state;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure><p>I promised to keep this guide as simple as possibile. That’s why our first reducer is a silly one: it returns the initial state without doing anything else.</p><p>Notice how the initial state is passed as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">default parameter</a>.</p><p>In the next section we’ll add an action to the mix. That’s where things will become interesting.</p><h2><span id="react-redux-tutorial-getting-to-know-redux-actions">React Redux tutorial: getting to know Redux actions</span></h2><p>Redux reducers are without doubt the most important concept in Redux. <strong>Reducers produce the state of the application</strong>.</p><p>But <strong>how does a reducer know when to produce the next state</strong>?</p><p>The second principle of Redux says the <strong>only way to change the state is by sending a signal to the store</strong>.This signal is an <strong>action. “Dispatching an action”</strong> is the process of sending out a signal.</p><p>Now, how do you change an immutable state? You won’t. The resulting state is a copy of the current state plus the new data.</p><p>That’s a lot to know.</p><p>The reassuring thing is that <strong>Redux actions are nothing more than Javascript objects</strong>. This is what an action looks like:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_ARTICLE&#x27;,</span><br><span class="line">  payload: &#123; name: &#x27;React Redux Tutorial&#x27;, id: <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Every action needs a type property for describing how the state should change.</p><p>You can specify a payload as well. In the above example the payload is a new article. A reducer will add the article to the current state later.</p><p>It is a best pratice to <strong>wrap every action within a function</strong>. Such function is an <strong>action creator</strong>.</p><p>Let’s put everything together by creating a simple Redux action.</p><p>Create a directory for the actions:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/actions</span><br></pre></td></tr></table></figure><p>Then create a new file named <code>index.js</code> in <code>src/js/actions</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/actions/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addArticle = <span class="function"><span class="params">article</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">&quot;ADD_ARTICLE&quot;</span>, <span class="attr">payload</span>: article &#125;);</span><br></pre></td></tr></table></figure><p>So, the <strong>type property</strong> is nothing more than a string.</p><p>The reducer will use that string to determine how to calculate the next state.</p><p>Since strings are prone to typos and duplicates it’s <strong>better to have action types declared as constants</strong>.</p><p>This approach helps <strong>avoiding errors that will be difficult to debug</strong>.</p><p>Create a new directory:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/constants</span><br></pre></td></tr></table></figure><p>Then create a new file named <code>action-types.js</code> into the <code>src/js/constants</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/constants/action-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_ARTICLE = <span class="string">&quot;ADD_ARTICLE&quot;</span>;</span><br></pre></td></tr></table></figure><p>Now open up again <code>src/js/actions/index.js</code> and update the action to use action types:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/actions/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/action-types&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addArticle = <span class="function"><span class="params">article</span> =&gt;</span> (&#123; <span class="attr">type</span>: ADD_ARTICLE, <span class="attr">payload</span>: article &#125;);</span><br></pre></td></tr></table></figure><p>We’re one step closer to have a working Redux application. Let’s refactor our reducer!</p><h2><span id="react-redux-tutorial-refactoring-the-reducer">React Redux tutorial: refactoring the reducer</span></h2><p>Before moving forward let’s recap the main Redux concepts:</p><ul><li>the <strong>Redux store</strong> is like a brain: it’s in charge for <strong>orchestrating all the moving parts</strong> in Redux</li><li>the <strong>state of the application lives as a single, immutable object</strong> within the store</li><li>as soon as <strong>the store receives an action it triggers a reducer</strong></li><li>the <strong>reducer returns the next state</strong></li></ul><p>What’s a <strong>Redux reducer</strong> made of?</p><p>A reducer is a Javascript function taking <strong>two parameters</strong>: the <strong>state</strong> and the <strong>action</strong>.</p><p>A reducer function may have a <strong>switch statement</strong> (but I prefer using if).</p><p>The <strong>reducer calculates the next state depending on the action type</strong>. Moreover, <strong>it should return at least the initial state when no action type matches</strong>.</p><p>When the action type matches a case clause the <strong>reducer calculates the next state</strong> and <strong>returns a new object</strong>. Here’s an excerpt of the code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_ARTICLE:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">articles</span>: [...state.articles, action.payload] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>The reducer we created in the previous section does nothing than returning the initial state. Let’s fix that.</p><p>Open up <code>src/js/reducers/index.js</code> and update the reducer as follow:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/action-types&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">articles</span>: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_ARTICLE:</span><br><span class="line">      state.articles.push(action.payload);</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure><p>We’re not done yet! With the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread operator</a> we can make our reducer even better:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/action-types&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">articles</span>: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_ARTICLE:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">articles</span>: [...state.articles, action.payload] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure><p>In the example above the initial state is left utterly untouched.</p><p>The initial articles array doesn’t change in place.</p><p>The initial state object doesn’t change as well. The resulting state is a copy of the initial state.</p><p>There are two key points for <strong>avoiding mutations in Redux</strong>:</p><ul><li><a href="https://egghead.io/lessons/react-redux-avoiding-array-mutations-with-concat-slice-and-spread">Using concat(), slice(), and …spread</a> for arrays</li><li><a href="https://egghead.io/lessons/react-redux-avoiding-object-mutations-with-object-assign-and-spread">Using Object.assign() and …spread</a> for objects</li></ul><p>The <strong>object spread operator</strong> is still in stage 3. Install <a href="https://babeljs.io/docs/plugins/transform-object-rest-spread/">Object rest spread transform</a> to <strong>avoid a SyntaxError Unexpected token</strong> when using the object spread operator in Babel:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev babel-plugin-transform-object-rest-spread</span><br></pre></td></tr></table></figure><p>Open up <code>.babelrc</code> and update the configuration:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;env&quot;</span>, <span class="string">&quot;react&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-object-rest-spread&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Redux protip</strong>: the reducer will grow as your app will become bigger. You can split a big reducer into separate functions and combine them with <a href="https://redux.js.org/docs/api/combineReducers.html">combineReducers</a></p><p>In the next section we’ll play with Redux from the console. Hold tight!</p><h2><span id="react-redux-tutorial-redux-store-methods">React Redux tutorial: Redux store methods</span></h2><p>This will be super quick, I promise.</p><p>I want you to play with the brower’s console for gaining a quick understanding of how Redux works.</p><p>Redux itself is a small library (2KB). The <a href="https://redux.js.org/docs/api/Store.html">Redux store exposes a simple API</a> for managing the state. The most important methods are:</p><ul><li><a href="https://redux.js.org/docs/api/Store.html#getState">getState</a> for accessing the current state of the application</li><li><a href="https://redux.js.org/docs/api/Store.html#dispatch">dispatch</a> for dispatching an action</li><li><a href="https://redux.js.org/docs/api/Store.html#subscribe">subscribe</a> for listening on state changes</li></ul><p>We will play in the brower’s console with the above methods.</p><p>To do so we have to export as global variables the store and the action we created earlier.</p><p>Create <code>src/js/index.js</code> and update the file with the following code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../js/store/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addArticle &#125; <span class="keyword">from</span> <span class="string">&quot;../js/actions/index&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.store = store;</span><br><span class="line"><span class="built_in">window</span>.addArticle = addArticle;</span><br></pre></td></tr></table></figure><p>Open up <code>src/index.js</code> as well, clean up its content and update it as follows:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&quot;./js/index&quot;</span></span><br></pre></td></tr></table></figure><p>Now run webpack dev server (or Parcel) with:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>head over <a href="http://localhost:8080/">http://localhost:8080/</a> and open up the console with F12.</p><p>Since we’ve exported the store as a global variable we can access its methods. Give it a try!</p><p>Start off by <strong>accessing the current state</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getState()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">articles</span>: <span class="built_in">Array</span>(<span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure><p>Zero articles. In fact we haven’t update the initial state yet.</p><p>To make things interesting we can listen for state updates with subscribe.</p><p>The <strong>subscribe method accepts a callback that will fire whenever an action is dispatched</strong>. Dispatching an action means notifying the store that we want to change the state.</p><p>Register the callback with:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(() =&gt; console.log(&#x27;Look ma, Redux!!&#x27;))</span><br></pre></td></tr></table></figure><p>To <strong>change the state in Redux we need to dispatch an action</strong>. To dispatch an action you have to call the <a href="https://redux.js.org/docs/api/Store.html#dispatch">dispatch</a> method.</p><p>We have one action at our disposal: addArticle for adding a new item to the state.</p><p>Let’s dispatch the action with:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch( addArticle(&#123; <span class="attr">name</span>: <span class="string">&#x27;React Redux Tutorial for Beginners&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;) )</span><br></pre></td></tr></table></figure><p>Right after running the above code you should see:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Look ma, Redux!!</span><br></pre></td></tr></table></figure><p>To verify that the state changed run again:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getState()</span><br></pre></td></tr></table></figure><p>The output should be:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">articles</span>: <span class="built_in">Array</span>(<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure><p>And that’s it. This is Redux in its simplest form.</p><p>Was that difficult?</p><p>Take your time to explore these three Redux methods as an exercise. Play with them from the console:</p><ul><li><a href="https://redux.js.org/docs/api/Store.html#getState">getState</a> for <strong>accessing the current state</strong> of the application</li><li><a href="https://redux.js.org/docs/api/Store.html#dispatch">dispatch</a> for <strong>dispatching an action</strong></li><li><a href="https://redux.js.org/docs/api/Store.html#subscribe">subscribe</a> for <strong>listening on state changes</strong></li></ul><p>That’s everything you need to know for getting started with Redux.</p><p>Once you feel confident head over the next section. We’ll go straight to connecting React with Redux!</p><h2><span id="react-redux-tutorial-connecting-react-with-redux">React Redux tutorial: connecting React with Redux</span></h2><p>After learning Redux I realized it wasn’t so complex.</p><p>I knew how to access the current state with <a href="https://redux.js.org/docs/api/Store.html#getState">getState</a>.</p><p>I knew how to dispatch an action with <a href="https://redux.js.org/docs/api/Store.html#dispatch">dispatch</a></p><p>I knew how to listen for state changes with <a href="https://redux.js.org/docs/api/Store.html#subscribe">subscribe</a></p><p>Yet I didn’t know how to couple React and Redux together.</p><p>I was asking myself: should I call getState within a React component? How do I dispatch an action from a React component? And so on.</p><p>Redux on its own is framework agnostic. You can use it with vanilla Javascript. Or with Angular. Or with React. There are bindings for joining together Redux with your favorite framework/library.</p><p>For React there is <a href="https://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a>.</p><p>Before moving forward install <a href="https://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a> by running:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-redux --save-dev</span><br></pre></td></tr></table></figure><p>To demonstrate how React and Redux work together we’ll build a super simple application. The application is made of the following components:</p><ul><li>an App component</li><li>a List component for displaying articles</li><li>a Form component for adding new articles</li></ul><p>(The application is a toy and it does nothing serious other than displaying a list and a form for adding new items. Nonetheless it’s still a good starting point for learning Redux)</p><h2><span id="react-redux-tutorial-react-redux">React Redux tutorial: react-redux</span></h2><p><a href="https://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a> is a Redux binding for React. It’s a small library for connecting Redux and React in an efficient way.</p><p>The most important method you’ll work with is connect</p><p>What does react-redux’s connect do? Unsurprisingly it <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">connects</a> a React component with the Redux store.</p><p>You will use <strong>connect</strong> with two or three arguments depending on the use case. The fundamental things to know are:</p><ul><li>the mapStateToProps function</li><li>the mapDispatchToProps function</li></ul><p><strong>What does mapStateToProps do</strong> in react-redux? mapStateToProps does exactly what its name suggests: it <strong>connects a part of the Redux state</strong> to the <a href="https://reactjs.org/docs/components-and-props.html">props of a React component</a>. By doing so a connected React component will have access to the exact part of the store it needs.</p><p><strong>What does mapDispatchToProps</strong> do in react-redux? mapDispatchToProps does something similar, but for actions. <strong>mapDispatchToProps connects Redux actions to React props</strong>. This way a connected React component will be able to dispatch actions.</p><p>Is everything clear? If not, stop and take your time to re-read the guide. I know it’s a lot to learn and it requires time. Don’t worry if you don’t get Redux right know. It will click sooner or later.</p><p>In the next section we’ll finally get our hands dirty!</p><h2><span id="react-redux-tutorial-app-component-and-redux-store">React Redux tutorial: App component and Redux store</span></h2><p>We saw that mapStateToProps connects a portion of the Redux state to the props of a React component. You may wonder: is this enough for connecting Redux with React? No, it’s not.</p><p>To start off <strong>connecting Redux with React we’re going to use [Provider[(<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store">https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store</a>)</strong>.</p><p><a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store">Provider</a> is an high order component coming from react-redux.</p><p>Using layman’s terms, Provider wraps up your React application and makes it aware of the entire Redux’s store.</p><p>Why so? We saw that in Redux the store manages everything. React must talk to the store for accessing the state and dispatching actions.</p><p>Enough theory.</p><p>Open up <code>src/js/index.js</code>, wipe out everything and update the file with the following code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./components/App&quot;</span>;</span><br><span class="line">render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>You see? Provider wraps up your entire React application. Moreover it gets the store as a prop.</p><p>Now let’s create the <strong>App</strong> component since we’re requiring it. It’s nothing special: App should import a List component and render itself.</p><p>Create a directory for holding the components:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/components</span><br></pre></td></tr></table></figure><p>and a new file named <code>App.js</code> inside <code>src/js/components</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/components/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">&quot;./List&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row mt-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-4 offset-md-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Articles<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>Take moment and look at the component without the markup:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">&quot;./List&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>then move on to createing <strong>List</strong>.</p><h2><span id="react-redux-tutorial-list-component-and-redux-state">React Redux tutorial: List component and Redux state</span></h2><p>We have done nothing special so far.</p><p>But our new component, List, will interact with the Redux store.</p><p>A brief recap: the key for connecting a React component with Redux is <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">connect</a>.</p><p>Connect takes at least one argument.</p><p>Since we want List to get a list of articles it’s a matter of connecting state.articleswith the component. How? With <strong>mapStateToProps</strong>.</p><p>Create a new file named <code>List.js</code> inside <code>src/js/components</code>. It should look like the following:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/components/List.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">articles</span>: state.articles &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ConnectedList = <span class="function">(<span class="params">&#123; articles &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;list-group list-group-flush&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;articles.map(el =&gt; (</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">key</span>=<span class="string">&#123;el.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;el.title&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ))&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> List = connect(mapStateToProps)(ConnectedList);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> List;</span><br></pre></td></tr></table></figure><p>The List component receives the prop <code>articles</code> which is a copy of the <code>articles</code> array. Such array lives inside the Redux state we created earlier. It comes from the reducer:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">articles</span>: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_ARTICLE:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">articles</span>: [...state.articles, action.payload] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then it’s a matter of using the prop inside JSX for generating a list of articles:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;articles.map(<span class="function"><span class="params">el</span> =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">key</span>=<span class="string">&#123;el.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;el.title&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">))&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>React protip</strong>: take the habit of validating props with <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">PropTypes</a></p></blockquote><p>Finally the component gets exported as List. List is the result of connecting the stateless component ConnectedList with the Redux store.</p><p>A stateless component does not have its own local state. Data gets passed to it as props</p><p>Still confused? I was too. Understanding how connect works will take some time. Fear not, the road to learn Redux is paved with “ah-ha” moments.</p><p>I suggest taking a break for exploring both connect and mapStateToProps.</p><p>Once you’re confident about them head over the next section!</p><h2><span id="react-redux-tutorial-form-component-and-redux-actions">React Redux tutorial: Form component and Redux actions</span></h2><p>The Form component we’re going to create is a bit more complex than List. It’s a form for adding new items to our application.</p><p>Plus it is a <strong>stateful component</strong>.</p><p>A stateful component in React is a component carrying its own local state</p><p>A stateful component? “Valentino, we’re talking about Redux for managing the state! Why on earth would you give Form its own local state??”</p><p><strong>Even when using Redux it is totally fine to have stateful components</strong>.</p><p>Not every piece of the application’s state should go inside Redux.</p><p>In this example I don’t want any other component to be aware of the Form local state.</p><p>And that’s perfectly fine.</p><p>What does the component do?</p><p>The component contains some logic for updating the local state upon a form submission.</p><p>Plus it receives a Redux action as prop. This way it can update the global state by dispatching the addArticle action.</p><p>Create a new file named <code>Form.js</code> inside <code>src/js/components</code>. It should look like the following:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/js/components/Form.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> uuidv1 <span class="keyword">from</span> <span class="string">&quot;uuid&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addArticle &#125; <span class="keyword">from</span> <span class="string">&quot;../actions/index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">addArticle</span>: <span class="function"><span class="params">article</span> =&gt;</span> dispatch(addArticle(article))</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectedForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleSubmit = <span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; [event.target.id]: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> id = uuidv1();</span><br><span class="line">    <span class="built_in">this</span>.props.addArticle(&#123; title, id &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">title</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">className</span>=<span class="string">&quot;form-control&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">id</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">value</span>=<span class="string">&#123;title&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">className</span>=<span class="string">&quot;btn btn-success btn-lg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          SAVE</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Form = connect(<span class="literal">null</span>, mapDispatchToProps)(ConnectedForm);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Form;</span><br></pre></td></tr></table></figure><p>What can I say about the component? Besides <strong>mapDispatchToProps</strong> and <strong>connect</strong> it’s standard React stuff.</p><p><strong>mapDispatchToProps connects Redux actions to React props</strong>. This way a connected component is able to dispatch actions.</p><p>You can see how the action gets dispatched in the handleSubmit method:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> id = uuidv1();</span><br><span class="line">    <span class="built_in">this</span>.props.addArticle(&#123; title, id &#125;); <span class="comment">// Relevant Redux part!!</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Finally the component gets exported as Form. Form is the result of connecting ConnectedForm with the Redux store.</p><p>Side note: the first argument for connect must be <code>null</code> when mapStateToProps is absent like in the Form example. Otherwise you’ll get <code>TypeError: dispatch is not a function</code>.</p><p>Our components are all set!</p><p>Update App to include the Form component:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">&quot;./List&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Form <span class="keyword">from</span> <span class="string">&quot;./Form&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row mt-5&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-4 offset-md-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Articles<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-4 offset-md-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Add a new article<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>Install uuid with:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i uuid --save-dev</span><br></pre></td></tr></table></figure><p>Now run webpack(or Parcel) with:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>and head over to <a href="http://localhost:8080">http://localhost:8080</a></p><p>You should see the following working POC:</p><p><img src="/img/react/react-redux-demo.png" alt="article"></p><p>Nothing fancy but still useful for showing React and Redux at work!</p><p>The <strong>List component on the left is connected to the Redux store</strong>. It will re-render whenever you add a new item.</p><p><img src="/img/react/react-redux-tutorial-demo-gif.gif" alt="redux-action"></p><p>Whoaaa!</p><h2><span id="react-redux-tutorial-wrapping-up">React Redux tutorial: wrapping up</span></h2><p>I hope you’ll learn something from this guide. I tried my best to keep things as simple as possibile. I would love to hear your feedback in the comments below!</p><p>Redux has a lot of boilerplate and moving parts. Don’t get discouraged. Pick Redux, play with it and take your time to absorb all the concepts.</p><p>I went from zero to understanding Redux by small steps. You can do it too!</p><p>Also, take your time to investigate why and if you should use Redux in your application.</p><p>Either way think of Redux as an investment: learning it is 100% worthwile.</p><h2><span id="react-redux-tutorial-redux-devtools">React Redux tutorial: Redux DevTools</span></h2><p>You will find the interesting tool from <a href="https://cloud.githubusercontent.com/assets/7957859/18002950/aacb82fc-6b93-11e6-9ae9-609862c18302.png">here</a>.</p><p>It’s very useful for inspect redux concept like <strong>Action</strong>, <strong>State</strong>, and can always replay the actions!</p><p><img src="/img/react/redux-devTools.png" alt="redux-devtool"></p>]]></content>
      
      
      
        <tags>
            
            <tag> react, redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to set up React, webpack 4, and Babel 7</title>
      <link href="/2018/11/19/react/react-webpack-babel/"/>
      <url>/2018/11/19/react/react-webpack-babel/</url>
      
        <content type="html"><![CDATA[<p><strong>React</strong> 主要用于单页面应用程序。</p><p>Y然而，你可以将React库集成到任何使用 <strong>webpack</strong>和<strong>Babel</strong>构建的网站中。</p><p><img src="/img/react/webpack4-react-babel.png" alt="react webpack babel"></p><span id="more"></span><h2><span id="how-to-set-up-react-webpack-and-babel-what-you-will-learn">How to set up React, Webpack, and Babel: What you will learn</span></h2><ol><li>如何安装和配置webpack</li><li>如何安装和配置Babel</li><li>如何安装React</li><li>如何按照<code>Container / Presentational</code>组件的原则创建两个React组件</li><li>如何将生成的包包含到HTML页面</li><li>如何安装和配置Webpack Dev Server</li></ol><p>React不仅限于SPA应用。可以将库集成到任何现有网站中。</p><p>可以通过CDN或模块包引入React。</p><p>对于我的大多数项目，我都使用Webpack：将React和Webpack结合起来很容易。</p><p>您也可以按下下面几分钟的教程与Webpack4工作。</p><h2><span id="how-to-set-up-react-webpack-and-babel-setting-up-the-project">How to set up React, Webpack, and Babel: Setting up the project</span></h2><p>首先为项目创建一个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-react-tutorial &amp;&amp; cd webpack-react-tutorial</span><br></pre></td></tr></table></figure><p>创建一个用于保存代码的最小目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src</span><br></pre></td></tr></table></figure><p>通过运行来启动项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>就是这么简单，项目建立完成！</p><h2><span id="how-to-set-up-react-webpack-and-babel-setting-up-webpack">How to set up React, Webpack, and Babel: Setting up webpack</span></h2><p><strong>Webpack</strong> 是现代Web开发的支柱之一。这是一个非常强大的工具。</p><p>了解如何使用webpack是使用React的基础。</p><p>webpack提取原始的React组件，用于生成(几乎)每个浏览器都能运行的JavaScript代码。</p><p>让我们通过运行以下命令来安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack --save-dev</span><br></pre></td></tr></table></figure><p>你还需要webpack-cli，将其加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>接下来将<code>webpack</code>命令加入到<code>package.json</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，不需要为webpack定义配置文件。</p><p>较旧的webpack版本会自动查找配置文件。</p><p>自版本4开始，你可以直接开发。</p><p>下一小节，我们将安装和配置Babel以便转换我们的代码。</p><h2><span id="how-to-set-up-react-webpack-and-babel-setting-up-babel">How to set up React, Webpack, and Babel: Setting up Babel</span></h2><p>React components(组件)大多是用JavaScript ES6编写的。</p><p>由于浏览器无法理解React组件，因此需要进行某种转换。</p><p>Webpack不知道如何进行转换，但它具有loaders(加载器)的概念：将它们视为转换器。</p><p>Webpack loaders(加载器)将某些内容作为输入并生成其他内容作为输出。</p><p>babel-loader是Webpack加载器，负责接收ES6代码并使其可以让所选择的浏览器理解。</p><p>很明显 babel-load使用Babel。并且Babel必须配置为使用一组预设：</p><p>babel-preset-env用于将JavaScript ES6代码编译为ES5(请注意，babel-preset-es2015现已弃用)</p><p>babel-preset-react用于将JSX和其它东西编译到JavaScript</p><p>让我们用以下命令引入依赖关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader babel-core babel-preset-env babel-preset-react --save-dev</span><br></pre></td></tr></table></figure><p>别忘了配置Babel！在项目文件夹中创建一个名为<code>.babelrc</code>的新文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们已准备好定义最小的webpack配置。</p><p>创建一个名为<code>webpack.config.js</code>的文件，写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">use: &#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置非常简单。</p><p>对于每个扩展名为<code>.js</code>的文件，webpack都会通过babel-loader来管理代码，将ES6转换为ES5.</p><p>有了这个，我们就可以编写我们的React组件了。</p><p>让我们来看看下一节。</p><h2><span id="how-to-set-up-react-webpack-and-babel-writing-react-components">How to set up React, webpack, and Babel: writing React components</span></h2><p>我喜欢按照容器(Container)组件/展示(Presentational)组件的原则编写我的React组件。</p><p>我建议看看Dan Abramov的 <a href="https://medium.com/@learnreact/container-components-c0e67432e005">container components</a> 和 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">smart and dumb components</a>，以了解更多信息。</p><p>简而言之，容器组件/展示组件原则是React组件的模式。</p><p>容器组件是承载所有逻辑的容器组件：用于处理state(状态)更改，内部组件state(状态)等的功能。</p><p>相反，展示组件仅用于显示所需的HTML标记。展示组件通常是普通的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，并从容器组件接受数据作为 <a href="https://reactjs.org/docs/components-and-props.html">props(属性)</a>。</p><p>你将在以下示例中看到它们的样子。</p><p>对于这片文章的范围，我想构建一个带有单个文本输入的超级简单的React表单。</p><p>在接触任何代码之前，让我们通过运行以下命令来引入React：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react react-dom --save-dev</span><br></pre></td></tr></table></figure><p>然后创建一个用于组织组件的最小目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/js/components/&#123;container,presentational&#125;</span><br></pre></td></tr></table></figure><p>接下来让我们创建一个容器组件：</p><ul><li>有自己的state(状态)</li><li>渲染HTML表单</li></ul><p>在<code>src/js/components/container/</code>中创建组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/js/components/container/ForContainer.js</span><br></pre></td></tr></table></figure><p>该组件将如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;article-form&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormContainer;</span><br></pre></td></tr></table></figure><p>该组件刺客没什么内容和交互。它只是一个包装组件的骨架。</p><p>事实上，如果一个容器组件不包含展示子组件的话，那么这个容器组件几乎是无用的。</p><p>我们来解决这个问题。</p><p>在<code>src/js/components/presentational/</code>中创建一个新组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/js/components/presentational/Input.js</span><br></pre></td></tr></table></figure><p>我们的第一个表示性的React组件将是文本输入框。我们知道HTML input具有以下属性：</p><ul><li>type</li><li>class</li><li>id</li><li>value</li><li>required</li></ul><p>所有这些都将成为容器组件传递给其展示子组件的props(属性)。</p><p>由于Input保持自己的state(状态)，我们必须确保React会处理它。HTML input成为一个React中的受控组件。</p><p>说到props(属性)，最好使用Prop Types记录你的React组件。</p><p>通过运行以下命令来安装prop-types包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i prop-types --save-dev</span><br></pre></td></tr></table></figure><p>回到React，HTML Input展示组件如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">&#123; label, text, type, id, value, handleChange &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;label&#125;</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">type</span>=<span class="string">&#123;type&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&quot;form-control&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">id</span>=<span class="string">&#123;id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">Input.propTypes = &#123;</span><br><span class="line">  <span class="attr">label</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">text</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">type</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">id</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">value</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">handleChange</span>: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Input;</span><br></pre></td></tr></table></figure><p>此时，我们就可以更新容器组件，以包含文本输入框，即 Input 展示组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">&quot;../presentational/Input&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">seo_title</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; [event.target.id]: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; seo_title &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;article-form&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;SEO title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">label</span>=<span class="string">&quot;seo_title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">id</span>=<span class="string">&quot;seo_title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">value</span>=<span class="string">&#123;seo_title&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">handleChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormContainer;</span><br></pre></td></tr></table></figure><p>是时候把所有这些东西联系起来了。</p><p>Webpack期望 entry point(入口点)为 <code>./src/index.js</code></p><p>创建 <code>./src/index.js</code>，并使用<code>import</code>指令将容器组件引入其中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FormContainer <span class="keyword">from</span> <span class="string">&quot;./js/components/container/FormContainer&quot;</span>;</span><br></pre></td></tr></table></figure><p>有了这个，我们就可以通过运行以下命令来创建我们的包了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>给Webpack一秒钟，看看bundle(包)就生产了！</p><p>bundle(包)将被放入 <code>./dist/main.js</code>。</p><p>现在让我们通过将bundle(包)包含在HTML页面中来实现我们的React实战。</p><p>如何使用webpack 4和 Babel 构建 React 应用：HTML webpack插件 (html-webpack-plugin，html-loader)</p><p>要显示我们的 React 表单，我们必须告诉 webpack生产一个HTML页面。生产的 bundle(包)将放在 <code>&lt;script&gt;&lt;/script&gt;</code>标签内。</p><p>webpack需要两个额外的组件来处理HTML： html-webpack-plugin 和 html-loader。</p><p>通过以下命令添加依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin html-loader --save-dev</span><br></pre></td></tr></table></figure><p>然后更新webpack配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebPackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;html-loader&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来<code>./src/index.html</code>中创建一个HTML文件(可以随意使用你喜欢的CSS库)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>How to set up React, Webpack, and Babel<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row mt-5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4 offset-md-1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Create a new article<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;create-article-form&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- form --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还剩下最后一件事！我们必须告诉我们React组件将自己渲染到 <code>&lt;div id=&quot;create-article-form&quot;&gt;&lt;/div&gt;</code>标签中。</p><p>打开<code>./src/js/components/container/FormContainer.js</code>并在文件底板添加以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">&quot;create-article-form&quot;</span>);</span><br><span class="line">wrapper ? ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">FormContainer</span> /&gt;</span></span>, wrapper) : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>关闭并保存文件。</p><p>现在再次运行构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>并查看 <code>./dist</code> 文件夹。 你应该看到生成的HTML。</p><p>使用webpack，无需在HTML文件中包含你的JavaScript：bundle(包)将自动注入页面。</p><p>在浏览器中打开<code>./dist/index.html</code>：你应该可以看到React表单了。</p><h2><span id="how-to-set-up-react-webpack-and-babel-webpack-dev-server">How to set up React, webpack, and Babel: webpack dev server</span></h2><p>每次更改文件时，你应该不希望每次都需要键入 <code>npm run build</code>来重新构建项目。</p><p>只需3行配置即可启动并运行开发服务器。</p><p>配置后，webpack将在浏览器中启动你的应用程序。</p><p>此外，每次在修改后保存文件时，webpack dev server都会自动刷新浏览器的窗口。</p><p>要设置webpack dev server，请先通过以下命令安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>打开 <code>package.json</code>添加启动脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --open --mode development&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>现在执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>webpack dev server会为每个更新的文件自动刷新浏览器窗口。</p><p><img src="/img/react/react-webpack-babel-webpack-dev-server.png" alt="webpack dev server"></p><h2><span id="how-to-set-up-react-webpack-and-babel-wrapping-up">How to set up React, webpack, and Babel: wrapping up</span></h2><p>React主要用于创建单页面应用程序。但它也可以适用于任何网站。</p><p>通过组合webpack 和 Babel，可以将一堆 React组件转换为适合分发的 bundle(包).</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Deploy a MongoDB Sharded Cluster on CentOS 7</title>
      <link href="/2018/10/31/mongo/deploying-mongodb-shared-cluster-on-centos-7/"/>
      <url>/2018/10/31/mongo/deploying-mongodb-shared-cluster-on-centos-7/</url>
      
        <content type="html"><![CDATA[<p><strong>Sharding</strong> is a MongoDB process to store data-set across different machines. It allows you to perform a horizontal scale of data and to partition all data across independent instances. Sharding allows you to add more machines based on data growth to your stack.</p><span id="more"></span><h2><span id="sharding-and-replication">Sharding and Replication</span></h2><p>Let’s make it simple. When you have collections of music, <code>Sharding</code> will save and keep your music collections in diferent folders on different instances or replica sets while <code>Replication</code> is just syncing your music collections to other instances.</p><h2><span id="threee-sharding-components">Threee Sharding Components</span></h2><ul><li><strong>Shard</strong> Used to store all data. And in a production environment, each shard is replica sets. Provides high-availability and data consistency.</li><li><strong>Config Server</strong> Used to store cluster metadata, and contains a mapping of cluster data set and shards. This data is used by mongos/query server to deliver operations. It’s recommended to use more than 3 instances in production.</li><li><strong>Mongos/Query Router</strong> This is just mongo instances runing as application interfaces. The application will make requests to the <code>mongos</code> instance, and then <code>mongos</code> will deliver the requests using shard key to the shards replica sets.</li></ul><h2><span id="prerequisites">Prerequisites</span></h2><ul><li>2 centOS 7 server as Config Replica Sets</li><li>10.0.15.31      configsvr1</li><li>10.0.15.32      configsvr2</li><li>4 CentOS 7 server as Shard Replica Sets</li><li>10.0.15.21      shardsvr1</li><li>10.0.15.22      shardsvr2</li><li>10.0.15.23      shardsvr3</li><li>10.0.15.24      shardsvr4</li><li>1 CentOS 7 server as mongos/Query Router</li><li>10.0.15.11       mongos</li><li>Root privileges</li><li>Each server connected to another server</li></ul><h2><span id="step-1-disable-selinux-and-configure-hosts">Step 1 - Disable SELinux and Configure Hosts</span></h2><p>In this tutorial, we will disable SELinux. Change SELinux configuration from ‘enforcing’ to ‘disabled’.</p><p>Connect to all nodes through OpenSSH.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@SERVERIP</span><br></pre></td></tr></table></figure><p>Disable SELinux by editing the configuration file.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/selinux</span><br></pre></td></tr></table></figure><p>Change SELINUX value to ‘disabled’.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>Save and exit.</p><p>Next, edit the hosts file on each server.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>Paste the following hosts configuration:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10.0.15.31      configsvr1</span><br><span class="line">10.0.15.32      configsvr2</span><br><span class="line">10.0.15.11      mongos</span><br><span class="line">10.0.15.21      shardsvr1</span><br><span class="line">10.0.15.22      shardsvr2</span><br><span class="line">10.0.15.23      shardsvr3</span><br><span class="line">10.0.15.24      shardsvr4</span><br></pre></td></tr></table></figure><p>Save and exit.</p><p>Now restart all servers using the reboot command.</p><p>reboot</p><h2><span id="step-2-install-mongodb-on-all-instances">Step 2 - Install MongoDB on all instances</span></h2><p>We will use the latest MongoDB version (3.4) for all instances. Add new MongoDB repository by executing the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;&#x27;EOF&#x27; &gt;&gt; /etc/yum.repos.d/mongodb.repo</span><br><span class="line">[mongodb-org-3.4]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>Now install MongoDB 3.4 from mongodb repository using the following yum command.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install mongodb-org</span><br></pre></td></tr></table></figure><p>After mongodb is installed, you can use the ‘mongo’ or ‘mongod’ command.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --version</span><br></pre></td></tr></table></figure><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/1.png" alt="mongod"></p><h2><span id="step-3-create-config-server-replica-set">Step 3 - Create Config Server Replica Set</span></h2><p>In the ‘prerequisites’ section, we’ve already defined config server with 2 machines ‘configsvr1’ and ‘configsvr2’. And in this step, we will configure it to be a replica set.</p><p>If there is a mongod service running on the server, stop it using the systemctl command.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mongod</span><br></pre></td></tr></table></figure><p>Edit the default mongodb configuration ‘mongod.conf’ using the Vim editor.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>Change the DB storage path to your own directory. We will use ‘/data/db1’ for the first server, and ‘/data/db2’ directory for the second config server.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">storage:</span><br><span class="line">   dbPath: /data/db1</span><br></pre></td></tr></table></figure><p>Change the value of the line ‘bindIP’ to your internal network addres - ‘configsvr1’ with IP address 10.0.15.31, and the second server with 10.0.15.32.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindIP: 10.0.15.31</span><br></pre></td></tr></table></figure><p>On the replication section, set a replication name.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replication:</span><br><span class="line">   replSetName: &quot;replconfig01&quot;</span><br></pre></td></tr></table></figure><p>And under sharding section, define a role of the instances. We will use these two instances as ‘configsvr’.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharding:</span><br><span class="line">   clusterRole: configsvr</span><br></pre></td></tr></table></figure><p>Save and exit.</p><p>Next, we must create a new directory for MongoDB data, and then change the owner of that directory to ‘mongod’ user.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/db1</span><br><span class="line">chown -R mongod:mongod /data/db1</span><br></pre></td></tr></table></figure><p>After this, start the mongod service with the command below.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>You can use the netstat command to check whether or not the mongod service is running on port 27017.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -plntu</span><br></pre></td></tr></table></figure><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/2.png" alt="Configure MongoDB"></p><p>Configsvr1 and Configsvr2 are ready for the replica set. Connect to the ‘configsvr1’ server and access the mongo shell.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@configsvr1</span><br><span class="line">mongo --host configsvr1 --port 27017</span><br></pre></td></tr></table></figure><p>Initiate the replica set name with all configsvr member using the query below.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: &quot;replconfig01&quot;,</span><br><span class="line">    configsvr: true,</span><br><span class="line">    members: [</span><br><span class="line">      &#123; _id : 0, host : &quot;configsvr1:27017&quot; &#125;,</span><br><span class="line">      &#123; _id : 1, host : &quot;configsvr2:27017&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>If you get a results <code>&#123; &quot;ok&quot; : 1 &#125;</code>, it means the configsvr is already configured with replica set.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/3.png" alt="Initiate the replica set name"></p><p>and you will be able to see which node is master and which node is secondary.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs.isMaster()</span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/4.png" alt="see which node is master and which node is secondary"></p><p>The configuration of Config Server Replica Set is done.</p><h2><span id="step-4-create-the-shard-replica-sets">Step 4 - Create the Shard Replica Sets</span></h2><p>In this step, we will configure 4 ‘centos 7’ servers as ‘Shard’ server with 2 ‘Replica Set’.</p><ul><li>2 server - ‘shardsvr1’ and ‘shardsvr2’ with replica set name: ‘shardreplica01’</li><li>2 server - ‘shardsvr3’ and ‘shardsvr4’ with replica set name: ‘shardreplica02’<br>Connect to each server, stop the mongod service (If there is service running), and edit the MongoDB configuration file.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mongod</span><br><span class="line">vim /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>Change the default storage to your specific directory.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">storage:</span><br><span class="line">   dbPath: /data/db1</span><br></pre></td></tr></table></figure><p>On the ‘bindIP’ line, change the value to use your internal network address.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindIP: 10.0.15.21</span><br></pre></td></tr></table></figure><p>On the replication section, you can use ‘shardreplica01’ for the first and second instances. And use ‘shardreplica02’ for the third and fourth shard servers.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replication:</span><br><span class="line">   replSetName: &quot;shardreplica01&quot;</span><br></pre></td></tr></table></figure><p>Next, define the role of the server. We will use all this as shardsvr instances.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharding:</span><br><span class="line">   clusterRole: shardsvr</span><br></pre></td></tr></table></figure><p>Save and exit.</p><p>Now, create a new directory for MongoDB data.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/db1</span><br><span class="line">chown -R mongod:mongod /data/db1</span><br></pre></td></tr></table></figure><p>Start the mongod service.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>Check MongoDB is running using the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -plntu</span><br></pre></td></tr></table></figure><p>You will see MongoDB is running on the local network address.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/5.png" alt="MongoDB is running on the local network address"></p><p>Next, create a new replica set for these 2 shard instances. Connect to the ‘shardsvr1’ and access the mongo shell.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@shardsvr1</span><br><span class="line">mongo --host shardsvr1 --port 27017</span><br></pre></td></tr></table></figure><p>Initiate the replica set with the name ‘shardreplica01’, and the members are ‘shardsvr1’ and ‘shardsvr2’.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(</span><br><span class="line">   &#123;</span><br><span class="line">     _id : &quot;shardreplica01&quot;,</span><br><span class="line">     members: [</span><br><span class="line">       &#123; _id : 0, host : &quot;shardsvr1:27017&quot; &#125;,</span><br><span class="line">       &#123; _id : 1, host : &quot;shardsvr2:27017&quot; &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>If there is no error, you will see results as below.</p><p>Results from <strong>shardsvr3</strong> and <strong>shardsvr4</strong> with replica set name <code>shardreplica02</code>.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/6.png" alt="Results from shardsvr3 and shardsvr4 with replica set name 'shardreplica02'."></p><p>Redo this step for <strong>shardsvr3</strong> and <strong>shardsvr4</strong> servers with different replica set name <code>shardreplica02</code>.</p><p>Now we’ve created 2 replica sets - <code>shardreplica01</code> and <code>shardreplica02</code> - as the shard.</p><h2><span id="step-5-configure-mongosquery-router">Step 5 - Configure mongos/Query Router</span></h2><p>The ‘Query Router’ or mongos is just instances that run ‘mongos’. You can run mongos with the configuration file, or run with just a command line.</p><p>Login to the mongos server and stop the MongoDB service.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@mongos  </span><br><span class="line">systemctl stop mongod</span><br></pre></td></tr></table></figure><p>Run mongos with the command line as shown below.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos --configdb &quot;replconfig01/configsvr1:27017,configsvr2:27017&quot;</span><br></pre></td></tr></table></figure><p>Use the ‘–configdb’ option to define the config server. If you are on production, use at least 3 config servers.</p><p>You should see results similar to the following.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Successfully connected to configsvr1:27017</span><br><span class="line">Successfully connected to configsvr2:27017</span><br></pre></td></tr></table></figure><p>mongos instances are running.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/7.png" alt="Configure mongos/Query Router"></p><h2><span id="step-6-add-shards-to-mongosquery-router">Step 6 - Add shards to mongos/Query Router</span></h2><p>Open another shell from the previous step, connect to the mongos server again, and access the mongo shell.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@mongos</span><br><span class="line">mongo --host mongos --port 27017</span><br></pre></td></tr></table></figure><p>Add shard server with the sh mongodb query.</p><p>For <code>shardreplica01</code> instances:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard( &quot;shardreplica01/shardsvr1:27017&quot;)</span><br><span class="line">sh.addShard( &quot;shardreplica01/shardsvr2:27017&quot;)</span><br></pre></td></tr></table></figure><p>For <code>shardreplica02</code> instances:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard( &quot;shardreplica02/shardsvr3:27017&quot;)</span><br><span class="line">sh.addShard( &quot;shardreplica02/shardsvr4:27017&quot;)</span><br></pre></td></tr></table></figure><p>Make sure there is no error and check the shard status.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p>You will see sharding status similar to the way what the following screenshot shows.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/8.png" alt="Add shards to mongos/Query Router"></p><p>We have 2 shard replica set and 1 mongos instance running on our stack.</p><h2><span id="step-7-testing">Step 7 - Testing</span></h2><p>To test the setup, access the mongos server mongo shell.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@mongos</span><br><span class="line">mongo --host mongos --port 27017</span><br></pre></td></tr></table></figure><p><strong>Enable Sharding for a Database</strong></p><p>Create a new database and enable sharding for the new database.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use lemp</span><br><span class="line">sh.enableSharding(&quot;lemp&quot;)</span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/9.png" alt="Enable Sharding for a Database"></p><p>Now see the status of the database, it’s has been partitioned to the replica set ‘shardreplica01’.</p><p><strong>Enable Sharding for Collections</strong></p><p>Next, add new collections to the database with sharding support. We will add new collection named ‘stack’ with shard collection ‘name’, and then see database and collections status.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(&quot;lemp.stack&quot;, &#123;&quot;name&quot;:1&#125;)</span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/10.png" alt="Enable Sharding for Collections"></p><p>New collections ‘stack’ with shard collection ‘name’ has been added.</p><p><strong>Add documents to the collections ‘stack’.</strong></p><p>Now insert the documents to the collections. When we add documents to the collection on sharded cluster, we must include the ‘shard key’.</p><p>In the example below, we are using shard key ‘name’, as we added when enabling sharding for collections.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.stack.save(&#123;</span><br><span class="line">    &quot;name&quot;: &quot;LEMP Stack&quot;,</span><br><span class="line">    &quot;apps&quot;: [&quot;Linux&quot;, &quot;Nginx&quot;, &quot;MySQL&quot;, &quot;PHP&quot;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>As shown in the following screenshots, documents have been successfully added to the collection.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/11.png" alt="Add documents to the collections 'stack'."></p><p>If you want to test the database, you can connect to the replica set <code>shardreplica01</code> PRIMARY server and open the mongo shell. I’m logging in to the ‘shardsvr2’ PRIMARY server.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@shardsvr2</span><br><span class="line">mongo --host shardsvr2 --port 27017</span><br></pre></td></tr></table></figure><p>Check database available on the replica set.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br><span class="line">use lemp</span><br><span class="line">db.stack.find()</span><br></pre></td></tr></table></figure><p>You will see that the database, collections, and documents are available in the replica set.</p><p><img src="https://www.howtoforge.com/images/deploying_mongodb_sharded_cluster_on_centos_7/big/12.png" alt="MongoDB Sharded Cluster on CentOS 7 has been successfully installed and deployed."></p><p>MongoDB Sharded Cluster on CentOS 7 has been successfully installed and deployed.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.howtoforge.com/tutorial/deploying-mongodb-sharded-cluster-on-centos-7/">https://www.howtoforge.com/tutorial/deploying-mongodb-sharded-cluster-on-centos-7/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB分片集群搭建</title>
      <link href="/2018/10/31/mongo/mongo-cluster-sharding/"/>
      <url>/2018/10/31/mongo/mongo-cluster-sharding/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="环境">环境</span></h2><ul><li><p>CentOS 7.5</p></li><li><p>MongoDB 4.0.1</p></li><li><p>shard分片主机：</p><ul><li>shard1：IP：192.168.50.211</li><li>shard2：IP：192.168.50.212</li><li>shard3：IP：192.168.50.213<br>三台主机分别启动三个mongod实例：<ul><li>mongod1：端口：27017</li><li>mongod2：端口：27018</li><li>mongod3：端口：27019</li></ul></li></ul></li><li><p>configsrv主机：</p><ul><li>IP：192.168.50.214<ul><li>mongod1：端口：27019</li><li>mongod2：端口：37018</li><li>mongod3：端口：47019</li></ul></li></ul></li><li><p>route主机：192.168.50.215</p><ul><li>mongods：端口：27017</li></ul></li></ul><h2><span id="准备工作">准备工作</span></h2><ol><li>在所有节点安装mongodb-4 并创建相关文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/mongodb.repo</span><br><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB 4.0 Repository</span><br><span class="line">baseurl=https://mirrors.aliyun.com/mongodb/yum/redhat/\$releasever/mongodb-org/4.0/\$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">yum install -y mongodb-org</span><br><span class="line"></span><br><span class="line">mkdir -p /var/run/mongodb</span><br><span class="line">mkdir -p /data/mongod&#123;1..3&#125;</span><br><span class="line">mkdir -p /etc/mongo</span><br><span class="line">mkdir -p /tmp/mongod&#123;1..3&#125;</span><br><span class="line"></span><br><span class="line">chown -R mongod.mongod /data</span><br><span class="line">chown -R mongod.mongod /var/run/mongodb</span><br><span class="line">chown -R mongod.mongod /tmp/mongod&#123;1..3&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>生成key并复制至所有主机</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在192.168.50.211主机执行</span></span><br><span class="line"></span><br><span class="line">openssl rand -base64 756 &gt; /etc/mongo/mongo.key</span><br><span class="line">chown -R mongod.mongod /etc/mongo</span><br><span class="line">chmod -R 600 /etc/mongo</span><br><span class="line"></span><br><span class="line">scp -r /etc/mongo 192.168.50.212:/etc/</span><br><span class="line">scp -r /etc/mongo 192.168.50.213:/etc/</span><br><span class="line">scp -r /etc/mongo 192.168.50.214:/etc/</span><br><span class="line">scp -r /etc/mongo 192.168.50.215:/etc/</span><br></pre></td></tr></table></figure><h2><span id="配置configsvr">配置configsvr</span></h2><ol><li>在configsvr主机(IP：192.168.50.214)操作</li><li>生成三个configsvr的配置文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">configsvr1的配置文件</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/configsvc1.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod1.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod1</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true</span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod1.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod1</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: BigBoss</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">configsvr2的配置文件</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/configsvc2.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod2.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod2</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true</span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod2.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line">net:</span><br><span class="line">  port: 37019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod2</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: BigBoss</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">configsvr3的配置文件</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/configsvc3.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod3.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod3</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true</span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod3.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 47019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod3</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: BigBoss</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="3"><li>启动mongod：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /etc/mongo/configsvc1.conf</span><br><span class="line">mongod -f /etc/mongo/configsvc2.conf</span><br><span class="line">mongod -f /etc/mongo/configsvc3.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化configsrv副本集群</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27019</span><br><span class="line"></span><br><span class="line">rs.initiate(</span><br><span class="line">&#123;</span><br><span class="line">  _id: &quot;BigBoss&quot;,</span><br><span class="line">  version: 1,</span><br><span class="line">  protocolVersion: 1,</span><br><span class="line">  writeConcernMajorityJournalDefault: true,</span><br><span class="line">  configsvr: true,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      host: &quot;192.168.50.214:27019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 66,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;YES&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 1,</span><br><span class="line">      host: &quot;192.168.50.214:37019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 55,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 2,</span><br><span class="line">      host: &quot;192.168.50.214:47019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 33,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  settings: &#123;</span><br><span class="line">    chainingAllowed : true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看副本集状态</span></span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure><h2><span id="配置shard1副本集">配置shard1副本集</span></h2><ol><li>在shard1主机(IP：192.68.50.211)操作</li><li>生成三个mongod的配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mongod1.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod1.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod1.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod1</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod1.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod1</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard1</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod2.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod2.conf</span><br><span class="line"></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod2.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod2</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod2.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27018</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod2</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard1</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod3.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod3.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod3.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod3</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod3.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod3</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard1</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="3"><li>启动mongod</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /etc/mongo/mongod1.conf</span><br><span class="line">mongod -f /etc/mongo/mongod2.conf</span><br><span class="line">mongod -f /etc/mongo/mongod3.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化shard1副本集</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line"></span><br><span class="line">rs.initiate(</span><br><span class="line">&#123;</span><br><span class="line">  _id: &quot;shard1&quot;,</span><br><span class="line">  version: 1,</span><br><span class="line">  protocolVersion: 1,</span><br><span class="line">  writeConcernMajorityJournalDefault: true,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      host: &quot;192.168.50.211:27017&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 66,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;YES&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 1,</span><br><span class="line">      host: &quot;192.168.50.211:27018&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 55,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 2,</span><br><span class="line">      host: &quot;192.168.50.211:27019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 33,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  settings: &#123;</span><br><span class="line">    chainingAllowed : true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看副本集状态</span></span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure><h2><span id="配置shard2副本集">配置shard2副本集</span></h2><ol><li>在shard2主机(IP：192.168.50.212)操作</li><li>生成三个mongod的配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mongod1.conf配置文件:</span></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod1.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod1.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod1</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod1.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod1</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard2</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod2.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod2.conf</span><br><span class="line"></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod2.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod2</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod2.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27018</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod2</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard2</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod3.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod3.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod3.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod3</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod3.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod3</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard2</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="3"><li>启动mongod</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /etc/mongo/mongod1.conf</span><br><span class="line">mongod -f /etc/mongo/mongod2.conf</span><br><span class="line">mongod -f /etc/mongo/mongod3.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化shard2副本集</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line"></span><br><span class="line">rs.initiate(</span><br><span class="line">&#123;</span><br><span class="line">  _id: &quot;shard2&quot;,</span><br><span class="line">  version: 1,</span><br><span class="line">  protocolVersion: 1,</span><br><span class="line">  writeConcernMajorityJournalDefault: true,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      host: &quot;192.168.50.212:27017&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 66,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;YES&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 1,</span><br><span class="line">      host: &quot;192.168.50.212:27018&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 55,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 2,</span><br><span class="line">      host: &quot;192.168.50.212:27019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 33,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  settings: &#123;</span><br><span class="line">    chainingAllowed : true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看shard2副本集状态</span></span><br><span class="line"></span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure><h2><span id="配置shard3副本集">配置shard3副本集</span></h2><ol><li>在shard3主机(IP：192.168.50.203)操作</li><li>生成三个mongod的配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mongod1.conf配置文件:</span></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod1.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod1.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod1</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod1.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod1</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard3</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod2.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod2.conf</span><br><span class="line"></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod2.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod2</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod2.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27018</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod2</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard3</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">mongod3.conf配置文件:</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/mongod3.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod3.log</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /data/mongod3</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">  wiredTiger:</span><br><span class="line">    engineConfig:</span><br><span class="line">      directoryForIndexes: true     </span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod3.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27019</span><br><span class="line"><span class="meta">  #</span><span class="bash">bindIp: 0.0.0.0  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span></span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp/mongod3</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: shard3</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="3"><li>启动mongod</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /etc/mongo/mongod1.conf</span><br><span class="line">mongod -f /etc/mongo/mongod2.conf</span><br><span class="line">mongod -f /etc/mongo/mongod3.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化shard3副本集</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line"></span><br><span class="line">rs.initiate(</span><br><span class="line">&#123;</span><br><span class="line">  _id: &quot;shard3&quot;,</span><br><span class="line">  version: 1,</span><br><span class="line">  protocolVersion: 1,</span><br><span class="line">  writeConcernMajorityJournalDefault: true,</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      host: &quot;192.168.50.213:27017&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 66,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;YES&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 1,</span><br><span class="line">      host: &quot;192.168.50.213:27018&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 55,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      _id: 2,</span><br><span class="line">      host: &quot;192.168.50.213:27019&quot;,</span><br><span class="line">      arbiterOnly: false,</span><br><span class="line">      buildIndexes: true,</span><br><span class="line">      hidden: false,</span><br><span class="line">      priority: 33,</span><br><span class="line">      tags: &#123;</span><br><span class="line">        BigBoss: &quot;NO&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      slaveDelay: 0,</span><br><span class="line">      votes: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  settings: &#123;</span><br><span class="line">    chainingAllowed : true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看shard3副本集状态</span></span><br><span class="line"></span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure><h2><span id="配置route">配置route</span></h2><ol><li>创建mongos配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">route是无状态的，在任何一台主机启动都行，只要能够连接至configsrv即可</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/mongo/route.conf</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /var/log/mongodb/mongod.log</span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # fork and run in background</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod.pid  # location of pidfile</span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  bindIpAll: true</span><br><span class="line">  maxIncomingConnections: 500</span><br><span class="line">  unixDomainSocket:</span><br><span class="line">    enabled: true</span><br><span class="line">    pathPrefix: /tmp</span><br><span class="line">    filePermissions: 0700</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  keyFile: /etc/mongo/mongo.key</span><br><span class="line"><span class="meta">#</span><span class="bash">  authorization: enabled</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">replication:</span></span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">  configDB: BigBoss/192.168.50.214:27019,192.168.50.214:37019,192.168.50.214:47019</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="2"><li>启动mongos并设置一个连接的账号密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">mongos -f /etc/mongo/route.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">连接</span></span><br><span class="line">mongo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置管理员账号密码</span></span><br><span class="line">use admin</span><br><span class="line"></span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: &quot;root&quot;,</span><br><span class="line">    pwd: &quot;123456&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;__system&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><ol start="3"><li>重连至mongodb</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mongo -uroot -p123456  --authenticationDatabase admin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加分片主机至集群中</span></span><br><span class="line">sh.addShard(&quot;shard1/192.168.50.211:27017,192.168.50.211:27018,192.168.50.211:27019&quot;)</span><br><span class="line">sh.addShard(&quot;shard2/192.168.50.212:27017,192.168.50.212:27018,192.168.50.212:27019&quot;)</span><br><span class="line">sh.addShard(&quot;shard3/192.168.50.213:27017,192.168.50.213:27018,192.168.50.213:27019&quot;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看状态</span></span><br><span class="line">sh.status()</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###为了展示出效果，修改一下默认的chunksize大小,这里修改为1M</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">默认的chunksize大小为64M，示例修改命令如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">use config</span></span><br><span class="line"><span class="meta">#</span><span class="bash">db.settings.save( &#123; _id:<span class="string">&quot;chunksize&quot;</span>, value: &lt;sizeInMB&gt; &#125; )</span></span><br><span class="line"></span><br><span class="line">use config</span><br><span class="line">db.settings.save( &#123; _id:&quot;chunksize&quot;, value: 1 &#125; )</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">为<span class="built_in">test</span>数据库开启分片</span></span><br><span class="line"><span class="meta">#</span><span class="bash">选择一个片键age并指定一个集合mycoll对其进行分片</span></span><br><span class="line"></span><br><span class="line">sh.enableSharding(&quot;test&quot;)</span><br><span class="line">sh.shardCollection(&quot;test.mycoll&quot;, &#123;&quot;age&quot;: 1&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试分片，写入数据到数据库中</span></span><br><span class="line"></span><br><span class="line">use test</span><br><span class="line">for (i = 1; i &lt;= 10000; i++) db.mycoll.insert(&#123;age:(i%100), name:&quot;bigboss_user&quot;+i, address:i+&quot;, Some Road, Zhengzhou, Henan&quot;, country:&quot;China&quot;, course:&quot;cousre&quot;+&quot;(i%12)&quot;&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">写入完成之后就可以查看分片信息了</span></span><br><span class="line"></span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka技术架构的一些架构建议</title>
      <link href="/2018/10/26/ideal/ideal-reference/"/>
      <url>/2018/10/26/ideal/ideal-reference/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="社交设计">社交设计</span></h2><p><a href="http://serendip.me/">Serendip.me</a>为人们提供<strong>社交音乐服务</strong>，帮助人们发现朋友们分享的优秀音乐，并为他们介绍“知音”——那些靠近他们的社交圈子，有相似音乐品味的陌生人。</p><p>serendip运行在AWS智商，采用了如下这些技术：<a href="http://www.scala-lang.org/">scala</a>(还有一些Java)，<a href="http://akka.io/">akka</a>(用来处理并发)，<a href="http://www.playframework.com/">Play</a>框架(Web和API前端)，<a href="http://www.mongodb.org/">MongoDB</a>和<a href="http://elasticsearch.org/">Elasticsearch</a>。</p><h2><span id="技术栈的选择">技术栈的选择</span></h2><p>Serendip的主要功能是从公共音乐服务中收集Twitter上分享的所有音乐，所以它需要处理大量的数据，所以Serendip在选择语言和技术时，首先要考虑它们的扩展能力。</p><p>因为JVM久经考验的性能和工具，并且还有很多采用这门语言开发的开源系统(比如Elasticsearch)，所以他们选择JVM作为系统的基石。</p><p>而在JVM的体系中，scala又脱颖而出，成为了一个有趣的选择。Scala可以用现代的方式写代码，又可以跟Java全面互通。此外还有一个很重要的原因，akka actor框架是非常合适的流处理基础设施(绝对是！)。刚刚开始流行起来的Play框架看起来也很不错。Serendip开始于2011年初，当时这些都是非常前沿的技术。到了2011年末，scala和akka合并成<a href="http://typesafe.com/">Typesafe</a>，Play也在不久之后加入。</p><p>选择MongoDB是因为它对开发者友好，易用，功能集和可能的扩展能力(采用了自动分片技术)。但因为Serendip使用和查询数据的方式需要在MongoDB上创建很多大索引，而这样会很快引发性能和内存方面的问题。所以他们主要是用MongoDB存储键-值文档，还有几个需要计数器的功能依赖于它的原子增长。</p><p>事实证明，这样使用时MongoDB非常牢靠。还容易操作，但主要是因为尽量避免使用分片，并且只有一个复制集(MongoDB的分片架构相当复杂)。</p><p>查询数据需要一个完全成熟的搜索系统。在开源的搜索解决方案中，Elasticsearch是扩展性最强，并且面向云端的系统。它有动态索引机制，还提供了很多搜索和切面的可能性，可以在其上构建很多功能。因此，Elasticsearch成为了serendip架构中的一个中心组件。</p><p>Serendip决定自己管理MongoDB和Elasticsearch，主要有两个原因。第一，Serendip要完全控制两个系统。不想在软件的升级/降级上依赖于其它元素。第二，因为serendip要处理大量数据，采用托管方案要比他们直接在EC2上自己管理昂贵得多。</p><h2><span id="一些数字">一些数字</span></h2><p>Serendip的“抽水泵” (处理Twitter公众流和Facebook用户订阅源的那部分)每天要消化大概5,000,000条信息项。这些信息项要经过一系列的“过滤器”，对它们进行检测，并解析出受支持服务(YouTube、Soundcloud、Bandcamp等)上的音乐链接，还要添加一些元数据上去。抽水泵和过滤器是akka的actor，并且整个过程是用单个m1.large EC2管理的。如果需要，可以用akka的远程actor将任务分发到集群中，轻松实现系统扩展。</p><p>从这些信息项中，Serendip每天大概能得到850,000条有效的信息项(也就是真的包含相关音乐链接的信息项)。这些信息项在Elasticsearch中索引(还要在MongoDB中备份并持续计数)。因为每条有效的信息项都要更新几个对象，所以在Elasticsearch中的索引率大约为40条/秒。</p><p>Serendip在Elasticsearch中保留一个月的信息项索引(微博和帖子)。每个月的索引大概包含25M信息项，有3个分片。集群运行着4个节点，每个都在m2.2xlarge实例上。这个配置有足够的内存运行Serendip所需的数据搜索。</p><p>Serendip的MongoDB集群的操作频率大概是100次写/秒和300次读/秒，因为它处理更多的数据类型、技术和统计数据更新。复制集的主节点跑在一个m2.2xlarge实例上，副节点在一个m1.xlarge实例上。</p><h2><span id="构建订阅源">构建订阅源</span></h2><p>在设计Serendip主音乐订阅源的架构时，想让订阅源是动态的，并且可以根据用户的动作和输入作出反应。比如说，如果某位用户将一首歌标为“摇滚”，或将某位艺术家标为“趾高气昂”，那么这些动作应该马上反应到订阅源上。如果用户“不喜欢”一位艺术家，那以后就不应该再播放那些音乐。</p><p>并且这个订阅源应该是几个源头的组合，比如朋友分享的音乐，喜爱的艺术家的音乐，以及有相同音乐品味的“建议”用户分享的音乐。</p><p>这些需求意味着那种“fan-out-on-write”式的订阅源创建方式可能并不合适。应该实时构建订阅源，把跟用户相关的所有信号都用上。Elasticsearch的功能可以构建出这种实时的订阅源生成器。</p><p>订阅源算法有几种选择信息项的“策略”，在每次订阅源的获取上都根据不同的比率动态组合。每个策略都会考虑到用户最近的动作和信号。策略的组合被转换成几种对鲜活数据的搜索，这些数据是不断地由Elasticsearch索引的。因为这些数据是基于时间的，并且索引每月创建一次，所以只需要查询全部数据中的一小部分子集。</p><p>Elasticsearch非常擅于处理这些搜索。它还提供了一种扩展这种架构的著名路径-通过增加分片数量扩展写操作。通过增加更多的复制和物理节点扩展搜索。</p><p>寻找“知音”的过程(根据用户的音乐品味进行匹配)充分利用了Elasticsearch的切面(聚合)能力。作为持续不断的社交流处理的一部分，系统通过计算顶级分享的艺术家来为它遇到的社交网络用户准备数据(在他们分享的音乐上使用切面搜索)。</p><p>当Serendip用户给出一个信号(播放音乐或跟订阅源交互)时，它能为那位用户重新触发一次知音计算过程。这个算法按照喜爱艺术家(这个是不断在更新的)列表来寻找匹配程度最高的其他用户，并用一些额外的参数作为权重，比如流行程度、分享次数等。然后再用另一组算法过滤掉垃圾邮件发送者(是的，有音乐垃圾邮件发送者)和异常值。</p><p>实践证明，这种处理能得出很好的结果，并不需要再用一套系统来运行更加复杂的聚类或推荐算法。</p><h2><span id="监测与部署">监测与部署</span></h2><p>Serendip用<a href="http://www.serverdensity.com/">ServerDensity</a>做系统监测和报警。对于初创公司而言，它是一种易于使用的托管方案，有像样的功能集和合理的价格。ServerDensity原生提供了服务器和MongoDB的监测。Serendi还大量使用了它报告定制指标的能力来报告内部系统统计数据。</p><p>内部统计数据采集机制负责采集系统内发生的所有动作，并把它们保留在一个MongoDB集合内。一个定期任务每隔一分钟从MongoDB中读取一次这些统计数据，并报告给ServerDensity。这样就可以用ServerDensity对Elasticsearch及运营数据进行监测和报警。</p><p>服务器的管理和部署是用亚马逊Elastic Beanstalk完成的。Elastic Beanstalk是AWS的受限PaaS解决方案。很容易上手，但它不是功能完整的PaaS，对于大部分常见用例而言，它的基本功能已经足够了。它提供了易用的自动扩展配置，还可以通过EC2完整访问。</p><p>应用程序的构建是由EC2上的Jenkins实例执行的。Play程序被打包成WAR。一个构建后置脚本将这个WAR作为新版本推送到Elastic Beanstalk上。这个新版本不会自动部署到服务器上-它的部署是手动完成的。通常是先部署到临时环境中进行测试，然后经过证实后再部署到生产环境中。</p><h2><span id="外卖">外卖</span></h2><p>作为结论，这里有一些在构建Serendip的过程中得到的最重要的经验教训，重要程度跟顺序没什么关系。</p><ol><li>知道如何扩展。一开始你可能并不需要扩展，但你得知道系统的每一部分能够如何扩展，以及能扩展到什么程度。如果扩展需要时间，要预先给你自己留出充足的时间。</li><li>为峰值做好准备。特别是在创业阶段，如果你总是接近满负荷运行，一个lifehacker或reddit帖子就能把你的系统宕掉。保留充足的边界空间，这样才能应对突发负载，或时刻准备好真正快速地扩展。</li><li>选择一门不会拖你后腿的语言。确保你所采用的技术在你的语言中有原生客户端，或者至少有维护得很活跃的一些。不要被等着类库更新给拖住。</li><li>相信炒作。你想要技术跟你的产品共同成长，不会过早死掉。一个充满活力的活跃社区，以及跟该项技术有关的一些噪音，是这种技术存活的良好迹象。</li><li>不要相信炒作。看看那些批判你正在评估的技术的帖子。它们可以告诉你它的弱点。但也不要太认真，当事情不能按照期望工作时，人们通常会变得情绪化。</li><li>玩得开心点。选择会让你兴奋的技术。要能让你觉得“哦，我能用它做的事情太酷啦”。毕竟那(也)是我们来这里的目的。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ideal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 搭建Spark2.3.1分布式集群</title>
      <link href="/2018/10/26/spark/spark-cluster-config/"/>
      <url>/2018/10/26/spark/spark-cluster-config/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="下载安装包">下载安装包</span></h2><ol><li>官方下载</li></ol><p>点击<a href="http://spark.apache.org/downloads.html">这里</a>下载，官方提供几种构建方式。为了节省时间，选择预先编译版本的hadoop。</p><ol start="2"><li>安装前提</li></ol><ul><li>JDK8</li><li>ZooKeeper，安装参考这里</li><li>Hadoop，安装参考这里</li><li>Scala</li></ul><p>注意：从Spark2.0版开始，默认使用Scala 2.11构建。Scala 2.10用户应该下载Spark源包并使用<a href="https://spark.apache.org/docs/latest/building-spark.html#building-for-scala-210">Scala2.10</a>支持构建。</p><ol start="3"><li>集群规划</li></ol><table><thead><tr><th style="text-align:center">节点名称</th><th style="text-align:center">IP</th><th style="text-align:center">ZooKeeper</th><th style="text-align:center">Master</th><th style="text-align:center">Worker</th></tr></thead><tbody><tr><td style="text-align:center">spark-node1</td><td style="text-align:center">192.168.50.200</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">主Master</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">spark-node2</td><td style="text-align:center">192.168.50.201</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center">备Master</td><td style="text-align:center">Worker</td></tr><tr><td style="text-align:center">spark-node3</td><td style="text-align:center">192.168.50.202</td><td style="text-align:center">ZooKeeper</td><td style="text-align:center"></td><td style="text-align:center">Worker</td></tr></tbody></table><h2><span id="集群安装">集群安装</span></h2><ol><li>解压缩</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ tar zxvf spark-2.3.1-bin-hadoop2.7.tgz -C /opt/</span><br><span class="line">[xxx@spark-node1 ~]$ sudo ln -s /opt/spark-2.31-bin-hadoop2.7 /opt/spark</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><ol><li>进入配置文件所在目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ <span class="built_in">cd</span> /opt/spark/conf/</span><br><span class="line">[xxx@spark-node1 ~]$ ll</span><br><span class="line">total 36K</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu  996 Jun  1 16:49 docker.properties.template</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu 1.1K Jun  1 16:49 fairscheduler.xml.template</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu 2.0K Jun  1 16:49 log4j.properties.template</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu 7.7K Jun  1 16:49 metrics.properties.template</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu  865 Jun  1 16:49 slaves.template</span><br><span class="line">-rw-rw-r--. 1 galudisu galudisu 1.3K Jun  1 16:49 spark-defaults.conf.template</span><br><span class="line">-rwxrwxr-x. 1 galudisu galudisu 4.2K Jun  1 16:49 spark-env.sh.template</span><br></pre></td></tr></table></figure><ol start="2"><li>复制<code>spark-env.sh.template</code>并重命名为<code>spark-env.sh</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 conf]$ cp spark-env.sh.template spark-env.sh</span><br><span class="line">[xxx@spark-node1 conf]$ vim spark-env.sh</span><br></pre></td></tr></table></figure><p>编辑并在文件末尾添加如下配置内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定默认master的ip或主机名</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=node21  </span><br><span class="line"><span class="comment">#指定maaster提交任务的默认端口为7077    </span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077 </span><br><span class="line"><span class="comment">#指定masster节点的webui端口       </span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_WEBUI_PORT=8080 </span><br><span class="line"><span class="comment">#每个worker从节点能够支配的内存数 </span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMORY=1g        </span><br><span class="line"><span class="comment">#允许Spark应用程序在计算机上使用的核心总数（默认值：所有可用核心）</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_CORES=1    </span><br><span class="line"><span class="comment">#每个worker从节点的实例（可选配置） </span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_INSTANCES=1   </span><br><span class="line"><span class="comment">#指向包含Hadoop集群的（客户端）配置文件的目录，运行在Yarn上配置此项   </span></span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/opt/module/hadoop-2.7.6/etc/hadoop</span><br><span class="line"><span class="comment">#指定整个集群状态是通过zookeeper来维护的，包括集群恢复</span></span><br><span class="line"><span class="built_in">export</span> SPARK_DAEMON_JAVA_OPTS=<span class="string">&quot;      </span></span><br><span class="line"><span class="string">-Dspark.deploy.recoveryMode=ZOOKEEPER </span></span><br><span class="line"><span class="string">-Dspark.deploy.zookeeper.url=node21:2181,node22:2181,node23:2181</span></span><br><span class="line"><span class="string">-Dspark.deploy.zookeeper.dir=/spark&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>复制<code>slaves.template</code>成<code>slaves</code>，并修改配置内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 conf]$ cp slaves.template slaves</span><br><span class="line">[xxx@spark-node1 conf]$ vim slaves</span><br></pre></td></tr></table></figure><p>修改从节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark-node2</span><br><span class="line">spark-node3</span><br></pre></td></tr></table></figure><ol start="4"><li>将安装包分发给其它节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 opt]$ scp -r spark-2.31-bin-hadoop2.7 xxx@spark-node2:/opt/</span><br><span class="line">[xxx@spark-node1 opt]$ scp -r spark-2.31-bin-hadoop2.7 xxx@spark-node3:/opt/</span><br></pre></td></tr></table></figure><p>修改spark-node2节点上<code>conf/spark-env.sh</code>配置的MasterIP为<code>SPARK_MASTER_IP=spark-node2</code></p><ol start="3"><li>配置环境变量</li></ol><p>所有节点均要配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/opt/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/sbin</span><br><span class="line">[xxx@spark-node1 spark]$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2><span id="启动集群">启动集群</span></h2><ol><li>启动ZooKeeper集群</li></ol><p>所有ZooKeeper节点均要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ zkServer.sh start</span><br></pre></td></tr></table></figure><ol start="2"><li>启动Hadoop集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ start-dfs.sh</span><br><span class="line">[xxx@spark-node2 ~]$ start-yarn.sh</span><br><span class="line">[xxx@spark-node3 ~]$ yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Spark集群</li></ol><p>启动Spark：启动master节点：<code>sbin/start-master.sh</code> 启动worker节点：<code>sbin/start-slaves.sh</code><br>或者：<code>sbin/start-all.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>注意：备用master节点需要手动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 spark]$ sbin/start-master.sh</span><br></pre></td></tr></table></figure><ol start="4"><li>查看进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ jps</span><br><span class="line">2368 JobHistoryServer</span><br><span class="line">2928 Jps</span><br><span class="line">2227 DFSZKFailoverController</span><br><span class="line">2533 Master</span><br><span class="line">2006 JournalNode</span><br><span class="line">1512 NodeManager</span><br><span class="line">1610 NameNode</span><br><span class="line">1820 DataNode</span><br><span class="line"></span><br><span class="line">[xxx@spark-node2 spark]$ jps</span><br><span class="line">2256 DFSZKFailoverController</span><br><span class="line">1651 NameNode</span><br><span class="line">2435 Worker</span><br><span class="line">2101 JournalNode</span><br><span class="line">2854 Jps</span><br><span class="line">1576 NodeManager</span><br><span class="line">1209 ResourceManager</span><br><span class="line">1835 DataNode</span><br><span class="line"></span><br><span class="line">[xxx@spark-node3 spark]$ jps</span><br><span class="line">1796 DataNode</span><br><span class="line">2436 Jps</span><br><span class="line">1900 JournalNode</span><br><span class="line">1613 NodeManager</span><br><span class="line">2095 Worker</span><br></pre></td></tr></table></figure><h2><span id="验证集群ha">验证集群HA</span></h2><ol><li>看Web页面Master状态</li></ol><p>spark-node1是ALIVE状态，spark-node2为STANDBY状态，WebUI查看：<a href="http://spark-node1:8080/">http://spark-node1:8080/</a></p><p><img src="/img/spark/spark-master1.png" alt="spark-master1"><br><img src="/img/spark/spark-master2.png" alt="spark-master2"></p><p>从节点连接地址：<a href="http://spark-node2:8081">http://spark-node2:8081/</a></p><p><img src="/img/spark/spark-worker1.png" alt="spark-worker1"><br><img src="/img/spark/spark-worker2.png" alt="spark-worker2"></p><ol start="2"><li>验证HA的高可用</li></ol><p>手动干掉spark-node1上面的Master进程，spark-node2:8080将自动切换为ALIVE状态。</p><p><img src="/img/spark/spark-alive.png" alt="spark-alive"></p><ol start="3"><li>HA注意点</li></ol><ul><li>主备切换过程中不能提交Application。</li><li>主备切换过程中不影响已经在集群中运行的Application。因为Spark是粗粒度资源调度。</li></ul><p><img src="/img/spark/spark-ha.png" alt="spark-ha"></p><h2><span id="集群提交命令方式">集群提交命令方式</span></h2><ol><li>Standalone模式</li></ol><h3><span id="standalone-client">Standalone-client</span></h3><ol><li>提交命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ ./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://spark-node1:7077 \</span><br><span class="line">--executor-memory 500m \</span><br><span class="line">--total-executor-cores 1 \</span><br><span class="line">examples/jars/spark-examples_2.11-2.3.1.jar 10</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 spark]$ ./bin/spark-submit --class org.apache.spark.exmaples.SparkPi \</span><br><span class="line">--master spark://spark-node1:7077 \</span><br><span class="line">--deploy-mode client \</span><br><span class="line">--executor-memory 500m \</span><br><span class="line">--total-executor-cores 1 \</span><br><span class="line">examples/jars/spark-examples_2.11-2.3.1.jar 10</span><br></pre></td></tr></table></figure><ol start="2"><li>提交原理图解</li></ol><p><img src="/img/spark/spark-standalone.png" alt="spark-standalone"></p><ol start="3"><li>执行流程</li></ol><ul><li>client模式提交任务后，会在客户端启动Driver进程。</li><li>Driver会向Master申请启动Application启动的资源。</li><li>资源申请成功，Driver端将task发送到worker端执行。</li><li>worker将task执行结果返回到Driver端。</li></ul><ol start="4"><li>总结</li></ol><p>client模式使用于测试调试程序。Driver进程是在客户端启动的，这里的客户端就是指提交应用程序的当前节点。在Driver端可以看到task执行的情况。生产环境下不能使用client模式，是因为：假设要提交100个Application到集群运行，Driver每次都会在client端启动，那么就会导致客户端100次网卡流量暴增的问题。</p><h3><span id="standalone-cluster">Standalone-cluster</span></h3><ol><li>提交命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ ./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark:spark-node1:7077 \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">examples/jars/spark-examples_2.11-2.3.1.jar 10</span><br></pre></td></tr></table></figure><ol start="2"><li>提交原理图解</li></ol><p><img src="/img/spark/spark-cluster.png" alt="spark-cluster"></p><ol start="3"><li>执行流程</li></ol><ul><li>cluster模式提交应用程序后，会向Master请求启动Driver。</li><li>Master接受请求，随机在集群一台节点启动Driver进程。</li><li>Driver启动后为当前的应用程序申请资源。</li><li>Driver端发送task到worker节点上执行。</li><li>worker将执行情况和执行结果返回给Driver端。</li></ul><ol start="4"><li>总结</li></ol><p>Driver进程是在集群某一台Worker上启动的，在客户端无法查看task的执行情况的。假设要提交100个application到集群运行，每次Driver会随机在集群中某一台Worker上启动，那么这100次网卡流量暴增的问题就散步在集群上。</p><ol start="2"><li>Yarn模式</li></ol><h3><span id="yarn-client">yarn-client</span></h3><ol><li>提交命令</li></ol><p>以client模式启动Spark应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class path.to.your.Class --master yarn --deploy-mode client [options] &lt;app jar&gt; [app options]</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ ./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode client \</span><br><span class="line">examples/jars/spark-examples_2.11-2.3.1.jar 10</span><br></pre></td></tr></table></figure><ol start="2"><li>提交原理图解</li></ol><p><img src="/img/spark/spark-yarn-standalone.png" alt="spark-yarn"></p><ol start="3"><li>执行流程</li></ol><ul><li>客户单提交一个Application，在客户端启动一个Driver进程。</li><li>应用程序启动后会向RS(ResourceManager)发送请求，启动AM(ApplicationMaster)的资源。</li><li>RS收到请求，随机选择一台NM(NodeManager)启动AM。这里的NM相当于Standalone中的Worker节点。</li><li>AM启动后，会向RS请求一批container资源，用于启动Executor。</li><li>RS会找到一批NM返回给AM，用于启动Executor。</li><li>AM会向NM发送命令启动Executor。</li><li>Executor启动后，会反向注册给Driver，Driver发送task到Executor，执行情况和结果返回给Driver端。</li></ul><ol start="4"><li>总结</li></ol><p>Yarn-client模式同样是适用于测试，因为Driver运行在本地，Driver会与yarn集群中的Executor进行大量的通信，会造成客户机网卡流量的大量增加。</p><p>ApplicationMaster的作用：</p><ul><li>为当前的Application申请资源</li><li>给NodeManager发送消息启动Executor</li></ul><p>注意：ApplicationMaster有launchExecutor和申请资源的功能，并没有作业调度的功能。</p><h3><span id="yarn-cluster">yarn-cluster</span></h3><ol><li>提交命令</li></ol><p>以cluster模式启动Spark应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class path.to.your.Class --master yarn --deploy-mode cluster [options] &lt;app jar&gt; [app options]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 spark]$ ./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">examples/jars/sprk-examples_2.11-2.3.1.jar 10</span><br></pre></td></tr></table></figure><ol start="2"><li>提交原理图解</li></ol><p><img src="/img/spark/spark-yarn-cluster.png" alt="spark-yarn"></p><ol start="3"><li>执行流程</li></ol><ul><li>客户机提交Application应用程序，发送请求到RS(ResourceManager),请求启动AM(ApplicationMaster)</li><li>RS收到请求后随机在一台NM(NodeManager)上启动AM(相当于Driver端)</li><li>AM启动，AM发送请求到RS，请求一批container用于启动Executor</li><li>RS返回一批NM节点给AM</li><li>AM连接到NM,发送请求到NM启动Executor</li><li>Executor反向注册到AM所在的节点的Driver，Driver发送task到Executor</li></ul><ol start="4"><li>总结</li></ol><p>Yarn-Cluster主要用于生产环境中，因为Driver运行在Yarn集群中某一台nodeManager中，每次提交任务的Driver所在的机器都是随机的，不会产生某一台机器网卡流量激增的现象，缺点是任务提交后不能看到日志。只能通过yarn查看日志。</p><p>ApplicationMaster的作用：</p><ul><li>为当前的Application申请资源</li><li>给NodeManager发送消息启动Executor</li><li>任务调度</li></ul><p>停止集群任务命令: <code>yarn application -kill applicationID</code></p><h2><span id="配置历史服务器">配置历史服务器</span></h2><ol><li>临时配置</li></ol><p>对本次提交的应用程序起作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./spark-shell --master spark://node21:7077 </span><br><span class="line">--name myapp1</span><br><span class="line">--conf spark.eventLog.enabled=<span class="literal">true</span></span><br><span class="line">--conf spark.eventLog.dir=hdfs://spark-node1:8020/spark/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>停止程序，在Web UI中Completed Applications对应的ApplicationID中能查看history.</p><ol start="2"><li>永久配置</li></ol><p><strong>spark-default.conf配置文件中配置History Server，对所有提交的Application都起作用</strong></p><p>在客户端节点，进入<code>../spark/conf/spark-defaults.conf</code>最后加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//开启记录事件日志的功能</span><br><span class="line">spark.eventLog.enabled          <span class="literal">true</span></span><br><span class="line">//设置事件日志存储的目录</span><br><span class="line">spark.eventLog.dir              hdfs://node21:8020/spark/<span class="built_in">test</span></span><br><span class="line">//设置HistoryServer加载事件日志的位置</span><br><span class="line">spark.history.fs.logDirectory   hdfs://node21:8020/spark/<span class="built_in">test</span></span><br><span class="line">//日志优化选项,压缩日志</span><br><span class="line">spark.eventLog.compress         <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动HistorySever：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-history-server.sh</span><br></pre></td></tr></table></figure><p>访问HistoryServer: spark-node1:18080，之后所有提交的应用程序运行状况都会被记录。</p><h2><span id="加入systemd">加入Systemd</span></h2><p>和前面ZooKeeper、HA的配置一样，将Spark的启动加入Systemd，让系统自动维护。在<code>/usr/lib/systemd/system/spark.serivce</code>加入</p><p>因为用了ZooKeeper集群做统一化管理，只需要master节点加入service即可。</p><p>spark-node1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Spark, Lightning-fast unified analytics engine</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target network-online.target</span><br><span class="line">Requires=network-online.target</span><br><span class="line">Wants=hadoop.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=galudisu</span><br><span class="line">Group=galudisu</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/opt/spark/sbin/start-all.sh &amp;</span><br><span class="line">ExecStop=/opt/spark/sbin/stop-all.sh &amp;</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">Environment=SPARK_HOME=/opt/spark</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>spark-node2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Spark, Lightning-fast unified analytics engine</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target network-online.target</span><br><span class="line">Requires=network-online.target</span><br><span class="line">Wants=hadoop.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=galudisu</span><br><span class="line">Group=galudisu</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/opt/spark/sbin/start-master.sh &amp;</span><br><span class="line">ExecStop=/opt/spark/sbin/stop-master.sh &amp;</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">Environment=SPARK_HOME=/opt/spark</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>又或者单独编写一个脚本执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop集群配置</title>
      <link href="/2018/10/22/spark/spark-hadoop-1/"/>
      <url>/2018/10/22/spark/spark-hadoop-1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="完全分布式集群ha">完全分布式集群(HA)</span></h2><ol><li>环境准备</li></ol><ul><li>修改IP</li><li>修改主机名及主机名和IP地址的映射</li><li>关闭防火墙</li><li>ssh免密登录</li><li>安装JDK，配置环境变量</li></ul><ol start="2"><li>集群规则</li></ol><table><thead><tr><th>节点名称</th><th>NN</th><th>JJN</th><th>DN</th><th>ZK/FC</th><th>ZK</th><th>RM</th><th>NM</th></tr></thead><tbody><tr><td>spark-node1</td><td>NameNode</td><td>JournalNode</td><td>DataNode</td><td>ZK/FC</td><td>ZooKeeper</td><td></td><td>NodeManager</td></tr><tr><td>spark-node2</td><td>NameNode</td><td>JournalNode</td><td>DataNode</td><td>ZK/FC</td><td>ZooKeeper</td><td>ResourceManager</td><td>NodeManager</td></tr><tr><td>spark-node3</td><td></td><td>JournalNode</td><td>DataNode</td><td></td><td>ZooKeeper</td><td>ResourceManager</td><td>NodeManager</td></tr></tbody></table><ol start="3"><li>安装Zookeeper集群</li></ol><p>安装详解参考：<a href="http://galudisu.info/2018/10/21/spark/spark-zookeeper-1/">CentOS 7.5 搭建Zookeeper集群与命令行操作</a></p><ol start="4"><li>设置SSH免密钥</li></ol><p>关于ssh免密钥的设置，要求每两台主机之前设置免密码，自己的主机与自己的主机之间也要设置免密码。这项操作可以在admin用户下执行，执行完毕公钥在<code>/home/xxx/.ssh/id_rsa.pub</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]<span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line">[xxx@spark-node1 ~]<span class="comment"># ssh-copy-id spark-node1</span></span><br><span class="line">[xxx@spark-node1 ~]<span class="comment"># ssh-copy-id spark-node2</span></span><br><span class="line">[xxx@spark-node1 ~]<span class="comment"># ssh-copy-id spark-node3</span></span><br></pre></td></tr></table></figure><p>spark-node1与spark-node2为namenode节点要相互免密钥 HDFS的HA</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 ~]<span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line">[xxx@spark-node2 ~]<span class="comment"># ssh-copy-id spark-node2</span></span><br><span class="line">[xxx@spark-node2 ~]<span class="comment"># ssh-copy-id spark-node1</span></span><br><span class="line">[xxx@spark-node2 ~]<span class="comment"># ssh-copy-id spark-node3</span></span><br></pre></td></tr></table></figure><p>spark-node2与spark-node3为yarn节点要相互免密钥 YARN的HA</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node3 ~]<span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line">[xxx@spark-node3 ~]<span class="comment"># ssh-copy-id spark-node3</span></span><br><span class="line">[xxx@spark-node3 ~]<span class="comment"># ssh-copy-id spark-node1</span></span><br><span class="line">[xxx@spark-node3 ~]<span class="comment"># ssh-copy-id spark-node2</span></span><br></pre></td></tr></table></figure><ol start="5"><li>安装配置Hadoop集群</li></ol><p>解压<code>hadoop-2.7.6.tar.gz</code> 到 <code>/opt/</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar zxvf hadoop-2.7.6.tar.gz -C /opt/</span><br></pre></td></tr></table></figure><p>创建软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/hadoop-2.7.6 /opt/hadoop</span><br></pre></td></tr></table></figure><p>配置Hadoop集群，配置文件都在<code>/opt/hadoop/etc/hadoop/</code>下，修改<code>hadoop-env.sh</code>，<code>mapred-env.sh</code>，<code>yarn-env.sh</code>的JAVA环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_191-amd64</span><br></pre></td></tr></table></figure><p>修改core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 把两个NameNode的地址组装成一个集群mycluster --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/data/ha/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定ZKFC故障自动切换转移 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node1:2181,spark-node2:2181,spark-node3:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置dfs副本数，默认3个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 完全分布式集群名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 集群中NameNode节点都有哪些 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.mycluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.mycluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.mycluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node2:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn1的http通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.mycluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node1:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.mycluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node2:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定NameNode元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://spark-node1:8485;spark-node2:8485;spark-node3:8485/mycluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置隔离机制，即同一时刻只能有一台服务器对外响应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>sshfence<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用隔离机制时需要ssh无秘钥登录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/admin/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明journalnode服务器存储目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/data/ha/jn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 关闭权限检查--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions.enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 访问代理类：client，mycluster，active配置失败自动切换实现方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.mycluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置自动故障转移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>　</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改mapred-site.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br><span class="line">vim mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mr框架为yarn方式 --&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mr历史服务器主机,端口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node1:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mr历史服务器WebUI主机,端口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-node1:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器的WEB UI上最多显示20000个历史的作业记录信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.joblist.cache.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>20000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置作业运行日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;yarn.app.mapreduce.am.staging-dir&#125;/history/done<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.intermediate-done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;yarn.app.mapreduce.am.staging-dir&#125;/history/done_intermediate<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.staging-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/hadoop-yarn/staging<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改slaves</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim slaves</span><br><span class="line">spark-node1</span><br><span class="line">spark-node2</span><br><span class="line">spark-node3</span><br></pre></td></tr></table></figure><p>修改yarn-site.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;!-- reducer获取数据的方式 --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;!--启用resourcemanager ha--&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;!--声明两台resourcemanager的地址--&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;rmCluster&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;spark-node2&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;spark-node3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;!--指定zookeeper集群的地址--&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;spark-node1:2181,spark-node2:2181,spark-node3:2181&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;!--启用自动恢复--&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;!--指定resourcemanager的状态信息存储在zookeeper集群--&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>拷贝hadoop到其它节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r hadoop-2.7.6/ xxx@spark-node2:/opt/</span><br><span class="line">scp -r hadoop-2.7.6/ xxx@spark-node3:/opt/</span><br></pre></td></tr></table></figure><p>配置Hadoop环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">## 末尾追加</span></span><br><span class="line"><span class="built_in">export</span>  HADOOP_HOME=/opt/hadoop-2.7.6</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure><ol start="5"><li>启动集群</li></ol><ol><li>在各个JournalNode节点上，输入以下命令启动journalnode服务：(前提zookeeper集群已启动)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[xxx@spark-node2 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[xxx@spark-node3 ~]$ hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure><p>启动Journalnode是为了创建<code>/data/ha/jn</code>，此时jn里面是空的</p><ol start="2"><li>在<code>[nn1 ]</code>上，对namenode进行格式化，并启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p><img src="/img/spark/hadoop-format.png" alt="hadoop-format"></p><p>格式化namenode，此时jn里面会产生集群ID等信息</p><p><img src="/img/spark/hadoop-id.png" alt="hadoop-id"></p><p>另外，<code>/data/ha/tmp</code>也会产生如下信息</p><p><img src="/img/spark/hadoop-tmp.png" alt="hadoop-tmp"></p><p>启动nn1上namenode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 current]$ hadoop-daemon.sh  start namenode</span><br><span class="line">starting namenode, logging to /opt/hadoop-2.7.6/logs/hadoop-admin-namenode-node21.out</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>[nn2]</code>上，同步nn1的元数据信息：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 ~]$ hdfs namenode -bootstrapStandby</span><br></pre></td></tr></table></figure><p><img src="/img/spark/hadoop-nn2.png" alt="hadoop-nn2"></p><ol start="4"><li>启动<code>[nn2]</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 ~]$ hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>[nn1]</code>上，启动所有datanode</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ hadoop-daemons.sh start datanode</span><br></pre></td></tr></table></figure><ol start="6"><li>查看web页面此时显示</li></ol><p><img src="/img/spark/hadoop-node1.png" alt="hadoop-node1"><br><img src="/img/spark/hadoop-node2.png" alt="hadoop-node2"></p><ol start="7"><li>手动切换状态，在各个namenode节点上启动DFSZK Failover Controller，先在哪台机器启动，哪个机器的namenode就是Active NameNode</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ hadoop-daemon.sh start zkfc</span><br><span class="line">[xxx@spark-node2 ~]$ hadoop-daemon.sh start zkfc</span><br></pre></td></tr></table></figure><p>或者强制手动其中一个节点变为Active</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 data]$ hdfs haadmin -transitionToActive nn1 --forcemanual</span><br></pre></td></tr></table></figure><p>web页面查看</p><p><img src="/img/spark/hadoop-active.png" alt="hadoop-active"></p><ol start="8"><li>自动切换状态，需要初始化HA在zookeeper中状态，先停掉hdfs服务，然后随便找一台zookeeper的安装节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 current]$ hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure><p>查看，此时会产生一个hadoop-ha目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@spark-node2 ~]<span class="comment"># zkCli.sh</span></span><br></pre></td></tr></table></figure><p>启动hdfs服务，查看namenode状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ start-dfs.sh</span><br></pre></td></tr></table></figure><ol start="9"><li>验证</li></ol><ul><li>将Active NameNode进程kill</li><li>将Active NameNode机器断开网络</li></ul><ol start="10"><li>启动yarn</li></ol><p>在spark-node2中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 ~]$ start-yarn.sh</span><br></pre></td></tr></table></figure><p>在spark-node3中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node3 ~]$ yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure><p>查看服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node2 ~]$ yarn rmadmin -getServiceState rm1</span><br><span class="line">active</span><br><span class="line">[xxx@spark-node2 ~]$ yarn rmadmin -getServiceState rm2</span><br><span class="line">standby</span><br></pre></td></tr></table></figure><p><img src="/img/spark/hadoop-yarn.png" alt="hadoop-yarn"></p><ol start="6"><li>测试集群</li></ol><ol><li>查看进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ start-dfs.sh </span><br><span class="line">[xxx@spark-node2 ~]$ start-yarn.sh </span><br><span class="line">[xxx@spark-node3 ~]$ yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx @ spark-node1 in ~ [10:29:20] </span></span><br><span class="line">$ jps</span><br><span class="line">3220 JournalNode</span><br><span class="line">3588 DataNode</span><br><span class="line">4967 Jps</span><br><span class="line">4378 NodeManager</span><br><span class="line">3725 DFSZKFailoverController</span><br><span class="line">3407 NameNode</span><br><span class="line"></span><br><span class="line"><span class="comment"># xxx @ spark-node2 in ~ [10:28:32] </span></span><br><span class="line">$ jps          </span><br><span class="line">3939 ResourceManager</span><br><span class="line">3380 NameNode</span><br><span class="line">3508 DataNode</span><br><span class="line">4040 NodeManager</span><br><span class="line">3660 DFSZKFailoverController</span><br><span class="line">4621 Jps</span><br><span class="line">3182 JournalNode</span><br><span class="line"></span><br><span class="line"><span class="comment"># xxx @ spark-node3 in ~ [10:28:09] </span></span><br><span class="line">$ jps          </span><br><span class="line">3188 JournalNode</span><br><span class="line">3989 Jps</span><br><span class="line">3784 ResourceManager</span><br><span class="line">3641 NodeManager</span><br><span class="line">3371 DataNode</span><br></pre></td></tr></table></figure><ol start="2"><li>任务提交</li></ol><p>上传文件到集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ hadoop fs -mkdir -p /user/galudisu/input</span><br><span class="line">[xxx@spark-node1 ~]$ mkdir -p  /opt/wcinput/</span><br><span class="line">[xxx@spark-node1 ~]$ vi  /opt/wcinput/wc.txt </span><br><span class="line">[xxx@spark-node1 ~]$ hadoop fs -put  /opt/wcinput/wc.txt /user/galudisu/input</span><br></pre></td></tr></table></figure><p>wc.txt文本内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop spark   storm</span><br><span class="line">hbase hive sqoop</span><br><span class="line">hadoop flink flume</span><br><span class="line">spark hadoop</span><br></pre></td></tr></table></figure><p>上传文件后查看文件存放在什么位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件存储路径</span><br><span class="line">[xxx@spark-node1 subdir0]$ <span class="built_in">pwd</span></span><br><span class="line">/opt/hadoop/data/ha/tmp/dfs/data/current/BP-1244373306-192.168.100.21-1527653416622/current/finalized/subdir0/subdir0</span><br><span class="line">查看文件内容</span><br><span class="line">[xxx@spark-node1 subdir0]$ cat blk_1073741825</span><br><span class="line">hadoop spark   storm</span><br><span class="line">hbase hive sqoop</span><br><span class="line">hadoop flink flume</span><br><span class="line">spark hadoop</span><br></pre></td></tr></table></figure><p>下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 opt]$ hadoop fs -get /user/admin/input/wc.txt</span><br></pre></td></tr></table></figure><p>执行wordcount程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxx@spark-node1 ~]$ hadoop jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.6.jar wordcount /user/galudisu/input /user/galudisu/output</span><br></pre></td></tr></table></figure><p>执行过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">18/10/22 10:44:06 INFO input.FileInputFormat: Total input paths to process : 1</span><br><span class="line">18/10/22 10:44:06 INFO mapreduce.JobSubmitter: number of splits:1</span><br><span class="line">18/10/22 10:44:07 INFO mapreduce.JobSubmitter: Submitting tokens <span class="keyword">for</span> job: job_1540218481613_0001</span><br><span class="line">18/10/22 10:44:07 INFO impl.YarnClientImpl: Submitted application application_1540218481613_0001</span><br><span class="line">18/10/22 10:44:07 INFO mapreduce.Job: The url to track the job: http://spark-node2:8088/proxy/application_1540218481613_0001/</span><br><span class="line">18/10/22 10:44:07 INFO mapreduce.Job: Running job: job_1540218481613_0001</span><br><span class="line">18/10/22 10:44:19 INFO mapreduce.Job: Job job_1540218481613_0001 running <span class="keyword">in</span> uber mode : <span class="literal">false</span></span><br><span class="line">18/10/22 10:44:19 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">18/10/22 10:44:31 INFO mapreduce.Job:  map 100% reduce 0%</span><br><span class="line">18/10/22 10:44:39 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">18/10/22 10:44:40 INFO mapreduce.Job: Job job_1540218481613_0001 completed successfully</span><br><span class="line">18/10/22 10:44:40 INFO mapreduce.Job: Counters: 49</span><br><span class="line">File System Counters</span><br><span class="line">FILE: Number of bytes <span class="built_in">read</span>=102</span><br><span class="line">FILE: Number of bytes written=250893</span><br><span class="line">FILE: Number of <span class="built_in">read</span> operations=0</span><br><span class="line">FILE: Number of large <span class="built_in">read</span> operations=0</span><br><span class="line">FILE: Number of write operations=0</span><br><span class="line">HDFS: Number of bytes <span class="built_in">read</span>=178</span><br><span class="line">HDFS: Number of bytes written=64</span><br><span class="line">HDFS: Number of <span class="built_in">read</span> operations=6</span><br><span class="line">HDFS: Number of large <span class="built_in">read</span> operations=0</span><br><span class="line">HDFS: Number of write operations=2</span><br><span class="line">Job Counters </span><br><span class="line">Launched map tasks=1</span><br><span class="line">Launched reduce tasks=1</span><br><span class="line">Data-local map tasks=1</span><br><span class="line">Total time spent by all maps <span class="keyword">in</span> occupied slots (ms)=9932</span><br><span class="line">Total time spent by all reduces <span class="keyword">in</span> occupied slots (ms)=4401</span><br><span class="line">Total time spent by all map tasks (ms)=9932</span><br><span class="line">Total time spent by all reduce tasks (ms)=4401</span><br><span class="line">Total vcore-milliseconds taken by all map tasks=9932</span><br><span class="line">Total vcore-milliseconds taken by all reduce tasks=4401</span><br><span class="line">Total megabyte-milliseconds taken by all map tasks=10170368</span><br><span class="line">Total megabyte-milliseconds taken by all reduce tasks=4506624</span><br><span class="line">Map-Reduce Framework</span><br><span class="line">Map input records=4</span><br><span class="line">Map output records=11</span><br><span class="line">Map output bytes=112</span><br><span class="line">Map output materialized bytes=102</span><br><span class="line">Input split bytes=108</span><br><span class="line">Combine input records=11</span><br><span class="line">Combine output records=8</span><br><span class="line">Reduce input groups=8</span><br><span class="line">Reduce shuffle bytes=102</span><br><span class="line">Reduce input records=8</span><br><span class="line">Reduce output records=8</span><br><span class="line">Spilled Records=16</span><br><span class="line">Shuffled Maps =1</span><br><span class="line">Failed Shuffles=0</span><br><span class="line">Merged Map outputs=1</span><br><span class="line">GC time elapsed (ms)=186</span><br><span class="line">CPU time spent (ms)=1950</span><br><span class="line">Physical memory (bytes) snapshot=291643392</span><br><span class="line">Virtual memory (bytes) snapshot=4170993664</span><br><span class="line">Total committed heap usage (bytes)=141291520</span><br><span class="line">Shuffle Errors</span><br><span class="line">BAD_ID=0</span><br><span class="line">CONNECTION=0</span><br><span class="line">IO_ERROR=0</span><br><span class="line">WRONG_LENGTH=0</span><br><span class="line">WRONG_MAP=0</span><br><span class="line">WRONG_REDUCE=0</span><br><span class="line">File Input Format Counters </span><br><span class="line">Bytes Read=70</span><br><span class="line">File Output Format Counters </span><br><span class="line">Bytes Written=64</span><br></pre></td></tr></table></figure><p>下载查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx @ spark-node1 in ~ [10:52:01] </span></span><br><span class="line">$ hadoop fs -get /user/galudisu/output/part-r-00000</span><br><span class="line"></span><br><span class="line"><span class="comment"># galudisu @ spark-node1 in ~ [10:52:06] </span></span><br><span class="line">$ cat part-r-00000 </span><br><span class="line">flink1</span><br><span class="line">flume1</span><br><span class="line">hadoop3</span><br><span class="line">hbase1</span><br><span class="line">hive1</span><br><span class="line">spark2</span><br><span class="line">sqoop1</span><br><span class="line">storm1</span><br></pre></td></tr></table></figure><h2><span id="hadoop加入systemd服务">Hadoop加入Systemd服务</span></h2><p>类似于ZooKeeper，将hadoop加入systemd中，让系统启动后自启</p><p>首先，在各个节点的hadoop目录创建一个启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;/etc/profile&quot;</span></span><br><span class="line"></span><br><span class="line">    /opt/hadoop/sbin/start-dfs.sh</span><br><span class="line">    /opt/hadoop/sbin/start-yarn.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;/etc/profile&quot;</span></span><br><span class="line"></span><br><span class="line">    /opt/hadoop/sbin/stop-yarn.sh</span><br><span class="line">    /opt/hadoop/sbin/stop-dfs.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    start|stop) <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>加入系统Systemd开机启动，注意下面after，没有的服务要去掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hadoop DFS namenode and datanode</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target network-online.target</span><br><span class="line">Requires=network-online.target</span><br><span class="line">Wants=zookeeper.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=spark</span><br><span class="line">Group=spark</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/opt/hadoop/hadoop-service.sh start</span><br><span class="line">ExecStop=/opt/hadoop/hadoop-service.sh stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">Environment=JAVA_HOME=/usr/java/jdk1.8.0_191-amd64</span><br><span class="line">Environment=HADOOP_HOME=/opt/hadoop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>按照上面的方式，单独修改每个节点的<code>hadoop-service.sh</code>即可。</p><p><img src="/img/spark/hadoop-data-node.png" alt="hadoop-data-node"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper原理与API应用</title>
      <link href="/2018/10/21/spark/spark-zookeeper-2/"/>
      <url>/2018/10/21/spark/spark-zookeeper-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="zookeeper概述">ZooKeeper概述</span></h2><p>1.1 概述</p><p>Zookeeper是Google的Chubby一个开源实现。它是一个针对大型分布式系统的可靠协调系统。提供的功能包括：配置维护、名字服务、分布式同步、组服务等。Zookeeper的目标就是封装复杂易出错的关键服务，讲简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><span id="more"></span><p>Zookeeper从设计模式角度来理解：是一个机遇观察者模式设计的分布式服务管理框架，它负责存储和管理大家关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应，从而实现集群中类似Master/Slave管理模式。</p><p>1.2 特点</p><p><img src="/img/spark/zookeeper-architecture.png" alt="zookeeper-architecture"></p><ul><li>Zookeeper：一个领导者(leader)，多个跟随者(follower)组成的集群。</li><li>Leader负责进行投票的发起和决议，更新系统状态。</li><li>所有服务(servers)存储数据的一份拷贝(既可以存储在内存，也可以本地文件系统)</li><li>Follower用于接收客户请求并向客户端返回结果，在选举Leader过程中参与投票。</li><li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。</li><li>全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。</li><li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行。</li><li>数据更新原子性，一次数据更新要么成功，要么失败。</li><li>实时性，在一定时间范围内，client能读到最新数据。</li><li>不存在分区读写。</li></ul><p>1.3 数据结构</p><p><img src="/img/spark/zookeeper-data-model.png" alt="zookeeper-data-model"></p><p>Zookeeper数据模式的结构与Unix文件系统类似，整体上可以看做是一颗树，每个节点称作一个ZNode。每个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p><p>1.4 应用场景</p><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><ul><li>统一命名服务：在分布式环境下，经常需要对应用/服务进行统一命名，便于识别不同服务。</li><li>统一配置管理：将配置信息写入ZooKeeper上的一个ZNode，各个节点监听这个ZNode，一旦ZNode中的数据被修改，ZooKeeper通知各个节点。</li><li>统一集群管理：将节点信息写入ZooKeeper上的一个ZNode，监听这个ZNode获取它的实时状态变化。</li><li>服务器节点动态上下线：监听注册服务列表，服务器下线发送事件通知。</li><li>软负载均衡。</li></ul><p><img src="/img/spark/zookeeper-in-hadoop.png" alt="zookeeper-in-hadoop"></p><h2><span id="zookeeper内部原理">Zookeeper内部原理</span></h2><ol><li>选举机制</li></ol><ul><li>半数机制：集群中半数以上机器存活，集群可用。所以ZooKeeper适合装在奇数台机器上。</li><li>ZooKeeper虽然在配置文件中没有指定master和slave。但是，ZooKeeper在启动时，leader被选举出，并且只有一个，其它作为follower，Leader是通过内部的选举机制临时产生的。</li></ul><ol start="2"><li>节点类型</li></ol><p>ZNode有两种类型：</p><ul><li>短暂(ephemeral)：客户端和服务端断开连接后，创建的节点自己删除</li><li>持久(persistent)：客户端和服务端断开连接后，创建的节点不删除</li></ul><p>ZNode有四种形式的目录节点(默认是persistent)</p><ul><li>持久化目录节点(persistent)：客户端与ZooKeeper断开连接后，该节点依旧存在</li><li>持久化顺序编号目录节点(persistent_sequential)：客户端与ZooKeeper断开连接后，该节点依旧存在，只是ZooKeeper给该节点名称进行顺序编号</li><li>临时目录节点(ephemeral)：客户端与ZooKeeper断开连接后，该节点被删除</li><li>临时顺序编号目录节点(ephemeral_sequential)：客户端与ZooKeeper断开连接后，该节点被删除，只是ZooKeeper给该节点名称进行顺序编号</li></ul><p>创建ZNode时设置顺序标识，ZNode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。</p><p>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</p><ol start="3"><li>stat结构体</li></ol><ol><li>czxid- 引起这个znode创建的zxid，创建节点的事务的zxid</li></ol><p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p><p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p><ol start="2"><li><p>ctime - znode被创建的毫秒数(从1970年开始)</p></li><li><p>mzxid - znode最后更新的zxid</p></li><li><p>mtime - znode最后修改的毫秒数(从1970年开始)</p></li><li><p>pZxid-znode最后更新的子节点zxid</p></li><li><p>cversion - znode子节点变化号，znode子节点修改次数</p></li><li><p>dataversion - znode数据变化号</p></li><li><p>aclVersion - znode访问控制列表的变化号</p></li><li><p>ephemeralOwner- 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</p></li><li><p>dataLength- znode的数据长度</p></li><li><p>numChildren - znode子节点数量</p></li></ol><ol start="4"><li>监听器原理</li></ol><p><img src="/img/spark/zookeeper-listener.png" alt="zookeeper-listener"></p><ol start="5"><li>写数据流程</li></ol><p><img src="/img/spark/zookeeper-write-process.png" alt="zookeeper-write"></p><p><img src="/img/spark/zookeeper-write-process-b.png" alt="zookeeper-write"></p><ol start="6"><li>读数据流程</li></ol><p>读流程比较简单，因为是所有节点的数据都是相同的，ZooKeeper的读流程是直接读取即可。</p><h2><span id="api应用">API应用</span></h2><p>创建ZooKeeper客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">&quot;node21:2181,node22:2181,node23:2181&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 收到事件通知后的回调函数（用户的业务逻辑）</span></span><br><span class="line">      System.out.println(event.getType() + <span class="string">&quot;--&quot;</span> + event.getPath());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建子节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建子节点</span><br><span class="line">@Test</span><br><span class="line">public void create() throws Exception &#123;</span><br><span class="line">// 数据的增删改查</span><br><span class="line">// 参数1：要创建的节点的路径； 参数2：节点数据 ； 参数3：节点权限 ；参数4：节点的类型</span><br><span class="line">String nodeCreated = zkClient.create(<span class="string">&quot;/eclipse&quot;</span>, <span class="string">&quot;hello zk&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断ZNode是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 判断znode是否存在</span><br><span class="line">@Test</span><br><span class="line">public void exist() throws Exception &#123;</span><br><span class="line">       Stat <span class="built_in">stat</span> = zkClient.exists(<span class="string">&quot;/eclipse&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">       System.out.println(<span class="built_in">stat</span> == null ? <span class="string">&quot;not exist&quot;</span> : <span class="string">&quot;exist&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="zookeeper实战">Zookeeper实战</span></h2><ol><li>监听服务器节点上下线</li></ol><p>需求：某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。<br>具体实现：</p><p>在集群上创建/servers节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] create /servers <span class="string">&quot;servers&quot;</span></span><br><span class="line">Created /servers</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyg.zkcase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">&quot;node21:2181,node22:2181,node23:2181&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String parentNode = <span class="string">&quot;/servers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registServer</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">String create = zk.create(parentNode + <span class="string">&quot;/server&quot;</span>, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname +<span class="string">&quot; is online &quot;</span>+ create);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(hostname+<span class="string">&quot; is working ...&quot;</span>);</span><br><span class="line">       Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取zk连接</span></span><br><span class="line">DistributeServer server = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">server.getConnect();</span><br><span class="line"><span class="comment">// 利用zk连接注册服务器信息</span></span><br><span class="line">server.registServer(args[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 启动业务功能</span></span><br><span class="line">server.business(args[<span class="number">0</span>]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyg.zkcase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String parentNode = <span class="string">&quot;/servers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 再次启动监听</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          getServerList();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器子节点信息，并且对父节点进行监听</span></span><br><span class="line">    List&lt;String&gt; children = zk.getChildren(parentNode, <span class="keyword">true</span>);</span><br><span class="line">    ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = zk.getData(parentNode + <span class="string">&quot;/&quot;</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把servers赋值给成员serverList，已提供给各业务线程使用</span></span><br><span class="line">     serversList = servers;</span><br><span class="line">     System.out.println(serversList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;client is working ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取zk连接</span></span><br><span class="line">DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">client.getConnect();</span><br><span class="line"><span class="comment">// 获取servers的子节点信息，从中获取服务器信息列表</span></span><br><span class="line">client.getServerList();</span><br><span class="line"><span class="comment">// 业务进程启动</span></span><br><span class="line">client.business();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.5 搭建Zookeeper集群与命令行操作</title>
      <link href="/2018/10/21/spark/spark-zookeeper-1/"/>
      <url>/2018/10/21/spark/spark-zookeeper-1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2><span id="分布式安装部署">分布式安装部署</span></h2><p>官网首页：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a><br>下载地址：<a href="http://mirror.bit.edu.cn/apache/zookeeper/">http://mirror.bit.edu.cn/apache/zookeeper/</a></p><p><img src="/img/spark/zookeeper-releases.png" alt="zookeeper-release"></p><h3><span id="集群规划">集群规划</span></h3><p>在node1，node2和node3三个节点上部署zookeeper，三个节点都已安装jdk。</p><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">节点名称</th><th style="text-align:center">zookeeper</th></tr></thead><tbody><tr><td style="text-align:center">192.168.100.21</td><td style="text-align:center">spark-node1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">192.168.100.22</td><td style="text-align:center">spark-node2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">192.168.100.23</td><td style="text-align:center">spark-node3</td><td style="text-align:center"></td></tr></tbody></table><h3><span id="解压安装">解压安装</span></h3><ol><li>解压zookeeper按转包到<code>/opt/</code>目录下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf zookeeper-3.4.12.tar.gz -C /opt/</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>/opt/</code> 创建软连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/zookeeper-3.4.12 /opt/zookeeper</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>/opt/zookeeper</code>目录下创建data</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/zookeeper/data</span><br></pre></td></tr></table></figure><ol start="4"><li>覆盖zookeeper的安装配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/zookeeper/conf/zoo_sample.cfg /opt/zookeeper/conf/zoo.cfg</span><br></pre></td></tr></table></figure><h3><span id="配置zoocfg文件">配置zoo.cfg文件</span></h3><p>具体配置，修改dateDir，添加日志存放目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/opt/zookeeper/data</span><br><span class="line">dataLogDir=/opt/zookeeper/logs</span><br></pre></td></tr></table></figure><p>末尾增加如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=spark-node1:2888:3888</span><br><span class="line">server.2=spark-node2:2888:3888</span><br><span class="line">server.3=spark-node3:2888:3888</span><br></pre></td></tr></table></figure><h3><span id="集群配置">集群配置</span></h3><ol><li>在<code>/opt/zookeeper/data</code>目录下创建一个myid的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch myid</span><br></pre></td></tr></table></figure><ol start="2"><li>编辑myid文件，在文件中添加与server对应的编号：如 1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim myid</span><br></pre></td></tr></table></figure><ol start="3"><li>拷贝配置好的zookeeper到其它机器上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r zookeeper*/ xxx@spark-node2:/opt/</span><br><span class="line">scp -r zookeeper*/ xxx@spark-node3:/opt/</span><br></pre></td></tr></table></figure><p>并修改spark-node2，spark-node3中myid文件中内容为2、3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; myid</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; myid</span><br></pre></td></tr></table></figure><h3><span id="启动集群">启动集群</span></h3><ol><li>分别启动zookeeper</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure><ol start="2"><li>查看状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.12/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follwer</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>停止zookeeper</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh stop</span><br></pre></td></tr></table></figure><h3><span id="加入systemd管理">加入Systemd管理</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/zookeeper.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Zookeeper service</span><br><span class="line">After=syslog.target etwork.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">Environment=ZOO_LOG_DIR=/opt/zookeeper/data/logs</span><br><span class="line">ExecStart=/opt/zookeeper/bin/zkServer.sh start</span><br><span class="line">ExecStop=/opt/zookeeper/bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3><span id="配置环境变量">配置环境变量</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/opt/zookeeper-3.4.12 </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ZOOKEEPER_HOME</span>/bin</span><br></pre></td></tr></table></figure><h3><span id="zoocfg配置参数解读">zoo.cfg配置参数解读</span></h3><p>Server.A=B:C:D。</p><p>A是一个数字，表示这个是第几号服务器；</p><p>B是这个服务器的ip地址；</p><p>C是这个服务器与集群中的Leader服务器交换信息的端口；</p><p>D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p><p>集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。</p><ol><li>tickTime=2000：通信心跳数</li></ol><p>tickTime：通信心跳数，Zookeeper服务器心跳时间，单位毫秒</p><p>Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。</p><p>它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2 x tickTime)</p><p>2)initLimit=10：LF初始通信时限</p><p>集群中的follower跟随者服务器(F)与leader领导者服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。</p><p>投票选举新leader的初始化时间</p><p>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。</p><p>Leader允许F在initLimit时间内完成这个工作。</p><p>3)syncLimit=5：LF同步通信时限</p><p>集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit x tickTime，</p><p>Leader认为Follwer死掉，从服务器列表中删除Follwer。</p><p>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。</p><p>如果L发出心跳包在syncLimit之后，还没有从F那收到响应，那么就认为这个F已经不在线了。</p><p>4)dataDir：数据文件目录+数据持久化路径</p><p>保存内存数据库快照信息的位置，如果没有其他说明，更新的事务日志也保存到数据库。</p><p>5)clientPort=2181：客户端连接端口</p><p>监听客户端连接的端口</p><h2><span id="客户端命令行操作">客户端命令行操作</span></h2><ol><li>启动客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>显示所有操作命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] <span class="built_in">help</span></span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">    <span class="built_in">stat</span> path [watch]</span><br><span class="line">    <span class="built_in">set</span> path data [version]</span><br><span class="line">    ls path [watch]</span><br><span class="line">    delquota [-n|-b] path</span><br><span class="line">    ls2 path [watch]</span><br><span class="line">    setAcl path acl</span><br><span class="line">    setquota -n|-b val path</span><br><span class="line">    <span class="built_in">history</span> </span><br><span class="line">    redo cmdno</span><br><span class="line">    printwatches on|off</span><br><span class="line">    delete path [version]</span><br><span class="line">    sync path</span><br><span class="line">    listquota path</span><br><span class="line">    rmr path</span><br><span class="line">    get path [watch]</span><br><span class="line">    create [-s] [-e] path data acl</span><br><span class="line">    addauth scheme auth</span><br><span class="line">    quit </span><br><span class="line">    getAcl path</span><br><span class="line">    close </span><br><span class="line">    connect host:port</span><br></pre></td></tr></table></figure><ol start="3"><li>查看当前znode中所包含的内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure><ol start="4"><li>查看当前节点数据并能看到更新次数等数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Wed Dec 31 19:00:00 EST 1969</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Wed Dec 31 19:00:00 EST 1969</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure><ol start="5"><li>创建普通节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] create /opt <span class="string">&quot;aa&quot;</span></span><br><span class="line">Created /opt</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create /opt/s <span class="string">&quot;bb&quot;</span></span><br><span class="line">Created /opt</span><br></pre></td></tr></table></figure><ol start="6"><li>获取节点值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] get /opt</span><br><span class="line">aa</span><br><span class="line">cZxid = 0x4100000004</span><br><span class="line">ctime = Wed Jul 25 07:48:55 EDT 2018</span><br><span class="line">mZxid = 0x4100000004</span><br><span class="line">mtime = Wed Jul 25 07:48:55 EDT 2018</span><br><span class="line">pZxid = 0x4100000005</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 2</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /opt/s</span><br><span class="line">bb</span><br><span class="line">cZxid = 0x4100000005</span><br><span class="line">ctime = Wed Jul 25 07:51:21 EDT 2018</span><br><span class="line">mZxid = 0x4100000005</span><br><span class="line">mtime = Wed Jul 25 07:51:21 EDT 2018</span><br><span class="line">pZxid = 0x4100000005</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 2</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><ol start="7"><li>创建短暂节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] create -e /app 8888           </span><br><span class="line">Created /app</span><br></pre></td></tr></table></figure><p>在当前客户端是能查看到的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] ls /</span><br><span class="line">[app, opt, zookeeper]</span><br></pre></td></tr></table></figure><p>退出当前客户端然后再重启客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 9] quit</span><br><span class="line">[root@spark-node2 zookeepe]$ bin/zkCli.sh</span><br></pre></td></tr></table></figure><p>再次查看根目录下短暂节点已经删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[opt, zookeeper]</span><br></pre></td></tr></table></figure><ol start="8"><li>创建带序号的节点</li></ol><p>先创建一个普通的根节点app</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /app <span class="string">&quot;app&quot;</span></span><br><span class="line">create /app <span class="string">&quot;app&quot;</span></span><br></pre></td></tr></table></figure><p>创建带序号的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s /app/aa 888</span><br><span class="line">Created /app/aa0000000000</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -s /app/bb 888</span><br><span class="line">Created /app/bb0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create -s /app/cc 888</span><br><span class="line">Created /app/cc0000000002</span><br></pre></td></tr></table></figure><p>如果原节点下有1个节点，则在排序时从1开始，以此类推。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s /opt/aa 888</span><br><span class="line">Created /opt/aa0000000001</span><br></pre></td></tr></table></figure><ol start="9"><li>修改节点数据值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] <span class="built_in">set</span> /opt 999</span><br><span class="line">cZxid = 0x4100000004</span><br><span class="line">ctime = Wed Jul 25 07:48:55 EDT 2018</span><br><span class="line">mZxid = 0x410000000e</span><br><span class="line">mtime = Wed Jul 25 08:14:18 EDT 2018</span><br><span class="line">pZxid = 0x410000000d</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure><ol start="10"><li>节点的值变化监听</li></ol><p>在spark-node2主机上注册监听/opt节点数据变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /opt watch</span><br></pre></td></tr></table></figure><p>在spark-node1主机上修改/opt节点的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] <span class="built_in">set</span> /opt 777</span><br></pre></td></tr></table></figure><p>观察spark-node2主机收到数据变化的监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] </span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/opt</span><br></pre></td></tr></table></figure><ol start="11"><li>节点的子节点变化监听(路径变化)</li></ol><p>在spark-node2主机上注册监听/opt节点的子节点变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /opt watch</span><br><span class="line">[aa0000000001, module]</span><br></pre></td></tr></table></figure><p>在spark-node2主机/opt节点上创建子节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] create /opt/bb 666</span><br><span class="line">Created /opt/bb</span><br></pre></td></tr></table></figure><p>观察spark-node2主机收到子节点变化的监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] </span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/opt</span><br></pre></td></tr></table></figure><ol start="12"><li>删除节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 9] delete /opt/bb</span><br></pre></td></tr></table></figure><ol start="13"><li>递归删除节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] rmr /opt</span><br></pre></td></tr></table></figure><ol start="14"><li>查看节点状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 14] <span class="built_in">stat</span> /app</span><br><span class="line">cZxid = 0x4100000009</span><br><span class="line">ctime = Wed Jul 25 08:09:56 EDT 2018</span><br><span class="line">mZxid = 0x4100000009</span><br><span class="line">mtime = Wed Jul 25 08:09:56 EDT 2018</span><br><span class="line">pZxid = 0x410000000c</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 3</span><br></pre></td></tr></table></figure><ol start="15"><li>退出客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 17] quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker部署ELK</title>
      <link href="/2018/10/20/docker/docker-elk/"/>
      <url>/2018/10/20/docker/docker-elk/</url>
      
        <content type="html"><![CDATA[<p><a href="https://elk-docker.readthedocs.io/">ELK</a>，是Elasticsearch，Logstash，Kibana三大日志服务的合集，本文基于docker部署这三个服务。</p><p>前提条件：</p><ul><li>Docker: 预先安装好docker</li><li>至少4G内存</li><li>mmap counts 至少262,144，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/vm-max-map-count.html#vm-max-map-count">这里</a></li><li>访问5044端口</li></ul><span id="more"></span><h2><span id="安装">安装</span></h2><p>先从docker上面拉取下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull sebp/elk</span><br></pre></td></tr></table></figure><h3><span id="指定版本拉取">指定版本拉取</span></h3><p>对于例如Elasticsearch 1.7.3，Logstash 1.5.5，和Kibana 4.1.2版本，可以组合为<code>E1L1K41</code>，因此，可以使用<code>sudo docker pull sebp/elk:E1L1K4</code>进行拉取。</p><h2><span id="部署">部署</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk</span><br></pre></td></tr></table></figure><p>该命令包含下列端口，</p><ul><li>5601 (Kibana web interface).</li><li>9200 (Elasticseearch JSON interface).</li><li>5044 (Logstash Beats interface, receives logs from Beats such as Filebeat).</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker, elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker安装配置keycloak</title>
      <link href="/2018/10/20/docker/docker-keycloak/"/>
      <url>/2018/10/20/docker/docker-keycloak/</url>
      
        <content type="html"><![CDATA[<p>keycloak基于OAuth 2.0、OpenID Connect、JSON Web Token(JWT)和SAML 2.0规范，为浏览器应用和RESTful Web Service提供SSO和IDM集成。</p><p>keycloak最新的版本为3.3.0。<br>首先安装数据库，假设使用的为postgres，容器名为postgres</p><span id="more"></span><p>下载docker镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jboss/keycloak:3.3.0.Final</span><br></pre></td></tr></table></figure><p>然后通过以下命令创建容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name keycloak -d -p 443:443 -p 9990:9990 -p 8080:8080 \</span><br><span class="line">--link postgres:postgres -e POSTGRES_DATABASE=keycloak \</span><br><span class="line">-e POSTGRES_USER=keycloak -e POSTGRES_PASSWORD=keycloakxxxx \</span><br><span class="line">-e TZ=Asia/Shanghai -v /etc/localtime:/etc/localtime \</span><br><span class="line">--restart=always jboss/keycloak:3.3.0.Final</span><br></pre></td></tr></table></figure><p>其中指定了数据库，时区等参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker, keycloak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker环境下的zookeeper和kafka部署</title>
      <link href="/2018/10/20/docker/docker-kafka/"/>
      <url>/2018/10/20/docker/docker-kafka/</url>
      
        <content type="html"><![CDATA[<h2><span id="kafka-简单介绍">Kafka 简单介绍</span></h2><p><code>kafka</code>是 <em>LinkedIn</em> 开源的一种高吞吐量的分布式发布订阅消息系统，kafka的诞生就是为了处理海量日志数据，所以kafka处理消息的效率非常高，即使是非常普通的硬件也可以支持每秒数百万的消息。</p><p><code>kafka</code>天然支持集群负载均衡，使用 <em>zookeeper</em> 进行分布式协调管理。不支持事务，有一定概率丢失消息。</p><p><code>kafka</code>的特点，决定了使用场景：日志中间件。</p><span id="more"></span><h2><span id="下载docker镜像">下载docker镜像</span></h2><ul><li>zookeeper: <code>docker pull zookeeper:latest</code></li><li>kafka: <code>docker pull wurstmeister/kafka:latest</code></li></ul><h2><span id="创建并启动容器">创建并启动容器</span></h2><p>先启动zookeeper:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name zookeeper --publish 2181:2181 -v /etc/localtime:/etc/localtime zookeeper:latest</span><br></pre></td></tr></table></figure><p>zookeeper启动完成后再启动kafka:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kafka -p 9092:9092 \</span><br><span class="line">--link zookeeper \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \</span><br><span class="line">--env KAFKA_ADVERTIESED_HOST_NAME=&#123;your_host_ip&#125; \</span><br><span class="line">--env KAFKA_ADVERTISED_PORT=9092 \</span><br><span class="line">--volume /etc/localtime:/etc/localtime \</span><br><span class="line">wurstmeister/kafka:latest</span><br></pre></td></tr></table></figure><h2><span id="向kafka发送测试消息">向kafka发送测试消息</span></h2><p>运行<code>docker ps</code>，找到kafka的 <em>CONTAINER ID</em>，运行 <code>docker exec -it $&#123;kafka_id&#125; /bin/bash</code>，进入kafka容器。</p><p>进入kafka默认目录， <code>/opt/kafka</code>，运行<code>bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic test</code>，创建一个 <em>topic</em> 名称为 test。</p><p>运行<code>bin/kafka-topics.sh --list --zookeeper zookeeper:2181</code>查看当前的 <em>topic</em> 列表。</p><p>运行一个消息生产者，制定 <em>topic</em> 为刚刚创建的 <em>test</em>，<code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</code>，输入一些测试消息。</p><p>运行一个消息消费者，同样指定 <em>topic</em> 为 <em>test</em>，<code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-begining</code>，可以接收到生产者发送的消息。</p><h2><span id="最后">最后</span></h2><p><strong>kafka</strong> 环境已经搭建完成，接下来我们要对之前的工程进行改造，使用log4j2的kafka appender把日志统一输出到 <strong>kafka</strong> 日志中间件。</p><p>日志导入 <strong>kafka</strong> 之后，接下来的处理就比较灵活了，可以用不同功能的消费者订阅感兴趣的 topic，进行日志分析。例如：使用 kafka 作为 storm 的数据来源 spout，进行流式处理；订阅 kafka 中需要做离线统计处理的 topic，把数据保存到数据库，一般是 mongodb 或 hbase 这种数据结构松散的 nosql 数据库；又或者可以使用 flume 或 logstash 这种管道工具，把数据导入到其他的系统，比如 elasticsearch、 solr 等。<br><strong>kafka</strong> 作为最常用的日志中间件，可以把分散的日志集中到一处，并做缓冲处理，再和其他开源工具进行集成，对数据做进一步处理，是日志统计系统的基础组件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装汉化版Gitlab</title>
      <link href="/2018/09/27/gitlab/gitlab-ce-zh/"/>
      <url>/2018/09/27/gitlab/gitlab-ce-zh/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>有个问题是Docker需要创建独立的网络环境，避免多个docker容器冲突，参考<a href="https://hub.docker.com/r/twang2218/gitlab-ce-zh/">这里</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create gitlab-ent</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">--hostname galilei.ink \</span><br><span class="line">--publish 443:443 --publish 10080:80 --publish 10022:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--env GITLAB_OMNIBUS_CONFIG=<span class="string">&quot;external_url &#x27;http://galilei.ink:10080/&#x27;; gitlab_rails[&#x27;lfs_enabled&#x27;] = true;&quot;</span> \</span><br><span class="line">--restart unless-stopped \</span><br><span class="line">--volume /data/docker/gitlab/config:/etc/gitlab \</span><br><span class="line">--volume /data/docker/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">--volume /data/docker/gitlab/data:/var/opt/gitlab \</span><br><span class="line">--network gitlab-net \</span><br><span class="line">twang2218/gitlab-ce-zh:11.1.4</span><br></pre></td></tr></table></figure><h2><span id="external_url-设置">external_url 设置</span></h2><p>有个比较重要的地方是，如果设置的<code>external_url</code>带有端口，需要添加nginx监控</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx[&#x27;listen_port&#x27;] = nil</span></span><br><span class="line">nginx[<span class="string">&#x27;listen_port&#x27;</span>] = 80</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it gitlab gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>即可！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://hub.docker.com/r/twang2218/gitlab-ce-zh/">https://hub.docker.com/r/twang2218/gitlab-ce-zh/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> gitlab, zh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YouTrack 快速安装</title>
      <link href="/2018/09/14/youtrack/youtrack-install/"/>
      <url>/2018/09/14/youtrack/youtrack-install/</url>
      
        <content type="html"><![CDATA[<p>最近入手敏捷开发工具，比较了一番之后发现YouTrack比较优秀。同类产品中leangoo太过简单，JIRA要收费，很贵！功能也很不错，但是安装复杂。其它国产的什么禅道、leangoo之类的，毕竟没有大气风范</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir -p /data/docker/youtrack /data/docker/youtrack/data /data/docker/youtrack/conf /data/docker/youtrack/logs /data/docker/youtrack/backups</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;-Djava.security.egd=file:/dev/./urandom&#x27;</span> &gt; /data/docker/youtrack/conf/youtrack.jvmoptions</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;-Djava.security.egd=file:/dev/./urandom&#x27;</span> &gt; /data/docker/youtrack/conf/youtrack.jvmoptions</span><br><span class="line"></span><br><span class="line">chmod -R a+w /data/docker/youtrack/*</span><br><span class="line"></span><br><span class="line">docker pull ilanyu/youtrack</span><br><span class="line"></span><br><span class="line">docker run --name youtrack-server-instance -v /data/docker/youtrack/data:/opt/youtrack/data -v /data/docker/youtrack/conf:/opt/youtrack/conf -v /data/docker/youtrack/logs:/opt/youtrack/logs -v /data/docker/youtrack/backups:/opt/youtrack/backups -p 8080:8080 -d --restart=always ilanyu/youtrack</span><br></pre></td></tr></table></figure><p>打开浏览器 <a href="http://your_server:8080">http://your_server:8080</a></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:  ilanyu  </span><br><span class="line">activation code:  7b5480c07039fb790dfe66bc90c5fdb604a02da33c68b8d50825ff45fa41af354c0a827ac9d45e6440b8e799917feb5bd514eee41b01bde2e9481d581ba89cac71bb76c83b607b6332ffe1bbb43e18edbb1c94361cd06addbe0f6e33b8135f16faca768c5f17408aacb11abc991e5b3c59a524e4392b361212eb51151d33c3a8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> youtrack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于遗传算法实现排课系统</title>
      <link href="/2018/07/24/algorithm/ga/genetic-algorithm/"/>
      <url>/2018/07/24/algorithm/ga/genetic-algorithm/</url>
      
        <content type="html"><![CDATA[<p>遗传算法属于NP完备问题，不确定问题需要大量离散的数据进行线性处理。</p><span id="more"></span><div style="float:left"><img src="/img/algorithm/ga/DNA-helix.jpg" alt="DNA"></div><div style="float:right"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=489694&auto=1&height=66"></iframe></div><div class="clearfix"></div><p><code>遗传算法(genetic algorithm)</code>是受Charles Darwin自然进化理论启发的搜索启发式算法。该算法反映了自然选择的过程，选择最合适的个体进行繁殖，以产生下一代后代。</p><p><img src="/img/algorithm/ga/1_BYDJpa6M2rzWNSurvspf8Q.png" alt="DNA"></p><h2><span id="notion-of-natural-selection">Notion of Natural Selection</span></h2><p>自然选择的过程，开始于种群中最适个体的选择。它们产生子代，子代继承父代的特性。如果父代有最适值，子代将有比父代更好机会生存。该选择过程将迭代进行，直到最适值种群个体出现。</p><p>分析该问题，可以从DDD方面描述，从种群进化和优胜劣汰方面，我们需要专业术语进行描述。我们考虑遗传进化是多个解决方案对一个抽象问题的描述。</p><p>遗传算法考虑5个阶段</p><ol><li>初始化种群(population)</li><li>适值函数(fitness)</li><li>蒙特卡罗选举(selection)</li><li>交叉(crossover)</li><li>变异(mutate)</li></ol><h2><span id="initial-population">Initial Population</span></h2><p>一个个体(Individual)是一系列<strong>基因</strong> 的集合，基因组成染色体(<code>Chromosome</code>)的解决方案。</p><p>在遗传算法中，一系列基因用字符(char)表示，术语称为<code>alphabet</code>，字母表或基因池。通常用二进制表示(1或0)。如下看到的染色体基因编码：</p><p><img src="/img/algorithm/ga/1_vIrsxg12DSltpdWoO561yA.png" alt="1_vIrsxg12DSltpdWoO561yA.png"></p><h2><span id="fitness-function">Fitness Function</span></h2><p>适值函数决定了一个个体的适应能力(一个个体与其它个体的竞争能力)。每个个体都拥有自身的<code>适值分数(fitness score)</code>。个体被选中作为繁衍基于它自身的<code>适值分数</code>。</p><h2><span id="selection">Selection</span></h2><p>选择阶段就是选择最适个体，并将它们的基因传递给下一代。</p><p>根据它们的适值分数(fitness score)选择一对个体(父代)。适值数高的，将有更高的机会被选择进行繁衍。</p><h2><span id="crossover">Crossover</span></h2><p>交叉在遗传算法中是最有成效的阶段。对于每一对被匹配到的父代，交叉点(crossover point)在基因中被随机选取。</p><p>例如，从第3个位置开始：</p><p><img src="/img/algorithm/ga/1_Wi6ou9jyMHdxrF2dgczz7g.png" alt="1_Wi6ou9jyMHdxrF2dgczz7g.png"></p><p>子代的创建，来源于父代基因的交换</p><p><img src="/img/algorithm/ga/1_eQxFezBtdfdLxHsvSvBNGQ.png" alt="1_eQxFezBtdfdLxHsvSvBNGQ.png"></p><p>新生子代被添加到种群中。子代的产生，都是按照批次出现，不会出现年龄的概念，也不考虑种群数量增多的情况。</p><h2><span id="mutation">Mutation</span></h2><p>在某些新生代中，它们某些基因可能以一种非常低的概率发生<code>变异(mutation)</code>。这意味着新生代的基因可能会出现<code>反转(flipped)</code>。</p><p><img src="/img/algorithm/ga/1_CGt_UhRqCjIDb7dqycmOAg.png" alt="1_CGt_UhRqCjIDb7dqycmOAg.png"></p><p>基因突变是为了保持种群内的多样性和防止过早收敛。一般有两种情况考虑基因突变的情况：</p><ol><li>当种群进化到一定阶段出现无解(种群所有个体基因全部相同，交叉后子代基因和父代基因没有变化；但是所有个体都不满足条件，种群无法再次进化)</li><li>过早收敛，得不到一个最优解。特别是多个维度中，收敛出现偏向某一个维度。</li></ol><h2><span id="termination">Termination</span></h2><p>终止条件是种群收敛(新生子代和前一代没有明显不同)。这表示遗传算法得出的解已经满足我们的问题。</p><h2><span id="psuedocode">Psuedocode</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">START</span><br><span class="line">Generate the initial population</span><br><span class="line">Compute fitness</span><br><span class="line">REPEAT</span><br><span class="line">    Selection</span><br><span class="line">    Crossover</span><br><span class="line">    Mutation</span><br><span class="line">    Compute fitness</span><br><span class="line">UNTIL population has converged</span><br><span class="line">STOP</span><br></pre></td></tr></table></figure><h2><span id="ga">GA</span></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.typesafe.scalalogging.<span class="type">LazyLogging</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.<span class="type">Logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.annotation.tailrec</span><br><span class="line"><span class="keyword">import</span> scala.collection.immutable.<span class="type">Stream</span>.consWrapper</span><br><span class="line"><span class="keyword">import</span> scala.language._</span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GeneticLayout</span> <span class="keyword">extends</span> <span class="title">App</span> <span class="keyword">with</span> <span class="title">LazyLogging</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 目标</span></span><br><span class="line">  <span class="keyword">val</span> target = <span class="string">&quot;101010&quot;</span></span><br><span class="line">  <span class="comment">// 基因池</span></span><br><span class="line">  <span class="keyword">val</span> genePool = <span class="type">Array</span>[<span class="type">Char</span>](&#x27;<span class="number">1</span>&#x27;,&#x27;<span class="number">0</span>&#x27;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> _: <span class="type">Logger</span> = logger.underlying</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计相等的个数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fitness</span></span>(src: <span class="type">String</span>, tgt: <span class="type">String</span>): <span class="type">Double</span> = src.zip(tgt).count &#123; <span class="keyword">case</span> (s, t) =&gt; s == t &#125;</span><br><span class="line">  <span class="comment">// 冲突消除 todo:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">conflictClear</span></span>(agents: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">Seq</span>[<span class="type">String</span>] = agents</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> testBench = <span class="keyword">new</span> <span class="type">GeneticExploration</span>[<span class="type">Char</span>, <span class="type">String</span>](<span class="number">0.5</span>, <span class="number">0.01</span>, <span class="number">10</span>, genePool, cs =&gt; <span class="keyword">new</span> <span class="type">String</span>(cs.toArray), conflictClear, fitness)</span><br><span class="line">  <span class="keyword">val</span> (p, g) = testBench.evolution(testBench.newPool(<span class="number">10</span>, target.length), target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param cross crossover probability 交叉概率</span></span><br><span class="line"><span class="comment">  * @param mutation 变异概率</span></span><br><span class="line"><span class="comment">  * @param population 种群数量</span></span><br><span class="line"><span class="comment">  * @param genePool 基因池</span></span><br><span class="line"><span class="comment">  * @param specimenBuilder 个体构造器</span></span><br><span class="line"><span class="comment">  * @param conflictClear   冲突消除 Rm为硬约束条件；Rn为软约束条件；Rx为解保证</span></span><br><span class="line"><span class="comment">  * @param fitnessF 适值函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneticExploration</span>[<span class="type">Gene</span>, <span class="type">Specimen</span>](<span class="params">val cross: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                                         val mutation: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                                         val population: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                                         genePool: <span class="type">Array</span>[<span class="type">Gene</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                                         specimenBuilder: <span class="type">Iterable</span>[<span class="type">Gene</span>] =&gt; <span class="type">Specimen</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                                         conflictClear: <span class="type">Seq</span>[<span class="type">Specimen</span>] =&gt; <span class="type">Seq</span>[<span class="type">Specimen</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">                                         fitnessF: (<span class="type">Specimen</span>, <span class="type">Specimen</span></span>) <span class="title">=&gt;</span> <span class="title">Double</span>)(<span class="params">implicit ev$1: <span class="type">Specimen</span> =&gt; <span class="type">Iterable</span>[<span class="type">Gene</span>], logger: <span class="type">Logger</span></span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Pool</span> </span>= <span class="type">Seq</span>[<span class="type">Specimen</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">MatePool</span> </span>= <span class="type">Seq</span>[(<span class="type">Specimen</span>, <span class="type">Double</span>)]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">randomGenes</span></span>: <span class="type">Stream</span>[<span class="type">Gene</span>] = genePool(<span class="type">Random</span>.nextInt(genePool.length)) #:: randomGenes</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">newSpecimen</span></span>(len: <span class="type">Int</span>): <span class="type">Specimen</span> = specimenBuilder(randomGenes.take(len))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">newPool</span></span>(size: <span class="type">Int</span>, len: <span class="type">Int</span>): <span class="type">Pool</span> = (<span class="number">1</span> to size).map(_ =&gt; newSpecimen(len))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matePool</span></span>(pool: <span class="type">Pool</span>, tgt: <span class="type">Specimen</span>): <span class="type">MatePool</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> fitnesses: <span class="type">Seq</span>[<span class="type">Double</span>] = pool.map(fitnessF(_, tgt))</span><br><span class="line">    pool.zip(renormalize(fitnesses))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 每个个体被选中的概率 */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">renormalize</span></span>(vector: <span class="type">Iterable</span>[<span class="type">Double</span>]): <span class="type">Iterable</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> sum = vector.sum</span><br><span class="line">    vector.map(_ / sum)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 蒙特卡罗选举，伪随机生成个体 */</span></span><br><span class="line">  <span class="meta">@tailrec</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">monteCarloSelection</span></span>(matePool: <span class="type">MatePool</span>): <span class="type">Specimen</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> (specimen, fitness) = matePool(<span class="type">Random</span>.nextInt(matePool.length))</span><br><span class="line">    <span class="comment">// 子代适值大于父代适值？Y 替换 N 保持</span></span><br><span class="line">    <span class="keyword">if</span> (fitness &gt; <span class="type">Random</span>.nextFloat()) specimen <span class="keyword">else</span> monteCarloSelection(matePool)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 产生新生代 */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">popReproduction</span></span>(matePool: <span class="type">MatePool</span>): <span class="type">Pool</span> =</span><br><span class="line">    (<span class="number">1</span> to population)</span><br><span class="line">      .par</span><br><span class="line">      .map(_ =&gt; crossover(monteCarloSelection(matePool), monteCarloSelection(matePool)))</span><br><span class="line">      .map(mutate)</span><br><span class="line">      ./:(<span class="type">Seq</span>[<span class="type">Specimen</span>]())(conflictDetection)</span><br><span class="line">      .seq</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 进行交叉操作，交叉概率 Pc */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crossover</span></span>(a: <span class="type">Specimen</span>, b: <span class="type">Specimen</span>): <span class="type">Specimen</span> = specimenBuilder(a.zip(b).map(gene =&gt; <span class="keyword">if</span> (<span class="type">Random</span>.nextFloat &gt; cross) gene._1 <span class="keyword">else</span> gene._2))</span><br><span class="line">  <span class="comment">/** 进行变异操作，变异概率 Pm */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mutate</span></span>(s: <span class="type">Specimen</span>): <span class="type">Specimen</span> = specimenBuilder(s.map(gene =&gt; <span class="keyword">if</span> (mutation &gt; <span class="type">Random</span>.nextFloat) randomGenes.head <span class="keyword">else</span> gene))</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新生成的种群需要做 &#x27;&#x27;&#x27;冲突检测与消除操作&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">    * 例如：</span></span><br><span class="line"><span class="comment">    * 001,001   =&gt;  (a,α)</span></span><br><span class="line"><span class="comment">    * 001,010   =&gt;  (a,β)</span></span><br><span class="line"><span class="comment">    * 010,110   =&gt;  (b,ζ)</span></span><br><span class="line"><span class="comment">    * 随机检测发现 &#x27;&#x27;&#x27;(a,α)&#x27;&#x27;&#x27; 和 &#x27;&#x27;&#x27;(a,β)&#x27;&#x27;&#x27;冲突。随机获取冲突之外的任意值 &#x27;&#x27;&#x27;(b,ζ)&#x27;&#x27;&#x27;，替换为：</span></span><br><span class="line"><span class="comment">    * 001,001   =&gt;  (a,α)</span></span><br><span class="line"><span class="comment">    * 010,010   =&gt;  (b,β)</span></span><br><span class="line"><span class="comment">    * 001,110   =&gt;  (a,ζ)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 依次循环，直到cursor等于种群大小。确保每次进化种群个体不重复。方便快速收敛</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">conflictDetection</span></span>(z: <span class="type">Pool</span>, b: <span class="type">Specimen</span>): <span class="type">Pool</span> = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span> <span class="function"><span class="keyword">def</span> <span class="title">_conflictRif</span></span>(e: <span class="type">Specimen</span>): <span class="type">Specimen</span> =</span><br><span class="line">      <span class="keyword">if</span> (!z.contains(e)) e</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x = mutate(e)</span><br><span class="line">        <span class="keyword">if</span> (z.contains(x)) _conflictRif(e)</span><br><span class="line">        <span class="keyword">else</span> x</span><br><span class="line">      &#125;</span><br><span class="line">    conflictClear(z :+ _conflictRif(b))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 遗传进化操作，将适值较高的个体选择出来，并将其优秀的基因传递给下一代 */</span></span><br><span class="line">  <span class="meta">@tailrec</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">evolution</span></span>(pool: <span class="type">Pool</span>, target: <span class="type">Specimen</span>, generation: <span class="type">Int</span> = <span class="number">0</span>): (<span class="type">Pool</span>, <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> newGeneration = popReproduction(matePool(pool, target))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===========================================</span></span><br><span class="line">    logger.debug(<span class="string">s&quot;第<span class="subst">$&#123;Console.RED&#125;</span>[&#123;&#125;]<span class="subst">$&#123;Console.RESET&#125;</span>代 向 第<span class="subst">$&#123;Console.RED&#125;</span>[&#123;&#125;]<span class="subst">$&#123;Console.RESET&#125;</span>代进化: &quot;</span>, generation, generation + <span class="number">1</span>)</span><br><span class="line">    logger.debug(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    pool.zip(newGeneration).collect&#123; <span class="keyword">case</span> (s, t) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (t.equals(target))</span><br><span class="line">        logger.debug(<span class="string">s&quot;<span class="subst">$&#123;s.mkString&#125;</span> -&gt; <span class="subst">$&#123;Console.BLACK_B&#125;</span><span class="subst">$&#123;Console.GREEN&#125;</span><span class="subst">$t</span><span class="subst">$&#123;Console.RESET&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        logger.debug(<span class="string">s&quot;<span class="subst">$&#123;s.mkString&#125;</span> -&gt; <span class="subst">$&#123;t.mkString&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===========================================</span></span><br><span class="line">    <span class="keyword">if</span> (newGeneration.contains(target)) (newGeneration, generation)</span><br><span class="line">    <span class="keyword">else</span> evolution(newGeneration, target, generation + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/algorithm/ga/gatest.png" alt="测试结果"></p><h2><span id="遗传算法实现自动排课">遗传算法实现自动排课</span></h2><p>点击<a href="https://github.com/barudisshu/syllabus">这里</a>获取源码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ga, ml, scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实践MySQL主从复制(Master-Slave)的操作流程！</title>
      <link href="/2018/07/16/mysql/mysql-master-slave-config/"/>
      <url>/2018/07/16/mysql/mysql-master-slave-config/</url>
      
        <content type="html"><![CDATA[<p>对于发展很小的公司来说，单台服务器支撑整个公司的运转是常见的事情。但是随着用户量的增加，随之而来的数据量也会跟着增加，这就导致更多地用户会使用查询select我们的数据库，从而导致性能急剧的下降。例如，查询缓慢，用户等待时间长等等，高并发，大数据，负载均衡甚至是集群，这些方案都是小公司不会采用的，一方面成本极高，需要运维维护，这已经抵n个程序猿的工资了，所以一般不会采用这种模式。</p><p>仔细的分析一下，这种情况，其实更多地是来源于数据库mysql的承受能力变大，一方面需要读操作，另一方面有需要增删改操作，那么多人同时请求肯定受不了啦！<br>有人说使用缓存，但是再想想mysql的缓存是有限制的，并不是一味的去缓存就可以，又有人说使用redis缓存，存储在内存中，然而事实上运转的时候redis缓存并不能全部给你缓存，有些数据需要实时的查看，而且redis缓存过多，导致cpu直接上涨，严重的话，机器直接运转停止。</p><span id="more"></span><h2><span id="mysql主从复制的解析描述">mysql主从复制的解析描述</span></h2><p>主从复制是指一台服务器充当主数据库服务器（master），另一台或多台服务器充当从数据库服务器（slave），主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。<br>请注意：当你进行复制时，所有对复制中的表的更新必须在主服务器上进行。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对从服务器上的表所进行的更新之间的冲突。</p><p>首先准备环境：<br>1 两台服务器（这里还是以虚拟机做）</p><ul><li>主服务器IP：192.168.200.139</li><li>从服务器IP：192.168.153.140<br>安装的mysql（安装过程不在叙述）：版本号尽可能的保持一致性 本机安装版本是：mysql5.7.21</li></ul><p>一、修改主服务器的mysql配置文件</p><ol><li>本机的主服务器mysql配置文件地址在：<code>etc/my.cnf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line">log-bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line"><span class="comment"># 设置server-id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment"># 关闭名称解析</span></span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><ol start="2"><li>创建从服务器登录主服务器的账号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">mysql&gt; create user <span class="string">&#x27;galudisu&#x27;</span>@<span class="string">&#x27;192.168.200.%&#x27;</span> identified by <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="comment"># 分配权限</span></span><br><span class="line">mysql&gt; grant replication slave on *.* to <span class="string">&#x27;galudisu&#x27;</span>@<span class="string">&#x27;192.168.200.%&#x27;</span>;</span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看主服务器(master)二进制日志状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| master-bin.000001 |      567 |              |                  |                   |</span><br><span class="line">+-------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>解析下参数：<br><i class="conum" data-value="1"></i> File-&gt;mysql-bin.000001 表示记录二进制文件名称<br><i class="conum" data-value="2"></i> Position-&gt;948 所在位置<br><i class="conum" data-value="3"></i> Binlog_Do_DB 指定mysql的binlog日志记录哪个db<br><i class="conum" data-value="4"></i> Binlog_Ignore_DB 告诉master，如果当前的数据库是db_name（就是Binlog_Ignore_DB这个对应的值），不应将更新保存到二进制日志中<br><i class="conum" data-value="5"></i> Executed_Gtid_Set mysql5.7以上新增参数 具体用法 自行百度下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同步哪些数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=<span class="built_in">test</span></span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只同步哪些数据库，除此之外，其它不同步</span></span><br><span class="line">binlog-do-db=shop</span><br></pre></td></tr></table></figure><ol start="4"><li>查看二进制日志状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 4</span><br><span class="line"> Event_type: Format_desc</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 123</span><br><span class="line">       Info: Server ver: 5.7.22-log, Binlog ver: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 123</span><br><span class="line"> Event_type: Previous_gtids</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 154</span><br><span class="line">       Info: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 154</span><br><span class="line"> Event_type: Anonymous_Gtid</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 219</span><br><span class="line">       Info: SET @@SESSION.GTID_NEXT= <span class="string">&#x27;ANONYMOUS&#x27;</span></span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 219</span><br><span class="line"> Event_type: Query</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 415</span><br><span class="line">       Info: CREATE USER <span class="string">&#x27;galudisu&#x27;</span>@<span class="string">&#x27;192.168.200.%&#x27;</span> IDENTIFIED WITH <span class="string">&#x27;mysql_native_password&#x27;</span> AS <span class="string">&#x27;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#x27;</span></span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 415</span><br><span class="line"> Event_type: Anonymous_Gtid</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 480</span><br><span class="line">       Info: SET @@SESSION.GTID_NEXT= <span class="string">&#x27;ANONYMOUS&#x27;</span></span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">   Log_name: master-bin.000001</span><br><span class="line">        Pos: 480</span><br><span class="line"> Event_type: Query</span><br><span class="line">  Server_id: 1</span><br><span class="line">End_log_pos: 567</span><br><span class="line">       Info: flush privileges</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>二、配置从服务器（slave）</p><ol><li>同样的配置文件路径 <code>etc/my.cnf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置server-id，让从服务器又唯一ID号</span></span><br><span class="line">server-id=5</span><br><span class="line"><span class="comment"># 打开MySQL日志，日志格式为二进制</span></span><br><span class="line">relay_log=relay-bin</span><br><span class="line">relay_log_index=relay-bin.index</span><br><span class="line"><span class="comment"># 设置制度权限</span></span><br><span class="line">read_only=1</span><br><span class="line"><span class="comment"># 开启从服务器二进制日志</span></span><br><span class="line">log_bin=slave-bin</span><br><span class="line"><span class="comment"># 使得更新的数据写入二进制日志中</span></span><br><span class="line">log_slave_updates=1</span><br></pre></td></tr></table></figure><p>PS：上面未打开选项是配置文件中可能需要用到的参数，目前只做演示主从 所以是需要使用server-id=5 这个参数就行了。</p><ol start="2"><li>启动从服务器复制线程机制<br>进入从服务器的数据库中：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msyql -uroot -p**</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to</span><br><span class="line">-&gt; master_host=<span class="string">&#x27;192.168.200.139&#x27;</span>, <span class="comment"># 主服务器ip地址</span></span><br><span class="line">-&gt; master_user=<span class="string">&#x27;galudisu&#x27;</span>, <span class="comment"># 主服务器创建的授权用户(切记这个是给从服务器登录的账号)</span></span><br><span class="line">-&gt; master_password=<span class="string">&#x27;123456&#x27;</span>, <span class="comment"># 主服务器创建用户的密码</span></span><br><span class="line">-&gt; master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, <span class="comment"># 主服务器的二进制文件名称</span></span><br><span class="line">-&gt; master_log_pos=567; <span class="comment"># 开始记录的位置</span></span><br><span class="line">回车出现：</span><br><span class="line">Query OK, 0 rows affected, 2 warnings(0.03 sec)</span><br></pre></td></tr></table></figure><p>PS：上面的sql语句是从头开始复制第一个binlog，如果想从某个位置开始复制binlog，就需要在change master to时指定要开始的binlog文件名和语句在文件中的起点位置，参数为：master_log_file和master_log_pos这两个参数哦。</p><ol start="3"><li>启动slave同步进程：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看状态是否已启动复制功能</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 192.168.200.139</span><br><span class="line">                  Master_User: galudisu</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: master-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 931</span><br><span class="line">               Relay_Log_File: relay-bin.000004</span><br><span class="line">                Relay_Log_Pos: 321</span><br><span class="line">        Relay_Master_Log_File: master-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 931</span><br><span class="line">              Relay_Log_Space: 522</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: 14739182-88be-11e8-ba6a-000c292e5d5b</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Slave_IO_Running: Yes</code><br><code>Slave_SQL_Running: Yes</code></p><p>这两项必须为Yes才是成功,截图出现问题 没有截图（抱歉）。</p><p>如果使用了复制的虚拟机, mysql服务的uuid可能会一样Slave_IO_Runing=No, 需要把从服务器mysql目录下的auto.cnf删掉然后重启mysql服务。<br>例如我从服务器的mysql地址是：/var/lib/mysql 切换到下面删除auto.cnf即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf auto.cnf</span><br></pre></td></tr></table></figure><p>另外，如果有防火墙，需要添加3306端口到iptables。</p><p>三、测试一下喽</p><p>在主服务器(master)上，进入数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create database shop;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>在从服务器(slave)上，看看是否有相应的数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shop               |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>这个时候从库就出现这条数据了。</p><p>好了到这里基本上已经OK了，如果有细节未处理，大家就可以自行补充。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql, lvs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slick 3 代码生成实战</title>
      <link href="/2018/07/12/slick/slick3-with-code-generator/"/>
      <url>/2018/07/12/slick/slick3-with-code-generator/</url>
      
        <content type="html"><![CDATA[<p>Slick的全称是&quot;Scala Language-Integrated Connection Kit&quot;，它是类型安全的函数式关系型映射库，简称<code>FRM</code> - Functional Relational Mapping。专门用于Scala对关系型数据库的操作。它带来了函数式语言的便利性，可以通过Scala的丰富集合对数据库转换。Slick适用基于<a href="https://playframework.com/">Play</a> 和 <a href="http://akka.io/">Akka</a> 框架的功能实现。</p><p>Slick底层实现了<code>DBIO</code>的响应式设计，它是一个<a href="http://www.reactive-streams.org/">Reactive Stream</a>的实现，因此有一下一些特性：</p><ul><li>Clean separation of I/O and CPU-intensive code: Isolating I/O allows you to keep your main thread pool busy with CPU-intensive parts of the application while waiting for I/O in the background.</li><li>Resilience under load(负荷回弹): When a database cannot keep up with the load of your application, Slick will not create more and more threads (thus making the situation worse) or lock out all kinds of I/O. Back-pressure is controlled efficiently through a queue (of configurable size) for database I/O actions, allowing a certain number of requests to build up with very little resource usage and failing immediately once this limit has been reached.</li><li>Reactive Streams for asynchronous streaming.</li><li>Efficient utilization of database resources: Slick can be tuned easily and precisely for the parallelism (number of concurrent active jobs) and resource ussage (number of currently suspended database sessions) of your database server.</li><li></li></ul><span id="more"></span><p>Slick 3 的新特性集中在：大量使用组合的设计模式，不需要显式声明session，非阻塞，stream支持的 reactive 等 。</p><p>首先创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `action`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `action` (</span><br><span class="line">  `id`   <span class="type">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)</span><br><span class="line">  ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><p>SBT配置依赖，并加入SBT Task</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;chapa-Slick&quot;</span></span><br><span class="line"></span><br><span class="line">version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">scalaVersion := <span class="string">&quot;2.11.8&quot;</span></span><br><span class="line"></span><br><span class="line">organization := <span class="string">&quot;Scala in ALG &amp; design pattern&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append options passed to the Scala compiler</span></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-deprecation&quot;</span>, <span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-feature&quot;</span>)</span><br><span class="line"></span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.scalatest&quot;</span> %% <span class="string">&quot;scalatest&quot;</span> % <span class="string">&quot;3.0.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;junit&quot;</span> % <span class="string">&quot;junit&quot;</span> % <span class="string">&quot;4.12&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.slf4j&quot;</span> % <span class="string">&quot;slf4j-api&quot;</span> % <span class="string">&quot;1.7.22&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.apache.logging.log4j&quot;</span> % <span class="string">&quot;log4j-core&quot;</span> % <span class="string">&quot;2.7&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.apache.logging.log4j&quot;</span> % <span class="string">&quot;log4j-api&quot;</span> % <span class="string">&quot;2.7&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.apache.logging.log4j&quot;</span> % <span class="string">&quot;log4j-slf4j-impl&quot;</span> % <span class="string">&quot;2.7&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.typesafe.scala-logging&quot;</span> %% <span class="string">&quot;scala-logging&quot;</span> % <span class="string">&quot;3.5.0&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mysql&quot;</span> % <span class="string">&quot;mysql-connector-java&quot;</span> % <span class="string">&quot;6.0.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.zaxxer&quot;</span> % <span class="string">&quot;HikariCP&quot;</span> % <span class="string">&quot;2.7.8&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;com.typesafe.slick&quot;</span> %% <span class="string">&quot;slick&quot;</span> % <span class="string">&quot;3.2.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.typesafe.slick&quot;</span> %% <span class="string">&quot;slick-hikaricp&quot;</span> % <span class="string">&quot;3.2.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.typesafe.slick&quot;</span> %% <span class="string">&quot;slick-codegen&quot;</span> % <span class="string">&quot;3.2.1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">slick &lt;&lt;= slickCodeGenTask</span><br><span class="line"></span><br><span class="line">sourceGenerators in <span class="type">Compile</span> &lt;+= slickCodeGenTask</span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> slick = <span class="type">TaskKey</span>[<span class="type">Seq</span>[<span class="type">File</span>]](<span class="string">&quot;gen-tables&quot;</span>)</span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> slickCodeGenTask = (sourceManaged, dependencyClasspath in <span class="type">Compile</span>, runner in <span class="type">Compile</span>, streams) map &#123; (dir, cp, r, s) =&gt;</span><br><span class="line">  <span class="keyword">val</span> outputDir = (dir / <span class="string">&quot;main/scala&quot;</span>).getPath</span><br><span class="line">  <span class="keyword">val</span> username = <span class="string">&quot;root&quot;</span></span><br><span class="line">  <span class="keyword">val</span> password = <span class="string">&quot;****&quot;</span></span><br><span class="line">  <span class="keyword">val</span> url = <span class="string">&quot;jdbc:mysql:///test?nullNamePatternMatchesAll=true&amp;serverTimezone=UTC&quot;</span></span><br><span class="line">  <span class="keyword">val</span> jdbcDriver = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line">  <span class="keyword">val</span> slickDriver = <span class="string">&quot;slick.jdbc.MySQLProfile&quot;</span></span><br><span class="line">  <span class="keyword">val</span> pkg = <span class="string">&quot;cn.galudisu.fp.models&quot;</span></span><br><span class="line">  toError(r.run(<span class="string">&quot;slick.codegen.SourceCodeGenerator&quot;</span>, cp.files, <span class="type">Array</span>(slickDriver, jdbcDriver, url, outputDir, pkg, username, password), s.log))</span><br><span class="line">  <span class="keyword">val</span> fname = outputDir + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;cn/galudisu/fp/models&quot;</span> + <span class="string">&quot;/Tables.scala&quot;</span></span><br><span class="line">  <span class="type">Seq</span>(file(fname))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立Dao层</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">Executors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.galudisu.fp.models.<span class="type">Tables</span>._</span><br><span class="line"><span class="keyword">import</span> cn.galudisu.fp.models.<span class="type">Tables</span>.profile.api._</span><br><span class="line"><span class="keyword">import</span> cn.galudisu.fp.models._</span><br><span class="line"><span class="keyword">import</span> slick.lifted.<span class="type">Query</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.&#123;<span class="type">ExecutionContext</span>, <span class="type">ExecutionContextExecutorService</span>, <span class="type">Future</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findById</span></span>(id: <span class="type">Long</span>): <span class="type">Future</span>[<span class="type">Option</span>[<span class="type">Tables</span>.<span class="type">ActionRow</span>]]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(name: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">Long</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionDaoImpl</span>(<span class="params">db: <span class="type">Database</span></span>) <span class="keyword">extends</span> <span class="title">ActionDao</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">implicit</span> <span class="keyword">val</span> ec: <span class="type">ExecutionContextExecutorService</span> = <span class="type">ExecutionContext</span>.fromExecutorService(<span class="type">Executors</span>.newFixedThreadPool(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findById</span></span>(id: <span class="type">Long</span>): <span class="type">Future</span>[<span class="type">Option</span>[<span class="type">Tables</span>.<span class="type">ActionRow</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> query: <span class="type">Query</span>[<span class="type">Tables</span>.<span class="type">Action</span>, <span class="type">Tables</span>.<span class="type">Action</span>#<span class="type">TableElementType</span>, <span class="type">Seq</span>] = <span class="type">Action</span>.filter(_.id === id)</span><br><span class="line">    <span class="keyword">val</span> action = query.result.headOption</span><br><span class="line">    db.run(action)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(name: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">Long</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> query = <span class="type">Action</span>.map(a =&gt; a.name)</span><br><span class="line">    <span class="keyword">val</span> actions = (<span class="keyword">for</span> &#123;</span><br><span class="line">      actionInsert &lt;- query += name</span><br><span class="line">      actionId &lt;- <span class="string">sql&quot;SELECT LAST_INSERT_ID()&quot;</span>.as[(<span class="type">Long</span>)].head</span><br><span class="line">    &#125; <span class="keyword">yield</span> actionId).transactionally</span><br><span class="line">    db.run(actions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用了HikariCP作为数据库连接池，需要一些额外配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db = &#123;</span><br><span class="line">  driver = &quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line">  url = &quot;jdbc:mysql://localhost:3306/test?nullNamePatternMatchesAll=true&amp;serverTimezone=UTC&quot;</span><br><span class="line">  connectionTimeout = 3000</span><br><span class="line">  validationTimeout = 1000</span><br><span class="line">  connectionTestQuery = &quot;/*ping*/ select 1&quot;</span><br><span class="line">  keepAliveConnection = true</span><br><span class="line">  numThreads = 10</span><br><span class="line">  numThreads = 5</span><br><span class="line">  connectionTimeout = 30000</span><br><span class="line">  maximumPoolSize = 26</span><br><span class="line">  user = &quot;root&quot;</span><br><span class="line">  password = &quot;****&quot;</span><br><span class="line">  connectionPool = &quot;HikariCP&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库需要打印输出SQL相关信息，所以加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration status=&quot;OFF&quot; monitorInterval=&quot;1800&quot;&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;TRACE&quot; onMatch=&quot;ACCEPT&quot;/&gt;</span><br><span class="line">            &lt;PatternLayout</span><br><span class="line">                    pattern=&quot;[%-5level %date&#123;HH:mm:ss.SSS&#125;] %msg%n%throwable&quot;/&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line">    &lt;/Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;logger name=&quot;slick&quot; level=&quot;DEBUG&quot;/&gt;</span><br><span class="line">        &lt;Root level=&quot;INFO&quot;&gt;</span><br><span class="line">            &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">        &lt;/Root&gt;</span><br><span class="line">    &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure><p>单元测试</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.galudisu.fp.models.<span class="type">Tables</span>.profile.api._</span><br><span class="line"><span class="keyword">import</span> org.scalatest._</span><br><span class="line"><span class="keyword">import</span> org.scalatest.concurrent.<span class="type">ScalaFutures</span></span><br><span class="line"><span class="keyword">import</span> org.scalatest.time.&#123;<span class="type">Millis</span>, <span class="type">Seconds</span>, <span class="type">Span</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionDaoSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">Matchers</span> <span class="keyword">with</span> <span class="title">ScalaFutures</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> defaultPatience: <span class="type">PatienceConfig</span> =</span><br><span class="line">    <span class="type">PatienceConfig</span>(timeout = <span class="type">Span</span>(<span class="number">2</span>, <span class="type">Seconds</span>), interval = <span class="type">Span</span>(<span class="number">5</span>, <span class="type">Millis</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> db = <span class="type">Database</span>.forConfig(<span class="string">&quot;db&quot;</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> actionDao = <span class="type">ActionDaoImpl</span>(db)</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;save&quot;</span> should <span class="string">&quot;save the value without exception&quot;</span> in &#123;</span><br><span class="line">    actionDao.save(<span class="string">&quot;Hello!&quot;</span>).futureValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;findById&quot;</span> should <span class="string">&quot;find a row&quot;</span> in &#123;</span><br><span class="line">    <span class="keyword">val</span> actionId = actionDao.save(<span class="string">&quot;New Hello!&quot;</span>).futureValue</span><br><span class="line">    <span class="keyword">val</span> maybeAction = actionDao.findById(actionId).futureValue</span><br><span class="line"></span><br><span class="line">    maybeAction.isDefined should be(<span class="literal">true</span>)</span><br><span class="line">    maybeAction.get.name should be(<span class="string">&quot;New Hello!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAO模式实际上在函数式编程中并不适用，读者有兴趣，可以参考Shapeless的设计进行改造</p><p><img src="/img/slick/slick-test.png" alt="Unit Test"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arnaudt.github.io/2015/03/31/slick-codegen.html">参考这里</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> slick, hikariCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Type_Level Programming in Scala</title>
      <link href="/2018/07/11/scala-exercises/type-level-in-scala/"/>
      <url>/2018/07/11/scala-exercises/type-level-in-scala/</url>
      
        <content type="html"><![CDATA[<p>最近在研究的Shapeless框架，需要我们从新认识Scala的类型系统编程，另外Scala的宏编译也是我们需要关注的部分。</p><p>动机，混合集合类型(Heterogeneous collection types, HList, Harray)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l1 = <span class="number">42</span> :: <span class="string">&quot;foo&quot;</span> :: <span class="type">Some</span>(<span class="number">1.0</span>) :: <span class="string">&quot;bar&quot;</span> :: <span class="type">HNil</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="type">Int</span> = l1.head</span><br><span class="line"><span class="keyword">val</span> s: <span class="type">String</span> = l1.tail.head</span><br></pre></td></tr></table></figure><span id="more"></span><div style="float:left"><ul><li>和Scala的tuples不同</li><li style="list-style-type: none"><ul><li>没有大小限制</li><li>没有类型抽象限制</li></ul></li><li>Requirement: No runtime overhead</li><li style="list-style-type: none"><ul><li>没有隐式</li></ul></li></ul></div><div style="float:right"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=442867433&auto=1&height=66"></iframe></div><div class="clearfix"></div><p>总体来说，我们要解决以下几个问题：</p><ul><li>ADTs (Algebraic Data Types)</li><li>Different basic values and classes become types</li><li>Purely-functional design</li><li>Polymorphic dispatch (on receiver)<br>• No match, if…else, etc.</li></ul><p>相应的转换规则方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT Values: `val` -&gt; `<span class="built_in">object</span>`</span><br><span class="line">Members: `<span class="function"><span class="keyword">def</span> <span class="title">x</span>/<span class="title">val</span> <span class="title">x</span>` -&gt; `<span class="built_in">type</span> X`</span></span><br><span class="line"><span class="function"> `<span class="keyword">def</span> f(x)`-&gt; `<span class="built_in">type</span> F[X]`</span></span><br><span class="line"><span class="function"> `a.b` -&gt; `A#B`</span></span><br><span class="line"><span class="function"> `x:</span> T` -&gt; `X &lt;: T`</span><br><span class="line"> `new A(b)`-&gt; `A[B]`</span><br></pre></td></tr></table></figure><h2><span id="scala-macro-precompute">Scala macro precompute</span></h2><p>Scala 的宏编译比较特殊，它实际上是在REPL上面进行的一段脚本，在介绍Type Level之前，有必要阐述一下Scala的宏编译实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PrintfMacro</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printf</span></span>(format: <span class="type">String</span>, params: <span class="type">Any</span>*) = macro printf_impl</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printf_impl</span></span>(c: blackbox.<span class="type">Context</span>)(format: c.<span class="type">Expr</span>[<span class="type">String</span>], params: c.<span class="type">Expr</span>[<span class="type">Any</span>]*): c.<span class="type">Expr</span>[<span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">import</span> c.universe._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="string">q&quot;<span class="subst">$&#123;s_format:String&#125;</span>&quot;</span> = format.tree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> evals = <span class="type">ListBuffer</span>[<span class="type">Tree</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precompute</span></span>(value: <span class="type">Tree</span>, tpe: <span class="type">Type</span>): <span class="type">Tree</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> freshName = <span class="type">TermName</span>(c.freshName(<span class="string">&quot;eval$&quot;</span>))</span><br><span class="line">      <span class="keyword">val</span> valdef = <span class="string">q&quot;val <span class="subst">$freshName</span>: <span class="subst">$tpe</span> = <span class="subst">$value</span>&quot;</span></span><br><span class="line">      evals += valdef</span><br><span class="line">      <span class="string">q&quot;<span class="subst">$freshName</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    <span class="keyword">val</span> paramsStack = mutable.<span class="type">Stack</span>[<span class="type">Tree</span>](params map (_.tree): _*)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> refs = s_format.split(<span class="string">&quot;(?&lt;=%[\\w%])|(?=%[\\w%])&quot;</span>) map &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;%d&quot;</span> =&gt; precompute(paramsStack.pop, typeOf[<span class="type">Int</span>])</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;%s&quot;</span> =&gt; precompute(paramsStack.pop, typeOf[<span class="type">String</span>])</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;%%&quot;</span> =&gt; <span class="type">Literal</span>(<span class="type">Constant</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">      <span class="keyword">case</span> part =&gt; <span class="type">Literal</span>(<span class="type">Constant</span>(part))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stats: <span class="type">ListBuffer</span>[<span class="type">Tree</span>] = evals ++ refs.map(ref =&gt; <span class="string">q&quot;print(<span class="subst">$ref</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c.<span class="type">Expr</span>[<span class="type">Unit</span>](<span class="string">q&quot;..<span class="subst">$stats</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PrintfTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    printf(<span class="string">&quot;simple test age = %d name = %s Hello&quot;</span>, <span class="number">41</span>, <span class="string">&quot;wangzaixiang&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际开发通常用到隐式复用中，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Macros</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerEx</span>(<span class="params">val logger: <span class="type">Logger</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEBUG</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = macro <span class="type">LogMacros</span>.<span class="type">DEBUG1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEBUG</span></span>(msg: <span class="type">String</span>, exception: <span class="type">Exception</span>): <span class="type">Unit</span> = macro <span class="type">LogMacros</span>.<span class="type">DEBUG2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">LogMacros</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEBUG1</span></span>(c: <span class="type">Context</span>)(msg: c.<span class="type">Tree</span>): c.<span class="type">Tree</span> = &#123;</span><br><span class="line">      <span class="keyword">import</span> c.universe._</span><br><span class="line">      <span class="keyword">val</span> pre = c.prefix</span><br><span class="line">      <span class="string">q&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">         val x = $pre.logger</span></span><br><span class="line"><span class="string">         println(&quot;</span>=<span class="string">&quot; * 60)</span></span><br><span class="line"><span class="string">         if( x.isDebugEnabled ) x.debug($msg)</span></span><br><span class="line"><span class="string">         println(&quot;</span>=<span class="string">&quot; * 60)</span></span><br><span class="line"><span class="string">       &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEBUG2</span></span>(c:<span class="type">Context</span>)(msg: c.<span class="type">Tree</span>, exception: c.<span class="type">Tree</span>): c.<span class="type">Tree</span> = &#123;</span><br><span class="line">      <span class="keyword">import</span> c.universe._</span><br><span class="line">      <span class="keyword">val</span> pre = c.prefix</span><br><span class="line">      <span class="string">q&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">         val x = $pre.logger</span></span><br><span class="line"><span class="string">         if(x.isDebugEnabled) x.debug( $msg, $exception )</span></span><br><span class="line"><span class="string">       &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入测试…</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DebugTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> log = <span class="type">LoggerFactory</span>.getLogger(<span class="keyword">this</span>.getClass)</span><br><span class="line">    log.<span class="type">DEBUG</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="thinking-recursively-addition">Thinking Recursively: Addition</span></h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://blog.xebia.com/compile-time-evaluation-scala-macros/">http://blog.xebia.com/compile-time-evaluation-scala-macros/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> scala, type-level </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo+Gnome+Systemd 安装记录</title>
      <link href="/2018/07/03/gentoo/Gentoo-Gnome-Systemd/"/>
      <url>/2018/07/03/gentoo/Gentoo-Gnome-Systemd/</url>
      
        <content type="html"><![CDATA[<p>Gentoo Linux（发音为/ˈdʒɛntuː/）是一种Linux操作系统，基于Portage包管理系统，而拥有几乎无限制的适应性特性，被官方称作元发行版（meta-distribution）[2]，支持多达10种以上的计算机系统结构平台。此项目和它的产品以巴布亚企鹅命名。Gentoo包管理系统的设计是模块化、可移植、易维护、灵活以及针对用户机器优化的。软件包从源代码构建，这延续了ports的传统。但是为了方便，也提供一些大型软件包在多种架构的预编译二进制文件，用户亦可自建或使用第三方二进制包镜像来直接安装二进制包。</p><span id="more"></span><p>安装步骤就不说了，Gentoo官网上的Wiki写得非常详细。</p><div class="responsive">  <div class="gallery">    <a target="_blank" href="/img/gentoo/g1.png">      <img src="/img/gentoo/g1.png" alt="Cinque Terre" width="600" height="400">    </a>  </div></div><div class="responsive">  <div class="gallery">    <a target="_blank" href="/img/gentoo/g2.png">      <img src="/img/gentoo/g2.png" alt="Forest" width="600" height="400">    </a>  </div></div><div class="responsive">  <div class="gallery">    <a target="_blank" href="/img/gentoo/g3.png">      <img src="/img/gentoo/g3.png" alt="Northern Lights" width="600" height="400">    </a>  </div></div><div class="responsive">  <div class="gallery">    <a target="_blank" href="/img/gentoo/g4.png">      <img src="/img/gentoo/g4.png" alt="Mountains" width="600" height="400">    </a>  </div></div><div class="clearfix"></div><p>系统<a href="https://github.com/daniruiz/flat-remix-gnome">美化</a> 使用扁平化风格，终端加入zsh-suggestions和oh-my-zsh。另外有个坑，就是gnome-terminal编译时，如果指定了locale，再将系统切换为其它locale时会出错，原因未知，可能是我操作有问题。系统字体模糊，可以参考<a href="https://wiki.gentoo.org/wiki/Fontconfig/zh-cn#Custom_system_wide_configuration">这里</a> ，infinality bundle是不被推荐的，因为存在兼容性问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> gentoo,linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka Distributed Data Deep Dive</title>
      <link href="/2018/06/06/akka/ddata/Akka-Distributed-Data-Deep-Dive/"/>
      <url>/2018/06/06/akka/ddata/Akka-Distributed-Data-Deep-Dive/</url>
      
        <content type="html"><![CDATA[<h2><span id="一致性难题">一致性难题</span></h2><p><a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP</a> 定理阐述了在构建分布式系统时候，<strong>Consistency(一致性)</strong>， <strong>Availability(可用性)</strong>，<strong>Partition tolerance(分区容错性)</strong>，这三者只能取二。</p><p>计算给我们再多的资源(常常以为可以用空间来换取时间，比如加内存，加物理机，甚至加钱)，受制于目前计算机体系(多核CPU)，理论上不可能三者都满足。</p><p>CAP 理论通常都会表述如下：在一致性、可用性和分区容错性这三个特性中，一个分布式系统只能够选择满足其中两个。<strong>分区容错性</strong>是我们必须要满足的，它表示如果数据被冗余备份到三个节点，那么如果其中一个节点暂时变得不可用，而另两个节点仍然能够正常运行，那么就认为系统具备分区容错性。</p><p>假设我们希望系统具备分区容错性，只在可用性和一致性之间进行妥协。读者可能会问为什么。在接收到一个有超时限制的请求时，如果节点不可用，我们其实就需要在两种方案之间进行选择：要么返回错误（选择一致性），要么继续，即使服务器之间可能会不一致（选择可用性）。等待的时间过长会导致该请求被抛弃，所以时间是一个重要的因素，系统必须要在上面两者中做出决定。</p><p>为了达到高可用，就必须满足最终一致性；为了达到最终一致性，就会牺牲可用性，数据插入后并不得到一个真实的返回。这里就出现了一致性问题，即要求强一致性时，系统非常非常慢，因为事件A的操作完成后，才能执行后续操作；若是要求最终一致性，多个节点如果没有同步副本，执行查询并不能得到希望的结果，因为我们并不知道副本什么时候同步完成。</p><p>现在认为，只要是最终一致性的就可以接受的范围。并且你会发现，所有力求最终一致性的分布式系统，都应该使用CRDT。</p><blockquote><p>分布式事务常见的有几种解决方案：</p><ul><li>两阶段提交（2PC）</li><li>补偿事务（TCC）</li><li>本地消息表（异步确保）</li><li>MQ 事务消息</li><li>Sagas 事务模型</li></ul><p>具体依赖于系统的实现逻辑方案来决定。这里撇开分布式事务不谈。</p></blockquote><h2><span id="conflict-free-replicated-data-types-crdt无冲突复制数据类型">Conflict Free Replicated Data Types - CRDT(无冲突复制数据类型)</span></h2><p>CRDT，顾名思义就是一类数据结构。指的是副本可以被同步到各个节点上，副本(replicas)与副本之间更新不需要依赖调停器(coordination)。有两种方式实现CRDT，<code>Operation-based CRDTs</code> 和 <code>State-based CRDTs</code>，两种方式都能实现强最终一致性(strong eventual consistencey)。</p><p>根据Shapiro本人的论文<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，两种实现都是等价的，都可以相互模拟。</p><p><strong>State-based replication</strong>: 当一个副本(replica)收到来自客户端的一个<code>Update</code>时，首先更新自己的状态，之后将自身的所有状态发送给另一个副本。间接性地，每个副本都将自己的<code>full state</code>发送给系统内的其它副本。当一个副本收到来自其它副本的状态，提供一个<code>Merge</code>函数，将自身本地的状态和接收到的状态合并。如下所示，如果集合的值的状态可以表示为一个半格(<a href="https://en.wikipedia.org/wiki/Semilattice">semi-lattice</a> )(半格 —— 一个偏序集，带有连续/最小上界)并且更新是递增的(譬如，状态是一个整数，更新是一个自增操作)，并且如果<code>Merge</code>函数计算最小上界，则可以确保副本已经合并了相同的值(接近最小上界)。要让系统尽可能成为一个<strong>半格</strong>，<code>Merge</code>操作必须满足等幂(idempotent)、结合律(associative)、交换律(commutative)。一个副本对象满足这些特征的CRDT，称为<strong>CvRDT(convergent replicated data type)</strong>。</p><p><img src="/img/akka/ddata/1_Vn9ZGiUAcxQHw27RH3bz8g.png" alt="State-based approach. “s” denotes the source replica where the initial update is applied"></p><p><strong>Operation-based replication</strong>: 该方式并没有将一个副本的全部状态发送给另一个副本，而是通过广播的形式将<code>Update</code>操作发送给系统的其他副本，并由它们重演更新操作(类似于<a href="https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6">状态机复制</a> )。因为是广播操作，如果有两个更新，<em>u_1</em> 和 <em>u_2</em>，作用于副本 <em>i</em> 上，然后副本 <em>i</em> 将这两个更新发送给另外两个副本 <em>r_1</em> 和 <em>r_2</em> ，这时更新到达副本的顺序是不同的，<em>r_1_可能先收到_u_1</em>，<em>u_2</em> ，<em>r_2</em> 可能是先收到 <em>u_2</em> 然后 <em>u_1</em> 。如何进行合并？不管顺序如何，这些更新是满足交换律的，副本最后得到的状态是相同的。类似于这种广播的形式发送<code>Update</code>到所有副本，这一类对象称之为<strong>CmRDT(commutative replicated data type)</strong>。</p><p><img src="/img/akka/ddata/1_E-_IN_tTSiirbJ1-7XTh5w.png" alt="Operation-based approach. “s” denotes source replicas and “d” denotes the downstream replicas"></p><p>CRDT解决了分布式系统的一个有趣而又基本的问题，但是有一些限制。CRDT不实现一致性，只针对部分问题空间的<code>Update</code>操作的交换，而不是所有。因此并不是所有问题都可以转化为CRDT。</p><p>关于CRDT的研究， Shapiro论文提出了几点理论<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p><ul><li>(Convergent Replicated Data Type (CvRDT)). Assuming eventual delivery and termination, any state-based object that satisfies the monotonic semilattice property is SEC.</li><li>(Commutative Replicated Data Type (CmRDT)). Assuming causal delivery of updates and method termination, any op-based object that satisfies the commutativity property for all concurrent updates, and whose delivery precondition is satisfied by causal delivery, is SEC.</li><li>(CvRDT emulation). Any SEC op-based object can be emulated by a SEC state-based object of a corresponding interface.</li></ul><h2><span id="akka集群分片">Akka集群分片</span></h2><p>作为抛砖引玉，这里先介绍Akka Sharding的实现方式，再来介绍Akka Distributed Data。</p><p>Akka Sharding也是一种分布式集群的实现<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，集群分片主要应用于需要有大量带有状态的Actor处理大量数据的情形。因为要处理Actor的状态，所以很多例子都要求分片上的Actor都是继承了PersistenceActor。为了避免混淆，我们这里不引入PersistenceActor，单独阐述Cluster Sharding的机制。</p><p>由于集群分片需要实现位置透明，即<code>ShardRegion.ExtractEntityId</code>需要通过<code>EntityId</code>知会分片Actor的具体位置，从而向对应的Actor发送消息；当然你也可以不需要知会Actor的位置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CounterClusterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityEnvelope</span>(<span class="params">entityId: <span class="type">String</span>, payload: <span class="type">Any</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span>(<span class="params">entityId: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">val</span> numberOfShards = <span class="number">100</span> <span class="comment">// 最大分片数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> extractEntityId: <span class="type">ShardRegion</span>.<span class="type">ExtractEntityId</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EntityEnvelope</span>(entityId, payload) =&gt; (entityId, payload)</span><br><span class="line">    <span class="keyword">case</span> msg<span class="meta">@Get</span>(entityId) =&gt; (entityId, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> extractShardId: <span class="type">ShardRegion</span>.<span class="type">ExtractShardId</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EntityEnvelope</span>(entityId, _) =&gt; (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Get</span>(entityId) =&gt; (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ShardRegion</span>.<span class="type">StartEntity</span>(entityId) =&gt;</span><br><span class="line">      <span class="comment">// StartEntity is used by remembering entities feature</span></span><br><span class="line">      (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Increment</span></span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Decrement</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Stop</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterChanged</span>(<span class="params">delta: <span class="type">Int</span></span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> com.lightbend.akka.np_sharding.<span class="type">Counter</span>._</span><br><span class="line">  <span class="keyword">import</span> com.lightbend.akka.np_sharding.<span class="type">CounterClusterConfig</span>.<span class="type">Get</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line">  context.setReceiveTimeout(<span class="number">120.</span>seconds)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> entityType: <span class="type">String</span> = getClass.getSimpleName</span><br><span class="line">  <span class="keyword">val</span> entityId  : <span class="type">String</span> = self.path.name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;==&gt;1. I was created...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;==&gt;4. I was stop...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Get</span>(id) =&gt;</span><br><span class="line">      log.debug(<span class="string">s&quot;==&gt;2. <span class="subst">$id</span> established...&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> it<span class="meta">@Increment</span> =&gt;</span><br><span class="line">      log.debug(<span class="string">&quot;==&gt;3. I am increase...&quot;</span>)</span><br><span class="line">      context stop self</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShardRegion每次收到来自客户端的消息时，如果分片中没有对应ID的Actor，则会先创建该Actor，然后发送消息；若存在该ID的Actor，则消息直接被Actor处理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counterRegion: <span class="type">ActorRef</span> = <span class="type">ClusterSharding</span>(system).start(</span><br><span class="line">  typeName = <span class="string">&quot;Counter&quot;</span>,</span><br><span class="line">  entityProps = <span class="type">Props</span>[<span class="type">Counter</span>],</span><br><span class="line">  settings = <span class="type">ClusterShardingSettings</span>(system),</span><br><span class="line">  extractEntityId = <span class="type">CounterClusterConfig</span>.extractEntityId,</span><br><span class="line">  extractShardId = <span class="type">CounterClusterConfig</span>.extractShardId)</span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduler sender message</span></span><br><span class="line">system.scheduler.schedule(<span class="number">0.</span>second,</span><br><span class="line">  <span class="number">5.</span>seconds,</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> id = java.util.<span class="type">UUID</span>.randomUUID.toString</span><br><span class="line">      counterRegion ! <span class="type">Get</span>(id)</span><br><span class="line">      counterRegion ! <span class="type">EntityEnvelope</span>(id, <span class="type">Increment</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sys.addShutdownHook &#123;</span><br><span class="line">  <span class="type">Await</span>.result(system.whenTerminated, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分片Region类似于线程池，既然可以重复利用，为什么不创建一个监督机制。这样每个Actor都是位置透明的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSupervisor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> counter = context.actorOf(<span class="type">Props</span>[<span class="type">Counter</span>], <span class="string">&quot;theCounter&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = <span class="type">OneForOneStrategy</span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">IllegalArgumentException</span>     ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Resume</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">ActorInitializationException</span> ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">DeathPactException</span>           ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">Exception</span>                    ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> msg ⇒ counter forward msg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">默认地，<span class="type">Akka</span> <span class="type">Sharding</span>使用的是[<span class="type">Distributed</span> <span class="type">Data</span> <span class="type">Mode</span>](https:<span class="comment">//doc.akka.io/docs/akka/current/cluster-sharding.html?language=scala#distributed-data-vs-persistence-mode)，</span></span><br><span class="line"></span><br><span class="line">```scala</span><br><span class="line">akka.cluster.sharding.state-store-mode = ddata</span><br></pre></td></tr></table></figure><p>你也可以使用Persistence Mode，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">akka.cluster.sharding.state-store-mode = persistence</span><br></pre></td></tr></table></figure><p>这个描述的Distributed Data Mode跟接下来的 Akka Distribted Data并不是一回事。关于更多Akka Sharding 的技术细节可以参考官网。</p><h2><span id="akka-distributed-data">Akka Distributed Data</span></h2><p>Akka Distributed Data 是一个用于节点间共享数据的模组。它被设计成Key-Value存储，Value实现了CRDT(Conflict Free Replicated Data Types)。它允许节点的数据可以从其它任意节点更新，二不需要经过<code>Coordinator</code>处理，CRDT的Value总是合并(converge)。</p><p>前面已经描述了CRDT的原理和结构，那么理解Akka Distribted Data就可以得心应手了。区别于Akka Sharding，distributed-data中的<code>Replicator</code>是API提供的，所以直接拿来用就可以了。</p><p>副本(Replicator)，声明如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.cluster.ddata._</span><br><span class="line"> </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(context.system)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> replicator: <span class="type">ActorRef</span> = <span class="type">DistributedData</span>(context.system).replicator</span><br></pre></td></tr></table></figure><p>Akka Distributed Data实际上相当于Redis的Key-Value存储，并且一致性都是可调的。由于Key的特殊性，它是Value类型的编码形式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Key</span> = <span class="type">ORMapKey</span>.create[<span class="type">String</span>, <span class="type">StoredOrder</span>](<span class="string">&quot;orders&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的<code>Key</code>变量以大写开头，允许用<code>match</code>表达式匹配。这是Scala语言规范，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8.1.1 Variable Patterns</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">A variable pattern x is a simple identifier which starts with a *lower case* letter. It matches any value, and binds the variable name to that value. [...]</span><br></pre></td></tr></table></figure><p><code>Replicator</code>实际上是一个简单的Actor，我们通过消息协议进行副本的通讯。例如要处理更新操作，让<code>Replicator</code>发送<code>Replicator.Update</code>消息，</p><figure class="highlight scala"><figcaption><span>Replicator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeOrderValidation</span></span>(id: <span class="type">OrderIdentifier</span>, storedOrder: <span class="type">StoredOrder</span>, request: <span class="type">StoreOrderValidation</span>) = &#123; </span><br><span class="line">  replicator ! <span class="type">Replicator</span>.<span class="type">Update</span>(</span><br><span class="line">    key = <span class="type">Key</span>, <i class="conum" data-value="1"></i></span><br><span class="line">    initial = <span class="type">ORMap</span>.empty[<span class="type">String</span>, <span class="type">StoredOrder</span>], <i class="conum" data-value="2"></i></span><br><span class="line">    writeConsistency = <span class="type">Replicator</span>.<span class="type">WriteMajority</span>(<span class="number">5.</span>seconds), <i class="conum" data-value="3"></i></span><br><span class="line">    request = <span class="type">Some</span>(request) <i class="conum" data-value="4"></i></span><br><span class="line">  ) &#123; orders =&gt; <i class="conum" data-value="5"></i></span><br><span class="line">    orders + (id.i.toString -&gt; storedOrder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="conum" data-value="1"></i> 副本需要知会Key是什么<br><i class="conum" data-value="2"></i> 分布式数据初始化值，这里定义了Key对应的Value是空的。Data Type为<code>ORMap[String, StoredOrder]</code><br><i class="conum" data-value="3"></i> 写一致性，它可以是<code>WriteLocal</code>，<code>WriteTo(number of nodes)</code>，<code>WriteMajority</code>以及<code>WriteAll</code>。这里我们使用<code>WriteMajority</code>。表示立即写入N/2 + 1个节点(N是集群中节点的个数)<br><i class="conum" data-value="4"></i> 可选的。该对象附带更新请求一并传递。<br><i class="conum" data-value="5"></i> 这里是一个函数，作用于要修改的值。例如这里的数据是添加一个新的<code>StoredOrder</code>到map中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span> &lt;: <span class="type">ReplicatedData</span>](</span><br><span class="line">    key: <span class="type">Key</span>[<span class="type">A</span>], initial: <span class="type">A</span>, writeConsistency: <span class="type">WriteConsistency</span>,</span><br><span class="line">    request: <span class="type">Option</span>[<span class="type">Any</span>] = <span class="type">None</span>)(modify: <span class="type">A</span> ? <span class="type">A</span>): <span class="type">Update</span>[<span class="type">A</span>]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>整个过程就是，<code>Update</code>消息携带的<code>Key</code>，通过<code>modify</code>函数，写入<code>Value</code>到<code>ORMap</code>中。那么接下来会出现3种情况：</p><ul><li>更新成功</li><li>更新全部失败</li><li>介于两者之间，部分更新成功</li></ul><p>如果所有都按计划执行，将返回一个<code>UpdateSuccess</code>消息，表示更新成功。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Replicator</span>.<span class="type">UpdateSuccess</span>(<span class="type">Key</span>, <span class="type">Some</span>(request: <span class="type">StoreOrderValidation</span>)) =&gt;</span><br><span class="line">  request.replyTo ! <span class="type">OrderValidationStored</span>(request.id, request.order)</span><br></pre></td></tr></table></figure><p>或者更新失败，返回得到一个<code>ModifyFailure</code>。</p><p>最后一种情况，“我们不确定是否成功，但它确实运行了”，这时包含有<code>UpdateTimeout</code>和<code>StoreFailure</code>。</p><p><code>UpdateTimeout</code>的出现，取决于事先定义的一致性等级。例如这里定义的是<code>Replicator.WriteMajority(5.seconds)</code>，表示主节点在5秒的时间内没有应答。这种情况出现，可能是其它几个节点处理消息非常慢、或者网络延迟等等因素。如何处理这种情况取决于真实的案例。</p><p><code>StoreFailure</code>，表示本地持久化存储出现了问题。这种问题出现之前，需先额外定义是否进行本地的持久化。</p><p>一个非常实用的操作是，我们可以监听分布式数据的改变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicator ! <span class="type">Replicator</span>.<span class="type">Subscribe</span>(<span class="type">OrderStorage</span>.<span class="type">Key</span>, self)</span><br></pre></td></tr></table></figure><p>当发生改变时，会得到一个<code>Replicator.Changed</code>消息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> change @ <span class="type">Replicator</span>.<span class="type">Changed</span>(<span class="type">OrderStorage</span>.<span class="type">Key</span>) =&gt;</span><br><span class="line">  <span class="keyword">val</span> allOrders: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">StoredOrder</span>] = change.get(<span class="type">OrderStorage</span>.<span class="type">Key</span>).entries</span><br><span class="line">  <span class="comment">// do something with the orders</span></span><br></pre></td></tr></table></figure><blockquote><p>对于<strong>Update</strong>，一致性等级大概有：</p><ul><li><code>WriteLocal</code> the value will immediately only be written to the local replica, and later disseminated with gossip</li><li><code>WriteTo(n)</code> the value will immediately be written to at least n replicas, including the local replica</li><li><code>WriteMajority</code> the value will immediately be written to a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group)</li><li><code>WriteAll</code> the value will immediately be written to all nodes in the cluster (or all nodes in the cluster role group)</li></ul><p>对于<strong>Get</strong>，一致性等级有：</p><ul><li><code>ReadLocal</code> the value will only be read from the local replica</li><li><code>ReadFrom(n)</code> the value will be read and merged from n replicas, including the local replica</li><li><code>ReadMajority</code> the value will be read and merged from a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group)</li><li><code>ReadAll</code> the value will be read and merged from all nodes in the cluster (or all nodes in the cluster role group)</li></ul></blockquote><p>前面说过，Value的实现是一个CvRDT，它的定义为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface for implementing a state based convergent</span></span><br><span class="line"><span class="comment"> * replicated data type (CvRDT).</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReplicatedData</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The type of the concrete implementation, e.g. `GSet[A]`.</span></span><br><span class="line"><span class="comment">   * To be specified by subclass.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">T</span> <span class="title">&lt;</span></span>: <span class="type">ReplicatedData</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Monotonic merge function.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(that: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该数据结构要求有<code>merge</code>函数，用于合并其它副本传递过来的数据。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ORMapKey</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>[<span class="type">A</span>, <span class="type">B</span> &lt;: <span class="type">ReplicatedData</span>](id: <span class="type">String</span>): <span class="type">Key</span>[<span class="type">ORMap</span>[<span class="type">A</span>, <span class="type">B</span>]] = <span class="type">ORMapKey</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该CvRDT被定义为Data Type函数的上界，以实现存储功能。</p><p>你会发现，<code>merge</code>函数返回一个<code>T</code> ，不是<code>Option[T]</code>也不是<code>Try[T]</code>——它证明了**<code>merge</code>总是正常的**。你会发现，<code>merge</code>函数是一个单调函数，总是向一个方向增长。</p><p><img src="/img/akka/ddata/monotonicity.png" alt="单调变换"></p><p>Akka api提供了一些基础<a href="https://doc.akka.io/docs/akka/current/distributed-data.html?language=scala#data-types">数据类型</a>，用于实现我们的分布式数据的存储。</p><p>对于上面的例子，可以直接操作数据，因为它本身就是个Key-Value，下面使用分布式方案实现基于内存的存储实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorRef</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.<span class="type">Cluster</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">DistributedData</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">LWWMap</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">LWWMapKey</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReplicatedCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>: <span class="type">Props</span> = <span class="type">Props</span>[<span class="type">ReplicatedCache</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">key: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PutInCache</span>(<span class="params">key: <span class="type">String</span>, value: <span class="type">Any</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFromCache</span>(<span class="params">key: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cached</span>(<span class="params">key: <span class="type">String</span>, value: <span class="type">Option</span>[<span class="type">Any</span>]</span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Evict</span>(<span class="params">key: <span class="type">String</span></span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCache</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCache</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> replicator = <span class="type">DistributedData</span>(context.system).replicator</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(context.system)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dataKey</span></span>(entryKey: <span class="type">String</span>): <span class="type">LWWMapKey</span>[<span class="type">String</span>, <span class="type">Any</span>] =</span><br><span class="line">    <span class="type">LWWMapKey</span>(<span class="string">&quot;cache-&quot;</span> + math.abs(entryKey.hashCode) % <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PutInCache</span>(key, value) =&gt;</span><br><span class="line">      replicator ! <span class="type">Update</span>(dataKey(key), <span class="type">LWWMap</span>(), <span class="type">WriteLocal</span>)(_ + (key -&gt; value))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Evict</span>(key) =&gt;</span><br><span class="line">      replicator ! <span class="type">Update</span>(dataKey(key), <span class="type">LWWMap</span>(), <span class="type">WriteLocal</span>)(_ - key)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GetFromCache</span>(key) =&gt;</span><br><span class="line">      replicator ! <span class="type">Get</span>(dataKey(key), <span class="type">ReadLocal</span>, <span class="type">Some</span>(<span class="type">Request</span>(key, sender())))</span><br><span class="line">    <span class="keyword">case</span> g @ <span class="type">GetSuccess</span>(<span class="type">LWWMapKey</span>(_), <span class="type">Some</span>(<span class="type">Request</span>(key, replyTo))) =&gt;</span><br><span class="line">      g.dataValue <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> data: <span class="type">LWWMap</span>[_, _] =&gt; data.asInstanceOf[<span class="type">LWWMap</span>[<span class="type">String</span>, <span class="type">Any</span>]].get(key) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(value) =&gt; replyTo ! <span class="type">Cached</span>(key, <span class="type">Some</span>(value))</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span>        =&gt; replyTo ! <span class="type">Cached</span>(key, <span class="type">None</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NotFound</span>(_, <span class="type">Some</span>(<span class="type">Request</span>(key, replyTo))) =&gt;</span><br><span class="line">      replyTo ! <span class="type">Cached</span>(key, <span class="type">None</span>)</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">UpdateResponse</span>[_] =&gt; <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TDD案例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> akka.cluster.<span class="type">Cluster</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">DistributedData</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>.<span class="type">GetReplicaCount</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>.<span class="type">ReplicaCount</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testconductor.<span class="type">RoleName</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testkit.<span class="type">MultiNodeConfig</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testkit.<span class="type">MultiNodeSpec</span></span><br><span class="line"><span class="keyword">import</span> akka.testkit._</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.<span class="type">ConfigFactory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReplicatedCacheSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> node1 = role(<span class="string">&quot;node-1&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> node2 = role(<span class="string">&quot;node-2&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> node3 = role(<span class="string">&quot;node-3&quot;</span>)</span><br><span class="line"></span><br><span class="line">  commonConfig(<span class="type">ConfigFactory</span>.parseString(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    akka.loglevel = INFO</span></span><br><span class="line"><span class="string">    akka.actor.provider = &quot;cluster&quot;</span></span><br><span class="line"><span class="string">    akka.log-dead-letters-during-shutdown = off</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode3</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpec</span>(<span class="params"><span class="type">ReplicatedCacheSpec</span></span>) <span class="keyword">with</span> <span class="title">STMultiNodeSpec</span> <span class="keyword">with</span> <span class="title">ImplicitSender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCacheSpec</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCache</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialParticipants</span> </span>= roles.size</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(system)</span><br><span class="line">  <span class="keyword">val</span> replicatedCache = system.actorOf(<span class="type">ReplicatedCache</span>.props)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(from: <span class="type">RoleName</span>, to: <span class="type">RoleName</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    runOn(from) &#123;</span><br><span class="line">      cluster join node(to).address</span><br><span class="line">    &#125;</span><br><span class="line">    enterBarrier(from.name + <span class="string">&quot;-joined&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;Demo of a replicated cache&quot;</span> must &#123;</span><br><span class="line">    <span class="string">&quot;join cluster&quot;</span> in within(<span class="number">20.</span>seconds) &#123;</span><br><span class="line">      join(node1, node1)</span><br><span class="line">      join(node2, node1)</span><br><span class="line">      join(node3, node1)</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="type">DistributedData</span>(system).replicator ! <span class="type">GetReplicaCount</span></span><br><span class="line">        expectMsg(<span class="type">ReplicaCount</span>(roles.size))</span><br><span class="line">      &#125;</span><br><span class="line">      enterBarrier(<span class="string">&quot;after-1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate cached entry&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key1&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key1&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate many cached entries&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i ← <span class="number">100</span> to <span class="number">200</span>)</span><br><span class="line">          replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key&quot;</span> + i, i)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        <span class="keyword">for</span> (i ← <span class="number">100</span> to <span class="number">200</span>) &#123;</span><br><span class="line">          replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key&quot;</span> + i), probe.ref)</span><br><span class="line">          probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key&quot;</span> + i, <span class="type">Some</span>(i)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate evicted entry&quot;</span> in within(<span class="number">15.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key2&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key2&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;B&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      enterBarrier(<span class="string">&quot;key2-replicated&quot;</span>)</span><br><span class="line"></span><br><span class="line">      runOn(node3) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">Evict</span>(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key2&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key2&quot;</span>, <span class="type">None</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate updated cached entry&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node2) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A2&quot;</span>)</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A3&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key1&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key1&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;A3&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="性能优化">性能优化</span></h2><p>如果没有做性能优化，将会是萦绕我们夜晚的致命罪孽。在生产环境，我们需要做：</p><ul><li>自定义的Data Type需要实现序列化</li><li>实现<code>delta-CRDTs</code>避免更新发送<code>full state</code></li><li>删除完成的记录</li></ul><p>序列化是性能优化的关键，Java自身的序列方案并不是最优的。建议使用<code>kryo</code>或谷歌的<code>protobuf</code></p><p>delta-CRDT主要用于减少<code>full state Update</code>的发送，它表示以一定的顺序传播更新。</p><p>因为是冲突自由(Conflict Free)的，在使用诸如<code>ORMap</code>时，如果并发地添加和删除一个条目，添加会获胜。你不能删除一个不存在的条目。这会引入一个问题，例如某个节点删除订单的同时，另外一个节点添加订单，添加订单被执行。原来的订单没有删除，所以需要额外修剪未移除的已经“完成”的条目。</p><p>总结，在副本同步操作时，有些方面并不完全正确的：</p><ul><li>对于<code>OrderHandler</code>是没有副本机制的——如果某个节点故障，所有当前处理的<code>Update</code>消息将停留在地域边缘，客户端也不会有任何响应。</li><li>不要将东西持久化存储！现实中这是相当疯狂的事情！(设想副本在不断地写入、不断地更新同步)</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://medium.com/@istanbul_techie/a-look-at-conflict-free-replicated-data-types-crdt-221a5f629e7e">https://medium.com/@istanbul_techie/a-look-at-conflict-free-replicated-data-types-crdt-221a5f629e7e</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://hal.inria.fr/inria-00609399v1">https://hal.inria.fr/inria-00609399v1</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://hal.inria.fr/inria-00609399v1/document">https://hal.inria.fr/inria-00609399v1/document</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://doc.akka.io/docs/akka/current/cluster-sharding.html?language=scala">https://doc.akka.io/docs/akka/current/cluster-sharding.html</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> ddata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch集群安装配置</title>
      <link href="/2018/05/22/elasticsearch/Elasticsearch-Cluster-Setup/"/>
      <url>/2018/05/22/elasticsearch/Elasticsearch-Cluster-Setup/</url>
      
        <content type="html"><![CDATA[<p>官方搭建步骤写得比较简单，因此遵循官方的指引<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html">安装</a>。</p><span id="more"></span><h2><span id="设置es占用内存">设置ES占用内存</span></h2><p>在默认情况下，ES只允许本地访问api接口，如果我们希望在另外一台机器上访问ES的接口的话，需要配置主机地址：<br>/data/elasticsearch-6.2.4&gt; vim config/elasticsearch.yml</p><p>#network.host: 192.168.0.1<br>network.host: 10.140.7.12</p><p>保存退出，重新启动es，一般都会报错，无法启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2017-03-16T10:51:23,168][INFO ][o.e.t.TransportService ] [DwX_4EG] publish_address &#123;10.140.7.12:9300&#125;, bound_addresses &#123;10.140.7.12:9300&#125;</span><br><span class="line">[2017-03-16T10:51:23,176][INFO ][o.e.b.BootstrapChecks ] [DwX_4EG] bound or publishing to a non-loopback or non-link-local address, enforcing bootstrap checks</span><br><span class="line">ERROR: bootstrap checks failed</span><br><span class="line">max virtual memory areas vm.max_map_count [65536] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure><p>对于这个错误，需要这样处理，执行下面的命令，或者把这个配置<code>/etc/sysctl.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>再次启动，报下面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system call filters failed to install; check the logs and fix your configuration or <span class="built_in">disable</span> system call filters at your own risk</span><br></pre></td></tr></table></figure><p>原因：<br>这是在因为操作系统不支持SecComp，而ES6.2.4默认<code>bootstrap.system_call_filter</code>为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p><p>解决：</p><p>在<code>elasticsearch.yml</code>中配置<code>bootstrap.system_call_filter</code>为false，注意要在Memory下面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: <span class="literal">false</span></span><br><span class="line">bootstrap.system_call_filter: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>重启ok<br>一下是网友遇到的问题，也一并记录一下：<br>[2016-12-20T22:37:28,543][INFO ][o.e.b.BootstrapCheck ] [elk-node1] bound or publishing to a non-loopback or non-link-local address, enforcing bootstrap checks<br>[2016-12-20T22:37:28,552][ERROR][o.e.b.Bootstrap ] [elk-node1] node validation exception<br>bootstrap checks failed<br>max number of threads [1024] for user [elasticsearch] is too low, increase to at least [2048]<br>[2016-12-20T22:37:28,560][INFO ][o.e.n.Node ] [elk-node1] stopping …<br>[2016-12-20T22:37:28,628][INFO ][o.e.n.Node ] [elk-node1] stopped<br>[2016-12-20T22:37:28,629][INFO ][o.e.n.Node ] [elk-node1] closing …<br>[2016-12-20T22:37:28,677][INFO ][o.e.n.Node ] [elk-node1] closed</p><p>报了一大串错误，其实只是一个警告。</p><p>解决：使用新的linux版本，就不会出现此类问题了。</p><p>问题二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: bootstrap checks failed</span><br><span class="line">max file descriptors [4096] <span class="keyword">for</span> elasticsearch process likely too low, increase to at least [65536]</span><br><span class="line">max number of threads [1024] <span class="keyword">for</span> user [lishang] likely too low, increase to at least [2048]</span><br></pre></td></tr></table></figure><p>解决：切换到root用户，编辑<code>/etc/security/limits.conf</code> 添加类似如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><p>问题三：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max number of threads [1024] <span class="keyword">for</span> user [lish] likely too low, increase to at least [2048]</span><br></pre></td></tr></table></figure><p>解决：切换到root用户，修改配置文件<code>/etc/security/limits.d/90-nproc.conf</code>，如果没有该文件，则增加</p><p>修改如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 1024</span><br><span class="line"><span class="comment">#修改为</span></span><br><span class="line">* soft nproc 2048</span><br></pre></td></tr></table></figure><p>问题四：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span><br></pre></td></tr></table></figure><p>解决：切换到root用户修改配置<code>/etc/sysctl.conf</code></p><p>添加下面配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure><p>并执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>问题五：</p><p>以.deb安装包方式安装时，会提示找不到配置文件。添加软连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/elasticsearch /usr/share/elasticsearch/config</span><br></pre></td></tr></table></figure><p>重启服务。</p><h2><span id="脑裂split-brain">脑裂(split brain)</span></h2><p>单机测试开发的时候, 其实一个节点就够了. 上线, 使用两个节点, 目的是利用es本身的特性做到高可用.</p><p>但是两个节点是远远不够的. 启动后, 集群会选举一个master, 一切ok. 但是如果存在网络问题或者某个节点无响应(负载过高), 就会认为对方dead了, 然后两个节点自动选举为master, 在后续建索引的时候造成数据不一致.</p><p>两个节点防脑裂的配置, minimum_master_nodes决定了选主需要的最少节点数, N/2+1, 两个节点即2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.minimum_master_nodes: 2 </span><br></pre></td></tr></table></figure><p>但是, 此时一个节点挂了, 则整个集群挂了(无法选举主节点了)</p><p>所以, 要再加一个节点, 这个节点只要保证稳定即可, 对cpu和磁盘要求不高. 这个es节点的配置同其他节点的区别node.data: false, 不存储索引数据.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split brain prevent</span></span><br><span class="line">node.data: <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modifying an Existing Docker Image</title>
      <link href="/2018/05/06/docker/Modifying-an-Existing-Docker-Image/"/>
      <url>/2018/05/06/docker/Modifying-an-Existing-Docker-Image/</url>
      
        <content type="html"><![CDATA[<p>To install a custom package or modify an existing docker image we need to</p><p>1 run a docker a container from the image we wish to modify<br>2 modify the docker container<br>3 commit the changes to the container as a docker image<br>4 test changes made to image</p><span id="more"></span><h3><span id="running-a-docker-container-from-an-image">Running a docker container from an image</span></h3><p>The command to do this is,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it yhat/scienceops-python:0.0.2 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>The -i tells docker to attach stdin to the container</li><li>The -t tells docker to give us a pseudo-terminal</li><li>/bin/bash will run a terminal process in your container</li></ul><h3><span id="modify-the-docker-container">Modify the docker container</span></h3><p>Once we are in our container we can install package(s), and set environment variables</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br><span class="line">$ <span class="built_in">export</span> AWS_SECRET_KEY=mysecretkey123</span><br><span class="line">$ <span class="built_in">export</span> AWS_ACCESS_KEY=fooKey</span><br></pre></td></tr></table></figure><p>When you are done modifying your container you must exit by running the exit command. Once we exit the container, we need to find the container ID by running</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3><span id="commit-the-changes-to-the-container-as-a-new-image">Commit the changes to the container as a new image</span></h3><p>Copy the container ID for the container you just modified, and then run the docker commit command to commit changes to your container as an image.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] [container ID] [repository:tag]</span><br></pre></td></tr></table></figure><p>An example docker commit command is the following.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit e8f0671518a2 yhat/scienceops-python:0.0.2</span><br></pre></td></tr></table></figure><p>Note here! You must commit the changes with the same tags as the scienceops image on your system. To see your new image run.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3><span id="test-changes-made-to-image">Test changes made to image</span></h3><p>To test your changes when adding an environment variable run the test command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it yhat/scienceops-python:0.0.2 <span class="built_in">echo</span> <span class="variable">$AWS_SECRET_KEY</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka Patterns 汇总</title>
      <link href="/2018/04/27/pattern/akkas/Akka-Patterns/"/>
      <url>/2018/04/27/pattern/akkas/Akka-Patterns/</url>
      
        <content type="html"><![CDATA[<p>Akka 常见设计模式.</p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> akka, scala, pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shapeless</title>
      <link href="/2018/04/16/scala-exercises/shapeless-hlist/"/>
      <url>/2018/04/16/scala-exercises/shapeless-hlist/</url>
      
        <content type="html"><![CDATA[<p>Shapeless 库主要思想参考了Haskell的<code>HList</code>，以及自身type-class的扩展。它主要用于编译期实现，所以叫做&quot;shapeless&quot;，无固定类型、无固定结构化、函数和对象多态等特点。因为它主要是在编译期实现，所以语法上接近于“表述式”。</p><span id="more"></span><h3><span id="什么是shapeless">什么是shapeless</span></h3><blockquote><p>Shapeless is a type class and dependent type based generic programming library for Scala.</p></blockquote><p>因为Shapeless是基于类型，因此对于Scala的类型系统如虎添翼，只要提供少量的样板代码(boilerplate)，就可以获得额外的类型安全机制。</p><p>因为shapeless的内容比较多，我们从<a href="http://www.scala-exercises.org">www.scala-exercises.org</a>开始介绍一些主要特性。</p><h3><span id="polymorphic-functions">Polymorphic functions</span></h3><p>多态函数，先看下面的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> demo = <span class="number">42</span> :: <span class="string">&quot;Hello&quot;</span> :: <span class="type">User</span>(<span class="string">&quot;Julien&quot;</span>) :: <span class="type">HNil</span></span><br></pre></td></tr></table></figure><p>因为这个<code>HList</code>结构不是固定类型的，如果我们要进行<code>map</code>映射操作，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](h: <span class="type">Int</span> :: <span class="type">String</span> :: <span class="type">User</span> :: <span class="type">HNil</span>)(f0: <span class="type">Int</span> =&gt; <span class="type">A</span>, f1: <span class="type">String</span> =&gt; <span class="type">B</span>, f3: <span class="type">User</span> =&gt; <span class="type">C</span>)</span><br></pre></td></tr></table></figure><p>但是，过多这样的<code>f0</code>,<code>f1</code>,<code>f2</code>参数函数是不切实际的，我们希望只用一个<code>f</code>参数表示，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](h: <span class="type">Int</span> :: <span class="type">String</span> :: <span class="type">User</span> :: <span class="type">HNil</span>)(f: (<span class="type">Int</span> =&gt; <span class="type">A</span>) &amp; (<span class="type">String</span> =&gt; <span class="type">B</span>) &amp; (<span class="type">User</span> =&gt; <span class="type">C</span>))</span><br></pre></td></tr></table></figure><p>可惜Scala里面没有 <code>&amp;</code> 这样的用法。记住一点，只要遇到非结构固定类型的地方，基本可以考虑用shapeless来实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shapeless._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">plusOne</span> <span class="keyword">extends</span> <span class="title">Poly1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">caseInt</span> </span>= at[<span class="type">Int</span>](_ + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">caseString</span> </span>= at[<span class="type">String</span>](_ + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">caseUser</span> </span>=</span><br><span class="line">    at[<span class="type">User</span>](<span class="keyword">case</span> <span class="type">User</span>(name) =&gt; <span class="type">User</span>(name + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo.map(plusOne)</span><br></pre></td></tr></table></figure><h3><span id="generic">Generic</span></h3><p><code>Generic</code>，顾名思义，类似于Java的泛型，它主要用于case class/product types 到 <code>HList</code>之间的转换，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shapeless.<span class="type">Generic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserWithAge</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">val</span> gen = <span class="type">Generic</span>[<span class="type">UserWithAge</span>]</span><br><span class="line"><span class="keyword">val</span> u = <span class="type">UserWithAge</span>(<span class="string">&quot;Julien&quot;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> h = gen.to(u) <span class="comment">// returns Julien :: 30 :: HNil</span></span><br><span class="line">gen.from(h) <span class="comment">// return UserWithAge(&quot;Julien&quot;, 30)</span></span><br></pre></td></tr></table></figure><p>还是那句话，case class也是非结构固定类型的，因此可以扩展，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">author: <span class="type">String</span>, title: <span class="type">String</span>, id: <span class="type">Int</span>, price: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">val</span> bookGen = <span class="type">LabelledGeneric</span>[<span class="type">Book</span>]</span><br><span class="line"><span class="keyword">val</span> tapl = <span class="type">Book</span>(<span class="string">&quot;Benjamin Pierce&quot;</span>, <span class="string">&quot;Types and Programming Languages&quot;</span>, <span class="number">262162091</span>, <span class="number">44.11</span>)</span><br><span class="line"><span class="keyword">val</span> rec = bookGen.to(tapl)</span><br><span class="line">rec(<span class="symbol">&#x27;price</span>) should be(<span class="number">44.11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedBook</span>(<span class="params">author: <span class="type">String</span>, title: <span class="type">String</span>, id: <span class="type">Int</span>, price: <span class="type">Double</span>, inPrint: <span class="type">Boolean</span></span>)</span></span><br><span class="line"><span class="keyword">val</span> bookExtGen = <span class="type">LabelledGeneric</span>[<span class="type">ExtendedBook</span>]</span><br><span class="line"><span class="keyword">val</span> extendedBook = bookExtGen.from(rec + (<span class="symbol">&#x27;inPrint</span> -&gt;&gt; <span class="literal">true</span>))</span><br><span class="line">extendedBook.inPrint should be(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3><span id="tuples">Tuples</span></h3><p>Shapleless对Tuplex提供了语法，因此可以在tuples上使用<code>HList</code>的方法,</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">12.3</span>).tail</span><br><span class="line"><span class="comment">// &lt;console&gt;:14: error: value tail is not a member of (Int, String, Double)</span></span><br><span class="line"><span class="comment">//        (1, &quot;foo&quot;, 12.3).tail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shapeless.syntax.std.tuple._</span><br><span class="line">(<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">12.3</span>).tail <span class="comment">// returns (foo,12.3)</span></span><br></pre></td></tr></table></figure><h3><span id="lenses">Lenses</span></h3><p>Lenses，透镜。从名字可以看出，可以通过“透镜”直接操作，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A pair of ordinary case classes ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span>(<span class="params">street: <span class="type">String</span>, city: <span class="type">String</span>, postcode: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, address: <span class="type">Address</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some lenses over Person/Address ...</span></span><br><span class="line"><span class="keyword">val</span> nameLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;name</span></span><br><span class="line"><span class="keyword">val</span> ageLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;age</span></span><br><span class="line"><span class="keyword">val</span> addressLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;address</span></span><br><span class="line"><span class="keyword">val</span> streetLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;address</span> &gt;&gt; <span class="symbol">&#x27;street</span></span><br><span class="line"><span class="keyword">val</span> cityLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;address</span> &gt;&gt; <span class="symbol">&#x27;city</span></span><br><span class="line"><span class="keyword">val</span> postcodeLens = lens[<span class="type">Person</span>] &gt;&gt; <span class="symbol">&#x27;address</span> &gt;&gt; <span class="symbol">&#x27;postcode</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = <span class="type">Person</span>(<span class="string">&quot;Joe Grey&quot;</span>, <span class="number">37</span>, <span class="type">Address</span>(<span class="string">&quot;Southover Street&quot;</span>, <span class="string">&quot;Brighton&quot;</span>, <span class="string">&quot;BN2 9UA&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get &amp; set</span></span><br><span class="line">ageLens.get(person)</span><br><span class="line">ageLens.set(person)(<span class="number">38</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested</span></span><br><span class="line">streetLens.get(person)</span><br><span class="line">streetLens.set(person)(<span class="string">&quot;Montpelier Road&quot;</span>)</span><br></pre></td></tr></table></figure><h3><span id="abstracting-over-arity">Abstracting over arity</span></h3><p>并不是一个具体的特性，它只是<code>HList</code>和 <code>Generic</code>的一个运用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> syntax.std.function._</span><br><span class="line"><span class="keyword">import</span> ops.function._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">applyProduct</span></span>[<span class="type">P</span> &lt;: <span class="type">Product</span>, <span class="type">F</span>, <span class="type">L</span> &lt;: <span class="type">HList</span>, <span class="type">R</span>](p: <span class="type">P</span>)(f: <span class="type">F</span>)(<span class="keyword">implicit</span> gen: <span class="type">Generic</span>.<span class="type">Aux</span>[<span class="type">P</span>, <span class="type">L</span>], fp: <span class="type">FnToProduct</span>.<span class="type">Aux</span>[<span class="type">F</span>, <span class="type">L</span> =&gt; <span class="type">R</span>]) =</span><br><span class="line">  f.toProduct(gen.to(p))</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">applyProduct(<span class="number">1</span>, <span class="number">2</span>)((_: <span class="type">Int</span>) + (_: <span class="type">Int</span>)) should be(<span class="number">3</span>)</span><br><span class="line">applyProduct(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)((_: <span class="type">Int</span>) * (_: <span class="type">Int</span>) * (_: <span class="type">Int</span>)) should be(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://milessabin.com/blog/2012/04/27/shapeless-polymorphic-function-values-1/">http://milessabin.com/blog/2012/04/27/shapeless-polymorphic-function-values-1/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">参考wiki了解更多内容。<a href="https://github.com/milessabin/shapeless/wiki">https://github.com/milessabin/shapeless/wiki</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> scala, shapeless, typeclass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非阻塞方式处理迭代Future问题</title>
      <link href="/2018/04/10/pattern/futures/Execute-Scala-Futures-in-serial-one-after-the-other-non-blocking/"/>
      <url>/2018/04/10/pattern/futures/Execute-Scala-Futures-in-serial-one-after-the-other-non-blocking/</url>
      
        <content type="html"><![CDATA[<p>Scala的Future实现是非常cool的，它很容易并行处理代码，除此之外易于组合，因为它是一个<code>monad</code>实现。</p><span id="more"></span><p>我们在创建一个Future的同时，它被切分为多个线程执行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleFuture</span></span>(i: <span class="type">Int</span>) = <span class="type">Future</span> &#123;i * <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">list map doubleFuture <span class="comment">//returns List[Future[Int]]</span></span><br><span class="line"><span class="type">Future</span>.traverse(list)(doubleFuture) <span class="comment">//returns Future[List[Int]]</span></span><br></pre></td></tr></table></figure><p>因为<code>map</code>执行后会返回得到一个<code>List[Future[Int]]</code>，更通常的一种用法是使用<code>Future.traverse</code>将它转换为<code>Future[List[Int]]</code>，它最终结果是相同的，以及并行地去执行Future里面的内容，只不过仅返回一个Future类型。</p><p>有时候，我们并不希望并行地去处理所有<code>Iterator</code>里面的内容？又或者我们希望在处理过程中，某个计算failed掉了，可以终止整个处理进程？实际上，在工作中有大量的这种情形需要这样特别对待：Future 按顺序一个一个地处理，某一个failed，终止进程。很明显，我们不期待使用<code>Await</code>，它会阻塞上一个进程。下面的“技巧”用到了<code>foldLeft</code>的方式，这样List里面下一个值的计算，开始于前一个计算完成时。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialiseFutures</span></span>[<span class="type">A</span>, <span class="type">B</span>](l: <span class="type">Iterable</span>[<span class="type">A</span>])(fn: <span class="type">A</span> =&gt; <span class="type">Future</span>[<span class="type">B</span>])</span><br><span class="line">  (<span class="keyword">implicit</span> ec: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">List</span>[<span class="type">B</span>]] =</span><br><span class="line">  l.foldLeft(<span class="type">Future</span>(<span class="type">List</span>.empty[<span class="type">B</span>])) &#123;</span><br><span class="line">    (previousFuture, next) =&gt;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        previousResults &lt;- previousFuture</span><br><span class="line">        next &lt;- fn(next)</span><br><span class="line">      &#125; <span class="keyword">yield</span> previousResults :+ next</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>它仅在上一个future是complete或successful下才被调用。它会被立即执行，但Future实际上是顺序执行的。</p><p>上面代码的返回类型是<code>Future[List[B]]</code>。理想情况下，它应该返回<code>Future[C[B]]</code>，C是我们真正传递的集合类型。我们可以借助<code>CanBuildFrom</code>进行优化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialiseFutures</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>[<span class="type">A</span>] &lt;: <span class="type">Iterable</span>[<span class="type">A</span>]]</span><br><span class="line">  (collection: <span class="type">C</span>[<span class="type">A</span>])(fn: <span class="type">A</span> =&gt; <span class="type">Future</span>[<span class="type">B</span>])(</span><br><span class="line">  <span class="keyword">implicit</span> ec: <span class="type">ExecutionContext</span>,</span><br><span class="line">  cbf: <span class="type">CanBuildFrom</span>[<span class="type">C</span>[<span class="type">B</span>], <span class="type">B</span>, <span class="type">C</span>[<span class="type">B</span>]]): <span class="type">Future</span>[<span class="type">C</span>[<span class="type">B</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> builder = cbf()</span><br><span class="line">  builder.sizeHint(collection.size)</span><br><span class="line"></span><br><span class="line">  collection.foldLeft(<span class="type">Future</span>(builder)) &#123;</span><br><span class="line">    (previousFuture, next) =&gt;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        previousResults &lt;- previousFuture</span><br><span class="line">        next &lt;- fn(next)</span><br><span class="line">      &#125; <span class="keyword">yield</span> previousResults += next</span><br><span class="line">  &#125; map &#123; builder =&gt; builder.result &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> start = <span class="type">System</span>.currentTimeMillis</span><br><span class="line"><span class="keyword">val</span> doubled = <span class="type">Await</span>.result(&#123;</span><br><span class="line">  serialiseFutures(<span class="type">List</span>(<span class="number">10</span>, <span class="number">20</span>)) &#123; i =&gt;</span><br><span class="line">    <span class="type">Future</span> &#123;</span><br><span class="line">      <span class="type">Thread</span>.sleep(i)</span><br><span class="line">      i * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1</span> second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timeElapsed = <span class="type">System</span>.currentTimeMillis - start</span><br><span class="line">timeElapsed should be &gt;= (<span class="number">30</span>l)</span><br><span class="line">doubled should be(<span class="type">List</span>(<span class="number">20</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure><p>那是否可以通过顺序执行中抛出异常的方式，终止整个for循环的调用吗？</p><p>实际上，循环中某个Future fail掉了，循环是不会终止的。因为原生的for-comprehension(它是一个flatMap实现).</p><p>另外一种实现方式是使用Akka Stream的<code>mapAsyncUnordered</code>来处理，由Stream的Strategy来处理异常：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futureFlow = <span class="type">Flow</span>.fromGraph(<span class="type">GraphDSL</span>.create() &#123; <span class="keyword">implicit</span> builder =&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">GraphDSL</span>.<span class="type">Implicits</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> dangerousFlow = <span class="type">Flow</span>[<span class="type">Int</span>].mapAsyncUnordered[<span class="type">Int</span>](<span class="number">5</span>)(makeFuture)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> safeFlow = <span class="type">Flow</span>[<span class="type">Int</span>]</span><br><span class="line">  <span class="keyword">val</span> bcast = builder.add(<span class="type">Broadcast</span>[<span class="type">Int</span>](<span class="number">2</span>))</span><br><span class="line">  <span class="keyword">val</span> zip = builder.add(<span class="type">Zip</span>[<span class="type">Int</span>, <span class="type">Int</span>])</span><br><span class="line"></span><br><span class="line">  bcast ~&gt; dangerousFlow ~&gt; zip.in0</span><br><span class="line">  bcast ~&gt; safeFlow ~&gt; zip.in1</span><br><span class="line"></span><br><span class="line">  <span class="type">FlowShape</span>(bcast.in, zip.out)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">Source</span>(<span class="number">1</span> to <span class="number">10</span>)</span><br><span class="line">.via(futureFlow)</span><br><span class="line">.withAttributes(<span class="type">ActorAttributes</span>.supervisionStrategy(<span class="type">Supervision</span>.resumingDecider))</span><br><span class="line">.runForeach(println)</span><br></pre></td></tr></table></figure><p><img src="/img/pattern/non-blocking/1_wMSQADz5K35nCeOAuwx9fA.png" alt></p><p>由于<code>Broadcast</code>使用back-pressure机制，执行时需要等待上游的完成才进行下一步操作，因此也是按照顺序执行的，该方式跟<code>Future.foldLeft</code>的实现是等价的。我们还是希望可以各个Future异步地调用处理，并快速失败。但这并不符合响应式设计，因为如果异步地不按顺序执行，我们并不知哪个快哪个慢，这是一种严重的内存消耗、硬件消耗！！</p><p>如果一定要实现性能最优，我们可能需要额外的<code>GraphStage</code>，并赋予因子<code>factor</code>，用于记录上一次下游向上游拉取所用的时间，并进行决策。</p>]]></content>
      
      
      
        <tags>
            
            <tag> scala, future </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra 安装入门</title>
      <link href="/2018/01/10/cassandra/cassandra-beginning/"/>
      <url>/2018/01/10/cassandra/cassandra-beginning/</url>
      
        <content type="html"><![CDATA[<p>Cassandra是Apache开源的分布式数据库管理系统，被用于处理大数据量的商用硬件或云设施上。Cassandra提供了高可用，无单点故障的特性。</p><p>Cassandra支持不停机的线性扩展机器的方式，增加Read和Write的吞吐量。</p><p>每个Cassandra节点在集群中会有相同的角色。数据被分布在各个集群节点上。Cassandra支持复制和多数据中心冗余复制，故障转移，灾难恢复。</p><span id="more"></span><h2><span id="单节点">单节点</span></h2><p>Apache Cassandra要求系统预先安装Java：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:webupd8team/java</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install oracle-java8-installer</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>安装时请注意Java版本的兼容性问题。</p><p>Cassandra的安装，官方推荐的是包管理的方式。以debian为例：</p><p>添加仓储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://www.apache.org/dist/cassandra/debian 36x main&quot;</span> | sudo tee -a /etc/apt/sources.list.d/cassandra.list</span><br></pre></td></tr></table></figure><p>添加公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver pgp.mit.edu --recv-keys 749D6EEC0353B12C</span><br><span class="line">gpg --<span class="built_in">export</span> --armor 749D6EEC0353B12C | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cassandra</span><br></pre></td></tr></table></figure><p>要注意的是，安装时最好选择覆盖安装，因为有可能你的<code>/etc/cassandra/</code>以前曾经保留了配置。</p><p>另外一种方式是deb包安装，推荐到<a href="http://mirrors.ustc.edu.cn">中科大</a>下载安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/apache/cassandra/debian/pool/main/c/cassandra/cassandra_3.11.1_all.deb</span><br><span class="line">sudo dpkg --force-confmiss -i cassandra_3.11.1_all.deb</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge cassandra</span><br></pre></td></tr></table></figure><p>安装完成之后，服务会添加到systemd。查看服务的运行情况，一般正常的话都处于Running状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service cassandra status</span><br></pre></td></tr></table></figure><p>查看端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -plntu</span><br></pre></td></tr></table></figure><p>cassandra主进程的子进程会开启几个端口：</p><p><img src="/img/cassandra/ports.png" alt="端口占用情况"></p><p>每个port代表着不同的意义：</p><ul><li>7000：node间的TCP port</li><li>7001：node间利用SSL传输资料的port</li><li>7199：JMX</li><li>9160： Client端Thrift API用到的port</li><li>9042: CQL使用</li><li>1024-65355: JMX要求的随机port</li></ul><p>cassandra虽然能启动，但不能通过静态ip访问，只能内部访问。打开<code>/etc/cassandra/cassandra.yaml</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster_name: <span class="string">&#x27;JCPT Test Cluster&#x27;</span></span><br><span class="line">listen_address: localhost</span><br><span class="line">start_rpc: <span class="literal">true</span></span><br><span class="line">rpc_address: 0.0.0.0</span><br><span class="line">boardcast_rpc_address: 192.168.2.248</span><br></pre></td></tr></table></figure><p>cassandra集群安装成功后，使用nodetool连接本机节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nodetool status</span><br></pre></td></tr></table></figure><p>出现下面内容说明正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address    Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  127.0.0.1  256.6 KiB  256          100.0%            c703e51b-5050-403e-8430-019b768f7dc9  rack1</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>U</code> - Cluster is <code>U</code>P<br><code>N</code> = Cluster is <code>N</code>ormal</p><p>现在可以使用<code>cqlsh</code>进行数据库查询了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cqlsh</span><br></pre></td></tr></table></figure><p>出现提示说明cassandra的单机节点部署成功了！</p><h2><span id="docker搭配的多节点">docker搭配的多节点</span></h2><p>架设环境：3台host(192.168.0.1, 192.168.0.2, 192.168.0.3)<br>情境：3台独立VM，各架设一个cassandra node，组成cassandra cluster。第1，2台host的node设为seed</p><p>下载cassandra image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull cassandra</span><br></pre></td></tr></table></figure><p>在第一台VM上建立cassandra，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --restart=always --name cassandra-1 -d -e CASSANDRA_BROADCAST_ADDRESS=192.168.0.1 -p 7000:7000 cassandra</span><br></pre></td></tr></table></figure><p>第二台host上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --restart=always --name cassandra-2 -d -e CASSANDRA_BROADCAST_ADDRESS=192.168.0.2 -p 7000:7000 -e CASSANDRA_SEEDS=192.168.0.1,192.168.0.2 cassandra</span><br></pre></td></tr></table></figure><p>第三台host：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --restart=always --name cassandra-3 -d -e CASSANDRA_BROADCAST_ADDRESS=192.168.0.3 -p 7000:7000 -e CASSANDRA_SEEDS=192.168.0.1,192.168.0.2 cassandra</span><br></pre></td></tr></table></figure><p>测试3个host是否正常：</p><p>测试剧本：在<code>cassandra-1</code>建立 test_keyspace，在 <code>cassandra-2</code>使用 test_keyspace 建立 test_table，最后在 <code>cassandra-3</code> 查询 test_table</p><p>进入 cassandra-1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it 3b39bc bash</span><br></pre></td></tr></table></figure><p>执行<code>cqlsh</code>，建立keyspace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cqlsh &gt; CREATE KEYSPACE test_keyspace WITH REPLICATION = &#123;</span><br><span class="line"><span class="string">&#x27;class&#x27;</span> : <span class="string">&#x27;SimpleStrategy&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;replication_factor&#x27;</span> : 2 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进入 cassandra-2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it fc04 bash</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:test_keyspace&gt; CREATE TABLE test_table(</span><br><span class="line"> id int PRIMARY KEY,</span><br><span class="line"> name text</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>进入 cassandra-3：</p><p>执行<code>cqlsh</code>查询，</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> cqlsh &gt; use test_keyspace;</span><br><span class="line">cqlsh:test_keyspace&gt; select * from test_table;</span><br></pre></td></tr></table></figure><p>目前table是空的，我们加一点数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:test_keyspace&gt; insert into test_table (id, name) values (1, <span class="string">&#x27;Doraemon&#x27;</span>);</span><br><span class="line">id | name</span><br><span class="line">----+----------</span><br><span class="line"> 1 | Doraemon</span><br><span class="line"></span><br><span class="line">(1 rows)</span><br></pre></td></tr></table></figure><p>回到 cassandra-1，cassandra-2 查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:test_keyspace&gt; select * from test_table;</span><br><span class="line"></span><br><span class="line">id | name</span><br><span class="line">----+----------</span><br><span class="line"> 1 | Doraemon</span><br><span class="line"></span><br><span class="line">(1 rows)</span><br></pre></td></tr></table></figure><p>如果3个node查询得到一样的数据，就代表成功啦~</p><h2><span id="二进制部署">二进制部署</span></h2><p>除了上面介绍的两种安装方式，本人推荐以压缩包方式部署。</p><ol><li>JDK安装</li></ol><p>首先确保你的环境需要有Java，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载地址</a>。</p><p>解压放到/usr/java/jdk1.8.0_151/目录，</p><ol start="2"><li>添加用户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd cassandra</span><br><span class="line">useradd -g cassandra cassandra</span><br><span class="line">passwd cassandra</span><br></pre></td></tr></table></figure><ol start="3"><li>下载</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.shuosc.org/apache/cassandra/3.11.1/apache-cassandra-3.11.1-bin.tar.gz</span><br><span class="line">tar -xvf apache-cassandra-3.11.1-bin.tar.gz</span><br><span class="line"><span class="built_in">cd</span> apache-cassandra-3.11.1</span><br></pre></td></tr></table></figure><ol start="4"><li>配置<code>vim conf/cassandra.yaml</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster_name: <span class="string">&#x27;JCPT Test Cluster&#x27;</span></span><br><span class="line">- seeds: <span class="string">&quot;10.112.68.186,10.112.68.192&quot;</span></span><br><span class="line">listen_address: 10.112.68.186</span><br><span class="line">rpc_address: 10.112.68.186</span><br></pre></td></tr></table></figure><p>不同节点listen_address、rpc_address不同，cluster_name和seeds是相同的。</p><ul><li>JVM配置: conf/cassandra-env.sh（JVM_OPTS）</li><li>日志配置：conf/logback.xml</li></ul><p>建立数据和日志的存储目录（生产环境数据和日志放在不同分期）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir data/data</span><br><span class="line">mkdir data/commitlog</span><br><span class="line">mkdir data/saved_caches</span><br><span class="line">mkdir data/hints</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><ol start="5"><li>启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/cassandra -f (前端启动)</span><br><span class="line">./bin/cassandra</span><br></pre></td></tr></table></figure><ol start="6"><li>查看集群状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/nodetool status</span><br><span class="line">./bin/nodetool describecluster</span><br></pre></td></tr></table></figure><h2><span id="多节点">多节点</span></h2><p>cassandra默认有两种启动模式， local和remote模式，可以在<code>/etc/cassandra-env.sh</code>中查看和修改。默认使用local模式。要想通过nodetool命令连接本机节点时，要更改为remote模式。</p><p>添加<code>LOCAL_JMX=false</code>和修改 <code>-Dcom.sun.management.jmxremote.authenticate=false</code>，当然你可以开启加密方式。配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_JMX=<span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$LOCAL_JMX</span>&quot;</span> = <span class="string">&quot;x&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOCAL_JMX=yes</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Specifies the default port over which Cassandra will be available for</span></span><br><span class="line"><span class="comment"># JMX connections.</span></span><br><span class="line"><span class="comment"># For security reasons, you should not expose this port to the internet.  Firewall it if needed.</span></span><br><span class="line">JMX_PORT=<span class="string">&quot;7199&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$LOCAL_JMX</span>&quot;</span> = <span class="string">&quot;yes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  JVM_OPTS=<span class="string">&quot;<span class="variable">$JVM_OPTS</span> -Dcassandra.jmx.local.port=<span class="variable">$JMX_PORT</span>&quot;</span></span><br><span class="line">  JVM_OPTS=<span class="string">&quot;<span class="variable">$JVM_OPTS</span> -Dcom.sun.management.jmxremote.authenticate=false&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  JVM_OPTS=<span class="string">&quot;<span class="variable">$JVM_OPTS</span> -Dcassandra.jmx.remote.port=<span class="variable">$JMX_PORT</span>&quot;</span></span><br><span class="line">  <span class="comment"># if ssl is enabled the same port cannot be used for both jmx and rmi so either</span></span><br><span class="line">  <span class="comment"># pick another value for this property or comment out to use a random port (though see CASSANDRA-7087 for origins)</span></span><br><span class="line">  JVM_OPTS=<span class="string">&quot;<span class="variable">$JVM_OPTS</span> -Dcom.sun.management.jmxremote.rmi.port=<span class="variable">$JMX_PORT</span>&quot;</span></span><br><span class="line">  <span class="comment"># turn on JMX authentication. See below for further options</span></span><br><span class="line">  JVM_OPTS=<span class="string">&quot;<span class="variable">$JVM_OPTS</span> -Dcom.sun.management.jmxremote.authenticate=false&quot;</span></span><br><span class="line">  <span class="comment"># jmx ssl options</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Dcom.sun.management.jmxremote.ssl=true&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Dcom.sun.management.jmxremote.ssl.need.client.auth=true&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Dcom.sun.management.jmxremote.ssl.enabled.protocols=&lt;enabled-protocols&gt;&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Dcom.sun.management.jmxremote.ssl.enabled.cipher.suites=&lt;enabled-cipher-suites&gt;&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Djavax.net.ssl.keyStore=/path/to/keystore&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Djavax.net.ssl.keyStorePassword=&lt;keystore-password&gt;&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Djavax.net.ssl.trustStore=/path/to/truststore&quot;</span></span><br><span class="line">  <span class="comment">#JVM_OPTS=&quot;$JVM_OPTS -Djavax.net.ssl.trustStorePassword=&lt;truststore-password&gt;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>修改配置，重启OK。</p><h2><span id="replication策略">Replication策略</span></h2><p>Cassandra在多个节点存储replica来确保可靠性和容错性。Replication策略决定了replica保存到哪些节点。</p><p>replica的总数由replication factor控制。replication factor 1表示一行数据，只会有一个replica，被保存在唯一一个节点上。replication factor 2表示一行数据有两个副本，每个副本保存在不同的节点上。所有的replica同等重要；没有主次replica之分。一般的规则是，replication factor不应该超过集群里的节点数量。不过，可以先增大replication factor，再添加更多节点。如果replication factor配置超过节点数量，写操作会被拒绝。读操作不受影响。</p><p>Cassandra内置了两种类型的replication策略：</p><ul><li><code>SimpleStrategy</code>：用于单个数据中心。如果有可能以后会有多个数据中心，应该用<code>NetworkTopologyStrategy</code></li><li><code>NetworkTopologyStrategy</code>：对绝大多数部署方式，都强烈推荐该策略，因为今后的扩展更容易</li></ul><p>关于每个数据中心应该配置几个replica，一般主要考虑以下两个因素：</p><ul><li>保证读操作没有跨数据中心的延时损耗</li><li>如何处理硬件故障的情形</li></ul><p>对于多数据中心，最常用的两种配置replica的策略是：</p><ul><li>每个数据中心2个replica：基于这种配置，对于每个数据中心，即使单个节点故障，还是能够支持consistency level ONE的本地读</li><li>每个数据中心3个replica：基于这种配置，对于每个数据中心，即使单个节点故障，还是能够支持consistency level LOCAL_QUORUM的本地读；即使2两个节点故障，还是能够支持consistency level ONE的本地读</li></ul><p>cassandra默认建keyspace的时候，需要定制拓扑策略的，默认是<code>SimpleStrategy</code>，修改 <code>conf/cassandra.yaml</code>里面的<code>endpoint_snitch</code>，将其更改为<code>GossipingPropertyFileSnitch</code>。表示多数据中心策略。</p><ul><li><code>SimpleSnitch</code>：默认的，单数据中心部署，可以在禁用读修复时提高缓存位置。</li><li><code>GossipingPropertyFileSnitch</code>：官方推荐在生产环境下使用，本节点的rack和dc名字保存在cassandra-rackdc.properties，并且会通过gossip这个p2p协议传播到所有节点上去<br>如果cassandra-topology.properties文件存在，cassandra会把两个properties文件的结果合并，如果两个properties文件里面有有同一个节点的配置，以cassandra-rackdc.properties的配置为准。</li><li><code>PropertyFileSnitch</code>：dc和rack通过显式的定义在cassandra-topology.properties文件里面。</li><li><code>Ec2Snitch</code>：适合单个区域(数据中心)的EC2部署。</li><li><code>Ec2MultiRegionSnitch</code>：集群跨多个区域(数据中心)的EC2部署。</li><li><code>RackInferringSnitch</code>：通过本机IP地址判断节点数据哪个数据中心哪个rack。IP第2段相同为同一个数据中心，IP第3段相同为一个Rack。如下图：</li></ul><p><img src="/img/cassandra/rack-inferring-snitch.jpg" alt="分段rack"></p><h2><span id="安装mx4j集群监控">安装MX4J集群监控</span></h2><p>cassandra监控有许多方案，DataStax的Opscenter是比较耗的监控解决方案。可惜Opscenter6.0版本后已经不再支持开源cassandra版本。Opscenter5.x版本支持到cassandra2.1。最好使用cassandra自身支持的<a href="http://mx4j.sourceforge.net/">MX4J</a>进行监控。</p><p>解压后将mx4j-tools.jar拷贝到cassandra的安装目录的lib文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip mx4j-3.0.2.zip</span><br><span class="line">cp mx4j-3.0.2/lib/mx4j-tools.jar apache-cassandra-3.11.1/lib/</span><br></pre></td></tr></table></figure><p>配置mx4j</p><p>编辑 <code>vim /etc/cassandra/cassandra-env.sh</code>，去除注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MX4J_ADDRESS=<span class="string">&quot;-Dmx4jaddress=10.112.68.186&quot;</span></span><br><span class="line">MX4J_PORT=<span class="string">&quot;-Dmx4jport=8081&quot;</span></span><br></pre></td></tr></table></figure><p>然后重启cassandra</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart cassandra</span><br></pre></td></tr></table></figure><p>浏览器输入地址 <a href="http://10.112.68.186:8081">http://10.112.68.186:8081</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.howtoforge.com/tutorial/how-to-install-apache-cassandra-on-centos-7/">https://www.howtoforge.com/tutorial/how-to-install-apache-cassandra-on-centos-7/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> cassandra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Circuit Breaker</title>
      <link href="/2017/12/29/philosophy/circuit-breaker/"/>
      <url>/2017/12/29/philosophy/circuit-breaker/</url>
      
        <content type="html"><![CDATA[<p>熔断器(circuit breaker)包含在电路设备中，用于防止过载或短路的组件。常见于洗衣机、电热水壶、烤机等。今天所讲的比这个稍微复杂一些。</p><span id="more"></span><p><img src="/img/philosophy/circuit-breaker/circuit_breaker_state_diagram.gif" alt="circuit-breaker"></p><p>一个熔断器包含下面的功能：</p><ul><li>当所有情况正常，它的状态为<code>closed</code>，让电流(electricity)或数据(data)流通。</li><li>当探测到过载(overload)或短路(short circuit)，熔断器跳闸(<code>trips</code>)进入<code>open</code>状态，不让任何东西流通。</li><li>一段时间后，熔断器会自动进入<code>half-open</code>状态，探测(probing)是否恢复正常。如果电流(或数据流)正常，熔断器进入<code>open</code>状态。</li></ul><p>因为远程调用和内存(in-memory)调用不同，远程调用会出现超时和挂掉的情况。软件服务间需要提供一种响应式的设计。Michael Nygard 发表了一篇文章阐述了<code>Circuit Breaker pattern</code>来防护这种灾难性的级联发生。</p><p>和电路上的熔断器又些许不同，熔断器模式包含下面状态改变的规则：</p><ul><li>在<code>closed</code>状态，熔断器统计失败的次数或 事先定义好的<code>callTimeout</code>的次数。如果失败的次数到达设定的阈值(maxFailures or thresholds)，跳闸。任何调用都应该在计数(counter)重置为0时才能成功访问。</li><li>在<code>open</code>状态，熔断器闲置(idles until)执行到配置的<code>resetTimeout</code>时间，随后进入<code>half-open</code>状态。</li><li>在<code>half-open</code>状态，如果第一次尝试调用仍然失败，它重新跳闸到<code>open</code>状态；如果第一次调用成功了，熔断器重置为<code>closed</code>状态， <code>restTimeout</code>被重置。</li></ul><p><img src="/img/philosophy/circuit-breaker/state.png" alt="图例"></p><h2><span id="reactive-design">Reactive Design</span></h2><p>最早的响应式宣言宣布于2013年6月。它是响应式应用的软件架构描述。它包含下面4个特点：</p><ul><li><em>Responsive</em> —— React to users(快速检测并高效处理问题)</li><li><em>Scalable(Elastic)</em> —— React to load(弹性控制，大部分实现依赖于硬件和软件平台)</li><li><em>Resilient</em> —— React to failure(有回复，受控制，隔离，委派)</li><li><em>Event-driven</em> —— React to events(异步消息，确保松耦合，隔离，位置透明。非阻塞的交互服务)</li></ul><p>一些实现方式：</p><ol><li>请求回复链路：</li></ol><p><img src="/img/philosophy/circuit-breaker/chain.png" alt="RRC"></p><ol start="2"><li>我们的设计：</li></ol><p><img src="/img/philosophy/circuit-breaker/%E7%9B%91%E7%AE%A1%E7%AD%96%E7%95%A5.png" alt="supervisor"></p>]]></content>
      
      
      
        <tags>
            
            <tag> circuit-breaker, reactivemanifesto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="/2017/11/22/musics/audio-player-nest/"/>
      <url>/2017/11/22/musics/audio-player-nest/</url>
      
        <content type="html"><![CDATA[<p><img src alt></p><span id="more"></span><div class="rabbit-player"><audio id="audio-1" controls class="rabbit-audio">    <source src="/music/明日への涙.mp3" type="audio/mpeg"></audio><div class="rabbit-lyrics" data-audio="#audio-1">明日への涙歌手：川田まみ所属专辑：MAMI KAWADA BEST BIRTH[01:01.64]あの星は同じ瞬きで远方的星星同时在闪烁[01:09.15]変わらずに私を見て映照出 一如既往的我[01:16.59]退屈な夢を嘆き伏せた侧卧的脸颊[01:24.15]横顔をそっと照らしてた浮现出对寂寞梦惊的无奈[01:30.76]明日には小さな荷物背負い明天要背着小小的行李[01:38.23]荒野を飛び立つ鳥になるから因为我要成为翱翔天空的鸟[01:45.07]向い風の中向かう場所はまだ在迎面而来的风中 还看不到目的地[01:51.52]顔上げれば遥か遠くて(抬起头来的话 遥远的地方...)[01:52.98]いつか辿り着く星になれる何时才能到达 变成星星[02:00.06]まつげに滲んだ雫をなびかせ泪滴渗透睫毛 轻轻抖动[02:06.62]溢れそうな思い乗せて(载满不断涌出的回忆...)[02:07.57]決して終わらない旅を继续吧[02:13.78]続けにゆくよ绝不停止的旅行[02:31.66]大切なものが多すぎで要牵挂的事情太多[02:39.23]一人では選べなくて自己无法抉择[02:46.61]降りそそぐ孤独夕暮れ時夕阳西下的时候 体会强烈的孤独感[02:54.15]意味のない会話にすがった寄希望于无意义的对话[03:00.77]明日には本当の私に会い明天我要展现真实的自我[03:07.99]荒野に駆け出す風になるから因为我要成为驰骋荒野的风[03:15.05]浮かぶ夢の中歌う星達は漂浮的梦中 群星歌唱[03:21.53]追いつけない時の中で(追赶不上的 时间中)[03:22.80]永遠の空をまわっている在永远的天空中旋转着[03:29.94]頬に落ちた粒指で弾いたら如果用手指弹去 落在脸夹的粉末[03:36.61]零れてゆく夢の欠片(不断流出的 梦的碎片)[03:37.65]風に舞い上がり碧の光に変わる就会在风中飞舞 变成蓝色的光[04:45.82]明日にはちぎれた羽を拾い向着明天拾起残破的翅膀[04:53.05]荒野に羽ばたく鳥になるから因为我成为展翅荒野的鸟[05:00.03]向い風の中向かう場所はまだ在迎面而来的风中 还看不到目的地[05:06.37]顔上げれば遥か遠くて(抬起头来的话遥远的远方...)[05:07.58]いつか辿り着く星になれる何时才能到达 成为星星[05:14.96]背中を押すのは小さなこの手と按在后背的 是小小的手[05:21.86]辿り着いた見つけた答え(寻寻睨睨 才找到的答案)[05:22.69]大空に投げた夢と明日への涙向着天空的梦想和 为明天而落的眼泪[05:35.62]顔上げれば遥か遠くて抬起头来的话 遥远的远方...[05:46.67]溢れそうな思い乗せて载满 不断涌出的回忆...[06:00.11]追いつけない時の中で在追赶不上的 时间中[06:08.76]零れてゆく夢の欠片不断流出的 梦的碎片</div></div><p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 请参考 <a href="https://guoyunhe.me/rabbit-lyrics/#example-mini-view-mode">这里</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> audio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An Akka DDD from scratch</title>
      <link href="/2017/11/13/pattern/ddd/dddfs/"/>
      <url>/2017/11/13/pattern/ddd/dddfs/</url>
      
        <content type="html"><![CDATA[<p>最近的多人游戏开发上，对<a href="http://akka.io/">Akka</a> 的使用非常感兴趣。在我的工作上，我和 <a href="http://www.dsfishlabs.com/en">@DsFishlabs</a> 使用了 Spring Boot 以及 Spring Cloud 作为我们的内部服务。</p><p>在本文，我想尝试基于 <code>Akka</code> 来构建相似的系统，功能方面跟原来差不多，但这里我想尝试一个不同的方式。其中包含有 Scala，<a href="http://doc.akka.io/docs/akka/snapshot/scala/cluster-sharding.html">Akka Cluster Sharding</a>，<a href="http://doc.akka.io/docs/akka/snapshot/scala/persistence.html">Akka Persistence aka.Event Sourcing</a> 以及 <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a>。</p><p>所有代码会在Github上，可能需要看看 <a href="https://github.com/evolution-gaming/akka-tools">extractShardId</a> 方面的资料。</p><span id="more"></span><h2><span id="通用语言-amp-第一个模型">通用语言 &amp; 第一个模型</span></h2><p>这里，我将同时扮演开发者(Developer)和领域专家(Domain Expert)的角色，以减少问题的复杂性。我将围绕我自身在公司和游戏的层面出发。每个项目应该开始一种通用语言(an ubiquitous language)，以及要设计实现解决方案的需求，让我们定义一些术语。</p><blockquote><p>领域专家说：<br>&quot; Each <code>Player</code> has some amount of <code>XP</code> as well as <code>Credits</code> &quot;</p></blockquote><p>它引入了3个术语：</p><ul><li>Player 游戏玩家，它有唯一标识</li><li>XP每个游戏玩家通过经验值(the amount of <code>XP</code>)成长</li><li>Credits该游戏中用于交易的通用货币</li></ul><p><img src="/img/pattern/ddd/dddfc/first-model.svg" alt="first-model"></p><p>真实的需求，引导我们建立模型。这里<code>Player</code> 作为一个 <code>Aggregate Root</code> 并附上一个类型Id(<code>PlayerId</code>)。</p><p>它包含上述的所有需求(当然只有一个…)。我们的模型也包括了通用语言中的所有术语(terms)。</p><div class="clearfix"></div>对应Scala类实现如下：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">PlayerId</span> = <span class="type">PlayerId</span>(<span class="type">UUID</span>.randomUUID.toString)</span><br><span class="line">  <span class="keyword">var</span> xp: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> credits: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerId</span>(<span class="params">value: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>完美！所有需求实现了…</p><p>但只有一个类起不到什么作用，不能向玩家发送信息，也没有初始化的随机<code>UUID</code>控制，因此让我们补上。</p><blockquote><p>领域专家说：<br>“A new <code>Player</code> will be created when a Person registers on the Backend.<br>It will the be initialized with a given amount of <code>XP</code> and <code>Creadits</code> (in this case 0) When a <code>Player</code> requests his information from the backend then it should return the <code>Id</code> and the amount of <code>XP</code> as well as the amount of <code>Credits</code>”</p></blockquote><p>是的，玩家可以自己创建角色，并初始化一定的经验值和币值(开始时都是0)。并且能获取到创建角色的有关信息。</p><p>下面我们来满足这一需求：</p><h2><span id="第一个actor">第一个Actor</span></h2><p>首先我们要将<code>Player</code>类转换为一个事件溯源(event sourced)Actor，下面为代码：</p><figure class="highlight scala"><figcaption><span>PlayerActor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerActor</span> <span class="keyword">extends</span> <span class="title">PersistentActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">PlayerId</span> = <span class="type">PlayerId</span>(self.path.name) <i class="conum" data-value="1"></i></span><br><span class="line">  <span class="keyword">var</span> xp: <span class="type">Int</span> = _</span><br><span class="line">  <span class="keyword">var</span> credits: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">// self.path.name is the entity identifier (utf-8 URL-encoded)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">persistenceId</span></span>: <span class="type">String</span> = <span class="string">&quot;Player-&quot;</span> + self.path.name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveCommand</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> init: <span class="type">InitializePlayer</span> =&gt; <i class="conum" data-value="2"></i></span><br><span class="line">      persist(<span class="type">PlayerInitialized</span>(init.playerId, init.xp, init.credits)) &#123; ev =&gt; <i class="conum" data-value="3"></i></span><br><span class="line">        initialize(ev)</span><br><span class="line">        sender() ! ev <i class="conum" data-value="4"></i></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GetPlayerInformation</span> =&gt; sender() ! <span class="type">PlayerInformation</span>(id, xp, credits) <i class="conum" data-value="5"></i></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">&quot;received unknown message&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveRecover</span> </span>= &#123; <i class="conum" data-value="6"></i></span><br><span class="line">    <span class="keyword">case</span> init: <span class="type">PlayerInitialized</span> =&gt; initialize(init)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">&quot;received unknown message&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(init: <span class="type">PlayerInitialized</span>) = &#123; <i class="conum" data-value="7"></i></span><br><span class="line">    <span class="keyword">this</span>.xp = init.xp</span><br><span class="line">    <span class="keyword">this</span>.credits = init.credits</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="conum" data-value="1"></i> 之后你将看到我们可以从actor 路径获得 <code>Player</code>的Id，因此一个<code>Player</code>总是有一个Id。<br><i class="conum" data-value="2"></i> 要实现需求，<code>Player</code>应该初始化事件响应。<br><i class="conum" data-value="3"></i> 首先我们会持久化产生的事件，之后调用<code>initialized</code>方法初始化<code>Player</code>的状态。<br><i class="conum" data-value="4"></i> 初始化后，我们给sender回应该事件<br><i class="conum" data-value="5"></i> 这里实现了<code>Player</code>可以获取它的状态。因为没有命令(command)产生的事件，仅返回数据。<br><i class="conum" data-value="6"></i> 当调用这个方法表示该actor的事件进入“重玩”(replayed)。因此直接调用初始化方法，这个不需要持久化。<br><i class="conum" data-value="7"></i> 该方法根据事件来设置<code>XP</code>和<code>Credits</code>.</p><p>由于要使用<code>Event Sourcing</code>作为持久化机制，这里扩展<code>PersistentActor</code>。</p><p>伴生对象如下所示，这里我们定义了事件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PlayerActor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// define compatible commands</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializePlayer</span>(<span class="params">playerId: <span class="type">PlayerId</span>, xp: <span class="type">Int</span>, credits: <span class="type">Int</span></span>)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetPlayerInformation</span>(<span class="params">playerId: <span class="type">PlayerId</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// define compatible events</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerInitialized</span>(<span class="params">playerId: <span class="type">PlayerId</span>, xp: <span class="type">Int</span>, credits: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// custom responses</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerInformation</span>(<span class="params">playerId: <span class="type">PlayerId</span>, xp: <span class="type">Int</span>, credits: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extractEntityId</span></span>(): <span class="type">ShardRegion</span>.<span class="type">ExtractEntityId</span> = &#123; <i class="conum" data-value="1"></i></span><br><span class="line">    <span class="keyword">case</span> msg<span class="meta">@InitializePlayer</span>(id, _, _) =&gt; (id.value.toString, msg)</span><br><span class="line">    <span class="keyword">case</span> msg<span class="meta">@GetPlayerInformation</span>(id) =&gt; (id.value.toString, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extractShardId</span></span>(numberOfShards: <span class="type">Int</span>): <span class="type">ShardRegion</span>.<span class="type">ExtractShardId</span> = &#123; <i class="conum" data-value="2"></i></span><br><span class="line">    <span class="keyword">case</span> <span class="type">InitializePlayer</span>(id, _, _) =&gt; <span class="type">Math</span>.abs(id.hashCode() % numberOfShards).toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GetPlayerInformation</span>(id) =&gt;  <span class="type">Math</span>.abs(id.hashCode() % numberOfShards).toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="conum" data-value="1"></i> 要使用<a href="http://doc.akka.io/docs/akka/snapshot/scala/cluster-sharding.html">Akka Cluster Sharding</a> 我们需要定义一个<code>extractEntityId</code>方法，这样akka知道哪个actor应该接受当前的消息。这里返回<code>Player</code>的Id，同时也是actor的路径名称。<br><i class="conum" data-value="2"></i> 另外也需要定义一个<code>extractShardId</code>方法，这样akka知道哪个分片负责该Actor(这里定义100个分片)，这样将actor分配到每个节点上。</p><h2><span id="主函数">主函数</span></h2><p>我们还需要注册一个endpoint将它们连接起来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">App</span> <span class="keyword">with</span> <span class="title">AkkaInjectable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>()</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> executor = system.dispatcher</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">5</span> seconds)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = <span class="type">ConfigFactory</span>.load()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> logger: <span class="type">LoggingAdapter</span> = <span class="type">Logging</span>(system, getClass)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> appModule = <span class="keyword">new</span> <span class="type">PlayerModule</span> <i class="conum" data-value="1"></i></span><br><span class="line">  <span class="keyword">val</span> player = inject[<span class="type">ActorRef</span>](<span class="symbol">&#x27;player</span>) <i class="conum" data-value="2"></i></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> routes = &#123;</span><br><span class="line">    logRequestResult(<span class="string">&quot;server&quot;</span>) &#123;</span><br><span class="line">      (post &amp; path(<span class="string">&quot;register&quot;</span>)) &#123;</span><br><span class="line">        complete &#123;</span><br><span class="line">          <span class="comment">// create a new user and send it a message</span></span><br><span class="line">          <span class="keyword">val</span> playerId = <span class="type">PlayerId</span>(<span class="type">UUID</span>.randomUUID().toString) <i class="conum" data-value="3"></i></span><br><span class="line">          (player ? <span class="type">InitializePlayer</span>(playerId, <span class="number">0</span>, <span class="number">0</span>)).mapTo[<span class="type">PlayerInitialized</span>].map &#123; ev: <span class="type">PlayerInitialized</span> =&gt; ev.playerId.value &#125; <i class="conum" data-value="4"></i></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Http</span>().bindAndHandle(routes, config.getString(<span class="string">&quot;http.interface&quot;</span>), config.getInt(<span class="string">&quot;http.port&quot;</span>)) <i class="conum" data-value="5"></i></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="conum" data-value="1"></i> 载入<code>PlayerModule</code>。<br><i class="conum" data-value="2"></i> 注入分片actor的引用，这样我们可以发送信息。<br><i class="conum" data-value="3"></i> 创建一个唯一标识的Id。<br><i class="conum" data-value="4"></i> 发送请求。<br><i class="conum" data-value="5"></i> 地址和端口。</p><p>这里，我使用了<a href="http://scaldi.org/">Scaldi</a>作为依赖注入方式，因此我们需要声明集群分片：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerModule</span>(<span class="params">implicit system: <span class="type">ActorSystem</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> numberOfShards = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> playerRegion: <span class="type">ActorRef</span> = <span class="type">ClusterSharding</span>(system).start(</span><br><span class="line">    typeName = <span class="string">&quot;Player&quot;</span>,</span><br><span class="line">    entityProps = <span class="type">Props</span>[<span class="type">PlayerActor</span>],</span><br><span class="line">    settings = <span class="type">ClusterShardingSettings</span>(system),</span><br><span class="line">    extractEntityId = <span class="type">PlayerActor</span>.extractEntityId(), <i class="conum" data-value="1"></i></span><br><span class="line">    extractShardId = <span class="type">PlayerActor</span>.extractShardId(numberOfShards) <i class="conum" data-value="2"></i></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  bind[<span class="type">ActorRef</span>] as <span class="symbol">&#x27;player</span> to playerRegion <i class="conum" data-value="3"></i></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="conum" data-value="1"></i> <code>extractEntityId</code>方法的引用<br><i class="conum" data-value="2"></i> <code>extractShardId</code>方法的引用<br><i class="conum" data-value="3"></i> <code>player</code>绑定为分片actor的引用，用作依赖注入实现</p><p><a href="https://github.com/Chumper/akka-game-backend-from-scratch/tree/master/part1">这里</a>可以参考完整代码。</p><h2><span id="测试">测试</span></h2><p>启动服务或执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt run</span><br></pre></td></tr></table></figure><p>我这里使用了<a href="https://github.com/jkbrzt/httpie">Httpie</a>，测试更加方便。</p><p>你可以<code>POST</code>到<code>/register</code>端点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; http POST :9000/register</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 36</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Date: Sun, 10 Jan 2016 18:44:59 GMT</span><br><span class="line">Server: akka-http/2.4.1</span><br><span class="line"></span><br><span class="line">62b058cf-6d73-4d5c-9855-2aed6e36ad3d</span><br></pre></td></tr></table></figure><p>下面作一个短期的基准(benchmark)测试(10秒，10并发请求)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt; ab -t10 -c10 -mPOST http://localhost:9000/register</span><br><span class="line"></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1663405 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10377 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        akka-http/2.4.1</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            9000</span><br><span class="line"></span><br><span class="line">Document Path:          /register</span><br><span class="line">Document Length:        36 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   10.000 seconds</span><br><span class="line">Complete requests:      10377</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      2044269 bytes</span><br><span class="line">HTML transferred:       373572 bytes</span><br><span class="line">Requests per second:    1037.70 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       9.637 [ms] (mean)</span><br><span class="line">Time per request:       0.964 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          199.64 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.1      0       3</span><br><span class="line">Processing:     2    9  15.0      8     474</span><br><span class="line">Waiting:        2    9  15.0      8     474</span><br><span class="line">Total:          3   10  15.0      9     474</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%      9</span><br><span class="line">  66%      9</span><br><span class="line">  75%     10</span><br><span class="line">  80%     10</span><br><span class="line">  90%     11</span><br><span class="line">  95%     12</span><br><span class="line">  98%     14</span><br><span class="line">  99%     17</span><br><span class="line"> 100%    474 (longest request)</span><br></pre></td></tr></table></figure><p>10秒内得到10000新用户，令人印象深刻(我们的spring 服务甚至接近的水平都未到…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> ddd, shard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Domain Design Relish</title>
      <link href="/2017/11/07/pattern/ddd/functional-ddd/"/>
      <url>/2017/11/07/pattern/ddd/functional-ddd/</url>
      
        <content type="html"><![CDATA[<p>More formally, a domain model is a blueprint of the relationships between the various entities of the problem domain and sketches out other important details, such as the following:</p><ul><li>Objects that belong to the domain</li><li>Behaviors that those objects demonstrate in interacting among themselves</li><li>The language that the domain speaks</li><li>The context within which the model operates</li></ul><span id="more"></span><p>With a modular system, each component is self-contained in functionality and interacts with other components only through explicitly defined contracts. With this arrangement, you can manage complexity better than with a monolithic system.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Lifecycle of a domain object</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Domain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">E</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">H</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">P</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Every object (entity or value object) in any model must have a definite lifecycle pattern</span></span><br><span class="line">  <span class="comment">// thus events will be using repeatedly in various contexts of domain modeling.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">creation</span></span>: <span class="type">E</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">behaviors</span></span>: <span class="type">H</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">persistence</span></span>: <span class="type">P</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Bank is also an entity,</span></span><br><span class="line"><span class="comment">  * an entity can contain other entities or value objects</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// attributes of bank</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">debit</span></span>: <span class="type">Unit</span>   <span class="comment">// 贷款</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">issue</span></span>: <span class="type">Unit</span>   <span class="comment">// 转账</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * In fact, [[Account]] is a aggregate root</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Account</span> </span>&#123;                     <span class="comment">// Basic contract of an Account aggregate</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">no</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bank</span></span>: <span class="type">Bank</span>                    <span class="comment">// Reference to another entity</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span></span>: <span class="type">Address</span>              <span class="comment">// Address is a value object.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dateOfOpening</span></span>: <span class="type">Date</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dateOfClose</span></span>: <span class="type">Option</span>[<span class="type">Date</span>]</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory Pattern be used</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// define apply method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span>(<span class="params">         // 具体实现</span></span></span><br><span class="line"><span class="params"><span class="class">  no: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  bank: <span class="type">Bank</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  address: <span class="type">Address</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  dateOfOpening: <span class="type">Date</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  dateOfClose: <span class="type">Option</span>[<span class="type">Date</span>]</span></span></span><br><span class="line"><span class="params"><span class="class">  // ..</span></span></span><br><span class="line"><span class="params"><span class="class"></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br></pre></td></tr></table></figure><p>In reality, when you design aggregates, you may find that for performance and consistency of operations you have to optimize away many composing entities from the aggregate and have only the root along with the value objects. For example, you may choose to keep a bank ID instead of the entire Bank entity as part of the Account aggregate.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class"> no: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"> name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"> bank: <span class="type">Bank</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"> address: <span class="type">Address</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"> dateOfOpening: <span class="type">Date</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"> dateOfClose: <span class="type">Option</span>[<span class="type">Date</span>],</span></span></span><br><span class="line"><span class="params"><span class="class"></span></span></span><br><span class="line"><span class="params"><span class="class">  // ..</span></span></span><br><span class="line"><span class="params"><span class="class">  rateOfInterest: <span class="type">BigDecimal</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  // ..</span></span></span><br><span class="line"><span class="params"><span class="class"></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br></pre></td></tr></table></figure><p>A domain model is a blueprint of the relationships between the various entities of the problem domain and sketches out other important details, such as following:</p><ul><li>Objects that belong to the domain</li><li>Behaviors that those objects demonstrate in interacting among themselves</li><li>The language that the domain speaks</li><li>The context within which the model operates</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Amount</span> </span>= <span class="type">BigDecimal</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(from: <span class="type">Account</span>, to: <span class="type">Account</span>, amount: <span class="type">Amount</span>): <span class="type">Option</span>[<span class="type">Amount</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Repository doesn&#x27;t have any knowledge of the nature of the underlying persistent store.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(accountNo: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Account</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(criteria: <span class="type">Criteria</span>[<span class="type">Account</span>]): <span class="type">Seq</span>[<span class="type">Account</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(accounts: <span class="type">Seq</span>[<span class="type">Account</span>]): <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(account: <span class="type">Account</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>supply a bunch of arguments to the factory and get back an aggregate(such as <code>Account</code>).</li><li>use the aggregate as your contract through all behaviors that you implement through services.</li><li>use the aggregate to persist the entity in the repository</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * [[AccountServiceImpl]] respect the qualities of understandability</span></span><br><span class="line"><span class="comment">  * 1. The function body doesn&#x27;t contain any irrelevant details. It just encapsulates the domain logic</span></span><br><span class="line"><span class="comment">  * 2. The implementation used terms from the domain of banking, so business domain doesn&#x27;t know anything about</span></span><br><span class="line"><span class="comment">  * the underlying implementation platform, it is reference transparent.</span></span><br><span class="line"><span class="comment">  * 3. The implementation narrates use method composing and monadic and takes care of any exceptions in the sequence of execution.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountServiceImpl</span> <span class="keyword">extends</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These methods call `Ubiquitous language`</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">debit</span></span>(a: <span class="type">Account</span>, amount: <span class="type">Amount</span>): <span class="type">Try</span>[<span class="type">Account</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">credit</span></span>(a: <span class="type">Account</span>, amount: <span class="type">Amount</span>): <span class="type">Try</span>[<span class="type">Account</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(from: <span class="type">Account</span>, to: <span class="type">Account</span>, amount: <span class="type">Amount</span>): <span class="type">Try</span>[(<span class="type">Account</span>,<span class="type">Account</span>)] = <span class="keyword">for</span> &#123;</span><br><span class="line">    d &lt;- debit(from, amount)</span><br><span class="line">    c &lt;- credit(to, amount)</span><br><span class="line">  &#125; <span class="keyword">yield</span> (d,c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ddd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论</title>
      <link href="/2017/11/06/philosophy/cap-theorem/"/>
      <url>/2017/11/06/philosophy/cap-theorem/</url>
      
        <content type="html"><![CDATA[<p>分布式网络环境中，时间和顺序是无法预估的，要保证得到的数据正确，我们需要一些折衷的选择。</p><p>2000年7月19号，Eric Brewer在ACM研讨会上关于分布式计算的原则(Principlesof Distributed Computing，PODC)所做的开题演讲中，提出了一个猜想(后来的成为著名的Brewer猜想)：</p><blockquote><p>applications become more web-based we should stop worrying about data consistency, because if we want high availability in these new distributed applications, then guaranteed consistency of data is something we cannot have, thus giving anyone with three servers and a keen eye for customer experience permission to start an internet scale business.</p></blockquote><p>2年后，2002年，麻省理工（MIT）的Seth Gilbert和NancyLynch，理论上证明了Brewer猜想是正确的，就此Brewer定理（Theorem）诞生了。</p><span id="more"></span><h2><span id="cap理论">CAP理论</span></h2><p>Brewer认为在分布式的环境下设计和部署系统时，有3个核心的系统需求，以一种特殊的关系存在。</p><ul><li>一致性(Consistency, C)</li></ul><p>一致性是指客户端会返回某条记录最新的值。假如有一个银行账号，如果我们在存入一张400美元的支票之后马上试图取回400美元，我们希望系统能够给出正确的账户余额，并且允许我们取回400美元。</p><ul><li>可用性(Availability, A)</li></ul><p>可用性是指一个没有发生失败的节点能够返回一个合理的响应。</p><ul><li>分区容错性(Partition Tolerance, P)</li></ul><p>分区容错性指的是如果某个节点由于暂时的网络错误而被从网络中移除，那么系统可以继续正常运行。如果数据被冗余备份到三个节点，那么如果其中一个节点暂时变得不可用，而另两个节点仍然能够正常运行，那么就认为系统具备分区容错性。</p><h2><span id="cap-理论中的妥协">CAP 理论中的妥协</span></h2><p>CAP 理论通常都会表述如下：在一致性、可用性和分区容错性这三个特性中，一个分布式系统只能够选择满足其中两个。这种表示过于简单，可能会让人误解，如果阅读过一些文章的话，可以看到许多持不同观点的争论。<br>首先，假设我们希望系统具备分区容错性，只在可用性和一致性之间进行妥协。读者可能会问为什么。在接收到一个有超时限制的请求时，如果节点不可用，我们其实就需要在两种方案之间进行选择：要么返回错误（选择一致性），要么继续，即使服务器之间可能会不一致（选择可用性）。等待的时间过长会导致该请求被抛弃，所以时间是一个重要的因素，系统必须要在上面两者中做出决定，如图所示。我们将介绍更多相关知识，不过Eric Brewer 在发表了CAP 理论的论文12 年后，又写了一篇文章，对这一点做了深入讨论。参见<a href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-ruleshave-changed">http://www.infoq.com/articles/cap-twelve-years-later-how-the-ruleshave-changed</a>。</p><img src="/img/philosophy/cap/cap.png" width="350" height="350"><h2><span id="cp-系统一致性优先">CP 系统–一致性优先</span></h2><p>要实现一个一致性的分布式存储，有很多种不同的方法。一个最简单的强一致性数据库的例子也许有一个master 节点和任意数量包含冗余备份的附属节点。数据永远会在master 节点写入，而如果要确保读取最新的数据，那么页必须要从master 节点读取。如果master 节点发生错误，那么系统就不再可用，如图下图 所示。通常来说，可以采取一些应对错误的机制，比如让某个附属节点成为新的master 节点。因为master 节点发生故障的时候我们无法从系统中读取数据，也无法写入数据，所以我们放弃了可用性，而是启动错误处理过程，选出新的master 节点。一旦错误处理过程完成，系统的可用性就恢复了。Redis Sentinel 和具备冗余备份的RDBMS 都是强一致性分布式系统的很好的例子。</p><img src="/img/philosophy/cap/cp.png" width="550" height="165"><p>如果需要原子读取/写入、事务等支持的话，那么可以选择具备一致性的系统。</p><h2><span id="ap-系统可用性优先">AP 系统–可用性优先</span></h2><p>选择支持可用性和分区容错性，并牺牲一致性的系统被称为具有“最终一致性”。在高可用的分布式数据库（如Cassandra 和Riak）中，这是一种非常常见的模型。<br>由于分析AP 系统稍微复杂一些，因此我们将在本章中介绍更多AP 系统的细节。不过我们可以先看一下AP 系统的一种可能的实现例子。假设在3 个节点上保存了数据的3份备份。当我们写入数据时，数据会被写入到其中1 个节点，然后会被复制到其余2 个节点。无论写入的是哪个节点，该节点都会负责把数据同步到其他节点，如图所示。</p><img src="/img/philosophy/cap/ap.png" width="550" height="240"><p>当我们从一个节点读取数据时，只需要访问一个节点就够了。所以客户端可以任意选择一个节点读取。在这个例子中，因为从某个节点读取数据时，数据可能并不是最新的（不具备一致性），所以我们的系统具备最终一致性。但是由于我们可以从任何一个节点读取数据，也可以向任何一个节点写入数据，所以系统具备分区容错性和高可用性。如果某个节点变得不可用，我们可以直接尝试使用另一个节点。</p><h2><span id="灵活的一致性程度">灵活的一致性程度</span></h2><p>从实际应用的角度来说，在3 个特性之间的权衡并不是非黑即白的，其实可以平缓地过渡。例如在一个最终一致性系统中，如果想查询某条记录，而该记录有3 个冗余备份，那么我们可以选择从任意一个节点读取数据，这样一致性就比较弱。我们也可以选择其中任意两个节点返回数据，这样一致性就提升了。同样，我们可以向所有3 个节点请求返回结果，这样就能提供最高的一致性。当我们从3 个节点中得到返回数据时，有多种不同的机制可以用来对返回的记录排序，我们可以选择最新的数据。但是，这么做会牺牲分区容错性。如果我们需要所有3 个备份都可用，那么就无法容忍其中任何一个消失。很多时候，只要求特定数量的节点或是大多数节点可用并且能返回一致的结果是在一致性和分区容错性中进行权衡的一个不错的方法。</p><p>同样，在一个CP 系统中，我们可以允许从附属节点读取数据，牺牲一部分一致性来获取更高的可用性。如果保持仍然只能向master 节点写入数据，那么我们还是有高一致性的写入操作，但是允许读取操作最终一致，所以数据库在读取操作上就变成AP系统了。</p><ul><li><p>放弃P: 如果你想避免partition问题发生，你就必须要阻止其发生。一种做法是将所有的东西（与事务相关的）都放到一台机器上。或者放在像rack这类的atomically-failling单元上。无法100%地保证，因为还是有可能部分失败，但你不太可能碰到由partition问题带来的负面效果。当然，这个选择会严重影响scale限制。</p></li><li><p>放弃A：相对于放弃partition tolerance来说，其反面就是放弃availability。一旦遇到partition事件，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务。在多个节点上控制这一点会相当复杂，而且恢复的节点需要处理逻辑，以便平滑地返回服务状态。</p></li><li><p>放弃C: 或者如同Werner Vogels所提倡的，接受事情会变得“最终一致（EventuallyConsistent）”（2008年12月更新）。Vogels的文章值得一读。他比我在这里讨论了更多的操作方面的细节。许多的不一致性并不比你想的需要更多的工作（意味着持续的consistency或许并不是我们所需要的）。在购书的例子中，如果一本库存的书，接到了2个订单，第二个就会成为备份订单。只要告知客户这种情况（请记住这是一种罕见的情况），也许每个人都会高兴的。</p></li><li><p>引入BASE(Basically Available, Soft-state, Eventually consistent)：<code>BASE(化学含义是碱)</code>，如其名字，是<code>ACID(化学含义是酸)</code>的反面。但如果认为任何架构应该完全基于一种（BASE）或完全基于另一种（ACID），就大错特错了。这一点是需要谨记重点，尤其是这个行业的“一边倒”的习惯性的采用策略。这里，我要遵从Brewer教授自己的观点，他就本文通过email表达了自己的观点（comment）：</p></li></ul><blockquote><p>the term “BASE” was first presented in the 1997 SOSP article that you cite. I came up with acronym with my students in their office earlier that year. I agree it is contrived a bit, but so is “ACID” – much more than people realize, so we figured it was good enough. Jim Gray and I discussed these acronyms and he readily admitted that ACID was a stretch too – the A and D have high overlap and the C is ill-defined at best. But the pair connotes the idea of a spectrum, which is one of the points of the PODC lecture as you correctly point out.</p></blockquote><p>EBay的DanPritchett有一篇关于BASE的很棒的介绍。</p><blockquote><p>Guy Pardon，atomikos的CTO写了一篇他称作“CAP解决之道（证实Brewer的错误）”的文章，提出了一种架构方法，可以达到Consistency,Availability和Partition-tolerance，当然附带了一些说明（显然你不可能在同一时刻满足全部的3个要求）。值得一读，Guy雄辩地表达了（在该领域）相反的观点。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> cap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monoids and Monads</title>
      <link href="/2017/10/23/philosophy/monoids-and-monad/"/>
      <url>/2017/10/23/philosophy/monoids-and-monad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Haskell由于使用了Monad这种较费解的概念来控制副作用而遭到了一些批评意见。Wadler试图平息这些质疑，他解释说：“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？”<br>A monad is just a monoid in the category of endofunctors, what’s the problem?</p></blockquote><p>这一句话包含了好几个概念：单子(monad)，自函子(Endo-Functor)，幺半群(Monoid)，范畴(category)。</p><span id="more"></span><h2><span id="monoid">Monoid</span></h2><p>函数式编程的Monoid形式定义为：</p><ul><li>给定的类型 <code>T</code></li><li>一个二元操作，<code>Op: (T,T) =&gt; T</code>使得任意的 x, y, z ∈ T，满足 op(op(x,y), z) == op(x, op(y,z))</li><li>元单位 <code>Zero: T</code>使得任意的 x ∈ T，满足 op(x, zero) == x and op(zero, x) == x</li></ul><p>满足以上关系的代数数据结构，存在一种普遍存在形式：</p><ol><li>若T为整数，则有 <code>(a+b)+c == a+(b+c)</code>、<code>0+n == n+0 == n</code>; <code>(a*b)*c == a*(b*c)</code>、<code>1*n == n*1 == n</code></li><li>若T为字符串，则有 <code>a+(b+c)==(a+b)+c; &quot;&quot;+s==s</code>、<code>s+&quot;&quot; == s</code></li><li>若T为数组，则有 <code>List(1,2)+List(3,4) == List(1,2,3,4)</code></li><li>若T为集合，则有 <code>Set(1,2,3)+Set(2,4) == Set(1,2,3,4)</code></li></ol><p>可以看出，整数时明显满足了 “加法交换律和乘法分配律，包含一个单位元<code>e</code>”，它实际上是一个线性空间。尽管其它数据类型没有特别明显，我们要构造相应的定义关系，在其映射关系上构造一个幺半群(Monoid)。</p><p>一个群的定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）封闭性（Closure）：对于任意a，b∈G，有a*b∈G</span><br><span class="line">（2）结合律（Associativity）：对于任意a，b，c∈G，有（a*b）*c=a*（b*c）</span><br><span class="line">（3）幺元 （Identity）：存在幺元e，使得对于任意a∈G，e*a=a*e=a</span><br><span class="line">（4）逆元：对于任意a∈G，存在逆元a^-1，使得a^-1*a=a*a^-1=e</span><br></pre></td></tr></table></figure><p>则称 (G, *) 是群，简称G是群。</p><p>如果仅满足封闭性和结合律，则称G是一个半群（Semigroup）；如果仅满足封闭性、结合律并且有幺元，则称G是一个含幺半群（Monoid）。</p><p>所以一个半群(semigroup)的定义是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SemiGroup</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">T</span>, a2: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含单位元或幺元的半群，为幺半群(monoid)：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 二元操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">T</span>, a2: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="comment">// 单位元</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">SemiGroup</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照语义，属于群的任意集合要满足定义关系，所以任意集合的形式为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">Int</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Int</span>, a2: <span class="type">Int</span>) = a1 + a2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stringMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>) = a1 + a2</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">List</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]) = a1 ++ a2</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种定义在函数式编程中有什么作用？函数的抽象性在于，我们可以抽象一种类型，实现高阶函数。幺半群(Monoid)的抽象实际是一个域(Domain)，对应Scala的类型系统(type class)。我们用一个例子来说明Monoid这种类型类带来的函数式编程魅力。</p><p>Monoid带来两个重要法则：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">associativeLaw</span></span>[<span class="type">A</span>](x: <span class="type">A</span>, y: <span class="type">A</span>, z: <span class="type">A</span>)(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">Boolean</span> = m.op(x, m.op(y, z)) == m.op(m.op(x, y), z)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identityLaw</span></span>[<span class="type">A</span>](x: <span class="type">A</span>)(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  (m.op(x, m.zero) == x) &amp;&amp;</span><br><span class="line">(m.op(m.zero, x) == x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> intMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>):<span class="type">Int</span> = a + b</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">A</span>](ts: <span class="type">List</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = ts.foldLeft(m.zero)(m.f)</span><br></pre></td></tr></table></figure><h2><span id="范畴">范畴</span></h2><p>范畴由三部分组成：</p><blockquote><p>（1）一组对象<br>（2）一组态射（morphisms）。每个态射会绑定两个对象，假如f是从源对象A到目标对象B的态射，记作：<code>f：A -&gt; B</code><br>（3）态射组合。假如h是态射f和g的组合，记作：<code>h = g o f</code></p></blockquote><p>下图展示了一个简单的范畴，该范畴由对象 <code>A</code>, <code>B</code> 和 <code>C</code> 组成，有三个单位态射 <code>id_A</code>, <code>id_B</code> 和 <code>id_C</code> ，还有另外两个态射 <code>f : C =&gt; B</code> 和 <code>g : A =&gt; B </code></p><p><img src="/img/philosophy/fcp/category.png" alt="Simple-cat"></p><p>态射我们可以简单的理解为函数，假如在某范畴中存在一个态射，它可以把范畴中一个Int对象转化为String对象。在Scala中我们可以这样定义这个态射：<code>f : Int =&gt; String = ...</code>。所以态射的组合也就是函数的组合，见代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = i =&gt; i + <span class="number">1</span></span><br><span class="line">f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> f2: <span class="type">Int</span> =&gt; <span class="type">Int</span> = i =&gt; i + <span class="number">2</span></span><br><span class="line">f2: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> f3 = f1 compose f2</span><br><span class="line">f3: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br></pre></td></tr></table></figure><h4><span id="范畴公理">范畴公理</span></h4><p>范畴需要满足以下三个公理。</p><blockquote><p>（1）态射的组合操作要满足结合律。记作：<code>f o (g o h) = (f o g) o h</code><br>（2）对任何一个范畴 C，其中任何一个对象A一定存在一个单位态射，<code>id_A: A =&gt; A</code>。并且对于态射<code>g：A =&gt; B</code> 有 <code>id_B o g = g = g o id_A</code>。<br>（3）态射在组合操作下是闭合的。所以如果存在态射<code>f: A =&gt; B</code> 和<code>g: B =&gt; C</code>，那么范畴中必定存在态射 <code>h: A =&gt; C</code> 使得 <code>h = g o f</code>。</p></blockquote><p><img src="/img/philosophy/fcp/composition-ex.png" alt="Composition-ex"></p><p><code>f</code> 和 <code>g</code> 都是态射，所以我们一定能够对它们进行组合并得到范畴中的另一个态射。那么哪一个是态射 <code>f o g</code> 呢？唯一的选择就是 <code>id_A</code> 了。类似地，<code>g o f=id_B</code> 。</p><h2><span id="函子functor">函子(Functor)</span></h2><h4><span id="函子定义">函子定义</span></h4><p>函子有一种能力，把两个范畴关联在一起。函子本质上是范畴之间的转换。比如对于范畴 C 和 D ，函子<code>F : C =&gt; D</code> 能够：将 C 中任意对象a 转换为 D 中的 F(A); 将 C 中的态射<code>f : A =&gt; B</code> 转换为 D 中的 <code>F(f) : F(A) =&gt; F(B)</code></p><p>下图表示从范畴C到范畴D的函子。图中的文字描述了对象 A 和 B 被转换到了范畴 D 中同一个对象，因此，态射 g 就被转换成了一个源对象和目标对象相同的态射（不一定是单位态射），而且 id_A 和 id_B 变成了相同的态射。对象之间的转换是用浅黄色的虚线箭头表示，态射之间的转换是用蓝紫色的箭头表示。</p><p><img src="/img/philosophy/fcp/Functor.png" alt="Functor"></p><h4><span id="单位函子">单位函子</span></h4><p>每一个范畴C都可以定义一个单位函子：<code>Id： C =&gt; C</code>。它将对象和态射直接转换成它们自己：<code>Id[A] = A; f: A =&gt; B, Id[f] = f</code>。</p><h4><span id="函子公理">函子公理</span></h4><blockquote><p>（1）给定一个对象 A 上的单位态射Id_A ， F(Id_A) 必须也是 F(A) 上的单位态射，也就是说：<code>F(Id_A) = Id_(F(A))</code><br>（2）函子在态射组合上必须满足分配律，也就是说：<code>F(f o g) = F(f) o F(g)</code></p></blockquote><p>一个函子<code>Functor</code>表示范畴A到范畴B之间的映射。函子和函数都表示一种映射关系，但是针对的类型不同。</p><ol><li>函数表达的映射关系在类型上体现在**特定类型(proper type)**上。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int =&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(i:<span class="type">Int</span>): <span class="type">String</span> = i.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">// List[Int] =&gt; List[String]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(l:<span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">String</span>] = l.map(_.toString)</span><br></pre></td></tr></table></figure><ol start="2"><li>函子表达的映射关系，则体现在**高阶函数(high-order function)**上(确切来说是范畴)。</li></ol><p>怎么用代码来描述函子？根据定义，它包含两个层面的映射关系：</p><blockquote><ol><li>将C1中的类型 T 映射为 C2 中的 <code>List[T] :  T =&gt; List[T]</code></li><li>将C1中的函数 f 映射为 C2 中的 函数<code>fm :  (A =&gt; B) =&gt; (List[A] =&gt; List[B])</code></li></ol></blockquote><p>我们定义一个类型构造器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">typeMap</span></span>[<span class="type">A</span>]: <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">F</span>[<span class="type">A</span>]=&gt;<span class="type">F</span>[<span class="type">B</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这项定义再简化</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list Functor的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFunctor</span> </span>= <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = a.map(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用归纳证明的方法来阐述<code>Functor[F[_]]</code>是否满足定义关系。<code>f: A =&gt; B</code> 是一个态射，它构成了<code>A=&gt;B =&gt; F[A] =&gt; F[B]</code> 的一个映射关系。<code>map[Int, Int](List(1, 2, 3))(_ + 1)</code>，对于map 它的入参是<code>List(1,2,3)</code>，执行过程中被映射该函数 <code>_: Int + 1</code>，得到结果 List(2,3,4)。对于List范畴来说，这个过程就是：<code>List[Int] =&gt; List[Int]</code>。它就是Int 到 List 范畴的函子，即 <code>Int =&gt; Int =&gt; List[Int] =&gt; List[Int]</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范畴Int范畴List[_]</span><br><span class="line">+------------+            +----------------+</span><br><span class="line">|            |            |                |</span><br><span class="line">|    Int     |    map     |   List[Int]    |</span><br><span class="line">|     ↓      |   =====&gt;   |       ↓        |</span><br><span class="line">|    Int     |   f:A=&gt;B   |   List[Int]    |</span><br><span class="line">|            |            |                |</span><br><span class="line">+------------+            +----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在haskell里把这两个行为叫做提升(lift)，相当于把类型和函数放到容器里。</p><h2><span id="自函子endofunctor">自函子(Endofunctor)</span></h2><p>自函子是一类比较特殊的函子，它是一种将范畴映射到自身的函子 (A functor that maps a category to itself)。例如Int =&gt; Int, String =&gt; String等。</p><p>自函子的映射结果是自身，因此，对于自函子F，<code>F[Int]</code> 的结果是 <code>Int</code>，<code>F[Int =&gt; String]</code> 的结果仍是 <code>Int =&gt; String</code></p><h2><span id="monad">Monad</span></h2><p>那么回过头来看看定义，<strong>“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，有什么难以理解的。”</strong></p><p>首先，自函子是长这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幺半群是长这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自函子上的幺半群是啥？首先它是一个自函子，所以它应该包含类型<code>[M[_]]</code>，自函子满足 <code>A =&gt; B → M[A] =&gt; M[B]</code> 的关系，所以它包含有：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像还漏点什么？幺元(单位元)！补全之后，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Monad的确切定义为：</p><blockquote><p>Monad是一个函子：M: C -&gt; C，并且对C中的每一个对象x以下两个态射：</p><ol><li><code>unit: x -&gt; M[x]</code></li><li><code>join/bind: M[M[x]] -&gt; M[x]</code></li></ol></blockquote><p>第一个态射比较容易理解，它就是子函数的幺元；第二个就是我们描述的自函子！按照定义实现的Monad：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]   <span class="comment">//identity</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](mma: <span class="type">M</span>[<span class="type">M</span>[<span class="type">A</span>]]): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实际上和第一种Monad定义是等价的！！不过它还有更多的推导形式…</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](mma: <span class="type">M</span>[<span class="type">M</span>[<span class="type">A</span>]]): <span class="type">M</span>[<span class="type">A</span>] = flatMap(mma)(ma =&gt; ma)</span><br></pre></td></tr></table></figure><p>例子：我们实现下图的一个装箱操作：</p><p><img src="/img/philosophy/fcp/Monad.png" alt="Monad"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Monad在类库中总是和<code>implicity</code>一起使用，我们不做这么复杂，假设自函子范畴是<code>List</code>，实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">ListMonad</span> = <span class="keyword">new</span> <span class="type">Monad</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">List</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>: (<span class="type">List</span>[<span class="type">A</span>]) =&gt; <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">case</span> x :: xs =&gt; func(x) ::: fun(xs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="type">List</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该幺半群做自函子的映射，即每个元素加3</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;ListMonad.flatMap(List(1, 2, 3))(x =&gt; x + 3 :: Nil) &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>一点改进：尾递归实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listMonad = <span class="keyword">new</span> <span class="type">Monad</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">List</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a: <span class="type">List</span>[<span class="type">A</span>], b: <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = a <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; b</span><br><span class="line">  <span class="keyword">case</span> x :: xs =&gt; fun(xs, b ::: func(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(value, <span class="type">Nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="type">List</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于范畴论的推理总是辣么的多，Monad有几个常见的推导：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](v: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>], g: <span class="type">B</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]): <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">C</span>] = a =&gt; flatMap(f(a))(g)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>, <span class="type">B</span>](mma: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>] = flatMap(mma)(ma =&gt; ma)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>,<span class="type">B</span>](ma: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = flatMap(ma)(a =&gt; unit(f(a)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">《Advanced Scala with Cats》, underscore.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Scala和范畴论, <a href="http://www.jianshu.com/p/31377066bf97">http://www.jianshu.com/p/31377066bf97</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> scala, fp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala Method Overloading and Default Argument Values</title>
      <link href="/2017/10/09/pattern/magent/scala-method-overloading-and-default-argument-values/"/>
      <url>/2017/10/09/pattern/magent/scala-method-overloading-and-default-argument-values/</url>
      
        <content type="html"><![CDATA[<p>Using the magent pattern to get around a limitation with Scala’s overloading implementation.</p><span id="more"></span><p>I was writing some code recently that wanted to do this(somewhat contrived to simplify the example):</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(key: <span class="type">String</span>, value: <span class="type">String</span>)(<span class="keyword">implicit</span> ttl: <span class="type">Duration</span> = <span class="number">1.</span>hour): <span class="type">Int</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(key: <span class="type">String</span>, value: <span class="type">ByteString</span>)(<span class="keyword">implicit</span> ttl: <span class="type">Duration</span> = <span class="number">2.</span>hour): <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>There’s some specific detail about how the <a href="http://scala-lang.org/">Scala</a> compiler implements default values for method parameters - that I havent’t investigated and probalby wouldn’t understand anyway - that makes it say the following:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... multiple overloaded alternatives of method <span class="built_in">set</span> define default arguments.</span><br></pre></td></tr></table></figure><p>There’s clearly a way around this problem; don’t overload. So, I turned to the <a href="http://spray.io/blog/2012-12-13-the-magnet-pattern/">magnet pattern</a> as popularized by the <a href="http://spray.io/">Spray</a> library. It’s really just a specialized use for type classes that carries a cool name so it’s easy to talk about and reference. My use of the pattern, in this case, is even simpler because the return type of the method doesn’t vary with the magent instance. At any rate, here’s the deal:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ByteStringMagnet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> bs: <span class="type">ByteString</span></span><br><span class="line">  <span class="keyword">val</span> ttl: <span class="type">Duration</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: (<span class="type">ByteString</span>, <span class="type">Duration</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = f(bs, ttl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ByteStringMagnet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> language.implicitConversions</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">fromString</span></span>(s: <span class="type">String</span>)(<span class="keyword">implicit</span> ttlive: <span class="type">Duration</span> = <span class="number">1.</span>hour): <span class="type">ByteStringMagnet</span> = <span class="keyword">new</span> <span class="type">ByteStringMagnet</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ttl = ttlive</span><br><span class="line">    <span class="keyword">val</span> bs = <span class="type">ByteString</span>(s)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">fromByteString</span></span>(bytes: <span class="type">ByteString</span>)(<span class="keyword">implicit</span> ttlive: <span class="type">Duration</span> = <span class="number">2.</span>hours): <span class="type">ByteStringMagnet</span> = <span class="keyword">new</span> <span class="type">ByteStringMagnet</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ttl = ttlive</span><br><span class="line">    <span class="keyword">val</span> bs = bytes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** * Now we have only one instance of the `set` method; the magnet pattern takes * care of pulling the various types down into the argument. */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(key: <span class="type">String</span>, magnet: <span class="type">ByteStringMagnet</span>): <span class="type">Int</span> =</span><br><span class="line">    magnet &#123; (value, ttl) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;<span class="subst">$ttl</span>&quot;</span>)</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">      <span class="comment">// Do something with the ByteString value and return an Int       5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;str&quot;</span>)</span><br><span class="line">  set(<span class="string">&quot;key&quot;</span>, <span class="type">ByteString</span>(<span class="string">&quot;str&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Problem solved. The implicit conversions are resolved nicely because they’re right on the <code>ByteStringMagnet</code> and, in general, you should never have to define an implicit conversion anywhere else (unless of course you need to extend the functionality from outside of the library).</p>]]></content>
      
      
      
        <tags>
            
            <tag> scala, magent, implicits, typeclasses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command Query Responsibility Segregation Pattern</title>
      <link href="/2017/08/31/philosophy/cqrs/"/>
      <url>/2017/08/31/philosophy/cqrs/</url>
      
        <content type="html"><![CDATA[<p>在面向对象设计中，常常忽略了一个概念，对象是用于描述一个单一职责的，它要求我们：一个对象包含自身属性、行为、内在调用等行为。对象间通过相互调用完成一项工作。因此，我们在做面向对象设计时，应该分清一个对象应该包含多少东西，对象的属性是否 <code>belong to</code>它自身。如果一个对象的行为模糊不清，是否该对象设计合理？</p><span id="more"></span><h3><span id="什么是cqrs">什么是CQRS？</span></h3><p>CQRS即 <code>Command Query Responsibility Segregation</code>——命令查询职责分离。该术语描述了一个对象的方法应该 <code>要么是 commands 要么是 queries</code>。</p><ul><li>一个 <code>query</code> 返回数据但不会更改对象的状态。</li><li>一个 <code>command</code> 改变对象的状态，但不会返回任何数据。</li></ul><p>从该术语的原则性上带来的好处是：系统状态发生改变时，可以清晰理解状态的变更做了什么。</p><p>CQRS在该原则上更进一层，并定义了一个简单的模式。</p><p>前面说到，一个对象的方法要么是 commands 要么是 queries， CQRS则是从一个对象分离两个对象的实现。这种分离的依据是方法是 <code>command</code> 还是 <code>query</code> （<code>a command is any method that mutates state and a query is any method that returns a value</code>）。</p><p>在构建企业级系统中，这种简朴的模式带来什么重要的令人关注的方面？主要是迎合大规模、大范围架构的挑战，诸如：</p><ul><li>实现可伸缩性</li><li>管理复杂性</li><li>已有系统业务部分内容频繁变更</li></ul><blockquote><p>“CQRS is a simple pattern that strictly segregates the responsibility of handling command input into an autonomous system from the responsibility of handling side-effect-free query/read access on the same system. Consequently, the decoupling allows for any number of homogeneous or heterogeneous query/read modules to be paired with a command processor. This principle presents a very suitable foundation for event sourcing, eventual-consistency state replication/fan-out and, thus, high-scale read access. In simple terms, you don’t service queries via the same module of a service that you process commands through. In REST terminology, GET requests wire up to a different thing from what PUT, POST, and DELETE requests wire up to.”<br>—Clemens Vasters (CQRS Advisors Mail List)</p></blockquote><p>“大意：CQRS的模式将 <code>command</code>处理的职责分离出来，实现自治。并且允许任意数量的同构或异构的 <code>query/read</code> 搭配到 <code>command processor</code>。该原则非常适用于<code>event sourcing</code>的实现——最终一致性状态 应答/扇出、大规模read访问。简言之，服务通过<code>command</code>处理，不在同一个模块提供 <code>query</code>。 ”</p><h3><span id="read-and-write-sides">Read and write sides</span></h3><p>下图是 CQRS 在企业级系统的典型应用。</p><p><img src="/img/philosophy/cqrs/cqrs.png" alt="cqrs"></p><p>CQRS 模式中实现了读写分离。read side 仅包含 query methods；write side 仅包含 command methods。这样分离的动机主要考虑到：</p><ul><li>在多数业务系统，读和写的数量是不对等的(异构的)。每个 <code>write</code> 可能同时处理上千个 <code>reads</code>。分离这两部分使得我们能够单独进行优化。例如，对 <code>reads</code>部分进行水平扩展…</li><li>典型地，<code>commands</code>涉及到复杂业务逻辑，要确保系统能写入正确的、一致的数据到数据存储中。<code>read</code>操作比起<code>write</code>操作要简单许多。一个简单的同时封装 <code>read</code> 和 <code>write</code> 操作的模型(例如 JPA)可能两方面都处理不当。从最终结果分离 <code>read</code> 和 <code>write</code>，得到更容易维护、更灵活的模型。</li><li>分离也可以从数据存储上着手。<code>write</code>部分使用满足第三范式(3NF)的数据架构；<code>read</code>部分使用非规范型数据库用于优化得到更快速的<code>query</code>操作。</li></ul><blockquote><p>注意：<br>上图描述了CQRS在<code>read</code>和<code>write</code>使用了不同的数据存储，不是要求你使用不同的数据库。它仅仅描述CQRS这个模型，鼓励你分离读写部分。<br>上图建议<code>write</code>和<code>read</code>可能存在一一对应(one-to-one)关系，实际上没有必要要求建立这种关系。仅当你使用接口时，这种一一对应关系才明显。</p></blockquote><p>在实践和适应这种架构的同时，可能会潜在一系列问题：</p><ul><li>尽管单独<code>read</code>和<code>write</code>两个模型比起一个复合模型要简单，当业务量需求扩增时，整体的架构要比传统的方式要复杂。如何转移该复杂性？</li><li>在<code>read</code>和<code>write</code>两方面，如何传播数据的变更？</li><li>在<code>write</code>部分若发生延迟，如何传递到<code>read</code>部分？</li><li>CQRS的模型是什么？它能做什么？</li></ul><h3><span id="cqrs-and-ddd">CQRS and DDD</span></h3><p>领域驱动(Domain-Driven Design)设计理念要求有：</p><ul><li>Models should be bound to the implementation.</li><li>You should cultivate a language based on the model.</li><li>Models should be knowledge rich.</li><li>You should brainstorm and experiment to develop the model.</li></ul><p>当讨论在系统中实现CQRS，意味着你应该实现一个带有<code>bounded context</code>的CQRS模式。</p><p>在DDD，<code>bounded context</code>定义了一个模型的语义、通用语言(ubiquitous language)的作用域(scope)。实现CQRS模式理所当然带来了 scalability、simplicity、maintainability。因此，在讨论 <code>bounded context</code>时候，CQRS模式用于实现业务组件，DDD模式用于实现上下文边界(<code>bounded context</code>)。</p><blockquote><p>a business component can exist in only one bounded context.</p></blockquote><p>以前在DDD概念中，<code>bounded context</code>还没有一个比较明确的定位，术语<code>bounded context</code>和 <code>business component</code>表述的是同一个东西。引入CQRS模式后，术语<code>bounded context</code>优于<code>business component</code>使用。</p><p>总之，你<code>不应该</code>将CQRS模式用于系统的顶层设计。CQRS应该明确定义在系统中独立的、具有明显业务逻辑的功能。</p><h3><span id="commands-events-messages">Commands, Events, Messages</span></h3><p>DDD 属于一种分析和设计方法，它鼓励在使用<code>模型(models)</code>和<code>通用语言(ubiquitous language)</code>的基础上，使用领域的概念培养<strong>开发团队</strong>的共识， 构建<strong>业务</strong> 和 <strong>开发团队</strong>的桥接。必然地，DDD的方式面向分析行为，而不是业务领域中的数据，它导向于行为的建模和实现。较直接实现领域模型(domain model)的方式，就是使用<code>commands</code>和<code>events</code>。</p><ul><li><code>commands</code>是祈使句：它由系统发起处理一个任务或动作。命令通常处理一次。</li><li><code>events</code> 是通告(notifications)：告知某事已经发生。事件可以发生多次，被多处消费。</li></ul><p><code>commands</code>和<code>events</code>都属于<code>message</code>，都用于对象间数据交换。在DDD术语中，<code>message</code>表示业务行为，帮助系统捕获业务意图。</p><p>CQRS的一个可能的实现方式是分离<code>read</code>和<code>write</code>存储；每个数据存储被优化。<code>Event</code>提供了一个基本的机制用于异步<code>write</code>和<code>read</code>操作。当<code>write</code>部分发起一个事件表示应用状态变更，<code>read</code>部分响应该事件，并更新数据。下图为命令和事件在CQRS模式中的实现。</p><p><img src="/img/philosophy/cqrs/commands-events.png" alt="Commands and events in the CQRS Pattern"></p><h3><span id="为什么用cqrs">为什么用CQRS?</span></h3><p>回到DDD领域设计，CQRS适用于DDD的<code>bounded context</code>允许标识和专注于系统逻辑最为复杂部分的实现。CQRS仅仅是<code>bounded context</code>一个具体的实践，但不是唯一的模式。</p><p>对于业务逻辑带来以下几点好处：</p><h5><span id="scalability">Scalability</span></h5><p>在多数企业系统中，读操作远超过写操作，因此，读写操作的扩展要求是不一样的。在<code>bounded context</code>中分离<code>read</code>和<code>write</code>，成为单独的模型，可以单独扩展各自的功能。</p><p>另外，伸缩性并不是实现CQRS模式的唯一理由：在一个非协作领域，你可以水平地添加更多的数据库来支持更多用户、更多的请求。</p><h5><span id="reduced-complexity">Reduced complexity</span></h5><p>在领域的复杂区域，设计和实现对象，都会加剧复杂性。大多数情况下，复杂的业务逻辑仅仅在处理更新或事物处理上发生；相反，读的逻辑通常很简单。当读操作和其它业务逻辑混淆在相同的模型时，就变得难于处理问题，诸如多用户、共享数据、性能、事物、一致性、脏数据。因此要分离<code>read logic</code>和<code>business logic</code>到不同的模型中。然而，这种分离的代价是需要花费较大的努力，并且要求开发者自身对已有的模型有充足的理解。</p><p>分离职责是CQRS的核心动机，因为<code>query</code>会被用于非常多的场景、会被各处引用，每个修改都需要特别小心。如何设计一个复杂度更低的系统，正是<code>bounded context</code>的潜力所在，你可能需要TDD、refactor、或更多优秀的编码习惯来贯穿。</p><h5><span id="flexibility">Flexibility</span></h5><p>CQRS的灵活性，来源于<code>read-side</code>和<code>write-side</code>模型的扩展。<code>read-side</code>的扩展非常容易，因为读操作复杂度最低，并且不会受到业务逻辑的影响。对于<code>write-side</code>，它有单独的模型处理业务逻辑，模型相互独立，不依赖其它核心逻辑（从设计上来说，如果有依赖，要么设计有问题，要么面临重构）。</p><p>从长远来看，业务逻辑的灵活性直接与商业价值挂钩。它决定了你是否能够持续交付新功能、能否进行敏捷开发、能否满足同行的恶劣竞争。</p><p>灵活性和敏捷性与DDD的持续集成概念相关：</p><blockquote><p>“Continuous integration means that all work within the context is being merged and made consistent frequently enough that when splinters happen they are caught and corrected quickly.”<br>—Eric Evans, “Domain-Driven Design,” p342.</p></blockquote><h5><span id="focus-on-the-business">Focus on the business</span></h5><h5><span id="facilitates-building-task-based-uis">Facilitates building task-based UIs</span></h5><h3><span id="when-should-i-use-cqrs">When should I use CQRS?</span></h3><p>什么时候用CQRS？微服务。CQRS模式明显是用于<code>bounded context</code>中的。<code>bounded context</code>的另一个术语是<code>business components</code>。说白了就是我们要实现的服务，具体是什么服务？如何划分？服务之间的相互关系是怎样？这都属于<code>bounded context</code>中描述的内容。CQRS可能不是最好的，但它提供了 increased adaptability、flexibility、reduced maintenance costs各方面的优势。</p><h3><span id="collaborative-domains">Collaborative domains</span></h3><p>DDD概念需要解决的问题是如何描述有界上下文，开发者要与领域专家进行交流，就需要明确这个<code>bounded context</code>是什么。</p><p>CQRS参与了涉及复杂决定的协作过程——结果（产出）什么。这种协作往往是系统中最复杂、不固定、最需要关注的<code>bounded contexts</code>。</p><h3><span id="stale-data">Stale data</span></h3><p>在协作环境中，多个用户可能同时操作同一份数据，你将面临脏数据问题；如一个用户正在浏览数据，另一个用户在进行更改，那么第一个的用户看到的是脏数据。</p><p>前面两个举例是最常见的场景；大多数协作企业系统比这更多。CQRS从架构层面上解决脏数据的问题。我们切换到<code>write-side</code>，用户从<code>read-side</code>读取数据。无论用什么机制，将<code>write-side</code>的数据 <code>push</code>到<code>read-side</code>；<code>read-side</code>就以相同的机制操作数据。常见的机制就是<code>ES(Event sourcing)</code>。</p><p><img src="/img/philosophy/cqrs/event-sourcing.png" alt="Event Sourcing"></p><h3><span id="when-should-i-avoid-cqrs">When should I avoid CQRS?</span></h3><p>非协作的、简单的、静态的用于处理分析、建模之类的复杂实现<code>bounded contexts</code>。应该避免使用CQRS。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cqrs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA docker 插件使用</title>
      <link href="/2017/08/11/intellij/docker-compose-idea-plugin/"/>
      <url>/2017/08/11/intellij/docker-compose-idea-plugin/</url>
      
        <content type="html"><![CDATA[<h3><span id="安装升级你的docker客户端">安装／升级你的Docker客户端</span></h3><p>推荐安装1.6.0以上版本的Docker客户端。<br>您可以通过阿里云的镜像仓库下载：<a href="http://mirrors.aliyun.com/help/docker-engine">mirrors.aliyun.com/help/docker-engine</a><br>或执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure><span id="more"></span><p>如何使用Docker加速器<br>针对Docker客户端版本大于1.10的用户<br>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://ejburpg5.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125; EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3><span id="运行docker通过http管理api">运行Docker通过HTTP管理API</span></h3><p>编辑 <code>*/etc/init/docker.conf</code> 更新 <code>DOCKER_OPTS</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&#x27;-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&#x27;</span></span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>注意：如果重启依然没有生效，看看system启动中是否有引用该变量 /lib/systemd/system/docker.service , 里面增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentFile=-/etc/default/docker</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -d -H fd://</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -d -H fd:// $DOCKER_OPTS</span><br></pre></td></tr></table></figure><p>再次重启即可。</p><h3><span id="安装docker插件">安装docker插件</span></h3><p>在IDEA里面搜索docker integeration，安装即可。</p><ol><li>添加docker cloud</li></ol><p>setting &gt;&gt; cloud &gt;&gt; docker</p><p>填上上面配置的地址，如 <a href="http://localhost:2375">http://localhost:2375</a> 。certificates 留空不用填。</p><ol start="2"><li><p>所有配置通过将显示 Connection successful</p></li><li><p>运行时，需要在本机安装docker-compose，用于指定运行build。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2几种授权模式</title>
      <link href="/2017/08/04/auth-oauth2/oauth2-authentication-models/"/>
      <url>/2017/08/04/auth-oauth2/oauth2-authentication-models/</url>
      
        <content type="html"><![CDATA[<h3><span id="授权码模式">授权码模式</span></h3><p>授权码模式(authorization code)是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商“的认证服务器进行互动。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  +----------+</span><br><span class="line">  | Resource |</span><br><span class="line">  |   Owner  |</span><br><span class="line">  |          |</span><br><span class="line">  +----------+</span><br><span class="line">       ^</span><br><span class="line">       |</span><br><span class="line">      (B)</span><br><span class="line">  +----|-----+          Client Identifier      +---------------+</span><br><span class="line">  |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line">  |  User-   |                                 | Authorization |</span><br><span class="line">  |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line">  |          |                                 |               |</span><br><span class="line">  |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line">  +-|----|---+                                 +---------------+</span><br><span class="line">    |    |                                         ^      v</span><br><span class="line">   (A)  (C)                                        |      |</span><br><span class="line">    |    |                                         |      |</span><br><span class="line">    ^    v                                         |      |</span><br><span class="line">  +---------+                                      |      |</span><br><span class="line">  |         |&gt;---(D)-- Authorization Code ---------&#x27;      |</span><br><span class="line">  |  Client |          &amp; Redirection URI                  |</span><br><span class="line">  |         |                                             |</span><br><span class="line">  |         |&lt;---(E)----- Access Token -------------------&#x27;</span><br><span class="line">  +---------+       (w/ Optional Refresh Token)</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A), (B), and (C) are broken into</span><br><span class="line">two parts as they pass through the user-agent.</span><br><span class="line"></span><br><span class="line">                  Authorization Code Flow</span><br></pre></td></tr></table></figure><p>它的步骤如下：</p><p>(A): 用户访问客户端，后者将前者导向认证服务器。<br>(B): 用户选择是否给予客户端授权。<br>©: 假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI“(redirection URI)，同时附上一个授权码。<br>(D): 客户端收到授权码，附上早先的”重定向URI“，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。<br>(E): 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌(access_token)和更新令牌(refresh_token)。</p><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li><code>response_type</code>: 表示授权类型，必选项，此处的值固定为<code>code</code></li><li><code>client_id</code>: 表示客户端的ID，必选项</li><li><code>redirect_uri</code>: 表示重定向URI，可选</li><li><code>scope</code>: 表示申请的权限范围，可选项</li><li><code>state</code>: 表示客户端的当前状态，可以指任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li><code>code</code>: 表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li><code>state</code>: 如果客户端请求包含这个参数，认证服务器回应一模一样这个参数。</li></ul><p>下面是个例子。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>: 表示使用的授权模式，必选项，固定为<code>authorization_code</code>。</li><li><code>code</code>: 表示上一步获得的授权码，必选项。</li><li><code>redirect_uri</code>: 表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li><code>client_id</code>: 表示客户端ID，必选项。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li><code>access_token</code>: 表示访问令牌，必选项。</li><li><code>token_type</code>: 表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li><code>expires_in</code>: 表示过期时间，单位为秒。省略该参数，必须其它方式设置过期时间。</li><li><code>refresh_token</code>: 表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li><code>scope</code>: 表示权限范围，可选。</li></ul><p><img src="/img/auth/oauth2/authorization_code.png" alt="authorization code"></p><p>具体分三步：</p><ol><li>带领用户访问认证URL</li><li>通过<code>code</code> 获取 <code>access_token</code></li><li>使用此<code>access_token</code>可以获取用户账号、昵称、id、头像等信息。</li></ol><h4><span id="适用场景">适用场景：</span></h4><ol><li>某个网站想要获取你的个人信息；</li><li>被客户端网站重定向到授权网站；</li></ol><h3><span id="客户端模式">客户端模式</span></h3><p>客户端模式(Client Credentials Grant)指客户端以自己的名义，而不是用户的名义，向“服务提供商”进行认证。严格来说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户单以自己的名义要求“服务提供商“提供服务，其实不存在授权问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |                                  |               |</span><br><span class="line">|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(B)---- Access Token ---------&lt;|               |</span><br><span class="line">|         |                                  |               |</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line"></span><br><span class="line">                Client Credentials Flow</span><br></pre></td></tr></table></figure><p>这种客户端模式(Client Credentials Grant)必须仅被用于足够信任的”客户端提供商“所使用。</p><p>它的步骤如下：</p><p>(A)：客户端向认证服务器进行身份认证，并要求一个访问令牌。<br>(B)：认证服务器确认无误后，向客户端提供访问令牌。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>: 表示授权类型，固定为<code>client_credentials</code>，必须的。</li><li><code>scope</code>: 表示权限范围，可选项。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>认证服务器以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式明确告诉我们，认证的主体是客户端，我们对这种方式进行完善。</p><p><img src="/img/auth/oauth2/client_credentials.png" alt="client credentials"></p><ol><li>User首先在客户端平台进行一系列注册管理行为，得到当前用户相应的<code>client_id</code>、<code>client_secret</code>、<code>scope</code>。</li><li>此时，客户端(Client)相当于一个SDK或管理平台，客户端需要暴露一个向认证服务获取access_token的API，通过该API获取得到<code>access_token</code>。</li><li>客户端得到token后，带上该token访问对应的资源。</li></ol><h3><span id="简化模式">简化模式</span></h3><p>简化模式(implicit grant type)不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了&quot;授权码&quot;这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  +----------+</span><br><span class="line">  | Resource |</span><br><span class="line">  |  Owner   |</span><br><span class="line">  |          |</span><br><span class="line">  +----------+</span><br><span class="line">       ^</span><br><span class="line">       |</span><br><span class="line">      (B)</span><br><span class="line">  +----|-----+          Client Identifier     +---------------+</span><br><span class="line">  |         -+----(A)-- &amp; Redirection URI ---&gt;|               |</span><br><span class="line">  |  User-   |                                | Authorization |</span><br><span class="line">  |  Agent  -|----(B)-- User authenticates --&gt;|     Server    |</span><br><span class="line">  |          |                                |               |</span><br><span class="line">  |          |&lt;---(C)--- Redirection URI ----&lt;|               |</span><br><span class="line">  |          |          with Access Token     +---------------+</span><br><span class="line">  |          |            in Fragment</span><br><span class="line">  |          |                                +---------------+</span><br><span class="line">  |          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |</span><br><span class="line">  |          |          without Fragment      |     Client    |</span><br><span class="line">  |          |                                |    Resource   |</span><br><span class="line">  |     (F)  |&lt;---(E)------- Script ---------&lt;|               |</span><br><span class="line">  |          |                                +---------------+</span><br><span class="line">  +-|--------+</span><br><span class="line">    |    |</span><br><span class="line">   (A)  (G) Access Token</span><br><span class="line">    |    |</span><br><span class="line">    ^    v</span><br><span class="line">  +---------+</span><br><span class="line">  |         |</span><br><span class="line">  |  Client |</span><br><span class="line">  |         |</span><br><span class="line">  +---------+</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A) and (B) are broken into two</span><br><span class="line">parts as they pass through the user-agent.</span><br><span class="line"></span><br><span class="line">                    Implicit Grant Flow</span><br></pre></td></tr></table></figure><p>它的步骤如下：</p><p>(A) 客户端将用户导向认证服务器。<br>(B) 用户决定是否给于客户端授权。<br>© 假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向URI&quot;，并在URI的Hash部分包含了访问令牌。<br>(D) 浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。<br>(E) 资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。<br>(F) 浏览器执行上一步获得的脚本，提取出令牌。<br>(G) 浏览器将令牌发给客户端。</p><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>response_type</code>: 表示授权类型，此处的值固定为&quot;token&quot;，必选项。</li><li><code>client_id</code>: 表示客户端的ID，必选项。</li><li><code>redirect_uri</code>: 表示重定向的URI，可选项。</li><li><code>scope</code>: 表示权限范围，可选项。</li><li><code>state</code>: 表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">    Host: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li><code>access_token</code>: 表示访问令牌，必选项。</li><li><code>token_type</code>: 表示令牌类型，该值大小写不敏感，必选项。</li><li><code>expires_in</code>: 表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li><code>scope</code>: 表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li><code>state</code>: 如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。<br>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><p><img src="/img/auth/oauth2/implicit.png" alt="implicit"></p><p>该方式会暴露<code>access_token</code>，只有当其它方式不可用的情况下使用。</p><h3><span id="密码模式">密码模式</span></h3><p>密码模式(Resource Owner Password Credentials Grant)中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向&quot;服务商提供商&quot;索要授权。<br>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+----------+</span><br><span class="line">| Resource |</span><br><span class="line">|  Owner   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     v</span><br><span class="line">     |    Resource Owner</span><br><span class="line">    (A) Password Credentials</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |&gt;--(B)---- Resource Owner -------&gt;|               |</span><br><span class="line">|         |         Password Credentials     | Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(C)---- Access Token ---------&lt;|               |</span><br><span class="line">|         |    (w/ Optional Refresh Token)   |               |</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line"></span><br><span class="line">       Resource Owner Password Credentials Flow</span><br></pre></td></tr></table></figure><p>它的步骤如下：</p><p>(A) 用户向客户端提供用户名和密码。<br>(B) 客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>© 认证服务器确认无误后，向客户端提供访问令牌。</p><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li><code>grant_type</code>: 表示授权类型，此处的值固定为&quot;password&quot;，必选项。</li><li><code>username</code>: 表示用户名，必选项。</li><li><code>password</code>: 表示用户的密码，必选项。</li><li><code>scope</code>: 表示权限范围，可选项。</li></ul><p>下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/auth/oauth2/password.png" alt="password"></p>]]></content>
      
      
      <categories>
          
          <category> oauth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo fresh installation</title>
      <link href="/2017/07/31/linux/gentoo/gentoo-fresh-installation/"/>
      <url>/2017/07/31/linux/gentoo/gentoo-fresh-installation/</url>
      
        <content type="html"><![CDATA[<p>Gentoo fresh installation through Virtualbox and livecd.</p><p>Introduction:<br>Gentoo are very customizable distro compared to others such as ubuntu. You can go easymode and use ubuntu cause ubuntu is for people that dont know how to use or install gentoo. Gentoo is totally free from 3rd party application or commercial.</p><p>Note:<br>You better stick with Gentoo handbook until you know what you doing.<br>Learn from mistakes. Do it again until you familiar with your basic setting.</p><span id="more"></span><p>Part 1: Partitioning the HDD (This Virtual HDD is 40gb as example and we will be using gparted)</p><p>fdisk -lView HDD details<br>parted -a optimal /dev/sdaConfiguring HDD<br>mklabel gptMake label for HDD<br>unit MibThis will set metric unit<br>mkpart primary 1 3Creating grub partition (1 to 3 is HDD block unit count or ‘size’)<br>name 1 grubName it to ‘grub’<br>set 1 bios_grub onEnable the grub<br>mkpart primary 3 131Creating boot partition (3 to 131 is HDD block unit count or ‘size’)<br>name 2 bootName it to ‘boot’<br>mkpart primary 131 2179Creating swap partition (131 to 2179 is HDD block unit count or ‘size’)<br>name 3 swapSwap should be more than 1gb. We use 2gb (2048) as example<br>mkpart primary 2179 40000Creating root partition (2179 to 20000 is HDD block unit count or ‘size’)<br>name 4 rootfsName it to ‘rootfs’<br>set 2 boot onEnable the boot<br>quitQuit gparted</p><p>Part 2: File System and mount (You can use any filesystem, we just do it simple)</p><p>mkfs.vfat /dev/sda1<br>mkfs.ext2 -L “boot” /dev/sda2<br>mkswap -L “swap” /dev/sda3<br>swapon /dev/sda3<br>free -m<br>mkfs.ext4 -L “rootfs” /dev/sda4</p><p>mount /dev/sda4 /mnt/gentooRoot is on /dev/sda4<br>mkdir /mnt/gentoo/bootCreate boot directory<br>mount /dev/sda2 /mnt/gentoo/bootMounting boot partition</p><p>Part 3: Set the clock and downloading the stage tarball</p><p>date MMDDhhmmYYYYFormat is month - day - hour - minutes - year</p><p>cd /mnt/gentooGo into root directory<br>ping -c 3 <a href="http://gentoo.org">gentoo.org</a>Ping the address. I assume you got ur internet running or you will<br>need to figure it out by using ‘ifconfig’ or ‘net-setup’.<br>links <a href="http://www.gentoo.org/main/en/mirror.xml">www.gentoo.org/main/en/mirror.xml</a>Go to website and choose current stage 3 and download<br>tar xvjpf ‘stage3’ --xattrsUntar the compressed tarball</p><p>Part 4: Configuring the make.conf</p><p>nano -w /mnt/gentoo/etc/portage/make.confOpen the make.conf and edit few things below<br>CFLAGS=“-march=native -02 -pipe”March native will utilize CPU architecture<br>MAKEOPTS=“-j4”Set the number of ur CPU cores plus 1 or any value<br>USE=“python icu bindist mmx sse sse2”Set the basic USE flags.<br>ALSA_CARDS=“”Sound Cards. (ex, hda-intel) This are not necessary because new kernel version already know your alsa cards<br>VIDEO_CARDS=&quot; &quot;Video Cards. (ex, nvidia) Dont put anything yet<br>INPUT_DEVICES=&quot; &quot;Input Devices. (ex, keyboard) Dont put anything yet</p><p>Both VIDEO_CARDS and INPUT_DEVICES are better to be add after successful boot and @world merge to avoid conflict.</p><p>When done, press ‘Ctrl + X’ to save and press ‘Y’. And proceed to next step.</p><p>Part 5: CHROOTING (Change root) Selecting mirrors is not necessary because it already set by default. Just do the change root (chroot).</p><p>cp -L /etc/resolv.conf /mnt/gentoo/etc/<br>mount -t proc proc /mnt/gentoo/proc<br>mount --rbind /sys /mnt/gentoo/sys<br>mount --make-rslave /mnt/gentoo/sys<br>mount --rbind /dev /mnt/gentoo/dev<br>mount --make-rslave /mnt/gentoo/dev</p><p>chroot /mnt/gentoo /bin/bash<br>source /etc/profile<br>export PS1=“(chroot) $PS1”<br>emerge-webrsyncOr you can also ‘emerge --sync’ to sync all file</p><p>Selecting the right profile. This are important because it will pull all lib and package dependencies depend on what you want to use. KDE, Gnome, Xfce, Plasma, Hardened all have different USE Flags and libs dependencies.<br>eselect profile listSelect profile to use. We will be using desktop for example<br>eselect profile set XSet the Plasma desktop profile</p><p>Part 6: Timezone and Localization</p><p>ls /usr/share/zoneinfoView all zone list<br>ls /usr/share/zoneinfo/‘ur country’Choose country and state from list<br>echo “ur country/ur state” &gt; /etc/timezoneSave timezone info into /etc/timezone<br>emerge --config sys-libs/timezone-dataInstall timezone configuration</p><p>nano -w /etc/locale.genEdit locale.gen and set to ‘local’<br>locale-genGenerate locale<br>eselect locale listSelect appropriate locale<br>eselect locale set #Set locale</p><p>env-update &amp;&amp; source /etc/profile &amp;&amp; export PS1=“(chroot) $PS1”Update the environment</p><p>Note:<br>if occur SYNC setting found in make.conf. warning</p><p>comment <code>sync</code></p><p>vi /etc/portage/make.conf<br>GENTOO_MIRRORS=“<a href="http://ftp.iij.ad.jp/pub/linux/gentoo/">http://ftp.iij.ad.jp/pub/linux/gentoo/</a>”<br>SYNC=“rsync://rsync1.jp.gentoo.org/gentoo-portage”</p><p>mkdir /etc/portage/repos.conf<br>cp /usr/share/portage/config/repos.conf /etc/portage/repos.conf/gentoo.conf</p><p>Part 7: KERNEL and File system table (fstab)</p><p>emerge --ask --verbose sys-kernel/gentoo-sourcesThis will install gentoo sources kernel<br>emerge -av pciutils usbutilsInstall required tool to detect pci and usb<br>emerge genkernelInstall  kernel</p><p>nano -w /etc/fstabThere are few things need to be configure here to map your partitions</p><pre><code>/dev/sda2/bootext2noauto,noatime1 2/dev/sda4/ext4noatime0 1/dev/sda3noneswapsw0 0/dev/sr0/mnt/cdromiso9660noauto,user,ro0 0</code></pre><p>This file and drive order/names are very important so the kernel and modules can load properly and Dbus can start its process.<br>sr0 are cd/dvd drive and iso9660 is its default kernel module. Adding ‘user’ will allow user to mount cd/dvd<br>When all done, save the configuration press ‘Ctrl + X’ to save press ‘Y’. And proceed to next step.</p><p>genkernel --menuconfig allThis will open a GUI (Generated User Interface) kernel for customization<br>Add your hostname in General Setup. When you done, save it to .config<br>(by default name). Then exit. This will take a while to process.</p><p>emerge -av sys-kernel/linux-firmwareApply linux firmware</p><p>Part 8: Hostname and DHCP</p><p>nano -w /etc/conf.d/hostnameSet hostname for “localhost”<br>ifconfigView networking adapter and adapter name<br>emerge --ask --noreplace net-misc/netifrc<br>nano /etc/conf.d/netConfigure network adapter to use dhcp on boot. Make<br>sure adapter name is same from ifconfig<br>config_enp0s3=“dhcp”</p><p>cd /etc/init.d<br>ln -s net.lo net.enp0s3Prepares the adapter on boot<br>ls -lsaView (list) net.lo is redirected to net.enp0s3</p><p>nano -w /etc/hosts127.0.0.1 replace localhost</p><p>Part 9: Set root access and hardware clock</p><p>passwd passwordAny password<br>nano -w /etc/conf.d/hwclockSet UTC to local</p><p>Part 10: System tools</p><p>emerge -av app-admin/syslog-ng sys-process/cronie sys-apps/mlocateBasic app for admin</p><p>rc-update add syslog-ng default<br>rc-update add cronie default<br>rc-update add sshd default<br>emerge -av net-misc/dhcpcd</p><p>emerge -av sys-apps/iproute2 sys-apps/net-tools gentoolkitBasic network app (skip this, do it after Plasma desktop load if you need it)</p><p>Part 11: System Boot (Grub 2)</p><p>emerge -av sys-boot/grub<br>grub2-install /dev/sda<br>grub2-mkconfig -o /boot/grub/grub.cfg<br>exit</p><p>ls /mnt/gentoo<br>umount /mnt/gentoo<br>shutdown -P now</p><p>By now it should be boot and make sure to remove the livecd.</p><p>Part 12: Test Booting</p><p>login root<br>cd /<br>rm /stage3-*.tar.bz2</p><p>emerge -uvDNa worldThis will pull all libs and dependencies needed for the selected profile and also update all the package. This will takes hours depends on your CPU and internet.<br>It took more than 5 hours for me.</p><p>EXTRAS</p><p>Part 13: Installing Xorg.</p><p>Both VIDEO_CARDS and INPUT_DEVICES will need to be configured again with the appropriate cards and devices.<br>Depends on your cards, you might need to configure your kernel too because some nvidia provided driver conflicts with nouveu in kernel driver<br>I will use VIDEO_CARDS=“vesa intel fbdev” and INPUT_DEVICES=“evdev mouse keyboard” as test, because im building this Gentoo in virtual environment.<br>Add this In /etc/portage/make.conf</p><p>VIDEO_CARDS=“vesa intel fbdev”<br>INPUT_DEVICES=“evdev mouse keyboard”</p><p>When done, press ‘Ctrl + X’ to save and press ‘Y’.</p><p>emerge -av xorg-driversInstall the video cards<br>emerge -av xorg-server</p><p>After its done, you might need to do emerge twm and xterm, just to test if everything are working correctly.</p><p>emerge twm xterm</p><p>Then do, startx</p><p>If everything working as intended, you will get 3 white console. Now you can uninstall the twm and xterm.</p><p>emerge --unmerge twm xterm</p><p>Part 14: Adding Users</p><p>useradd -m -G users,wheel,audio,portage,usb,video -s /bin/bash <user><br>passwd <user></user></user></p><p>Part 15: Installing Desktop Environment (Plasma)</p><p>There are 2 main package for Plasma desktop,</p><ol><li>kde-plasma/plasma-metaEverything in Plasma will be installed</li><li>kde-plasma/plasma-desktopOnly few basic things for loading a plasma desktop<br>Just choose either 1 that you need. Then do, emerge.</li></ol><p>emerge app-portage/cpuinfo2cpuflags copy the tail after CPU_FLAGS_X86: to CPU_FLAGS_X86 of your make.conf</p><p>emerge -av kde-plasma/plasma-meta</p><p>You might as well want to install internet browser, file manager, and terminal emulator.</p><p>emerge -av kde-apps/konsole kde-apps/konqueror kde-apps/dolphin</p><p>Part 16: Configuring boot up and finalizing</p><p>nano /etc/env.d/90xsession<br>add a new line,<br>XSESSION=“KDE-4”</p><p>When done, press ‘Ctrl + X’ to save and press ‘Y’.</p><p>nano ~/.xinitrc<br>add a new line,<br>exec ck-launch-session dbus-launch --sh-syntax --exit-with-session startkde</p><p>When done, press ‘Ctrl + X’ to save and press ‘Y’.</p><p>nano /etc/conf.d/xdm<br>edit the line and add with sddm,<br>DISPLAYMANAGER=“sddm”</p><p>When done, press ‘Ctrl + X’ to save and press ‘Y’.</p><p>Add sddm to video group,<br>usermod -a -G video sddm</p><p>/etc/init.d/dbus statusCheck the dbus status<br>/etc/init.d/dbus start<br>rc-update add dbus default</p><p>/etc/init.d/consolekit statusCheck consolekit status<br>/etc/init.d/consolekit start<br>rc-update add consolekit default</p><p>rc-update add xdm default<br>/etc/init.d/xdm status</p><p>env-update &amp;&amp; source /etc/profile<br>/etc/init.d/xdm start</p><p>IF everything working and you follow this guide, it will load the Plasma login screen after you start the xdm. If it doesn’t something is wrong with your step.<br>Check everything back if it does. Your desktop will be flickering because it still have twm and xterm in the background, under the plasma. You can fix it by doing a reboot after login the plasma.</p><p>If it working, all good. You will get the same desktop as im currently using now.</p><p>Part 17: Installing ALSA (Advance Linux Sound Architecture), and Pulseaudio<br>By default, libs and packages needed for sound to working are already pulled in when merging the Plasma desktop. We just need to enable it.</p><p>/etc/init.d/alsasound statusCheck for sound card status<br>/etc/init.d/alsasound start<br>rc-update add alsasound bootSet alsasound to run at boot level<br>alsamixerAdjust the sound level<br>speaker-test -t wav -c 2Sound check</p><p>Add USE flags “alsa” and “pulseaudio” into /etc/portage/make.conf<br>emerge -av pavucontrolPulseaudio volume control. This are very useful application to manage your sound cards<br>speaker test -t wav -c 2</p><p>You should get to hear sound from speaker test. If you dont, open Pulseaudio volume control and select your sound cards and appropriate sound codec.<br>Don’t use “speaker-test -t wav -c 2” as a root access. Do speaker test as a normal user in another terminal. You will hear sound from the test.</p><p>env-update &amp;&amp; source /etc/profile</p><p>Dispatch-conf and etc-update are tools to help you fix your config files. It will give you an option for each to use the new file, use old file, or let you edit the two files together. If you have a new system that you didn’t customize, typically using the new file is easiest.</p><p>Part 18: Last check and booting.<br>Check everything again and tinkering around with desktop settings.</p><p>To fully optimize for browsing internet (Youtube), i recommend to install Firefox and also adobe flash</p><p>emerge -av firefox<br>emerge -av adobe</p><p>You need to mount cd/dvd rom (sr0) by yourself if you want to use the drive. Just like mounting a usb memory stick.</p><p>mkdir /mnt/cdrom<br>mount -t iso9660 /dev/sr0 /mnt/cdrom</p><p>mkdir /mnt/usb<br>mount /dev/sdb1 /mnt/usb</p><p><a href="https://gist.github.com/kidlj/f30e82c2c6f064990596">https://gist.github.com/kidlj/f30e82c2c6f064990596</a> font config</p><p>Any question, post in my channel. I’ll reply later.<br>I will upload the “Configuring WIFI” and “Installing Wine, Winetricks, 32bit Wineprefix, including Steam” in another video.</p>]]></content>
      
      
      
        <tags>
            
            <tag> gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>writing an api client with akka http</title>
      <link href="/2017/07/26/akka/http/writing-an-api-client-with-akka-http/"/>
      <url>/2017/07/26/akka/http/writing-an-api-client-with-akka-http/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.stockfighter.io/">Stockfighter</a> is a CTF (short for Capture the Flag) game that I first heard about at Microconf 2015, but haven’t gotten a chance to play up until very recently. I plan on posting more about my impressions of the game later, but very shortly: it is a series of programming challenges based on the concept of stock exchanges and ways to manipulate stock exchanges. Along with the web UI, a public json <a href="https://starfighter.readme.io/">API</a> is exposed as a mechanism for interacting with the game. There did not seem to be any Scala clients floating around, so I took this as a chance to play around with <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/index.html">akka-http</a>.</p><span id="more"></span><h3><span id="scaffolding">Scaffolding</span></h3><p>After some quick googling and reading of tutorials, it looked like the basic structure of an http client would be something like this:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stockfighter.client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model._</span><br><span class="line"><span class="keyword">import</span> akka.stream.<span class="type">ActorMaterializer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TradingApiClient</span>(<span class="params">apiKey: <span class="type">String</span></span>)(<span class="params">implicit val system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  <span class="comment">// def endpoint(): Response = &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A couple of things to note here. First off, <code>akka-http</code> is a part of the (increasingly pervasive) akka ecosystem, so obviously actors have to be involved. The tutorials either had the <code>ActorSystem</code> at the top level or had the client itself be an <code>Actor</code>, but I felt like a regular class would suffice so I compromised by passing the system in as a parameter with a default. The <code>ActorMaterializer</code> is completely new to me, since I am coming from <code>spray</code> ~1.1 and have missed out on a lot of the latest reactive-buzzwordy developments.</p><p>I’m still not sure I grok it completely, but my understanding is that akka-http is backed completely by reactive streams, which the client constructs as lazy descriptions of computations. When the computations are run, the <code>ActorMaterializer</code> spins up the actors to do the actual work. In any case, I thought about putting the Materializer in the constructor as well, but the fact that it takes an implicit <code>ActorSystem</code> as an argument makes it fairly awkward to have both <code>ActorSystem</code> and <code>ActorMaterializer</code> live as constructor params with defaults. I can think of a few ways to deal with this, but for a quickie client I decided to just in-line the materializer and move on.</p><h3><span id="making-a-request">Making a request</span></h3><p>The Stockfighter API ships with a heartbeat/status endpoint, i.e., “is the service up?” The endpoint lives at <a href="https://api.stockfighter.io/ob/api/heartbeat">https://api.stockfighter.io/ob/api/heartbeat</a> and returns a response in the following format:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This seemed like as good a starting point as any, in that it’s a fairly simple endpoint with a simple response type, but still complex enough to test a full request flow with some common functionality like serialization/deserialization.</p><p>As it turns out, it took a decent amount of time and a lot of reading to get to a basic implementation:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.http.scaladsl.<span class="type">Http</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model._</span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model.<span class="type">Uri</span>.<span class="type">Path</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl.&#123; <span class="type">Source</span>, <span class="type">Sink</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor boilerplate elided</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">HttpResponse</span>] = &#123;</span><br><span class="line">  <span class="comment">// Fancier DSL: `Path.singleSlash / &quot;ob&quot; / &quot;api&quot; / &quot;heartbeat&quot;`</span></span><br><span class="line">  <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">&quot;/ob/api/heartbeat&quot;</span>))))</span><br><span class="line">  <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">&quot;api.stockfighter.io&quot;</span>)</span><br><span class="line"></span><br><span class="line">  source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executive summary: <code>akka-http</code> leverages the concept of reactive streams that seems to be the new hot thing lately. Streams are essentially fancied up functions, and consist of three parts: the <code>Source</code>, the <code>Flow</code>, and the <code>Sink</code>. The <code>Source</code> describes the input, which can be single element (<code>Source.single</code>), an iterator (<code>Source.iterator</code>), a Future (<code>Source.fromFuture</code>), etc. The <code>Flow</code> is the description of a computation to run on the data from the <code>Source</code>. The <code>Sink</code> describes what to do with data after it has been run through the flow: push it into a <code>queue</code> (<code>Sink.queue[T]</code>), <code>fold</code> over it (<code>Sink.fold</code>), and so on. You can combine things in all sorts of different ways–the above uses <code>via</code> and <code>runWith</code>, but there’s also <code>viaMat</code>, <code>run</code>, and any number of other fancy combinators.</p><p>What it boils down to here is that the <code>Source</code> is an http request, the <code>Flow</code> describes how to send that request, and <code>runWith(Sink.head)</code> runs the flow and returns a future of the response. Phew…</p><h3><span id="serializationdeserialization">Serialization/Deserialization</span></h3><p>For serialization/deserialization, <code>akka-http</code> provides its own <code>Marshal/Unmarshal</code>. For json, the default option is to lean on <code>akka-http</code>’s predecessor, <code>spray</code>–Or more specifically, <code>spray-json</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADT describing the response</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatus</span>(<span class="params">ok: <span class="type">Boolean</span>, error: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spray.json._</span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.marshallers.sprayjson.<span class="type">SprayJsonSupport</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TradingApiSerialization</span> <span class="keyword">extends</span> <span class="title">SprayJsonSupport</span> </span>&#123;</span><br><span class="line">  <span class="comment">// One of the built-in spray-json auto-formatters</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ApiStatusFormat</span> = jsonFormat2(<span class="type">ApiStatus</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Previous imports elided</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.unmarshalling.<span class="type">Unmarshal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// N.B. mixing in TradingApiSerialization to get the automatic conversions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TradingApiClient</span>(<span class="params">apiKey: <span class="type">String</span></span>)(<span class="params">implicit val system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(</span>)) <span class="keyword">extends</span> <span class="title">TradingApiSerialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">ApiStatus</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">&quot;/ob/api/heartbeat&quot;</span>))))</span><br><span class="line">    <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">&quot;api.stockfighter.io&quot;</span>).mapAsync(<span class="number">1</span>) &#123; r =&gt;</span><br><span class="line">      <span class="type">Unmarshal</span>(r.entity).to[<span class="type">ApiStatus</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The Serialization trait is normal procedure for <code>spray-json</code>, and the <code>SprayJsonSupport</code> provided by <code>akka-http</code> just provides an implicit conversion that links the <code>Unmarshal(r.entity)</code> together with the <code>jsonFormat</code> for the entity. The big wart here is actually the <code>mapAsync(parallelism = 1)</code>, which is a result of <code>Unmarshall(...).to[T]</code> returning a <code>Future[T]</code>. I didn’t dig too deeply into this, but based on some quick googling the general consensus seems to be that the use of <code>Future</code> here is a way of handling lazy/streaming responses. Whatever the case, I could not find an alternative API for this so <code>mapAsync(1)</code> seemed to be the least of the evils–another choice would have been something like <code>.map &#123; r =&gt; Await.result(Unmarshal(r.entity).to[ApiStatus], Duration.Inf) &#125;</code> but that seems even clunkier.</p><h3><span id="error-handling">Error handling</span></h3><p>The above code still has the flaw that if the server responds with e.g. 404, it will throw an exception and the client will be SOL. This is not so much an issue for the heartbeat endpoint, but Stockfighter is nice enough to enumerate a bunch of its common errors for us so why not add in some minimal handling via <a href="http://danielwestheide.com/blog/2013/01/02/the-neophytes-guide-to-scala-part-7-the-either-type.html">Either</a>?</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type alias for readability&#x27;s sake</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">TradingApiResult</span>[<span class="type">T</span>] </span>= <span class="type">Either</span>[<span class="type">ApiError</span>, <span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFound</span>(<span class="params">error: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Unauthorized</span>(<span class="params">error: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UnexpectedStatusCode</span>(<span class="params">status: <span class="type">StatusCode</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.unmarshalling.&#123; <span class="type">Unmarshal</span>, <span class="type">Unmarshaller</span> &#125;</span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model.<span class="type">StatusCodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor/etc elided</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `um` is provided by the previously mentioned `SprayJsonSupport`</span></span><br><span class="line"><span class="comment">// This is a prevalent theme in akka-related code: IMPLICITS, IMPLICITS EVERYWHERE.  Fun fact: this also requires</span></span><br><span class="line"><span class="comment">// an implicit ActorSystem and ActorMaterializer floating around!</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span></span>[<span class="type">T</span>](r: <span class="type">HttpResponse</span>)(<span class="keyword">implicit</span> um: <span class="type">Unmarshaller</span>[<span class="type">ResponseEntity</span>, <span class="type">T</span>]): <span class="type">Future</span>[<span class="type">TradingApiResult</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  r.status <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">OK</span> =&gt; <span class="type">Unmarshal</span>(r.entity).to[<span class="type">T</span>] map <span class="type">Right</span>.apply</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">Unauthorized</span> =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">Unauthorized</span>(r.entity.toString)))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">NotFound</span> =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">NotFound</span>(r.entity.toString)))</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">UnexpectedStatusCode</span>(r.status)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use it in the API call!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">TradingApiResult</span>[<span class="type">ApiStatus</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">&quot;/ob/api/heartbeat&quot;</span>))))</span><br><span class="line">  <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">&quot;api.stockfighter.io&quot;</span>).mapAsync(<span class="number">1</span>) &#123; r =&gt;</span><br><span class="line">    deserialize[<span class="type">ApiStatus</span>](r)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat for rest of the endpoints</span></span><br></pre></td></tr></table></figure><p><code>apiIsUp</code> should now return an <code>Either[ApiError, ApiStatus]</code> unless something really bad (dare I say, exceptional?) happens.</p><h3><span id="todos">TODOs</span></h3><p>The above is a nice start, but a few big TODOs stand out to me before I go on and toss this onto github.</p><p>First and foremost… Tests! Testing libraries like this is always tricky since they’re essentially all integration-y glue code, but I have always been a big fan of the <a href="https://github.com/vcr/vcr">vcr</a> gem in Ruby. As far as I know the closest thing in Scala is <a href="https://github.com/betamaxteam/betamax">betamax</a>, which I have not used but would like to. (I know, I know–Not writing test firsts? What about TDD? BAD DEVELOPER! <em>rolls up newspaper</em>)</p><p>Another big thing for me is domain modeling. The built-in json deserialization is fine for working with row-level data, but the plain case class format leaves a bit to be desired as far as robust data modeling. As a simple example:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simplistic &quot;order request&quot;</span></span><br><span class="line">&#123; price: <span class="number">0</span>, qty: <span class="number">0</span>, direction: <span class="string">&quot;buy&quot;</span> &#125; <span class="comment">// &quot;buy&quot; or &quot;sell&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive translation:</span></span><br><span class="line"><span class="type">OrderRequest</span>(price: <span class="type">Int</span>, qty: <span class="type">Int</span>, direction: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferable:</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderDirection</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Buy</span> <span class="keyword">extends</span> <span class="title">OrderDirection</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Sell</span> <span class="keyword">extends</span> <span class="title">OrderDirection</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">BetterOrderRequest</span>(price: <span class="type">Int</span>, qty: <span class="type">Int</span>, direction: <span class="type">OrderDirection</span>)</span><br></pre></td></tr></table></figure><p>I haven’t decided whether it would be better to add another step to the pipeline (e.g., <code>mapJsonToDomainObject</code>) or to roll custom spray <code>JsonFormat</code>s to do this.</p><p>Lastly: websockets. In <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/client-side/websocket-support.html">theory</a> websockets are supported, but the documentation is even sparser than for http clients and I haven’t quite figured it out yet–especially since the deserialization provided in <code>SprayJsonSupport</code> does not seem to work with the types used in the websocket API.</p><h3><span id="overall-impressions">Overall Impressions</span></h3><p>So far, my impression of <code>akka-http</code> is by and large the same as my impression of <code>spray</code>. Actors (and now reactive streams) provide a lot of power and performance in exchange for non-trivial complexity. In my experience this tradeoff is generally worth it for server-side/business application code, but lugging around an ActorSystem/etc ends up feeling very clunky for a simple http client. It doesn’t help that the -client libraries seem to be the red-headed step-children of both ecosystems.</p><p>The documentation feels consistent with the general API design. That is: it tries to look simple for the most basic use-cases, but in reality there is a lot of implicit stuff floating around. It was basically a pre-requisite for me to go digging for not only how streams worked conceptually but all the varied APIs that need to be used to link everything together before I could unpack the examples in the client tutorials. For example, while playing with the <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/client-side/websocket-support.html">websocket</a> tutorial I tried to switch the <code>Sink.foreach</code> with a <code>Sink.queue</code> and got the following:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[error] (...)/<span class="type">TradingApiClient</span>.scala:<span class="number">118</span>: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line">[error]  found:</span><br><span class="line">akka.stream.scaladsl.<span class="type">Sink</span>[<span class="type">Nothing</span>,akka.stream.scaladsl.<span class="type">SinkQueue</span>[<span class="type">Nothing</span>]]</span><br><span class="line">[error]  required:</span><br><span class="line">akka.stream.<span class="type">Graph</span>[akka.stream.<span class="type">SinkShape</span>[akka.http.scaladsl.model.ws.<span class="type">Message</span>],akka.stream.scaladsl.<span class="type">SinkQueue</span>[akka.http.scaladsl.model.ws.<span class="type">Message</span>]]</span><br><span class="line">[error]     outgoing.via(webSocketFlow).runWith(<span class="type">Sink</span>.queue)</span><br></pre></td></tr></table></figure><p>It’s not the end of the world as I worked out the need for a type parameter (i.e., <code>Sink.queue[Message]</code>) but there a lot of examples like this where the errors and tutorials are not exactly intuitive. I can see this being a huge deterrent to folks who are new to the ecosystem, to the concepts, or to Scala in general who will hit a wall and think, “Wow, all this and I can’t even open up a websocket/execute a json <code>POST</code>/etc?” Or even worse–the example code will be cargo-culted in by a harried developer on a deadline and carried on as the software version of the <a href="http://c2.com/cgi/wiki?TheFiveMonkeys">five monkeys</a>. (This is not to say I could do any better. Documentation and API design are some of the most underrated hard problems in software today, IMO. 😃</p><p>All my nitpicking aside, there is a lot to like about <code>akka-http</code>. In exchange for all the effort involved in learning about reactive streams and how to work with them, they provide a nice construct for abstracting away concerns like back-pressure management. This frees up developers to concentrate on the actual flow of the data. The resulting code is also quite clean and generally easy to follow, despite the time it took to actually get to that point. In other words, it trades off learning curve and ease of intuition for API comprehensiveness and composability. <code>akka-http</code> is especially nice on the server, where performance is a bigger concern. I’ve built a couple of internal webservices with <code>spray</code> previously, and it’s always been fairly performant without excessive tuning on my part. In addition, I’ve found the concept of Directives and the server-side routing DSL to be quite nice to work with in the past.</p><p>Overall I would recommend <code>akka-http</code> unreservedly for writing web services and business applications. My experience with it on the server side has been quite good. I would also use it again on the client side, mostly because there don’t seem to be any better options. I had looked into some alternatives, but e.g. play-ws has the same overloaded baggage problem and dispatch is like the poster-child of unintelligible symbolic operators (and seems unmaintained to boot). So until a better http client surfaces in the Scala ecosystem, one could do a lot worse.</p>]]></content>
      
      
      <categories>
          
          <category> akka-http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo 快速安装</title>
      <link href="/2017/07/26/linux/gentoo/gentoo-install-guide/"/>
      <url>/2017/07/26/linux/gentoo/gentoo-install-guide/</url>
      
        <content type="html"><![CDATA[<p>前置工作，下载mini安装镜像，检查网络、硬件设备信息、SSH连接…</p><span id="more"></span><h3><span id="分区">分区</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure><p>分区命令比较多，自己选一种即可。一般简单可分3个</p><ul><li><code>dev/sda1</code> boot引导，一般不超过1G</li><li><code>dev/sda2</code> 交换分区，一般为内存的一半大小</li><li><code>dev/sda3</code> 系统逻辑区，也可以根据个人喜好，分<code>home</code>、<code>usr</code>区</li></ul><h3><span id="格式化盘区">格式化盘区</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext2 /dev/sda1 &amp;&amp; mkfs.ext4 /dev/sda3 &amp;&amp; mkswap /dev/sda2</span><br></pre></td></tr></table></figure><h3><span id="挂载">挂载</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt/gentoo</span><br><span class="line">mkdir /mnt/gentoo/boot</span><br><span class="line">mount /dev/sda1 /mnt/gentoo/boot</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure><h3><span id="基础环境stage">基础环境Stage</span></h3><p>stage是什么？stage实际上是一个<code>tarball</code>（压缩文件、打包工具），因为挂载的/mnt/gentoo里面什么都没有，你需要下载一个根文件系统，里面包含有 <code>/bin</code>、<code>/root</code>。。。 这些内容。至于为什么有stage1、stage2、stage3、stage4，实际上是不同的标准，可以从官网上了解。</p><p>调整同步时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date MMDDhhmmYYY</span><br></pre></td></tr></table></figure><p>下载相应的二进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/gentoo</span><br><span class="line">links http://www.gentoo.org/main/en/mirrors.xml</span><br></pre></td></tr></table></figure><p>解压到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvjpf stage3-*.tar.bz2</span><br></pre></td></tr></table></figure><p>解压完成后，移除该包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm stage3-*.tar.bz2</span><br></pre></td></tr></table></figure><h3><span id="配置">配置</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /mnt/gentoo/etc/portage/make.conf</span><br></pre></td></tr></table></figure><p>选择镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/portage/make.conf</span><br><span class="line">mirrorselect -i -r -o &gt;&gt; /mnt/gentoo/etc/portage/make.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano /mnt/gentoo/etc/portage/make.conf</span><br><span class="line">cp -L /etc/resolv.conf /mnt/gentoo/etc/</span><br></pre></td></tr></table></figure><h3><span id="安装">安装</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc /proc /mnt/gentoo/proc</span><br><span class="line">mount --rbind /sys /mnt/gentoo/sys</span><br><span class="line">mount --rbind /dev /mnt/gentoo/dev</span><br></pre></td></tr></table></figure><p>切换到挂载系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/gentoo /bin/bash</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;(chroot) <span class="variable">$PS1</span>&quot;</span></span><br></pre></td></tr></table></figure><p>下载最新的portage snapshot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/portage</span><br><span class="line">emerge-webrsync</span><br></pre></td></tr></table></figure><p>或者直接下载后解压到 <code>/usr/portage</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links http://www.gentoo.org/main/en/mirrors.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvjpf portage-*.tar.bz2 -C /usr/portage</span><br></pre></td></tr></table></figure><h3><span id="环境设置">环境设置</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eselect profile list</span><br><span class="line">eselect profile <span class="built_in">set</span> 6   <span class="comment">## For KDE</span></span><br></pre></td></tr></table></figure><h3><span id="时区">时区</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/share/zoneinfo</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/locale.gen</span><br><span class="line">locale-gen</span><br><span class="line">env-update &amp;&amp; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3><span id="安装linux内核">安装linux内核</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emerge gentoo-sources</span><br><span class="line">ls -l /usr/src/linux</span><br></pre></td></tr></table></figure><p>编译内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emerge genkernel</span><br><span class="line">genkernel all</span><br></pre></td></tr></table></figure><h3><span id="其它一些配置">其它一些配置</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/fstab</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/conf.d/hostanme</span><br><span class="line">nano /etc/hosts</span><br></pre></td></tr></table></figure><p>网络连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emerge dhcpcd </span><br><span class="line">rc-update add dhcpcd default</span><br></pre></td></tr></table></figure><p>一些有用的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emerge virtual/ssh</span><br><span class="line">emerge syslog-ng</span><br><span class="line">emerge cronie</span><br><span class="line">emerge mlocate</span><br><span class="line">rc-update add sshd default</span><br><span class="line">rc-update add syslog-ng default</span><br><span class="line">rc-update add cronie default</span><br></pre></td></tr></table></figure><p>检查系统服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano -w /etc/rc.conf</span><br><span class="line">nano -w /etc/conf.d/keymaps</span><br><span class="line">nano -w /etc/conf.d/hwclock</span><br></pre></td></tr></table></figure><p>添加用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passwd </span><br><span class="line">useradd -m -G users,wheel,audio,lp,cdrom,portage,cron -s /bin/bash caezsar</span><br><span class="line">passwd caezsar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emerge sudo</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/sudoers</span><br></pre></td></tr></table></figure><h3><span id="安装系统引导">安装系统引导</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emerge sys-boot/grub</span><br><span class="line">grub2-install /dev/sda</span><br><span class="line">grub2-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h3><span id="卸载">卸载</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line">umount -l /mnt/gentoo/dev&#123;/shm,/pts,&#125;</span><br><span class="line">umount -l /mnt/gentoo&#123;/boot,/proc,&#125;</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启即可！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka Streaming学习</title>
      <link href="/2017/05/26/akka/streaming/akka-streams-learning/"/>
      <url>/2017/05/26/akka/streaming/akka-streams-learning/</url>
      
        <content type="html"><![CDATA[<p>时至今日，我们从因特尔上消遣服务包含许多流媒体数据(streaming data)，包括下载、上传、点对点的数据传送。把数据整体看做是一个元素集合的流(a stream of elements)，对我们计算机发送和接收这些数据起了很大帮助，因为数据变得越来越庞大，以“流”的方式处理数据显得很有必要。</p><p>Actors看起来也可以处理“流”：它们顺序地接收一系列消息，并对消息进行传输。但我们发现，在actor之间要实现一个stable streaming，会显得冗余乏味(tedious)和易出错(error-prone)，因为在处理发送(sending)和接收(receiving)时，我们还需要担心buffer溢出或邮箱溢出问题。另外一个陷阱(pitfall)是，Actor的消息会丢失，对丢失的消息要进行转发，以免stream一直停留在receiving的那一方。当处理完streams，Actor不能担保不会有连接(wiring)错误的出现。</p><span id="more"></span><p>基于这些原因，Akka Stream API便被提出。目的是提供一个直观的、安全的方式来**定制(formulate)**流处理，使我们在资源限制使用的情况(即控制内存溢出的情况)下高效处理。那么如何实现？akka stream实现了一个有 “back-pressure” 的特性，它来源于 <a href="http://reactive-streams.org/">Reactive Streams</a> ，akka是该规范的初始成员。</p><p>Reactive Streams规范实现只有4个接口：</p><p>Publisher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subscriber</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subscription</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Processor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该协议的主要目标是实现 <code>back-pressure</code>、<code>async</code>、<code>non-blocking boundaries and interoperability</code>。</p><ul><li><code>back-pressure</code>：反作用力，具体实现细节为，<code>Publisher</code>实现了一个<code>subscribe</code>方法，意思是，Publisher发布者拥有对Subscriber订阅的功能，所以Publisher本身也是个Subscriber，只是它仅能对唯一一个对象进行订阅——Subscriber。反作用力体现在，<code>Publisher</code>可以由该方法，得知<code>Subscriber</code>的订阅能力，由此控制“订阅”的“速度”，不会超出“发布”的速度很多，以此控制避免内存溢出等问题。</li><li><code>async</code>：异步。可以看到这4个接口的方法都没有返回值，所以这些方法实现以非阻塞方式控制，实现对流的异步操作处理。</li><li><code>non-blocking</code>：非阻塞。<code>Subscriber</code>除了<code>onSubscribe</code>外，包含有<code>onNext</code>方法，当一个Element处理完成(异步方式)，调用<code>onNext</code>方法，处理下一个Element，不会阻塞整个操作(出现异常或错误，具体看代码实现细节，akka stream对错误处理为supervision strategy方式，删除出错的element，继续处理下一个onNext，参考kafka设计)。</li></ul><h2><span id="快速开始">快速开始</span></h2><ul><li>Source: something with exactly one output stream</li><li>Sink: something with exactly one input stream</li><li>Flow: something with exactly one input and one output stream</li><li>BidiFlow: something with exactly two input streams and two output streams that conceptually behave like two Flows of opposite direction</li><li>Graph: a packaged stream processing topology that exposes a certain set of input and output ports, characterized by an object of type Shape.</li></ul><p>一个stream通常以一个source开始，我们需要引入相应的包</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.stream._</span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl._</span><br></pre></td></tr></table></figure><p>另外还需引入常用的执行关联包</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.&#123; <span class="type">NotUsed</span>, <span class="type">Done</span> &#125;</span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> java.nio.file.<span class="type">Paths</span></span><br></pre></td></tr></table></figure><p>以及Main方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最简单的<code>Source</code>，包含1 to 100整数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> source: <span class="type">Source</span>[<span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Source</span>(<span class="number">1</span> to <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>其中<code>Source</code>参数化两个类型：第一个是<code>Int</code>为该source 发射元素的类型，第二个为运行该source可能产生的 <code>辅助值(auxiliary value)</code>(如网络source会得到端口号或地址)，由<code>Sources</code>和<code>Sinks</code>运行后产生的auxiliary value，术语上被称作<code>materialized value</code>。不产生辅助信息时，用<code>akka.NotUsed</code>表示——这里例子的整型肯定不会产生辅助信息。</p><p>创建了source，我们便可以发射这100个自然数，但<code>Source</code>没有激活。因此我们需要执行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.runForeach(i =&gt; println(i))(materializer)</span><br></pre></td></tr></table></figure><p>这行执行在一个consumer 函数完成——以包含“run”的方法名执行；包含其它类似的方法。</p><p>在App执行该代码时，程序并没有终止退出，因为<code>ActorSystem</code>没有终止。<code>runForeach</code>返回一个<code>Future[Done]</code>表示stream完成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> done: <span class="type">Future</span>[<span class="type">Done</span>] = source.runForeach(i =&gt; println(i))(materializer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = system.dispatcher</span><br><span class="line">done.onComplete(_ =&gt; system.terminate())</span><br></pre></td></tr></table></figure><p>我们想知道<code>materializer</code>表示什么。首先我们要创建一个Actor system</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;QuickStart&quot;</span>)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br></pre></td></tr></table></figure><p>你也可以通过<code>ActorContext</code>来创建。<code>Materializer</code>是stream执行引擎的一个工厂，它使得streams可以执行——你现在不需要了解它的更多细节，仅需要知道你可以调用<code>Source</code>的<code>run*</code>方法。物化(materializer)实际上就是将<code>Source</code>、<code>Sink</code>、<code>Flow</code>构建起来的蓝图(blueprint)提供可执行实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> factorials = source.scan(<span class="type">BigInt</span>(<span class="number">1</span>))((acc, next) =&gt; acc * next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Future</span>[<span class="type">IOResult</span>] =</span><br><span class="line">  factorials</span><br><span class="line">    .map(num =&gt; <span class="type">ByteString</span>(<span class="string">s&quot;<span class="subst">$num</span>\n&quot;</span>))</span><br><span class="line">    .runWith(<span class="type">FileIO</span>.toPath(<span class="type">Paths</span>.get(<span class="string">&quot;factorials.txt&quot;</span>)))</span><br></pre></td></tr></table></figure><p>我们要时刻记住，<code>Source</code>内部实际上不会进行任何计算处理，它仅仅是一个描述(description)，当 run* 方法是计算它内部描述的内容。</p><p>在Akka Streams的术语中<code>Source</code>表示整个stream的输入，<code>Sink</code>表示整个stream的输出。在Akka Stream结构中，<code>Source</code>仅有一个output channel不包含input channel，<code>Sink</code>则刚好相反，包含一个input channel，不包含output channel。</p><p>下面是另外一个参考例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.<span class="type">NotUsed</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.<span class="type">ActorMaterializer</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">handle: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtag</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span>(<span class="params">author: <span class="type">Author</span>, timestamp: <span class="type">Long</span>, body: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hashtags</span></span>: <span class="type">Set</span>[<span class="type">Hashtag</span>] =</span><br><span class="line">    body.split(<span class="string">&quot; &quot;</span>).collect &#123; <span class="keyword">case</span> t <span class="keyword">if</span> t.startsWith(<span class="string">&quot;#&quot;</span>) =&gt; <span class="type">Hashtag</span>(t) &#125;.toSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> akkaTag = <span class="type">Hashtag</span>(<span class="string">&quot;#akka&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tweets: <span class="type">Source</span>[<span class="type">Tweet</span>, <span class="type">NotUsed</span>] = <span class="type">Source</span>(</span><br><span class="line">  <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;rolandkuhn&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka rocks!&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;patriknw&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka !&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;bantonsson&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka !&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;drewhk&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka !&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;ktosopl&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka on the rocks!&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;mmartynas&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;wow #akka !&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;akkateam&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#akka rocks!&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;bananaman&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#bananas rock!&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;appleman&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;#apples rock!&quot;</span>) ::</span><br><span class="line">    <span class="type">Tweet</span>(<span class="type">Author</span>(<span class="string">&quot;drama&quot;</span>), <span class="type">System</span>.currentTimeMillis, <span class="string">&quot;we compared #apples to #oranges!&quot;</span>) ::</span><br><span class="line">    <span class="type">Nil</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;reactive-tweets&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line"></span><br><span class="line">  tweets</span><br><span class="line">    .filterNot(_.hashtags.contains(akkaTag))</span><br><span class="line">    .mapConcat(_.hashtags)</span><br><span class="line">    .map(_.name.toUpperCase)</span><br><span class="line">    .runWith(<span class="type">Sink</span>.foreach(println))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $FiddleDependency org.akka-js %%% akkajsactorstream % 1.2.5.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="片段重用">片段重用</span></h2><p>Akka Streams中所有模块都可以实现resuable，例如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lineSink</span></span>(filename: <span class="type">String</span>): <span class="type">Sink</span>[<span class="type">String</span>, <span class="type">Future</span>[<span class="type">IOResult</span>]] =</span><br><span class="line">  <span class="type">Flow</span>[<span class="type">String</span>]</span><br><span class="line">    .map(s =&gt; <span class="type">ByteString</span>(s + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">    .toMat(<span class="type">FileIO</span>.toPath(<span class="type">Paths</span>.get(filename)))(<span class="type">Keep</span>.right)</span><br></pre></td></tr></table></figure><p>链接<code>Source</code>和<code>Flow</code>后得到的auxiliary information就是“materialized value”，我们可以直接将新创建的<code>Sink</code>贴到我们的<code>factorials</code> source上</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorials.map(_.toString).runWith(lineSink(<span class="string">&quot;factorial2.txt&quot;</span>))</span><br></pre></td></tr></table></figure><h2><span id="基于时间处理">基于时间处理</span></h2><p>现在我们通过zip实现将两个source转换为一个stream</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factorials</span><br><span class="line">  .zipWith(<span class="type">Source</span>(<span class="number">0</span> to <span class="number">100</span>))((num, idx) =&gt; <span class="string">s&quot;<span class="subst">$idx</span>! = <span class="subst">$num</span>&quot;</span>)</span><br><span class="line">  .throttle(<span class="number">1</span>, <span class="number">1.</span>second, <span class="number">1</span>, <span class="type">ThrottleMode</span>.shaping)</span><br><span class="line">  .runForeach(println)</span><br></pre></td></tr></table></figure><p>这段代码依赖于时间执行，我们使用<code>throttle</code>来协调stream的速率(每1秒钟，传输一个元素)，以此保证，即使是百万级以上的数据，也不会出现JVM内存溢出的情况。这里的<code>throttle</code>在Akka Streams被称作 combinators——协调器，Akka Streams中所有 combinators 都遵循back-pressure设计实现。</p><h2><span id="reactive-tweets">Reactive Tweets</span></h2><p>下面是一个例子，对非结构化数据的处理</p><p>首先定义我们的case class</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">handle: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtag</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span>(<span class="params">author: <span class="type">Author</span>, timestamp: <span class="type">Long</span>, body: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hashtags</span></span>: <span class="type">Set</span>[<span class="type">Hashtag</span>] =</span><br><span class="line">    body.split(<span class="string">&quot; &quot;</span>).collect &#123; <span class="keyword">case</span> t <span class="keyword">if</span> t.startsWith(<span class="string">&quot;#&quot;</span>) =&gt; <span class="type">Hashtag</span>(t) &#125;.toSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> akkaTag = <span class="type">Hashtag</span>(<span class="string">&quot;#akka&quot;</span>)</span><br></pre></td></tr></table></figure><p>引入隐式运行变量</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;reactive-tweets&quot;</span>)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br></pre></td></tr></table></figure><p>创建<code>Source</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tweets: <span class="type">Source</span>[<span class="type">Tweet</span>, <span class="type">NotUsed</span>]</span><br></pre></td></tr></table></figure><p>重用<code>Source</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> authors: <span class="type">Source</span>[<span class="type">Author</span>, <span class="type">NotUsed</span>] =</span><br><span class="line">  tweets</span><br><span class="line">    .filter(_.hashtags.contains(akkaTag))</span><br><span class="line">    .map(_.author)</span><br></pre></td></tr></table></figure><p>物化(materializer)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authors.runWith(<span class="type">Sink</span>.foreach(println))</span><br></pre></td></tr></table></figure><h2><span id="flow处理">Flow处理</span></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count: <span class="type">Flow</span>[<span class="type">Tweet</span>, <span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Flow</span>[<span class="type">Tweet</span>].map(_ =&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sumSink: <span class="type">Sink</span>[<span class="type">Int</span>, <span class="type">Future</span>[<span class="type">Int</span>]] = <span class="type">Sink</span>.fold[<span class="type">Int</span>, <span class="type">Int</span>](<span class="number">0</span>)(_ + _)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counterGraph: <span class="type">RunnableGraph</span>[<span class="type">Future</span>[<span class="type">Int</span>]] =</span><br><span class="line">  tweets</span><br><span class="line">    .via(count)</span><br><span class="line">    .toMat(sumSink)(<span class="type">Keep</span>.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sum: <span class="type">Future</span>[<span class="type">Int</span>] = counterGraph.run()</span><br><span class="line"></span><br><span class="line">sum.foreach(c =&gt; println(<span class="string">s&quot;Total tweets processed: <span class="subst">$c</span>&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> akka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka-streaming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Akka Reactive Streams</title>
      <link href="/2017/05/24/akka/streaming/akka-reactive-streams/"/>
      <url>/2017/05/24/akka/streaming/akka-reactive-streams/</url>
      
        <content type="html"><![CDATA[<p>Akka Streams have these key properties:</p><ul><li>They implement the <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0">Reactive Streams specification</a>, whose three main goals backpressure, async and non-blocking boundaries and interoperability between different implementations do fully apply for Akka Streams too.</li><li>They provide an abstraction for an evaluation engine for the streams, which is called <code>Materializer</code>.</li><li>Programs are formulated as reusable building blocks, which are represented as the three main types <code>Source</code>, <code>Sink</code> and <code>Flow</code>. The building blocks form a graph whose evaluation is based on the <code>Materializer</code> and needs to be explicitly triggered.<br>In the following a deeper introduction in how to use the three main types shall be given.</li></ul><span id="more"></span><h2><span id="relationship-with-reactive-streams">Relationship with Reactive Streams</span></h2><p>The Akka Streams API is completely decoupled from the Reactive Streams interfaces. While Akka Streams focus on the formulation of transformations on data streams the scope of Reactive Streams is just to define a common mechanism of how to move data across an asynchronous boundary without losses, buffering or resource exhaustion.</p><p>The relationship between these two is that the Akka Streams API is geared towards end-users while the Akka Streams implementation uses the Reactive Streams interfaces internally to pass data between the different processing stages. For this reason you will not find any resemblance between the Reactive Streams interfaces and the Akka Streams API. This is in line with the expectations of the Reactive Streams project, whose primary purpose is to define interfaces such that different streaming implementation can interoperate; it is not the purpose of Reactive Streams to describe an end-user API.</p><h2><span id="source">Source</span></h2><p>A <code>Source</code> is a data creator, it serves as an input source to the stream. Each <code>Source</code> has a single output channel and no input channel. All the data flows through the output channel to whatever is connected to the <code>Source</code>.</p><p><img src="/img/akka/streaming/akka-streams-source.png" alt="Source"></p><p>A <code>Source</code> can be created in multiple ways:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = Source.empty</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Nothing,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = Source.single(<span class="string">&quot;single element&quot;</span>)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[String,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = Source(1 to 3)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = Source(Future(<span class="string">&quot;single value from a Future&quot;</span>))</span></span><br><span class="line">s: akka.stream.scaladsl.Source[String,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s runForeach println</span></span><br><span class="line">res0: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">single value from a Future</span><br></pre></td></tr></table></figure><p>In the above cases we fed the <code>Source</code> with finite data, which means they will terminate eventually. One should not forget, that Reactive Streams are lazy and asynchronous by default. This means one explicitly has to request the evaluation of the stream. In Akka Streams this can be done through the <code>run*</code> methods. The <code>runForeach</code> would be no different to the well known <code>foreach</code> function - through the <code>run</code> addition it makes explicit that we ask for an evaluation of the stream. Since finite data is boring, we continue with infinite one:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = Source.repeat(5)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s take 3 runForeach println</span></span><br><span class="line">res1: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>With the <code>take</code> method we can create an artificial stop point that prevents us from evaluating indefinitely. Since actor support is built-in, we can also easily feed the stream with messages that are sent to an actor:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def run(actor: ActorRef) = &#123;</span><br><span class="line">  Future &#123; Thread.sleep(300); actor ! 1 &#125;</span><br><span class="line">  Future &#123; Thread.sleep(200); actor ! 2 &#125;</span><br><span class="line">  Future &#123; Thread.sleep(100); actor ! 3 &#125;</span><br><span class="line">&#125;</span><br><span class="line">val s = Source</span><br><span class="line">  .actorRef[Int](bufferSize = 0, OverflowStrategy.fail)</span><br><span class="line">  .mapMaterializedValue(run)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s runForeach println</span></span><br><span class="line">res1: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>We can see that the <code>Futures</code> are executed asynchronously on different threads, which explains the result. In the above example a buffer for the incoming elements is not necessary and therefore with <code>OverflowStrategy.fail</code> we can configure that the stream should fail on a buffer overflow. Especially through this actor interface, we can feed the stream through any data source. It doesn’t matter if the data is created by the same thread, by a different one, by another process or if they come from a remote system over the Internet.</p><h2><span id="sink">Sink</span></h2><p>A <code>Sink</code> is basically the opposite of a <code>Source</code>. It is the endpoint of a stream and therefore consumes data. A <code>Sink</code> has a single input channel and no output channel. <code>Sinks</code> are especially needed when we want to specify the behavior of the data collector in a reusable way and without evaluating the stream. The already known <code>run*</code> methods do not allow us these properties, therefore it is preferred to use <code>Sink</code> instead.</p><p><img src="/img/akka/streaming/akka-streams-sink.png" alt="Sink"></p><p>A short example of a <code>Sink</code> in action:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val <span class="built_in">source</span> = Source(1 to 3)</span></span><br><span class="line">source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val sink = Sink.foreach[Int](elem =&gt; println(s<span class="string">&quot;sink received: <span class="variable">$elem</span>&quot;</span>))</span></span><br><span class="line">sink: akka.stream.scaladsl.Sink[Int,scala.concurrent.Future[akka.Done]] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val flow = <span class="built_in">source</span> to sink</span></span><br><span class="line">flow: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> flow.run()</span></span><br><span class="line">res3: akka.NotUsed = NotUsed</span><br><span class="line">sink received: 1</span><br><span class="line">sink received: 2</span><br><span class="line">sink received: 3</span><br></pre></td></tr></table></figure><p>Connecting a <code>Source</code> to a <code>Sink</code> can be done with the <code>to</code> method. It returns a so called <code>RunnableFlow</code>, which is as we will later see a special form of a <code>Flow</code> - a stream that can be executed by just calling its <code>run()</code> method.</p><p><img src="/img/akka/streaming/akka-streams-runaable-flow.png" alt="run"></p><p>It is of course possible to forward all values that arrive at a sink to an actor:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> actor = system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> msg =&gt; println(<span class="string">s&quot;actor received: <span class="subst">$msg</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> sink = <span class="type">Sink</span>.actorRef[<span class="type">Int</span>](actor, onCompleteMessage = <span class="string">&quot;stream completed&quot;</span>)</span><br><span class="line">sink: akka.stream.scaladsl.<span class="type">Sink</span>[<span class="type">Int</span>,akka.<span class="type">NotUsed</span>] = ...</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> runnable = <span class="type">Source</span>(<span class="number">1</span> to <span class="number">3</span>) to sink</span><br><span class="line">runnable: akka.stream.scaladsl.<span class="type">RunnableGraph</span>[akka.<span class="type">NotUsed</span>] = ...</span><br><span class="line"></span><br><span class="line">scala&gt; runnable.run()</span><br><span class="line">res3: akka.<span class="type">NotUsed</span> = <span class="type">NotUsed</span></span><br><span class="line">actor received: <span class="number">1</span></span><br><span class="line">actor received: <span class="number">2</span></span><br><span class="line">actor received: <span class="number">3</span></span><br><span class="line">actor received: stream completed</span><br></pre></td></tr></table></figure><h2><span id="flow">Flow</span></h2><p>Data sources and sinks are great if you need a connection between Akka streams and an existing system but one can not really do anything with them. Flows are the last missing piece in the Akka Streams base abstraction. They act as a connector between different streams and can be used to transform its elements.</p><p><img src="/img/akka/streaming/akka-streams-flow.png" alt="Flow"></p><p>If a <code>Flow</code> is connected to a <code>Source</code> a new <code>Source</code> is the result. Likewise, a <code>Flow</code> connected to a <code>Sink</code> creates a new <code>Sink</code>. And a <code>Flow</code> connected with both a <code>Source</code> and a <code>Sink</code> results in a <code>RunnableFlow</code>. Therefore, they sit between the input and the output channel but by themselves do not correspond to one of the flavors as long as they are not connected to either a <code>Source</code> or a <code>Sink</code>.</p><p><img src="/img/akka/streaming/akka-streams-source-flow-sink.png" alt></p><p>In order to get a better understanding of <code>Flows</code>, we will have a look at some examples:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val <span class="built_in">source</span> = Source(1 to 3)</span></span><br><span class="line">source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val sink = Sink.foreach[Int](println)</span></span><br><span class="line">sink: akka.stream.scaladsl.Sink[Int,scala.concurrent.Future[akka.Done]] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val invert = Flow[Int].map(elem =&gt; elem * -1)</span></span><br><span class="line">invert: akka.stream.scaladsl.Flow[Int,Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val doubler = Flow[Int].map(elem =&gt; elem * 2)</span></span><br><span class="line">doubler: akka.stream.scaladsl.Flow[Int,Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val runnable = <span class="built_in">source</span> via invert via doubler to sink</span></span><br><span class="line">runnable: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> runnable.run()</span></span><br><span class="line">res10: akka.NotUsed = NotUsed</span><br><span class="line">-2</span><br><span class="line">-4</span><br><span class="line">-6</span><br></pre></td></tr></table></figure><p>Via the <code>via</code> method we can connect a <code>Source</code> with a <code>Flow</code>. We need to specify the input type because the compiler can’t infer it for us. As we can already see in this simple example, the flows <code>invert</code> and <code>double</code> are completely independent from any data producers and consumers. They only transform the data and forward it to the output channel. This means that we can reuse a flow among multiple streams:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s1 = Source(1 to 3) via invert to sink</span></span><br><span class="line">s1: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s2 = Source(-3 to -1) via invert to sink</span></span><br><span class="line">s2: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s1.run()</span></span><br><span class="line">res10: akka.NotUsed = NotUsed</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s2.run()</span></span><br><span class="line">res11: akka.NotUsed = NotUsed</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><code>s1</code> and <code>s2</code> represent completely new streams - they do not share any data through their building blocks.</p><h2><span id="unbounded-data-streams">Unbounded Data Streams</span></h2><p>Before we move on we should first revisit some of the key aspects of Reactive Streams. An unbounded number of elements can arrive at any point and can put a stream in different states. Beside from a runnable stream, which is the usual state, a stream may get stopped either through an error or through a signal that denotes that no further data will arrive. A stream can be modeled in a graphical way by marking events on a timeline as it is the case here:</p><p><img src="/img/akka/streaming/rcmwZ.png" alt></p><p>We have already seen runnable flows in the examples of the previous section. We get a <code>RunnableGraph</code> whenever a stream can actually be materialized, which means that a <code>Sink</code> is connected to a <code>Source</code>. So far we always materialized to the value <code>Unit</code>, which can be seen in the types:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> source: <span class="type">Source</span>[<span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Source</span>(<span class="number">1</span> to <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> sink: <span class="type">Sink</span>[<span class="type">Int</span>, <span class="type">Future</span>[<span class="type">Done</span>]] = <span class="type">Sink</span>.foreach[<span class="type">Int</span>](println)</span><br><span class="line"><span class="keyword">val</span> flow: <span class="type">Flow</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Flow</span>[<span class="type">Int</span>].map(x =&gt; x)</span><br></pre></td></tr></table></figure><p>For <code>Source</code> and <code>Sink</code> the second type parameter and for <code>Flow</code> the third type parameter denote the materialized value. Throughout this answer, the full meaning of materialization shall not be explained. However, further details about materialization can be found at the <a href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a>. For now the only thing we need to know is that the materialized value is what we get when we run a stream. Since we were only interested in side effects so far, we got <code>Unit</code> as the materialized value. The exception to this was a materialization of a sink, which resulted in a <code>Future</code>. It gave us back a <code>Future</code>, since this value can denote when the stream that is connected to the sink has been ended. So far, the previous code examples were nice to explain the concept but they were also boring because we only dealt with finite streams or with very simple infinite ones. To make it more interesting, in the following a full asynchronous and unbounded stream shall be explained.</p><h2><span id="clickstream-example">ClickStream Example</span></h2><p>As an example, we want to have a stream that captures click events. To make it more challenging, let’s say we also want to group click events that happen in a short time after each other. This way we could easily discover double, triple or tenfold clicks. Furthermore, we want to filter out all single clicks. Take a deep breath and imagine how you would solve that problem in an imperative manner. I bet no one would be able to implement a solution that works correctly on the first try. In a reactive fashion this problem is trivial to solve. In fact, the solution is so simple and straightforward to implement that we can even express it in a diagram that directly describes the behavior of the code:</p><p><img src="/img/akka/streaming/3tH8R.png" alt></p><p>The gray boxes are functions that describe how one stream is transformed into another. With the <code>throttle</code> function we accumulate clicks within 250 milliseconds, the <code>map</code> and <code>filter</code> functions should be self-explanatory. The color orbs represent an event and the arrows depict how they flow through our functions. Later in the processing steps, we get less and less elements that flow through our stream, since we group them together and filter them out. The code for this image would look something like this:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiClickStream = clickStream</span><br><span class="line">    .throttle(<span class="number">250.</span>millis)</span><br><span class="line">    .map(clickEvents =&gt; clickEvents.length)</span><br><span class="line">    .filter(numberOfClicks =&gt; numberOfClicks &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>The whole logic can be represented in only four lines of code! In Scala, we could write it even shorter:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiClickStream = clickStream.throttle(<span class="number">250.</span>millis).map(_.length).filter(_ &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>The definition of <code>clickStream</code> is a little bit more complex but this is only the case because the example program runs on the JVM, where capturing of click events is not easily possible. Another complication is that Akka by default doesn’t provide the <code>throttle</code> function. Instead we had to write it by ourselves. Since this function is (as it is the case for the <code>map</code> or <code>filter</code> functions) reusable across different use cases I don’t count these lines to the number of lines we needed to implement the logic. In imperative languages however, it is normal that logic can’t be reused that easily and that the different logical steps happen all at one place instead of being applied sequentially, which means that we probably would have misshaped our code with the throttling logic. The full code example is available as a <a href="https://gist.github.com/sschaef/8533e23f5856bd459e27#file-clickstreamexample-scala">gist</a> and shall not be discussed here any further.</p><h2><span id="simplewebserver-example">SimpleWebServer Example</span></h2><p>What should be discussed instead is another example. While the click stream is a nice example to let Akka Streams handle a real world example, it lacks the power to show parallel execution in action. The next example shall represent a small web server that can handle multiple requests in parallel. The web sever shall be able to accept incoming connections and receive byte sequences from them that represent printable ASCII signs. These byte sequences or strings should be split at all newline-characters into smaller parts. After that, the server shall respond to the client with each of the split lines. Alternatively, it could do something else with the lines and give a special answer token, but we want to keep it simple in this example and therefore don’t introduce any fancy features. Remember, the server needs to be able to handle multiple requests at the same time, which basically means that no request is allowed to block any other request from further execution. Solving all of these requirements can be hard in an imperative way - with Akka Streams however, we shouldn’t need more than a few lines to solve any of these. First, let’s have an overview over the server itself:</p><p><img src="/img/akka/streaming/Ji6AG.png" alt></p><p>Basically, there are only three main building blocks. The first one needs to accept incoming connections. The second one needs to handle incoming requests and the third one needs to send a response. Implementing all of these three building blocks is only a little bit more complicated than implementing the click stream:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkServer</span></span>(address: <span class="type">String</span>, port: <span class="type">Int</span>)(<span class="keyword">implicit</span> system: <span class="type">ActorSystem</span>, materializer: <span class="type">Materializer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">import</span> system.dispatcher</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> connectionHandler: <span class="type">Sink</span>[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>, <span class="type">Future</span>[<span class="type">Unit</span>]] =</span><br><span class="line">    <span class="type">Sink</span>.foreach[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>] &#123; conn =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Incoming connection from: <span class="subst">$&#123;conn.remoteAddress&#125;</span>&quot;</span>)</span><br><span class="line">      conn.handleWith(serverLogic)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> incomingCnnections: <span class="type">Source</span>[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>, <span class="type">Future</span>[<span class="type">Tcp</span>.<span class="type">ServerBinding</span>]] =</span><br><span class="line">    <span class="type">Tcp</span>().bind(address, port)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> binding: <span class="type">Future</span>[<span class="type">Tcp</span>.<span class="type">ServerBinding</span>] =</span><br><span class="line">    incomingCnnections.to(connectionHandler).run()</span><br><span class="line"></span><br><span class="line">  binding onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(b) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Server started, listening on: <span class="subst">$&#123;b.localAddress&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Server could not be bound to <span class="subst">$address</span>:<span class="subst">$port</span>: <span class="subst">$&#123;e.getMessage&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The function <code>mkServer</code> takes (besides from the address and the port of the server) also an actor system and a materializer as implicit parameters. The control flow of the server is represented by <code>binding</code>, which takes a source of incoming connections and forwards them to a sink of incoming connections. Inside of <code>connectionHandler</code>, which is our sink, we handle every connection by the flow  <code>serverLogic</code>, which will be described later. <code>binding</code> returns a <code>Future</code>, which completes when the server has been started or the start failed, which could be the case when the port is already taken by another process. The code however, doesn’t completely reflect the graphic as we can’t see a building block that handles responses. The reason for this is that the connection already provides this logic by itself. It is a bidirectional flow and not just a unidirectional one as the flows we have seen in the previous examples. As it was the case for materialization, such complex flows shall not be explained here. The <a href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a> has plenty of material to cover more complex flow graphs. For now it is enough to know that  <code>Tcp.IncomingConnection</code> represents a connection that knows how to receive requests and how to send responses. The part that is still missing is the <code>serverLogic</code> building block. It can look like this:</p><p><img src="/img/akka/streaming/xq4p8.png" alt></p><p>Once again, we are able to split the logic in several simple building blocks that all together form the flow of our program. First we want to split our sequence of bytes in lines, which we have to do whenever we find a newline character. After that, the bytes of each line need to be converted to a string because working with raw bytes is cumbersome. Overall we could receive a binary stream of a complicated protocol, which would make working with the incoming raw data extremely challenging. Once we have a readable string, we can create an answer. For simplicity reasons the answer can be anything in our case. In the end, we have to convert back our answer to a sequence of bytes that can be sent over the wire. The code for the entire logic may look like this:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serverLogic: <span class="type">Flow</span>[<span class="type">ByteString</span>, <span class="type">ByteString</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> delimiter = <span class="type">Framing</span>.delimiter(</span><br><span class="line">    <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">    maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">    allowTruncation = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> receiver = <span class="type">Flow</span>[<span class="type">ByteString</span>].map &#123; bytes =&gt;</span><br><span class="line">    <span class="keyword">val</span> message = bytes.utf8String</span><br><span class="line">    println(<span class="string">s&quot;Server received: <span class="subst">$message</span>&quot;</span>)</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> responder = <span class="type">Flow</span>[<span class="type">String</span>].map &#123; message =&gt;</span><br><span class="line">    <span class="keyword">val</span> answer = <span class="string">s&quot;Server hereby responds to message: <span class="subst">$message</span>\n&quot;</span></span><br><span class="line">    <span class="type">ByteString</span>(answer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">    .via(delimiter)</span><br><span class="line">    .via(receiver)</span><br><span class="line">    .via(responder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We already know that <code>serverLogic</code> is a flow that takes a <code>ByteString</code> and has to produce a <code>ByteString</code>. With <code>delimiter</code> we can split a <code>ByteString</code> in smaller parts - in our case it needs to happen whenever a newline character occurs. <code>receiver</code> is the flow that takes all of the split byte sequences and converts them to a string. This is of course a dangerous conversion, since only printable ASCII characters should be converted to a string but for our needs it is good enough. <code>responder</code> is the last component and is responsible for creating an answer and converting the answer back to a sequence of bytes. As opposed to the graphic we didn’t split this last component in two, since the logic is trivial. At the end, we connect all of the flows through the <code>via</code> function. At this point one may ask whether we took care of the multi-user property that was mentioned at the beginning. And indeed we did even though it may not be obvious immediately. By looking at this graphic it should get more clear:</p><img src="/img/akka/streaming/0a3Ey.png" alt style="width:460px;"><p>The <code>serverLogic</code> component is nothing but a flow that contains smaller flows. This component takes an input, which is a request, and produces an output, which is the response. Since flows can be constructed multiple times and they all work independently to each other, we achieve through this nesting our multi-user property. Every request is handled within its own request and therefore a short running request can overrun a previously started long running request. In case you wondered, the definition of <code>serverLogic</code> that was shown previously can of course be written a lot shorter by inlining most of its inner definitions:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serverLogic = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">  .via(<span class="type">Framing</span>.delimiter(</span><br><span class="line">      <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">      maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">      allowTruncation = <span class="literal">true</span>))</span><br><span class="line">  .map(_.utf8String)</span><br><span class="line">  .map(msg =&gt; <span class="string">s&quot;Server hereby responds to message: <span class="subst">$msg</span>\n&quot;</span>)</span><br><span class="line">  .map(<span class="type">ByteString</span>(_))</span><br></pre></td></tr></table></figure><p>A test of the web server may look like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># Client</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello World\nHow are you?&quot;</span> | netcat 127.0.0.1 6666</span></span><br><span class="line">Server hereby responds to message: Hello World</span><br><span class="line">Server hereby responds to message: How are you?</span><br></pre></td></tr></table></figure><p>In order for the above code example to function correctly, we first need to start the server, which is depicted by the <code>startServer</code> script:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># Server</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./startServer 127.0.0.1 6666</span></span><br><span class="line">[DEBUG] Server started, listening on: /127.0.0.1:6666</span><br><span class="line">[DEBUG] Incoming connection from: /127.0.0.1:37972</span><br><span class="line">[DEBUG] Server received: Hello World</span><br><span class="line">[DEBUG] Server received: How are you?</span><br></pre></td></tr></table></figure><p>The full code example of this simple TCP server can be found <a href="https://gist.github.com/sschaef/bd5ee6273ddaa7b015af#file-simpletcpserver-scala">here</a>. We are not only able to write a server with Akka Streams but also the client. It may look like this:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> connection = <span class="type">Tcp</span>().outgoingConnection(address, port)</span><br><span class="line"><span class="keyword">val</span> flow = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">  .via(<span class="type">Framing</span>.delimiter(</span><br><span class="line">      <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">      maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">      allowTruncation = <span class="literal">true</span>))</span><br><span class="line">  .map(_.utf8String)</span><br><span class="line">  .map(println)</span><br><span class="line">  .map(_ ⇒ <span class="type">StdIn</span>.readLine(<span class="string">&quot;&gt; &quot;</span>))</span><br><span class="line">  .map(_+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  .map(<span class="type">ByteString</span>(_))</span><br><span class="line"></span><br><span class="line">connection.join(flow).run()</span><br></pre></td></tr></table></figure><p>The full code TCP client can be found <a href="https://gist.github.com/sschaef/6b2661a0df512eb321e9">here</a>. The code looks quite similar but in contrast to the server we don’t have to manage the incoming connections anymore.</p><h2><span id="complex-graphs">Complex Graphs</span></h2><p>In the previous sections we have seen how we can construct simple programs out of flows. However, in reality it is often not enough to just rely on already built-in functions to construct more complex streams. If we want to be able to use Akka Streams for arbitrary programs we need to know how to build our own custom control structures and combinable flows that allow us to tackle the complexity of our applications. The good news is that Akka Streams was designed to scale with the needs of the users and in order to give you a short introduction into the more complex parts of Akka Streams, we add some more features to our client/server example.</p><p>One thing we can’t do yet is closing a connection. At this point it starts to get a little bit more complicated because the stream API we have seen so far doesn’t allow us to stop a stream at an arbitrary point. However, there is the <code>GraphStage</code> abstraction, which can be used to create arbitrary graph processing stages with any number of input or output ports. Let’s first have a look at the server side, where we introduce a new component, called <code>closeConnection</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> closeConnection = <span class="keyword">new</span> <span class="type">GraphStage</span>[<span class="type">FlowShape</span>[<span class="type">String</span>, <span class="type">String</span>]] &#123;</span><br><span class="line">  <span class="keyword">val</span> in = <span class="type">Inlet</span>[<span class="type">String</span>](<span class="string">&quot;closeConnection.in&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> out = <span class="type">Outlet</span>[<span class="type">String</span>](<span class="string">&quot;closeConnection.out&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> shape = <span class="type">FlowShape</span>(in, out)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createLogic</span></span>(inheritedAttributes: <span class="type">Attributes</span>) = <span class="keyword">new</span> <span class="type">GraphStageLogic</span>(shape) &#123;</span><br><span class="line">    setHandler(in, <span class="keyword">new</span> <span class="type">InHandler</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onPush</span></span>() = grab(in) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;q&quot;</span> ⇒</span><br><span class="line">          push(out, <span class="string">&quot;BYE&quot;</span>)</span><br><span class="line">          completeStage()</span><br><span class="line">        <span class="keyword">case</span> msg ⇒</span><br><span class="line">          push(out, <span class="string">s&quot;Server hereby responds to message: <span class="subst">$msg</span>\n&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setHandler(out, <span class="keyword">new</span> <span class="type">OutHandler</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onPull</span></span>() = pull(in)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This API looks a lot more cumbersome than the flow API. No wonder, we have to do a lot of imperative steps here. In exchange, we have more control over the behavior of our streams. In the above example, we only specify one input and one output port and make them available to the system by overriding the <code>shape</code> value. Furthermore we defined a so called <code>InHandler</code> and a <code>OutHandler</code>, which are in this order responsible for receiving and emitting elements. If you looked closely to the full click stream example you should recognize these components already. In the <code>InHandler</code> we grab an element and if it is a string with a single character <code>'q'</code>, we want to close the stream. In order to give the client a chance to find out that the stream will get closed soon, we emit the string <code>&quot;BYE&quot;</code> and then we immediately close the stage afterwards. The <code>closeConnection</code> component can be combined with a stream via the <code>via</code> method, which was introduced in the section about flows.</p><p>Beside from being able to close connections, it would also be nice if we could show a welcome message to a newly created connection. In order to do this we once again have to go a little bit further:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serverLogic</span></span></span><br><span class="line">    (conn: <span class="type">Tcp</span>.<span class="type">IncomingConnection</span>)</span><br><span class="line">    (<span class="keyword">implicit</span> system: <span class="type">ActorSystem</span>)</span><br><span class="line">    : <span class="type">Flow</span>[<span class="type">ByteString</span>, <span class="type">ByteString</span>, <span class="type">NotUsed</span>]</span><br><span class="line">    = <span class="type">Flow</span>.fromGraph(<span class="type">GraphDSL</span>.create() &#123; <span class="keyword">implicit</span> b ⇒</span><br><span class="line">  <span class="keyword">import</span> <span class="type">GraphDSL</span>.<span class="type">Implicits</span>._</span><br><span class="line">  <span class="keyword">val</span> welcome = <span class="type">Source</span>.single(<span class="type">ByteString</span>(<span class="string">s&quot;Welcome port <span class="subst">$&#123;conn.remoteAddress&#125;</span>!\n&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> logic = b.add(internalLogic)</span><br><span class="line">  <span class="keyword">val</span> concat = b.add(<span class="type">Concat</span>[<span class="type">ByteString</span>]())</span><br><span class="line">  welcome ~&gt; concat.in(<span class="number">0</span>)</span><br><span class="line">  logic.outlet ~&gt; concat.in(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">FlowShape</span>(logic.in, concat.out)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>The function <code>serverLogic</code> now takes the incoming connection as a parameter. Inside of its body we use a DSL that allows us to describe complex stream behavior. With <code>welcome</code> we create a stream that can only emit one element - the welcome message. logic is what was described as <code>serverLogic</code> in the previous section. The only notable difference is that we added <code>closeConnection</code> to it. Now actually comes the interesting part of the DSL. The <code>GraphDSL.create</code> function makes a builder <code>b</code> available, which is used to express the stream as a graph. With the <code>~&gt;</code> function it is possible to connect input and output ports with each other. The <code>Concat</code> component that is used in the example can concatenate elements and is here used to prepend the welcome message in front of the other elements that come out of <code>internalLogic</code>. In the last line, we only make the input port of the server logic and the output port of the concatenated stream available because all the other ports shall remain an implementation detail of the <code>serverLogic</code> component. For an in-depth introduction to the graph DSL of Akka Streams, visit the corresponding section in the <a href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/stream-graphs.html">official documentation</a>. The full code example of the complex TCP server and of a client that can communicate with it can be found <a href="https://gist.github.com/sschaef/df6315c87140d1d5951e">here</a>. Whenever you open a new connection from the client you should see a welcoming message and by typing <code>&quot;q&quot;</code> on the client you should see a message that tells you that the connection has been canceled.</p><p>There are still some topics which weren’t covered by this answer. Especially materialization may scare one reader or another but I’m sure with the material that is covered here everyone should be able to go the next steps by themselves. As already said, the <a href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a> is a good place to continue learning about Akka Streams.</p><h3><span id="参考">参考</span></h3><ul><li><a href="https://stackoverflow.com/questions/35120082/how-to-get-started-with-akka-streams">https://stackoverflow.com/questions/35120082/how-to-get-started-with-akka-streams</a></li><li><a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0">https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0</a></li><li><a href="http://doc.akka.io/docs/akka/2.5.1/scala/stream/stream-introduction.html#motivation">http://doc.akka.io/docs/akka/2.5.1/scala/stream/stream-introduction.html#motivation</a></li><li><a href="http://doc.akka.io/docs/akka/2.5.1/general/stream/stream-design.html#stream-design">http://doc.akka.io/docs/akka/2.5.1/general/stream/stream-design.html#stream-design</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> streaming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala中的Future和ExecutionContext</title>
      <link href="/2017/05/23/akka/future/future-and-execute/"/>
      <url>/2017/05/23/akka/future/future-and-execute/</url>
      
        <content type="html"><![CDATA[<p>Scala 这个语言可以用得很复杂、也可以用得很简洁。它在 Java 并发和 OO 之上做了进一步的抽象，将代码量大大降低。<br>最近流行的很多项目都使用 Scala，比如 Akka，Spark，Kafka，Spray，Play Framework，足见它是一门生产力很高的语言。<br>这里主要总结了下一些并发模式和并发线程池需要注意的地方。</p><span id="more"></span><p><img src="/img/akka/future/scala_future.jpg" alt="Future"></p><h2><span id="scala中的future并发模式">Scala中的Future并发模式</span></h2><h4><span id="一切皆future">一切皆Future：</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mFuture = future &#123;</span><br><span class="line">  <span class="type">Thread</span> sleep <span class="number">1000</span></span><br><span class="line">  <span class="string">&quot;result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span> result (mFuture, <span class="number">3</span> seconds)</span><br></pre></td></tr></table></figure><h4><span id="callback的几种方式">Callback的几种方式：</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.onComplete &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Await</span> result (mFuture, <span class="number">5</span> seconds)</span><br></pre></td></tr></table></figure><h4><span id="timeout-fallback">Timeout Fallback:</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> searchFuture = search(worktime)</span><br><span class="line"><span class="keyword">val</span> fallback = after(timeout, context.system.scheduler) &#123;</span><br><span class="line">  <span class="type">Future</span> successful <span class="string">s&quot;<span class="subst">$worktime</span> ms &gt; <span class="subst">$timeout</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Future</span> firstCompletedOf <span class="type">Seq</span>(searchFuture, fallback)</span><br></pre></td></tr></table></figure><h4><span id="future-之后的运算-map-filter-成其他-future">Future 之后的运算 map / filter 成其他 Future：</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.map &#123; r1 =&gt;</span><br><span class="line">    ...</span><br><span class="line">    r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="多个-future-链的处理-flatmap">多个 Future 链的处理 flatMap:</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nestedFuture: <span class="type">Future</span>[<span class="type">Future</span>[<span class="type">Boolean</span>]] = heatWater(<span class="type">Water</span>(<span class="number">25</span>)).map &#123;</span><br><span class="line">  water =&gt; temperatureOkay(water)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> flatFuture: <span class="type">Future</span>[<span class="type">Boolean</span>] = heatWater(<span class="type">Water</span>(<span class="number">25</span>)).flatMap &#123;</span><br><span class="line">  water =&gt; temperatureOkay(water)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="多个-future-的链合并的另一种方式">多个 Future 的链合并的另一种方式：</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="keyword">for</span> &#123;</span><br><span class="line">  result1 &lt;- remoteCall1</span><br><span class="line">  result2 &lt;-  remoteCall2</span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="type">List</span>(result1, result2)</span><br></pre></td></tr></table></figure><p>假如 future 定义在 for 之前则会并发执行，否则会顺序执行。另外，假如顺序执行 result1 可以作为参数传递到 remoteCall2 中。</p><h4><span id="转换-future-list-成-list-future-map-to">转换 Future List 成 List Future (map to)</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.sequence(list) <span class="comment">//(并发执行)</span></span><br></pre></td></tr></table></figure><h4><span id="转换-future-list-成单个-future-map-to">转换 Future List 成单个 Future (map to)</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.reduce(list)(f)</span><br></pre></td></tr></table></figure><p>Option 和 getOrElse 经常用在 Future 执行中。</p><h4><span id="scala-中的并发任务执行体-executioncontext">Scala 中的并发任务执行体 ExecutionContext</span></h4><p>Scala 中的 ExecutionContext 和 Java 的线程池的概念非常相似。都是执行具体 Task 的执行体。</p><h4><span id="scala-中默认的线程池">Scala 中默认的线程池：</span></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br></pre></td></tr></table></figure><p>是最方便的做法，如果不考虑优化和性能，在所有需要 ExecutionContext 的地方引用即可。当然这在生产环境是行不通的，原因是假如有 Task Block 了整个 global 线程池，应用将变得不可响应，即使 Block 不一定发生在本应用中，比如数据库的操作引起的 blocking 。</p><p>可以修改默认线程池的大小</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="type">Dscala</span>.concurrent.context.numThreads=<span class="number">8</span> -<span class="type">Dscala</span>.concurrent.context.maxThreads=<span class="number">8</span></span><br></pre></td></tr></table></figure><h4><span id="自定义线程池">自定义线程池</span></h4><p>创建固定大小线程池</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = <span class="type">ExecutionContext</span>.fromExecutor(<span class="type">Executors</span>.newFixedThreadPool(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>假如熟悉 Java 线程池的话，线程池的创建和 Java 中完全一样，可以套用。</p><h4><span id="scala-amp-akka-中的-dispatcher">Scala &amp; Akka 中的 Dispatcher</span></h4><p>定义一个 Dispatcher：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-dispatcher &#123;</span><br><span class="line">  # <span class="type">Dispatcher</span> is the name of the event-based dispatcher</span><br><span class="line">  <span class="class"><span class="keyword">type</span> </span>= <span class="type">Dispatcher</span></span><br><span class="line">  # <span class="type">What</span> kind of <span class="type">ExecutionService</span> to use</span><br><span class="line">  executor = <span class="string">&quot;fork-join-executor&quot;</span></span><br><span class="line">  # <span class="type">Configuration</span> <span class="keyword">for</span> the fork join pool</span><br><span class="line">  fork-join-executor &#123;</span><br><span class="line">    # <span class="type">Min</span> number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-min = <span class="number">2</span></span><br><span class="line">    # <span class="type">Parallelism</span> (threads) ... ceil(available processors * factor)</span><br><span class="line">    parallelism-factor = <span class="number">2.0</span></span><br><span class="line">    # <span class="type">Max</span> number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-max = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  # <span class="type">Throughput</span> defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # <span class="type">Set</span> to <span class="number">1</span> <span class="keyword">for</span> as fair as possible.</span><br><span class="line">  throughput = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-thread-pool-dispatcher &#123;</span><br><span class="line">  # <span class="type">Dispatcher</span> is the name of the event-based dispatcher</span><br><span class="line">  <span class="class"><span class="keyword">type</span> </span>= <span class="type">Dispatcher</span></span><br><span class="line">  # <span class="type">What</span> kind of <span class="type">ExecutionService</span> to use</span><br><span class="line">  executor = <span class="string">&quot;thread-pool-executor&quot;</span></span><br><span class="line">  # <span class="type">Configuration</span> <span class="keyword">for</span> the thread pool</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    # minimum number of threads to cap factor-based core number to</span><br><span class="line">    core-pool-size-min = <span class="number">2</span></span><br><span class="line">    # <span class="type">No</span> of core threads ... ceil(available processors * factor)</span><br><span class="line">    core-pool-size-factor = <span class="number">2.0</span></span><br><span class="line">    # maximum number of threads to cap factor-based number to</span><br><span class="line">    core-pool-size-max = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  # <span class="type">Throughput</span> defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # <span class="type">Set</span> to <span class="number">1</span> <span class="keyword">for</span> as fair as possible.</span><br><span class="line">  throughput = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Scala 代码中引用引用之前定义的 Dispatcher：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> executionContext = system.dispatchers.lookup(<span class="string">&quot;my-dispatcher&quot;</span>)</span><br></pre></td></tr></table></figure><p>给某个 Actor 指定 dispatcher：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myActor = context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>].withDispatcher(<span class="string">&quot;my-dispatcher&quot;</span>), <span class="string">&quot;myactor1&quot;</span>)</span><br></pre></td></tr></table></figure><h4><span id="最佳实践">最佳实践</span></h4><p>将不同类型的运算进行 dispatcher 隔离：</p><p>给 blocking I/O 创建单独的线程池：</p><p>因为 JDBC 没有 non-blocking API，所以为 DB R/W Heavey R/W 这些 Block 操作创建单独的 dispatcher。并在不同的 dispatcher 中执行不同类型的 Future 计算。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Contexts</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> simpleDbLookups: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.simple-db-lookups&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> expensiveDbLookups: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.expensive-db-lookups&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> dbWriteOperations: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.db-write-operations&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> expensiveCpuOperations: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.expensive-cpu-operations&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，需要给 CPU 密集计算创建单独的线程池。</p>]]></content>
      
      
      <categories>
          
          <category> future </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Migrating from Spray to Akka</title>
      <link href="/2017/05/18/akka/http/spray-to-akka-http/"/>
      <url>/2017/05/18/akka/http/spray-to-akka-http/</url>
      
        <content type="html"><![CDATA[<p>Spray is a well-known HTTP library in the Scala ecosystem. It was released in 2011, and since then it’s been widely used by the Scala community. It was recently announced that Spray would be replaced with Akka HTTP, thus cementing Akka HTTP as the successor of Spray. It’s maintained by Lightbend and it’s been recommended that users migrate to it soon.</p><p>However, migration from one major version of a library to another is not an easy task. Very often it requires you to spend some time reading the source code in order to figure out how to use certain features, as well as how to migrate existing logic.</p><p>This post will demonstrate what changes should be applied in order to migrate your app from Spray to Akka HTTP. The following steps don’t have a particular order, as it depends on which areas need to be rewritten.</p><span id="more"></span><h2><span id="packages">Packages</span></h2><p>In order to have the lastest Akka HTTP packages, all previous Spray dependencies now need to be replaced by the following:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;com.typesafe.akka&quot; %% &quot;akka-http-core&quot; % “2.4.3”</span><br><span class="line">&quot;com.typesafe.akka&quot; %% &quot;akka-http-experimental&quot; % “2.4.3”</span><br><span class="line">&quot;com.typesafe.akka&quot; %% &quot;akka-http-testkit&quot; % “2.4.3” % &quot;test&quot;</span><br></pre></td></tr></table></figure><h2><span id="httpservice">HttpService</span></h2><p>Spray’s HttpService has been removed. Use Http class and pass your routes to the bindAndHandle method. For example:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val service = system.actorOf(Props(new HttpServiceActor(routes)))</span><br><span class="line">IO(Http)(system) ! Http.Bind(service, &quot;0.0.0.0&quot;, port = 8080)</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http().bindAndHandle(routes, &quot;0.0.0.0&quot;, port = 8080)</span><br></pre></td></tr></table></figure><h2><span id="marshalling">Marshalling</span></h2><p><code>Marshaller.of</code> can be replaced with <code>Marshaller.withFixedContentType</code>. See below:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Marshaller.of[JsonApiObject](`application/vnd.api+json`) &#123; (value, contentType, ctx) =&gt;</span><br><span class="line">      ctx.marshalTo(HttpEntity(contentType, value.toJson.toString))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Marshaller.withFixedContentType(`application/vnd.api+json`) &#123; obj =&gt;</span><br><span class="line">      HttpEntity(`application/vnd.api+json`, obj.toJson.compactPrint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Akka HTTP marshallers support content negotiation, so you don’t have to specify the content type when creating one “super” marshaller from other marshallers:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ToResponseMarshaller.oneOf(</span><br><span class="line">      `application/vnd.api+json`,</span><br><span class="line">      `application/json`</span><br><span class="line">    )(</span><br><span class="line">      jsonApiMarshaller,</span><br><span class="line">      jsonMarshaller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Marshaller.oneOf(</span><br><span class="line">      jsonApiMarshaller,</span><br><span class="line">      jsonMarshaller</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2><span id="unmarshalling">Unmarshalling</span></h2><p>The example below shows one way that an Unmarshaller might be rewritten:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unmarshaller[Entity](`application/vnd.api+json`) &#123;</span><br><span class="line">      case HttpEntity.NonEmpty(contentType, data) =&gt;</span><br><span class="line">data.asString.parseJson.convertTo[Entity]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unmarshaller.stringUnmarshaller.forContentTypes(`application/vnd.api+json`).map(_.parseJson.convertTo[Entity])</span><br></pre></td></tr></table></figure><h2><span id="mediatypes">MediaTypes</span></h2><p><code>MediaType.custom</code> can be replaced with specific methods in <code>MediaType</code> object.</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaType.custom(&quot;application/vnd.acme+json&quot;)</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaType.applicationWithFixedCharset(&quot;application/vnd.acme+json&quot;, HttpCharsets.`UTF-8`)</span><br></pre></td></tr></table></figure><h2><span id="rejection-handling">Rejection Handling</span></h2><p>RejectionHandler now uses a builder pattern – see the example below:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def rootRejectionHandler = RejectionHandler &#123;</span><br><span class="line">    case Nil =&gt; &#123;</span><br><span class="line">      requestUri &#123; uri =&gt;</span><br><span class="line">        logger.error(&quot;Route: &#123;&#125; does not exist.&quot;, uri)</span><br><span class="line">        complete((NotFound, mapErrorToRootObject(notFoundError)))</span><br><span class="line">      &#125;</span><br><span class="line"> case AuthenticationFailedRejection(cause, challengeHeaders) :: _ =&gt; &#123;</span><br><span class="line">      logger.error(s&quot;Request is rejected with cause: $cause&quot;)</span><br><span class="line">      complete((Unauthorized, mapErrorToRootObject(unauthenticatedError)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RejectionHandler</span><br><span class="line">    .newBuilder()</span><br><span class="line">    .handle &#123;</span><br><span class="line">      case AuthenticationFailedRejection(cause, challengeHeaders) =&gt;</span><br><span class="line">        logger.error(s&quot;Request is rejected with cause: $cause&quot;)</span><br><span class="line">        complete((Unauthorized, mapErrorToRootObject(unauthenticatedError)))</span><br><span class="line">.handleNotFound &#123; ctx =&gt;</span><br><span class="line">      logger.error(&quot;Route: &#123;&#125; does not exist.&quot;, ctx.request.uri.toString())</span><br><span class="line">      ctx.complete((NotFound, mapErrorToRootObject(notFoundError)))</span><br><span class="line">    &#125;</span><br><span class="line">.result() withFallback RejectionHandler.default</span><br></pre></td></tr></table></figure><h2><span id="client">Client</span></h2><p>The Spray-client pipeline was removed. Use Http’s singleRequest method instead:</p><p>Before:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val pipeline: HttpRequest =&gt; Future[HttpResponse] = (addHeader(Authorization(OAuth2BearerToken(accessToken))) ~&gt; sendReceive)</span><br><span class="line"> val patch: HttpRequest = Patch(uri, object))</span><br><span class="line"></span><br><span class="line">pipeline(patch).map &#123; response ⇒</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val request = HttpRequest(</span><br><span class="line">                method = PATCH,</span><br><span class="line">                uri = Uri(uri),</span><br><span class="line">                headers = List(Authorization(OAuth2BearerToken(accessToken))),</span><br><span class="line">                entity = HttpEntity(MediaTypes.`application/json`, object)</span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">              http.singleRequest(request).map &#123;</span><br><span class="line">case … =&gt; …</span><br><span class="line">… </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="headers">Headers</span></h2><p>All HTTP headers have been moved to the akka.http.scaladsl.model.headers._ package.</p><p>Form fields and file upload</p><p>With the streaming nature of http entity, it’s important to have a strict http entity before accessing multiple form fields or use file upload directives. One solution might be using next directive before working with form fields:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val toStrict: Directive0 = extractRequest flatMap &#123; request =&gt;</span><br><span class="line">      onComplete(request.entity.toStrict(5.seconds)) flatMap &#123;</span><br><span class="line">        case Success(strict) =&gt;</span><br><span class="line">          mapRequest( req =&gt; req.copy(entity = strict))</span><br><span class="line">        case _ =&gt; reject</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>And one can use it like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toStrict &#123;</span><br><span class="line">formFields(&quot;name&quot;.as[String]) &#123; name =&gt;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this list isn’t an exhaustive collection of all the changes you need to do, it covers the trickiest ones that exist. One major drawback of Akka HTTP is that it’s not as mature as Spray, and it’s performance is not optimised yet. Users may also notice a lack of documentation for some cases.</p><p>Having said that, it would be a good idea to keep the above issues in mind during this process. Happy migration!</p>]]></content>
      
      
      <categories>
          
          <category> akka-http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> akka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu configure LAMP environment</title>
      <link href="/2017/05/03/php/ubuntu-install-php/"/>
      <url>/2017/05/03/php/ubuntu-install-php/</url>
      
        <content type="html"><![CDATA[<p>Use-Cases of this Tutorial</p><ul><li>Installing latest versions of Apache, MySql, PHP &amp; phpMyAdmin on Ubuntu 16.04</li><li>Installing latest versions of Apache, MySql, PHP &amp; phpMyAdmin on Ubuntu 16.04 (over an AWS EC2 Instance)</li></ul><span id="more"></span><p>Having your own VPS or a Dedicated Server offers a lot of freedom as compared to a Shared Hosting plan. You can enable Apache &amp; PHP modules as per your wish, and also use many useful Linux utilities in your PHP code.</p><p>However the initial setup is quite a pain. Installing applications and working with the Linux command line are not the easiest of things. But installing Apache, PHP, MySql &amp; phpMyAdmin is not difficult, as long as you stick with the process. In fact you can have a fully functional LAMP stack by executing only 10-12 command line operations !</p><p>Follow the steps given below, one by one.</p><h3><span id="updating-the-package-list">Updating the Package List</span></h3><p>Update the package list on your system so that you can have the latest available versions of Apache, PHP, MySql and phpMyAdmin.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3><span id="installing-apache">Installing Apache</span></h3><p>Install Apache through the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure><p>Note that it will install the latest available version of Apache (2.4 as of Jan, 2017).</p><h3><span id="checking-successful-installation-of-apache">Checking Successful Installation of Apache</span></h3><p>You can check whether Apache has been installed by typing in the IP address of your server <code>http://your-ip-address</code> (or <code>http://localhost</code> if you’re doing it on a local server). You should see a page like this :</p><p><img src="/img/lamp/apache-home.png" alt></p><h3><span id="installing-mysql">Installing MySQL</span></h3><p>Install MySql through the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>You will also be asked to enter the desired password of the MySql root account. <strong>Although it is optional, don’t leave it</strong>. The default password of the root account is blank, and instead of changing it later on, better do it now.</p><p><img src="/img/lamp/mysql-root-password.png" alt></p><p>Type in a strong password and <strong>press the arrow-down button to highlight the Ok button. When highlighted the Ok button will turn red</strong>. Press the enter key to proceed.</p><p>You will also be asked for a confirmation of the password. Repeat the same.</p><p>The latest available version of MySql (5.7 as of Jan, 2017) will be installed.</p><h3><span id="checking-successful-installation-of-mysql">Checking Successful Installation of MySql</span></h3><p>Type the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3><span id="installing-php-with-commonly-used-extensions">Installing PHP with Commonly Used Extensions</span></h3><p>Install PHP and commonly used extensions:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php libapache2-mod-php php-mysql php-curl php-gd php-json php-mcrypt php-zip</span><br></pre></td></tr></table></figure><p>In the above command in addition to PHP, the following PHP extensions are also installed :</p><ul><li>MySql Extension : To use MySql functions available in PHP</li><li>Curl Extension : To make CURL requests through PHP, commonly used in implementing API calls of web services</li><li>GD Extension : To enable the GD library. PHP uses GD library for image manipulation tasks</li><li>JSON Extension : To decode and encode JSON through PHP</li><li>Mcrypt Extension : Contains various encryption functions</li><li>Zip Extension : Zip and unzip through PHP</li></ul><p>PHP offers a lot more extensions, but these are the most commonly used. If required, you can install an extension later.</p><p>Also note that <code>libapache2-mod-php</code> is the Apache Module to run PHP. This module provides the connection between Apache and PHP.</p><p>The latest available version of PHP (7 as of Jan, 2017) will be installed.</p><h3><span id="checking-successful-installation-of-php">Checking Successful Installation of PHP</span></h3><p>Type the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;?php phpinfo(); ?&gt;&quot; | sudo tee /var/www/html/phpinfo.php</span><br></pre></td></tr></table></figure><p>This will create a phpinfo.php file in the root directory. Type this url in the browser <code>http://your-ip-address/phpinfo.php</code> (or <code>http://localhost/phpinfo.php</code> if installing locally). You should see a page like this, showing your PHP configuration :</p><p><img src="/img/lamp/php-home.png" alt></p><h3><span id="installing-phpmyadmin">Installing phpMyAdmin</span></h3><p>Install phpMyAdmin through the commannd :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure><p>You will be asked to choose the type of web server. The default choice would be apache2. Press space key to select. Now press Tab key to highlight the Ok button. Now press the enter key. <strong>Pressing key in this order is very important, otherwise apache2 will not be selected</strong>. When selected apache2 would have a * symbol beside it, see the second image how it would look like.</p><p><img src="/img/lamp/phpmyadmin-choose-server.png" alt></p><p><img src="/img/lamp/phpmyadmin-apache-server.png" alt></p><p>You will then be asked whether to configure database for phpmyadmin with dbconfig-common. Choose Yes and click enter.</p><p><img src="/img/lamp/phpmyadmin-choose-dbconfig.png" alt></p><p>You will then be asked to enter the password of MySql root account. Enter the password which you typed while installing MySql. Use the Tab key to highlight the Ok button and press enter.</p><p>Do the same when asked for password confirmation.</p><p><img src="/img/lamp/phpmyadmin-choose-password.png" alt></p><p>The latest available version of phpMyAdmin (4.5 as of Jan, 2017) will be installed.</p><h3><span id="checking-successful-installation-of-phpmyadmin">Checking Successful Installation of phpMyAdmin</span></h3><p>Visit the url <code>http://your-ip-addrss/phpmyadmin</code> (or <code>http://localhost/phpmyadmin</code>) in your browser. If phpMyAdmin is installed successfully, you should see the standard phpMyAdmin login page. Type in root as the username, and the MySql password you chose earlier to access the databases.</p><h3><span id="enable-apache-rewrite-module">Enable Apache Rewrite Module</span></h3><p>Enable the Rewrite Module in Apache, so that your application can make use of seo-friendly pretty URLs, such as <a href="http://website.com/posts/12/post-on-ubuntu/">http://website.com/posts/12/post-on-ubuntu/</a> (instead of <a href="http://website.com?post_id=12">http://website.com?post_id=12</a>). Most probably you will be needing pretty URLs in future, better enable it now.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br></pre></td></tr></table></figure><p>Now restart Apache so that this change becomes live.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><p>That’s it. You should have a fully functional LAMP stack. You can start writing your code now !</p><p>In case of any issues, please comment it below.</p><h3><span id="referrence">Referrence</span></h3><ul><li><a href="http://usefulangle.com/post/35/how-to-install-linux-apache-mysql-php-phpmyadmin-lamp-stack-on-ubuntu-16-04">http://usefulangle.com/post/35/how-to-install-linux-apache-mysql-php-phpmyadmin-lamp-stack-on-ubuntu-16-04</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下持续集成环境Teamcity搭建</title>
      <link href="/2017/05/01/ci/linux-CI-config/"/>
      <url>/2017/05/01/ci/linux-CI-config/</url>
      
        <content type="html"><![CDATA[<p>In any software development project a Continuous Integration/ Continuous Deployment DevOps environment is essential. A recent project I elected to make use of TeamCity &amp; Octopus Deploy all on an Azure stack.</p><p>In this post I twill detail the steps on how to install and configure Team City 2017.x on a Ubuntu 16.X server.</p><span id="more"></span><h3><span id="install-database-software">Install Database software</span></h3><p>Team City is able to store TeamCity stores build history, users, build results and some run time data to a number of Relation Database Management Systems(RDBMS) including</p><ul><li>Postrgre SQL</li><li>MySQL</li><li>MS SQL</li><li>Oracle</li><li>Default Internal DB(HSQL)</li></ul><p>In my particular case I make use of Postgres SQL, <a href="/2017/05/01/postgresql/ubuntu-install-postgresql">Install Postgres SQL on ubuntu</a></p><h3><span id="download-amp-install-team-city">Download &amp; Install Team city</span></h3><p>Download the latest TeamCity for linux from Jetbrains.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://data.services.jetbrains.com/products/download?code=TC&amp;platform=linux</span><br></pre></td></tr></table></figure><p>After the download completes unpack the file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf TeamCity-2017.1.1.tar.gz</span><br></pre></td></tr></table></figure><p>We will install TeamCity to the <code>opt</code> so we need to move the TeamCity Directory to <code>/opt/</code> and set permissions to the user running the TeamCity Application.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/jetbrains</span><br><span class="line">sudo mv Teamcity /opt/jetbrains/teamcity</span><br><span class="line">cd /opt/jetbrains/teamcity</span><br><span class="line">sudo chown -R $user /opt/jetbrains/teamcity</span><br></pre></td></tr></table></figure><ul><li><code>$user</code> the owner of teamcity &amp; teamagent</li></ul><p>Configure TeamCity to start automatically with the correct use by creating a script to start and stop TeamCity. We’ll create a simple bash script using the <code>nano</code> text editor.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/init.d/teamcity</span><br></pre></td></tr></table></figure><p>If you are going to running the team city service under username other than the one you are currently installing it with then you will need to replace <code>$user</code> in the code snippet with that username.</p><p>Copy and paste the following ocde into the editor.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          TeamCity autostart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: Start teamcity daemon at boot time</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:       Enable service provided by daemon.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/init.d/teamcity -  startup script <span class="keyword">for</span> teamcity</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Ensure you enter the  right  user name that  TeamCity will run  under</span></span><br><span class="line">USER=&quot;ubuntu&quot; </span><br><span class="line"> </span><br><span class="line">export TEAMCITY_DATA_PATH=&quot;/opt/jetbrains/teamcity/.BuildServer&quot;</span><br><span class="line"> </span><br><span class="line">case $1 in</span><br><span class="line"> </span><br><span class="line">start)</span><br><span class="line">  start-stop-daemon --start  -c $USER --exec /opt/jetbrains/teamcity/bin/runAll.sh start</span><br><span class="line"> ;;</span><br><span class="line">stop)</span><br><span class="line">  start-stop-daemon --start -c $USER  --exec  /opt/jetbrains/teamcity/bin/runAll.sh stop</span><br><span class="line"> ;;</span><br><span class="line"> esac</span><br><span class="line"> </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>Change the permissions required to execute the script and add it to the starup to nesure Team City is started whenever the server is start/restart</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/init.d/teamcity</span><br><span class="line">sudo update-rc.d teamcity defaults</span><br></pre></td></tr></table></figure><h3><span id="download-database-driver">Download database driver</span></h3><p>The database drivers are usually not included in the TeamCity set up files. We will need to download the PostGres Driver seperately and place them in the <code>/opt/jetbrains/teamcity/.BuildServer/lib/jdbc</code> folder.</p><p>Change into the directory</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/jetbrains/teamcity/.BuildServer/lib/jdbc</span><br></pre></td></tr></table></figure><p>Download the driver</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://jdbc.postgresql.org/download/postgresql-9.5.xxxx.jar</span><br></pre></td></tr></table></figure><p>We are now ready to start Team City and begin the configuration in the Team City UI</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/teamcity start</span><br></pre></td></tr></table></figure><p>Navigate to <code>http://[Server name or IP]:8111</code> and verify that you see “TeamCity First Start” page.</p><p>Congratulations TeamCity is installed continue the steps on the web page to configure it.</p><h3><span id="teamcity-build-agent-installation">Teamcity build agent installation</span></h3><ul><li>If you install TeamCity bundled with a Tomcat servlet container, or opt to install an agent for Windows, both the server and one build agent named <code>Default Agent</code> are installed on the same machine. This is not a recommended setup for <a href="https://confluence.jetbrains.com/display/TCD9/Installing+and+Configuring+the+TeamCity+Server#InstallingandConfiguringtheTeamCityServer-ConfiguringServerforProductionUse">production purposes</a> because of <a href="https://confluence.jetbrains.com/pages/viewpage.action?pageId=74847395#HowTo...-TeamCitySecurityNotes">security concerns</a> and since the build procedure can slow down the responsiveness of the webUI and overall TeamCity server functioning. If you need more build agents, perform the procedure described below.</li><li>If you need the agent to run a operating system different from the TeamCity server, perform the procedure described below.</li><li>For production installations, it is recommended to adjust the <a href="https://confluence.jetbrains.com/display/TCD9/Configuring+Build+Agent+Startup+Properties">Agent’s JVM parameters</a> to include the <code>-server</code> option.</li></ul><p>Download build agent archive from your TeamCity server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://your_teamcity.server.com:8111/update/buildAgent.zip</span><br></pre></td></tr></table></figure><p>Unzip it in separate directory</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/jetbrains/</span><br><span class="line">sudo mkdir buildagent</span><br><span class="line">sudo unzip buildAgent.zip -d buildagent</span><br><span class="line">sudo chown -R $user ../buildagent</span><br></pre></td></tr></table></figure><p>Copy agent’s settings file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp conf/buildAgent.dist.properties conf/buildAgent.properties</span><br></pre></td></tr></table></figure><p>Edit this file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano conf/buildAgent.properties</span><br></pre></td></tr></table></figure><p>There are fields which you must update</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> your TeamCity server address:</span></span><br><span class="line">serverUrl=http://your_teamcity.server.com:8111/</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> buildAgent<span class="string">&#x27;s name, which would displayed on Agents page in your TeamCity server UI:</span></span></span><br><span class="line">name=ubuntu</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> this field  leave blank, agent fill it after first connect to server:</span></span></span><br><span class="line">authorizationToken=</span><br></pre></td></tr></table></figure><p>Make bin files executable</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod u+x bin/*.sh</span><br></pre></td></tr></table></figure><p>Build agent usage</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/agent.sh</span></span><br><span class="line"></span><br><span class="line">  JetBrains TeamCity Build Agent</span><br><span class="line">  Usage:</span><br><span class="line">  ./bin/agent.sh start     - to start build agent in background</span><br><span class="line">  ./bin/agent.sh stop      - to stop build agent after current build finish</span><br><span class="line">  ./bin/agent.sh run         - to start build agent in the current console</span><br><span class="line">  ./bin/agent.sh stop force  - to stop build agent terminating currently running build</span><br></pre></td></tr></table></figure><p>Add build agent to <code>rc.local</code> for autostart after system reboot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/jetbrains/buildagent/bin/agent.sh start/stop</span><br></pre></td></tr></table></figure><p>The <code>&lt;agent home&gt;/launcher/conf/wrapper.conf</code> file can also be used to alter the agent JVM parameters.</p><p>The user account used to run build agent service must have enough rights to start/stop the agent service, as described <a href="https://confluence.jetbrains.com/display/TCD10/Setting+up+and+Running+Additional+Build+Agents#SettingupandRunningAdditionalBuildAgents-subinacl">above</a>.</p><h3><span id="automatic-agent-start-under-linux">Automatic Agent Start under Linux</span></h3><p>To run agent automatically on the machine boot under Linux, configure daemon process with the <code>agent.sh start</code> command to start it and <code>agent.sh stop</code> command to stop it. Refer to an example procedure below</p><ol><li>Navigate to the services start/stop services scripts directory</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/init.d/</span><br></pre></td></tr></table></figure><ol start="2"><li>Open the build agent service script</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim buildagent</span><br></pre></td></tr></table></figure><ol start="3"><li>Paste the following into the file</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          TeamCity Build Agent</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: Start build agent daemon at boot time</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:       Enable service provided by daemon.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Provide the correct user name:</span></span><br><span class="line">USER=&quot;ubuntu&quot;</span><br><span class="line"> </span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line"> su - $USER -c &quot;cd /opt/jetbrains/buildagent/bin ; ./agent.sh start&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"> su - $USER -c &quot;cd /opt/jetbrains/buildagent/bin ; ./agent.sh stop&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">  echo &quot;usage start/stop&quot;</span><br><span class="line">  exit 1</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line">esac</span><br><span class="line"> </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><ol start="4"><li>Set the permissions to execute the file</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x buildagent</span><br></pre></td></tr></table></figure><ol start="5"><li>Make links to start the agent service on the machine boot and on restarts using the appropriate tool</li></ol><ul><li>For Debian/Ubuntu</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d buildagent defaults</span><br></pre></td></tr></table></figure><ul><li>For Red Hat/CentOS</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig buildagent on</span><br></pre></td></tr></table></figure><ol start="6"><li>At the end, starting the Build Agent, and Team City will pick it up</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/buildagent start</span><br></pre></td></tr></table></figure><h3><span id="referrence">Referrence</span></h3><ul><li><a href="https://confluence.jetbrains.com/display/TCD10/Setting+up+and+Running+Additional+Build+Agents">Setting up and Running Additional Build Agents</a></li><li><a href="https://garywoodfine.com/how-to-install-team-city-10-x-on-ubuntu-16-x/">How to install Team City 10.x on ubuntu 16.X</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ci </category>
          
      </categories>
      
      
        <tags>
            
            <tag> teamcity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装postgreSQL</title>
      <link href="/2017/05/01/postgresql/ubuntu-install-postgresql/"/>
      <url>/2017/05/01/postgresql/ubuntu-install-postgresql/</url>
      
        <content type="html"><![CDATA[<h3><span id="安装并配置并设置远程登录用户名和密码">安装并配置，并设置远程登录用户名和密码</span></h3><ol><li>安装postgreSQL</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql</span><br></pre></td></tr></table></figure><ul><li>安装完postgreSQL后，会自动注册为服务</li><li>安装完postgreSQL后，自动添加一个postgres用户，密码随机。以及自动添加一个postgres数据库，用户名为postgres，密码也随机。</li></ul><span id="more"></span><ol start="2"><li>修改postgres数据库用户密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql postgres</span><br></pre></td></tr></table></figure><ul><li>其中，<code>sudo -u postgres</code> 是使用postgres用户登录的意思。数据库为postgres</li><li><code>postgres=#</code> 为PostgreSQL下的命令提示符，–注意最后的分号；</li></ul><p>修改数据库密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\password postgres</span><br></pre></td></tr></table></figure><ol start="3"><li>设置postgreSQL系统用户的密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres passwd</span><br></pre></td></tr></table></figure><h3><span id="实现远程访问">实现远程访问</span></h3><ol><li>修改数据库配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/postgresql/9.x/main/postgresql.conf</span><br></pre></td></tr></table></figure><p>监听任何地址访问，修改连接权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">listen_addresses = <span class="string">&#x27;localhost&#x27;</span></span></span><br><span class="line">listen_addresses = &#x27;*&#x27; </span><br></pre></td></tr></table></figure><p>启用密码验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">password_encryption = on</span></span><br><span class="line">password_encryption = on</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/postgresql/9.x/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>在文档末尾加上以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host all all 0.0.0.0 0.0.0.0 md5</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>防火墙添加信任</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT</span><br></pre></td></tr></table></figure><h3><span id="内部登录管理数据库-新建数据库-用户和密码">内部登录，管理数据库、新建数据库、用户和密码</span></h3><p>登录postgreSQL数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U postgres -h 127.0.0.1</span><br></pre></td></tr></table></figure><p>创建新用户，单不给建数据库权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=# create user &quot;shana&quot; with password &#x27;xxxx&#x27; nocreatedb;</span><br></pre></td></tr></table></figure><ul><li>用户名处是双引号</li></ul><p>建立数据库，并指定所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=#create database &quot;xxx_db&quot; with owner = &quot;shana&quot;;</span><br></pre></td></tr></table></figure><h3><span id="外部登录管理数据库-新建数据库-用户和密码">外部登录，管理数据库、新建数据库、用户和密码</span></h3><p>在外部命令行管理命令，创建用户pencil</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres createuser -D -P pencil</span><br></pre></td></tr></table></figure><ul><li>输入新的密码</li><li>再次输入新的密码</li></ul><p>建立数据库(tempdb)，并指定所有者为(pencil)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres createdb -O pencil tempdb</span><br></pre></td></tr></table></figure><ul><li><code>-O</code> 设定所有者为 pencil</li></ul><ul><li><a href="http://blog.sina.com.cn/s/blog_6af33caa0100ypck.html">参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.x 安装Gitlab</title>
      <link href="/2017/05/01/gitlab/ubuntu-gitlab-install/"/>
      <url>/2017/05/01/gitlab/ubuntu-gitlab-install/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 在GitLab的官方网站上面对Ubuntu的支持也是很好的，有比较详尽的安装指南。 在介绍postfix的地方有少部分的坑，本文抛砖引玉，解决一些我遇到的坑。 本文主要针对Ubuntu 16.04，介绍如何安装Gitlab。其他的Ubuntu可以作为一个参考。</p></blockquote><span id="more"></span><h3><span id="安装需要的库和软件">安装需要的库和软件</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl openssh-server ca-certificates postfix</span><br></pre></td></tr></table></figure><p>postfix用来发送邮件，由于需要发送验证邮件，所以需要装这个，这里官方推荐postfix。</p><h3><span id="添加gitlab的包并进行安装">添加Gitlab的包并进行安装</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><p>除了上述安装脚本的方式，你还可以下载直接安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -LJO https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/xenial/gitlab-ce-XXX.deb/download</span><br><span class="line">dpkg -i gitlab-ce-XXX.deb</span><br></pre></td></tr></table></figure><h3><span id="配置和启动gitlab">配置和启动Gitlab</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure><ol><li>修改外部链接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_url &#x27;http://192.168.2.248:10080&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改时区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure><ol start="3"><li>邮箱设置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Email Settings</span></span></span><br><span class="line">gitlab_rails[&#x27;gitlab_email_enabled&#x27;] = true</span><br><span class="line">gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;xxx@your_mail.com&#x27;</span><br><span class="line">gitlab_rails[&#x27;gitlab_email_display_name&#x27;] = &#x27;Gitlab&#x27;</span><br><span class="line">gitlab_rails[&#x27;gitlab_email_reply_to&#x27;] = &#x27;xxx@your_mail.com&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">&#x27;gitlab_email_subject_suffix&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>邮箱服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## GitLab email server settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! Docs: https://docs.gitlab.com/omnibus/settings/smtp.html</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! **Use smtp instead of sendmail/postfix.**</span></span></span><br><span class="line"></span><br><span class="line">gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line">gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.exmail.qq.com&quot;</span><br><span class="line">gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line">gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;xxx@your_mail.com&quot;</span><br><span class="line">gitlab_rails[&#x27;smtp_password&#x27;] = &quot;your_password&quot;</span><br><span class="line">gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;exmail.qq.com&quot;</span><br><span class="line">gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line">gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line">gitlab_rails[&#x27;smtp_tls&#x27;] = false</span><br></pre></td></tr></table></figure><ol start="5"><li>nginx监听端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx[&#x27;listen_addresses&#x27;] = [&#x27;192.168.2.248&#x27;]</span><br><span class="line">nginx[&#x27;listen_port&#x27;] = 10080</span><br></pre></td></tr></table></figure><p>配置完成后，执行下面命令使变更生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><h3><span id="访问gitlab">访问Gitlab</span></h3><p>在浏览器输入 <a href="http://192.168.2.248:10080">http://192.168.2.248:10080</a> 即可访问。首次登录需要为root管理员设置密码。</p><h3><span id="汉化教程">汉化教程</span></h3><p>请先使用官方包安装或升级完成，确认当前版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</span><br></pre></td></tr></table></figure><p>假设当前版本为<code>v9.0.0</code>，并确认汉化版本库是否包含该版本的汉化标签(<code>-zh</code>结尾)，也就是是否包含<code>v9.0.0-zh</code>。如果版本相同，首先在本地<code>clone</code>仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆汉化版本库</span></span><br><span class="line">git clone https://gitlab.com/xhang/gitlab.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经克隆过，则进行更新</span></span><br><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>然后比较汉化标签和原标签，导出patch用的diff文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 导出9.0.0 版本的汉化补丁</span></span><br><span class="line">git diff v9.0.0 v9.0.0-zh &gt; ../9.0.0-zh.diff</span><br></pre></td></tr></table></figure><p>然后上传<code>9.0.0-zh.diff</code>文件到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止 gitlab</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line">sudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 9.0.0-zh.diff</span><br></pre></td></tr></table></figure><p>确定没有<code>.rej</code>文件，重启GitLab即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure><p>执行重新配置命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>如果汉化中出现问题，请重新安装Gitlab(注意备份数据)。</p><ul><li><a href="https://gitlab.com/larryli/gitlab/wikis/home">https://gitlab.com/larryli/gitlab/wikis/home</a></li></ul><h3><span id="参考官网">参考官网</span></h3><ul><li><a href="https://about.gitlab.com/downloads/#ubuntu1604">https://about.gitlab.com/downloads/#ubuntu1604</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 安装 JDK7 / JDK8的两种方式</title>
      <link href="/2017/05/01/java/ubuntu-oracle-jdk/"/>
      <url>/2017/05/01/java/ubuntu-oracle-jdk/</url>
      
        <content type="html"><![CDATA[<h3><span id="使用ppa源方式安装">使用ppa源方式安装</span></h3><ol><li>添加ppa</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ol start="2"><li>安装oracle-java-installer</li></ol><p>JDK7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install oracle-java7-installer</span><br></pre></td></tr></table></figure><p>JDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure><span id="more"></span><p>安装器会提示你同意 oracle 的服务条款,选择 ok</p><p>然后选择yes 即可</p><p>如果你懒,不想自己手动点击.也可以加入下面的这条命令,默认同意条款:</p><p>JDK7 默认选择条款</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo oracle-java7-installer shared/accepted-oracle-license-v1-1 select true | sudo /usr/bin/debconf-set-selections</span><br></pre></td></tr></table></figure><p>JDK8 默认选择条款</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | sudo /usr/bin/debconf-set-selections</span><br></pre></td></tr></table></figure><p>接下会是等待(依个人网速定)</p><p>如果你因为防火墙或者其他原因,导致installer 下载速度很慢,可以中断操作.然后下载好相应jdk的tar.gz 包,放在:</p><p>/var/cache/oracle-jdk7-installer             (jdk7)</p><p>/var/cache/oracle-jdk8-installer              (jdk8)</p><p>下面,然后安装一次installer. installer 则会默认使用 你下载的tar.gz包</p><ol start="3"><li>设置系统默认jdk</li></ol><p>JDk7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-java-alternatives -s java-7-oracle</span><br></pre></td></tr></table></figure><p>JDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-java-alternatives -s java-8-oracle</span><br></pre></td></tr></table></figure><p>如果即安装了jdk7,又安装了jdk8,要实现两者的切换,可以:</p><p>jdk8 切换到jdk7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-java-alternatives -s java-7-oracle</span><br></pre></td></tr></table></figure><p>jdk7 切换到jdk8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-java-alternatives -s java-8-oracle</span><br></pre></td></tr></table></figure><ol start="4"><li>测试jdk 是是否安装成功:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure><h3><span id="直接下载jdk压缩包方式安装这里只介绍jdk7的jdk8-的原理完全一致">直接下载jdk压缩包方式安装(这里只介绍jdk7的,jdk8 的原理完全一致)</span></h3><ol><li>官网下载JDK</li></ol><p>地址: <a href="http://www.oracle.com/technetwork/articles/javase/index-jsp-138363.html">下载</a> 选择相应的 .gz包下载</p><ol start="2"><li>解压缩,放到指定目录(以jdk-7u60-linux-x64.gz为例)</li></ol><p>创建目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/lib/jvm</span><br></pre></td></tr></table></figure><p>加压缩到该目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm</span><br></pre></td></tr></table></figure><ol start="3"><li>修改环境变量:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>文件的末尾追加下面内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> oracle jdk environment</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_60  ## 这里要注意目录要换成自己解压的jdk 目录</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH  </span><br></pre></td></tr></table></figure><p>使环境变量马上生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><ol start="4"><li>设置系统默认jdk 版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_60/bin/java 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.7.0_60/bin/javac 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.7.0_60/bin/jar 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.7.0_60/bin/javah 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.7.0_60/bin/javap 300   </span><br></pre></td></tr></table></figure><p>然后执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure><p>若是初次安装jdk,会有下面的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There is only one alternative in link group java (providing /usr/bin/java): </span><br><span class="line">    /usr/lib/jvm/jdk1.7.0_60/bin/java</span><br></pre></td></tr></table></figure><p>否者,选择合适的jdk</p><ol start="5"><li>测试jdk</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version &quot;1.7.0_60&quot;</span><br><span class="line">  Java(TM) SE Runtime Environment (build 1.7.0_60-b19)</span><br><span class="line">  Java HotSpot(TM) 64-Bit Server VM (build 24.60-b09, mixed mode)</span><br></pre></td></tr></table></figure><p>JDK 安装成功</p><p>ubuntu  两种下安装jdk7 jdk8 的方式介绍完毕</p><p>参考文章:</p><ul><li><a href="http://www.webupd8.org/2012/01/install-oracle-java-jdk-7-in-ubuntu-via.html">http://www.webupd8.org/2012/01/install-oracle-java-jdk-7-in-ubuntu-via.html</a></li><li><a href="http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html">http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习记录</title>
      <link href="/2017/04/28/docker/docker-learning/"/>
      <url>/2017/04/28/docker/docker-learning/</url>
      
        <content type="html"><![CDATA[<h2><span id="一-docker-简介">一、Docker 简介</span></h2><p>Docker 两个主要部件：</p><ul><li>Docker: 开源的容器虚拟化平台</li><li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – <a href="https://registry.hub.docker.com/search?q=library">Docker Hub</a></li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p><span id="more"></span><p><img src="/img/docker/docker_arch.png" alt="Docker's architecture"></p><h3><span id="11-docker-守护进程">1.1 Docker 守护进程</span></h3><p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p><h3><span id="12-docker-客户端">1.2 Docker 客户端</span></h3><p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p><h3><span id="13-docker-内部">1.3 Docker 内部</span></h3><p>要理解 Docker 内部构建，需要理解以下三种部件：</p><ul><li>Docker 镜像 - Docker images</li><li>Docker 仓库 - Docker registeries</li><li>Docker 容器 - Docker containers</li></ul><h4><span id="docker-镜像">Docker 镜像</span></h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p><h4><span id="docker-仓库">Docker 仓库</span></h4><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p><h4><span id="docker-容器">Docker 容器</span></h4><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p><h3><span id="14-libcontainer">1.4 libcontainer</span></h3><p>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：</p><p><img src="/img/docker/libcontainer-linux.png" alt="libcontainer"></p><ul><li>图片来源: <a href="http://blog.docker.com/2014/03/docker-0-9-introducing-execution-drivers-and-libcontainer/">Docker 0.9: introducing execution drivers and libcontainer</a></li></ul><h3><span id="15-命名空间namespaces">1.5 命名空间「Namespaces」</span></h3><h4><span id="pid-namespace">pid namespace</span></h4><p>不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p><ul><li>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li><li>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li><li>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li><li>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</li></ul><p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/">Introduction to Linux namespaces – Part 3: PID</a></p><h4><span id="mnt-namespace">mnt namespace</span></h4><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace  中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p><h4><span id="net-namespace">net namespace</span></h4><p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/">Introduction to Linux namespaces – Part 5: NET</a></p><h4><span id="uts-namespace">uts namespace</span></h4><p>UTS (“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction to Linux namespaces – Part 1: UTS</a></p><h4><span id="ipc-namespace">ipc namespace</span></h4><p>container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/">Introduction to Linux namespaces – Part 2: IPC</a></p><h4><span id="user-namespace">user namespace</span></h4><p>每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p><h4><span id="reference">Reference</span></h4><ul><li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/">Docker Getting Start: Related Knowledge </a></li><li><a href="https://ruby-china.org/topics/22004">Docker 介绍以及其相关术语、底层原理和技术</a></li></ul><h3><span id="16-资源配额cgroups">1.6 资源配额「cgroups」</span></h3><p>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usage_in_bytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p><ul><li>memory<ul><li>内存相关的限制</li></ul></li><li>cpu<ul><li>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li></ul></li><li>blkio<ul><li>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li></ul></li><li>devices<ul><li>设备权限限制</li></ul></li></ul><p>参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/">how to use cgroup</a></p><h2><span id="二-docker-安装">二、Docker 安装</span></h2><p>docker 的相关安装方法这里不作介绍，具体安装参考 <a href="https://docs.docker.com/installation/">官档</a></p><p>获取当前 docker 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker version</span></span><br><span class="line">Client version: 1.3.2</span><br><span class="line">Client API version: 1.15</span><br><span class="line">Go version (client): go1.3.3</span><br><span class="line">Git commit (client): 39fa2fa/1.3.2</span><br><span class="line">OS/Arch (client): linux/amd64</span><br><span class="line">Server version: 1.3.2</span><br><span class="line">Server API version: 1.15</span><br><span class="line">Go version (server): go1.3.3</span><br><span class="line">Git commit (server): 39fa2fa/1.3.2</span><br></pre></td></tr></table></figure><h2><span id="三-docker-基础用法">三、Docker 基础用法</span></h2><p><a href="https://registry.hub.docker.com/">Docker HUB</a> : Docker镜像首页，包括官方镜像和其它公开镜像</p><p>因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 <a href="http://daocloud.com/">Daocloud</a> 镜像加速。</p><h3><span id="31-search-images">3.1 Search images</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker search ubuntu</span></span><br></pre></td></tr></table></figure><h3><span id="32-pull-images">3.2 Pull images</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull ubuntu <span class="comment"># 获取 ubuntu 官方镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images <span class="comment"># 查看当前镜像列表</span></span></span><br></pre></td></tr></table></figure><h3><span id="33-running-an-interactive-shell">3.3 Running an interactive shell</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -i -t ubuntu:14.04 /bin/bash</span></span><br></pre></td></tr></table></figure><ul><li>docker run - 运行一个容器</li><li>-t - 分配一个（伪）tty (link is external)</li><li>-i - 交互模式 (so we can interact with it)</li><li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li><li>/bin/bash - 运行命令 bash shell</li></ul><p><strong>注:</strong> ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps <span class="comment"># 查看当前运行的容器, ps -a 列出当前系统所有的容器</span></span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6c9129e9df10        ubuntu:14.04        /bin/bash           6 minutes ago       Up 6 minutes                            cranky_babbage</span><br></pre></td></tr></table></figure><h3><span id="34-相关快捷键">3.4 相关快捷键</span></h3><ul><li>退出：<code>Ctrl-D</code> or <code>exit</code></li><li>detach：<code>Ctrl-P + Ctrl-Q</code></li><li>attach: <code>docker attach CONTAINER-ID</code></li></ul><h2><span id="四-docker-命令帮助">四、Docker 命令帮助</span></h2><h3><span id="41-docker-help">4.1 docker help</span></h3><h4><span id="docker-command">docker command</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker   <span class="comment"># docker 命令帮助</span></span></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line">    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line">    commit    Create a new image from a container&#x27;s changes # 提交当前容器为新的镜像</span><br><span class="line">    cp        Copy files/folders from the containers filesystem to the host path</span><br><span class="line">              # 从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line">    diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化</span><br><span class="line">    events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line">    exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line">    export    Stream the contents of a container as a tar archive</span><br><span class="line">              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line">    history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line">    images    List images                                   # 列出系统当前镜像</span><br><span class="line">    import    Create a new filesystem image from the contents of a tarball</span><br><span class="line">              # 从tar包中的内容创建一个新的文件系统映像[对应 export]</span><br><span class="line">    info      Display system-wide information               # 显示系统相关信息</span><br><span class="line">    inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line">    kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line">    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line">    login     Register or Login to the docker registry server</span><br><span class="line">              # 注册或者登陆一个 docker 源服务器</span><br><span class="line">    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出</span><br><span class="line">    logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line">    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</span><br><span class="line">              # 查看映射端口对应的容器内部源端口</span><br><span class="line">    pause     Pause all processes within a container        # 暂停容器</span><br><span class="line">    ps        List containers                               # 列出容器列表</span><br><span class="line">    pull      Pull an image or a repository from the docker registry server</span><br><span class="line">              # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">    push      Push an image or a repository to the docker registry server</span><br><span class="line">              # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">    restart   Restart a running container                   # 重启运行的容器</span><br><span class="line">    rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line">    rmi       Remove one or more images</span><br><span class="line">              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">    run       Run a command in a new container</span><br><span class="line">              # 创建一个新的容器并运行一个命令</span><br><span class="line">    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line">    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line">    start     Start a stopped containers                    # 启动容器</span><br><span class="line">    stop      Stop a running containers                     # 停止容器</span><br><span class="line">    tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line">    top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line">    unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line">    version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line">    wait      Block until a container stops, then print its exit code</span><br><span class="line">              # 截取容器停止时的退出状态值</span><br><span class="line">Run &#x27;docker COMMAND --help&#x27; for more information on a command.</span><br></pre></td></tr></table></figure><h4><span id="docker-option">docker option</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage of docker:</span><br><span class="line">  --api-enable-cors=false                Enable CORS headers in the remote API                      # 远程 API 中开启 CORS 头</span><br><span class="line">  -b, --bridge=&quot;&quot;                        Attach containers to a pre-existing network bridge         # 桥接网络</span><br><span class="line">                                           use &#x27;none&#x27; to disable container networking</span><br><span class="line">  --bip=&quot;&quot;                               Use this CIDR notation address for the network bridge&#x27;s IP, not compatible with -b</span><br><span class="line">                                         # 和 -b 选项不兼容，具体没有测试过</span><br><span class="line">  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式</span><br><span class="line">  -D, --debug=false                      Enable debug mode                                          # debug 模式</span><br><span class="line">  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器</span><br><span class="line">  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域</span><br><span class="line">  -e, --exec-driver=&quot;native&quot;             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器</span><br><span class="line">  --fixed-cidr=&quot;&quot;                        IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)</span><br><span class="line">                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)</span><br><span class="line">  -G, --group=&quot;docker&quot;                   Group to assign the unix socket specified by -H when running in daemon mode</span><br><span class="line">                                           use &#x27;&#x27; (the empty string) to disable setting of a group</span><br><span class="line">  -g, --graph=&quot;/var/lib/docker&quot;          Path to use as the root of the docker runtime              # 容器运行的根目录路径</span><br><span class="line">  -H, --host=[]                          The socket(s) to bind to in daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]</span><br><span class="line">                                           specified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.</span><br><span class="line">  --icc=true                             Enable inter-container communication                       # 跨容器通信</span><br><span class="line">  --insecure-registry=[]                 Enable insecure communication with specified registries (no certificate verification for HTTPS and enable HTTP fallback) (e.g., localhost:5000 or 10.20.0.0/16)</span><br><span class="line">  --ip=&quot;0.0.0.0&quot;                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip</span><br><span class="line">  --ip-forward=true                      Enable net.ipv4.ip_forward                                 # 开启转发</span><br><span class="line">  --ip-masq=true                         Enable IP masquerading for bridge&#x27;s IP range</span><br><span class="line">  --iptables=true                        Enable Docker&#x27;s addition of iptables rules                 # 添加对应 iptables 规则</span><br><span class="line">  --mtu=0                                Set the containers network MTU                             # 设置网络 mtu</span><br><span class="line">                                           if no value is provided: default to the default route MTU or 1500 if no default route is available</span><br><span class="line">  -p, --pidfile=&quot;/var/run/docker.pid&quot;    Path to use for daemon PID file                            # 指定 pid 文件位置</span><br><span class="line">  --registry-mirror=[]                   Specify a preferred Docker registry mirror</span><br><span class="line">  -s, --storage-driver=&quot;&quot;                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动</span><br><span class="line">  --selinux-enabled=false                Enable selinux support                                     # 开启 selinux 支持</span><br><span class="line">  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项</span><br><span class="line">  --tls=false                            Use TLS; implied by tls-verify flags                       # 开启 tls</span><br><span class="line">  --tlscacert=&quot;/root/.docker/ca.pem&quot;     Trust only remotes providing a certificate signed by the CA given here</span><br><span class="line">  --tlscert=&quot;/root/.docker/cert.pem&quot;     Path to TLS certificate file                               # tls 证书文件位置</span><br><span class="line">  --tlskey=&quot;/root/.docker/key.pem&quot;       Path to TLS key file                                       # tls key 文件位置</span><br><span class="line">  --tlsverify=false                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机</span><br><span class="line">  -v, --version=false                    Print version information and quit                         # 输出 docker 版本信息</span><br></pre></td></tr></table></figure><h3><span id="42-docker-search">4.2 docker search</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker search --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker search TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images     # 从 Docker Hub 搜索镜像</span><br><span class="line"></span><br><span class="line">  --automated=false    Only show automated builds</span><br><span class="line">  --no-trunc=false     Don&#x27;t truncate output</span><br><span class="line">  -s, --stars=0        Only displays with at least xxx stars</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker search -s 100 ubuntu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像</span></span><br><span class="line">NAME      DESCRIPTION                  STARS     OFFICIAL   AUTOMATED</span><br><span class="line">ubuntu    Official Ubuntu base image   425       [OK]</span><br></pre></td></tr></table></figure><h3><span id="43-docker-info">4.3 docker info</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker info</span></span><br><span class="line">Containers: 1                       # 容器个数</span><br><span class="line">Images: 22                          # 镜像个数</span><br><span class="line">Storage Driver: devicemapper        # 存储驱动</span><br><span class="line"> Pool Name: docker-8:17-3221225728-pool</span><br><span class="line"> Pool Blocksize: 65.54 kB</span><br><span class="line"> Data file: /data/docker/devicemapper/devicemapper/data</span><br><span class="line"> Metadata file: /data/docker/devicemapper/devicemapper/metadata</span><br><span class="line"> Data Space Used: 1.83 GB</span><br><span class="line"> Data Space Total: 107.4 GB</span><br><span class="line"> Metadata Space Used: 2.191 MB</span><br><span class="line"> Metadata Space Total: 2.147 GB</span><br><span class="line"> Library Version: 1.02.84-RHEL7 (2014-03-26)</span><br><span class="line">Execution Driver: native-0.2        # 存储驱动</span><br><span class="line">Kernel Version: 3.10.0-123.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br></pre></td></tr></table></figure><h3><span id="44-docker-pull-ampamp-docker-push">4.4 docker pull &amp;&amp; docker push</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull --<span class="built_in">help</span>           <span class="comment"># pull 拉取镜像</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from the registry</span><br><span class="line"></span><br><span class="line">  -a, --all-tags=false    Download all tagged images in the repository</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker push                  <span class="comment"># push 推送指定镜像</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker push NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Push an image or a repository to the registry</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull ubuntu           <span class="comment"># 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull ubuntu:14.04     <span class="comment"># 下载指定版本 ubuntu 官方镜像</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker push 192.168.0.100:5000/ubuntu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker push 192.168.0.100:5000/ubuntu:14.04</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送指定镜像到私有源</span></span><br></pre></td></tr></table></figure><h3><span id="45-docker-images">4.5 docker images</span></h3><p>列出当前系统镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker images [OPTIONS] [NAME]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">  -a, --all=false      Show all images (by default filter out the intermediate image layers)</span><br><span class="line"><span class="meta">  #</span><span class="bash"> -a 显示当前系统的所有镜像，包括过渡层镜像，默认 docker images 显示最终镜像，不包括过渡层镜像</span></span><br><span class="line">  -f, --filter=[]      Provide filter values (i.e. &#x27;dangling=true&#x27;)</span><br><span class="line">  --no-trunc=false     Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet=false    Only show numeric IDs</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images            <span class="comment"># 显示当前系统镜像，不包括过渡层镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images -a         <span class="comment"># 显示当前系统所有镜像，包括过渡层镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images ubuntu     <span class="comment"># 显示当前系统 docker ubuntu 库中的所有镜像</span></span></span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                     12.04               ebe4be4dd427        4 weeks ago         210.6 MB</span><br><span class="line">ubuntu                     14.04               e54ca5efa2e9        4 weeks ago         276.5 MB</span><br><span class="line">ubuntu                     14.04-ssh           6334d3ac099a        7 weeks ago         383.2 MB</span><br></pre></td></tr></table></figure><h3><span id="46-docker-rmi">4.6 docker rmi</span></h3><p>删除一个或者多个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker rmi --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker rmi IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">  -f, --force=false    Force removal of the image       # 强制移除镜像不管是否有容器使用该镜像</span><br><span class="line">  --no-prune=false     Do not delete untagged parents   # 不要删除未标记的父镜像</span><br></pre></td></tr></table></figure><h3><span id="47-docker-run">4.7 docker run</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">  -a, --attach=[]            Attach to stdin, stdout or stderr.</span><br><span class="line">  -c, --cpu-shares=0         CPU shares (relative weight)                       # 设置 cpu 使用权重</span><br><span class="line">  --cap-add=[]               Add Linux capabilities</span><br><span class="line">  --cap-drop=[]              Drop Linux capabilities</span><br><span class="line">  --cidfile=&quot;&quot;               Write the container ID to the file                 # 把容器 id 写入到指定文件</span><br><span class="line">  --cpuset=&quot;&quot;                CPUs in which to allow execution (0-3, 0,1)        # cpu 绑定</span><br><span class="line">  -d, --detach=false         Detached mode: Run container in the background, print new container id # 后台运行容器</span><br><span class="line">  --device=[]                Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc)</span><br><span class="line">  --dns=[]                   Set custom dns servers                             # 设置 dns</span><br><span class="line">  --dns-search=[]            Set custom dns search domains                      # 设置 dns 域搜索</span><br><span class="line">  -e, --env=[]               Set environment variables                          # 定义环境变量</span><br><span class="line">  --entrypoint=&quot;&quot;            Overwrite the default entrypoint of the image      # ？</span><br><span class="line">  --env-file=[]              Read in a line delimited file of ENV variables     # 从指定文件读取变量值</span><br><span class="line">  --expose=[]                Expose a port from the container without publishing it to your host    # 指定对外提供服务端口</span><br><span class="line">  -h, --hostname=&quot;&quot;          Container host name                                # 设置容器主机名</span><br><span class="line">  -i, --interactive=false    Keep stdin open even if not attached               # 保持标准输出开启即使没有 attached</span><br><span class="line">  --link=[]                  Add link to another container (name:alias)         # 添加链接到另外一个容器</span><br><span class="line">  --lxc-conf=[]              (lxc exec-driver only) Add custom lxc options --lxc-conf=&quot;lxc.cgroup.cpuset.cpus = 0,1&quot;</span><br><span class="line">  -m, --memory=&quot;&quot;            Memory limit (format: &lt;number&gt;&lt;optional unit&gt;, where unit = b, k, m or g) # 内存限制</span><br><span class="line">  --name=&quot;&quot;                  Assign a name to the container                     # 设置容器名</span><br><span class="line">  --net=&quot;bridge&quot;             Set the Network mode for the container             # 设置容器网络模式</span><br><span class="line">                               &#x27;bridge&#x27;: creates a new network stack for the container on the docker bridge</span><br><span class="line">                               &#x27;none&#x27;: no networking for this container</span><br><span class="line">                               &#x27;container:&lt;name|id&gt;&#x27;: reuses another container network stack</span><br><span class="line">                               &#x27;host&#x27;: use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.</span><br><span class="line">  -P, --publish-all=false    Publish all exposed ports to the host interfaces   # 自动映射容器对外提供服务的端口</span><br><span class="line">  -p, --publish=[]           Publish a container&#x27;s port to the host             # 指定端口映射</span><br><span class="line">                               format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</span><br><span class="line">                               (use &#x27;docker port&#x27; to see the actual mapping)</span><br><span class="line">  --privileged=false         Give extended privileges to this container         # 提供更多的权限给容器</span><br><span class="line">  --restart=&quot;&quot;               Restart policy to apply when a container exits (no, on-failure[:max-retry], always)</span><br><span class="line">  --rm=false                 Automatically remove the container when it exits (incompatible with -d) # 如果容器退出自动移除和 -d 选项冲突</span><br><span class="line">  --security-opt=[]          Security Options</span><br><span class="line">  --sig-proxy=true           Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied.</span><br><span class="line">  -t, --tty=false            Allocate a pseudo-tty                              # 分配伪终端</span><br><span class="line">  -u, --user=&quot;&quot;              Username or UID                                    # 指定运行容器的用户 uid 或者用户名</span><br><span class="line">  -v, --volume=[]            Bind mount a volume (e.g., from the host: -v /host:/container, from docker: -v /container)</span><br><span class="line">                             # 挂载卷</span><br><span class="line">  --volumes-from=[]          Mount volumes from the specified container(s)      # 从指定容器挂载卷</span><br><span class="line">  -w, --workdir=&quot;&quot;           Working directory inside the container             # 指定容器工作目录</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images ubuntu</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu              14.04               e54ca5efa2e9        4 weeks ago         276.5 MB</span><br><span class="line">... ...</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -c 100 -m 512MB -h test1 -d --name=<span class="string">&quot;docker_test1&quot;</span> ubuntu /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器</span></span><br><span class="line">a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES</span><br><span class="line">a424ca613c9f        ubuntu:14.04    /bin/bash       6 seconds ago       Up 5 seconds                    docker_test1</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker attach docker_test1</span></span><br><span class="line">root@test1:/# pwd</span><br><span class="line">/</span><br><span class="line">root@test1:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>关于cpu优先级:</strong></p><blockquote><p>By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time - <a href="https://wiki.archlinux.org/index.php/cgroups">archlinux cgroups</a></p></blockquote><h3><span id="48-docker-startstopkill">4.8 docker start|stop|kill… …</span></h3><ul><li>docker start CONTAINER [CONTAINER…]<ul><li># 运行一个或多个停止的容器</li></ul></li><li>docker stop CONTAINER [CONTAINER…]<ul><li># 停掉一个或多个运行的容器 <code>-t</code> 选项可指定超时时间</li></ul></li><li>docker kill [OPTIONS] CONTAINER [CONTAINER…]<ul><li># 默认 kill 发送 SIGKILL 信号 <code>-s</code> 可以指定发送 kill 信号类型</li></ul></li><li>docker restart [OPTIONS] CONTAINER [CONTAINER…]<ul><li># 重启一个或多个运行的容器 <code>-t</code> 选项可指定超时时间</li></ul></li><li>docker pause CONTAINER<ul><li># 暂停一个容器，方便 commit</li></ul></li><li>docker unpause CONTAINER<ul><li># 继续暂停的容器</li></ul></li><li>docker rm [OPTIONS] CONTAINER [CONTAINER…]<ul><li># 移除一个或多个容器</li><li>-f, --force=false      Force removal of running container</li><li>-l, --link=false       Remove the specified link and not the underlying container</li><li>-v, --volumes=false    Remove the volumes associated with the container</li></ul></li><li>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<ul><li># 提交指定容器为镜像</li><li>-a, --author=“”     Author (e.g., “John Hannibal Smith <a href="mailto:hannibal@a-team.com">hannibal@a-team.com</a>”)</li><li>-m, --message=“”    Commit message</li><li>-p, --pause=true    Pause container during commit<ul><li># 默认 commit 是暂停状态</li></ul></li></ul></li><li>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE…]<ul><li># 查看容器或者镜像的详细信息</li></ul></li><li>docker logs CONTAINER<ul><li># 输出指定容器日志信息</li><li>-f, --follow=false        Follow log output<ul><li># 类似 tail -f</li></ul></li><li>-t, --timestamps=false    Show timestamps</li><li>–tail=“all”              Output the specified number of lines at the end of logs (defaults to all logs)</li></ul></li></ul><p>参考文档：<a href="https://docs.docker.com/reference/run/">Docker Run Reference</a></p><h3><span id="49-docker-13-新增特性和命令">4.9 Docker 1.3 新增特性和命令</span></h3><h4><span id="digital-signature-verification">Digital Signature Verification</span></h4><p>Docker 1.3 版本将使用数字签名自动验证所有官方库的来源和完整性，如果一个官方镜像被篡改或者被破坏，目前 Docker 只会对这种情况发出警告而并不阻止容器的运行。</p><h4><span id="inject-new-processes-with-docker-exec">Inject new processes with <code>docker exec</code></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec --help</span><br><span class="line"></span><br><span class="line">Usage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in an existing container</span><br><span class="line"></span><br><span class="line">  -d, --detach=false         Detached mode: run command in the background</span><br><span class="line">  -i, --interactive=false    Keep STDIN open even if not attached</span><br><span class="line">  -t, --tty=false            Allocate a pseudo-TTY</span><br></pre></td></tr></table></figure><p>为了简化调试，可以使用 <code>docker exec</code> 命令通过 Docker API 和 CLI 在运行的容器上运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it ubuntu_bash bash</span></span><br></pre></td></tr></table></figure><p>上例将在容器 ubuntu_bash 中创建一个新的 Bash 会话。</p><h4><span id="tune-container-lifecycles-with-docker-create">Tune container lifecycles with <code>docker create</code></span></h4><p>我们可以通过 <code>docker run &lt;image name&gt;</code> 命令创建一个容器并运行其中的程序，因为有很多用户要求创建容器的时候不启动容器，所以 <code>docker create</code> 应运而生了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker create -t -i fedora bash</span></span><br><span class="line">6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752</span><br></pre></td></tr></table></figure><p>上例创建了一个可写的容器层 (并且打印出容器 ID)，但是并不运行它，可以使用以下命令运行该容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker start -a -i 6d8af538ec5</span></span><br><span class="line">bash-4.2#</span><br></pre></td></tr></table></figure><h4><span id="security-options">Security Options</span></h4><p>通过 <code>--security-opt</code> 选项，运行容器时用户可自定义 SELinux 和 AppArmor 卷标和配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --security-opt label:<span class="built_in">type</span>:svirt_apache -i -t centos \ bash</span></span><br></pre></td></tr></table></figure><p>上例只允许容器监听在 Apache 端口，这个选项的好处是用户不需要运行 docker 的时候指定 <code>--privileged</code> 选项，降低安全风险。</p><p>参考文档：<a href="http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/">Docker 1.3: signed images, process injection, security options, Mac shared directories</a></p><h3><span id="410-docker-15-新特性">4.10 Docker 1.5 新特性</span></h3><p>参考文档：<a href="http://dockerone.com/article/202">Docker 1.5 新特性</a></p><h2><span id="五-docker-端口映射">五、Docker 端口映射</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker inspect &lt;container_id&gt; | grep IPAddress | cut -d ’<span class="string">&quot;’ -f 4</span></span></span><br></pre></td></tr></table></figure><p>无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。</p><p>Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。</p><h3><span id="51-自动映射端口">5.1 自动映射端口</span></h3><p><code>-P</code> 使用时需要指定 <code>--expose</code> 选项，指定需要对外提供服务的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -P --expose 22 --name server  ubuntu:14.04</span></span><br></pre></td></tr></table></figure><p>使用 <code>docker run -P</code> 自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000…49900) 自动选择，你可以通过 <code>docker ps</code> 、<code>docker inspect &lt;container_id&gt;</code> 或者 <code>docker port &lt;container_id&gt; &lt;port&gt;</code> 确定具体的绑定信息。</p><h3><span id="52-绑定端口到指定接口">5.2 绑定端口到指定接口</span></h3><p>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;</span></span><br></pre></td></tr></table></figure><p>默认不指定绑定 ip 则监听所有网络接口。</p><h4><span id="绑定-tcp-端口">绑定 TCP 端口</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p 127.0.0.1:80:8080 &lt;image&gt; &lt;cmd&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p 127.0.0.1::8080 &lt;image&gt; &lt;cmd&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p 80:8080 &lt;image&gt; &lt;cmd&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p 8080 &lt;image&gt; &lt;cmd&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="绑定-udp-端口">绑定 UDP 端口</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -p 127.0.0.1:53:5353/udp &lt;image&gt; &lt;cmd&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="六-docker-网络配置">六、Docker 网络配置</span></h2><p><img src="/img/docker/docker_networking.png" alt="docker_networking"></p><p>图: <a href="http://www.slideshare.net/janghoonsim/docker-container-and-lightweight-virtualization">Docker - container and lightweight virtualization</a></p><p>Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：</p><ul><li>creates the docker0 bridge if not present<ul><li># 如果 docker0 不存在则创建</li></ul></li><li>searches for an IP address range which doesn’t overlap with an existing route<ul><li># 搜索一个与当前路由不冲突的 ip 段</li></ul></li><li>picks an IP in the selected range<ul><li># 在确定的范围中选择 ip</li></ul></li><li>assigns this IP to the docker0 bridge<ul><li># 绑定 ip 到 docker0</li></ul></li></ul><h3><span id="61-docker-四种网络模式">6.1 Docker 四种网络模式</span></h3><p>四种网络模式摘自 <a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker 网络详解及 pipework 源码解读与实践 </a></p><p>docker run 创建 Docker 容器时，可以用 --net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p><ul><li>host 模式，使用 --net=host 指定。</li><li>container 模式，使用 --net=container:NAME_or_ID 指定。</li><li>none 模式，使用 --net=none 指定。</li><li>bridge 模式，使用 --net=bridge 指定，默认设置。</li></ul><h4><span id="host-模式">host 模式</span></h4><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p><p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><h4><span id="container-模式">container 模式</span></h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><h4><span id="none模式">none模式</span></h4><p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><h4><span id="bridge模式">bridge模式</span></h4><p><img src="/img/docker/vethbridge.png" alt="vethbridge"></p><p>图:<a href="http://www.wickedawesometech.us/2014/07/the-container-world-part-2-networking.html">The Container World Part 2 Networking</a></p><p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p><h3><span id="62-列出当前主机网桥">6.2 列出当前主机网桥</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl show  <span class="comment"># brctl 工具依赖 bridge-utils 软件包</span></span></span><br><span class="line">bridge name bridge id STP enabled interfaces</span><br><span class="line">docker0 8000.000000000000 no</span><br></pre></td></tr></table></figure><h3><span id="63-查看当前-docker0-ip">6.3 查看当前 docker0 ip</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig docker0</span></span><br><span class="line">docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx</span><br><span class="line">inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0</span><br></pre></td></tr></table></figure><p>在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。</p><h3><span id="64-运行一个容器">6.4 运行一个容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d ubuntu /bin/bash</span></span><br><span class="line">52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl show</span></span><br><span class="line">bridge name bridge id STP enabled interfaces</span><br><span class="line">docker0 8000.fef213db5a66 no vethQCDY1N</span><br></pre></td></tr></table></figure><p>以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。</p><h4><span id="使用特定范围的-ip">使用特定范围的 IP</span></h4><p>Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过 <code>-b</code> 选项自定义桥接网卡，需要安装 <code>bridge-utils</code> 软件包。</p><p>基本步骤如下：</p><ul><li>ensure Docker is stopped<ul><li># 确保 docker 的进程是停止的</li></ul></li><li>create your own bridge (bridge0 for example)<ul><li># 创建自定义网桥</li></ul></li><li>assign a specific IP to this bridge<ul><li># 给网桥分配特定的 ip</li></ul></li><li>start Docker with the -b=bridge0 parameter<ul><li># 以 -b 的方式指定网桥</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Stopping Docker and removing docker0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl delbr docker0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create our own bridge</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl addbr bridge0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip addr add 192.168.5.1/24 dev bridge0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev bridge0 up</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Confirming that our bridge is up and running</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip addr show bridge0</span></span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell Docker about it and restart (on Ubuntu)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;DOCKER_OPTS=&quot;-b=bridge0&quot;&#x27;</span> &gt;&gt; /etc/default/docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker start</span></span><br></pre></td></tr></table></figure><p>参考文档: <a href="https://docs.docker.com/articles/networking/">Network Configuration</a></p><h3><span id="65-不同主机间容器通信">6.5 不同主机间容器通信</span></h3><p>不同容器之间的通信可以借助于 pipework 这个工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/jpetazzo/pipework.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp -rp pipework/pipework /usr/<span class="built_in">local</span>/bin/</span></span><br></pre></td></tr></table></figure><h4><span id="安装相应依赖软件">安装相应依赖软件</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install iputils-arping bridge-utils -y</span></span><br></pre></td></tr></table></figure><h4><span id="桥接网络">桥接网络</span></h4><p>桥接网络可以参考 <a href="https://github.com/opskumu/Day/blob/master/tips/tips.md">日常问题处理 Tips</a> 关于桥接的配置说明，这里不再赘述。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.000c291412cd       no              eth0</span><br><span class="line">docker0         8000.56847afe9799       no              vetheb48029</span><br></pre></td></tr></table></figure><p>可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。</p><ul><li>ubuntu</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl delbr docker0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;DOCKER_OPTS=&quot;-b=br0&quot;&#x27;</span> &gt;&gt; /etc/default/docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker start</span></span><br></pre></td></tr></table></figure><ul><li>CentOS 7/RHEL 7</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl delbr docker0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/sysconfig/docker | grep <span class="string">&#x27;OPTIONS=&#x27;</span></span></span><br><span class="line">OPTIONS=--selinux-enabled -b=br0 -H fd://</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><h4><span id="pipework">pipework</span></h4><p><img src="/img/docker/docker_bridge.png" alt="docker 桥接图"></p><p>不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/jpetazzo/pipework.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp -rp pipework/pipework /usr/<span class="built_in">local</span>/bin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pipework</span></span><br><span class="line">Syntax:</span><br><span class="line">pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; &lt;ipaddr&gt;/&lt;subnet&gt;[@default_gateway] [macaddr][@vlan]</span><br><span class="line">pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; dhcp [macaddr][@vlan]</span><br><span class="line">pipework --wait [-i containerinterface]</span><br></pre></td></tr></table></figure><p>如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上 <code>--net=none</code>，防止自动分配的 IP 在局域网中有冲突。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --rm -ti --net=none ubuntu:14.04 /bin/bash</span></span><br><span class="line">root@a46657528059:/#</span><br><span class="line"><span class="meta">$</span><span class="bash">                  <span class="comment"># Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker  ps</span></span><br><span class="line">CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES</span><br><span class="line">a46657528059    ubuntu:14.04   &quot;/bin/bash&quot;   4 minutes ago   Up 4 minutes               hungry_lalande</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认不指定网卡设备名，则默认添加为 eth1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=<span class="literal">true</span> 权限在容器中手动添加，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但这种安全性有缺陷，可以通过 ip netns 操作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker attach a46657528059</span></span><br><span class="line">root@a46657528059:/# ifconfig eth0</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d</span><br><span class="line">          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:690 (690.0 B)</span><br><span class="line"></span><br><span class="line">root@a46657528059:/# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><p>使用 <code>ip netns</code> 添加静态路由，避免创建容器使用 <code>--privileged=true</code> 选项造成一些不必要的安全问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --format=<span class="string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span> a46657528059 <span class="comment"># 获取指定容器 pid</span></span></span><br><span class="line">6350</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /proc/6350/ns/net /var/run/netns/6350</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip netns <span class="built_in">exec</span> 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip netns <span class="built_in">exec</span> 6350 ip route    <span class="comment"># 添加成功</span></span></span><br><span class="line">192.168.0.0/16 via 192.168.115.2 dev eth0</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。</p><p>另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：</p><ul><li><a href="https://github.com/jpetazzo/pipework">Pipework 官方文档</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker 网络详解及 pipework 源码解读与实践 </a></li></ul><h2><span id="七-dockerfile">七、Dockerfile</span></h2><p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过 <code>docker build</code> 命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p><p>Dockerfile 有以下指令选项:</p><ul><li><code>FROM</code></li><li><code>MAINTAINER</code></li><li><code>RUN</code></li><li><code>CMD</code></li><li><code>EXPOSE</code></li><li><code>ENV</code></li><li><code>ADD</code></li><li><code>COPY</code></li><li><code>ENTRYPOINT</code></li><li><code>VOLUME</code></li><li><code>USER</code></li><li><code>WORKDIR</code></li><li><code>ONBUILD</code></li></ul><h3><span id="71-from">7.1 FROM</span></h3><p>用法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><ul><li><code>FROM</code> 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li><li><code>FROM</code> 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 <code>FROM</code> 语句开始。</li><li><code>FROM</code> 可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。</li><li>如果 <code>FROM</code> 语句没有指定镜像标签，则默认使用 <code>latest</code> 标签。</li></ul><h3><span id="72-maintainer">7.2 MAINTAINER</span></h3><p>用法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>指定创建镜像的用户</p><p>RUN 有两种使用方式</p><ul><li>RUN <command> (the command is run in a shell - /bin/sh -c - shell form)</li><li>RUN [“executable”, “param1”, “param2”] (exec form)</li></ul><p>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的 <code>RUN</code> 都在之前 <code>RUN</code> 提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。</p><p>exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure><p><code>RUN</code> 产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用 <code>--no-cache</code> 选项，即 <code>docker build --no-cache</code>，如此便不会缓存。</p><h3><span id="73-cmd">7.3 CMD</span></h3><p><code>CMD</code> 有三种使用方式:</p><ul><li>CMD [“executable”,“param1”,“param2”] (exec form, this is the preferred form, 优先选择)</li><li>CMD [“param1”,“param2”] (as default parameters to <code>ENTRYPOINT</code>)</li><li>CMD command param1 param2 (shell form)</li></ul><p><code>CMD</code> 指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p><p><code>CMD</code> 的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p><blockquote><p><code>CMD</code> 会在启动容器的时候执行，build 时不执行，而 <code>RUN</code> 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 <code>RUN</code> 无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p></blockquote><h3><span id="74-expose">7.4 EXPOSE</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 <code>-p</code> 或者 <code>-P</code> 选项生效。</p><h3><span id="75-env">7.5 ENV</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量</span><br></pre></td></tr></table></figure><p>指定一个环节变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保留。</p><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br></pre></td></tr></table></figure><h3><span id="76-add">7.6 ADD</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p><code>ADD</code> 复制本地主机文件、目录或者远程文件 URLS 从 &lt;src&gt; 并且添加到容器指定路径中 &lt;dest&gt;。</p><p>&lt;src&gt; 支持通过 GO 的正则模糊匹配，具体规则可参见 <a href="http://golang.org/pkg/path/filepath/#Match">Go filepath.Match</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD hom* /mydir/        # adds all files starting with &quot;hom&quot;</span><br><span class="line">ADD hom?.txt /mydir/    # ? is replaced with any single character</span><br></pre></td></tr></table></figure><ul><li>&lt;dest&gt; 路径必须是绝对路径，如果 &lt;dest&gt; 不存在，会自动创建对应目录</li><li>&lt;src&gt; 路径必须是 Dockerfile 所在路径的相对路径</li><li>&lt;src&gt; 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li></ul><h3><span id="77-copy">7.7 COPY</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p><code>COPY</code> 复制新文件或者目录从 &lt;src&gt; 添加到容器指定路径中 &lt;dest&gt;。用法同 <code>ADD</code>，唯一的不同是不能指定远程文件 URLS。</p><h3><span id="78-entrypoint">7.8 ENTRYPOINT</span></h3><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] (the preferred exec form，优先选择)</li><li>ENTRYPOINT command param1 param2 (shell form)</li></ul><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而 <code>CMD</code> 是可以被覆盖的。如果需要覆盖，则可以使用 <code>docker run --entrypoint</code> 选项。</p><p>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，当指定多个时，只有最后一个生效。</p><h4><span id="exec-form-entrypoint-例子">Exec form ENTRYPOINT 例子</span></h4><p>通过 <code>ENTRYPOINT</code> 使用 exec form 方式设置稳定的默认命令和选项，而使用 <code>CMD</code> 添加默认之外经常被改动的选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br></pre></td></tr></table></figure><p>通过 Dockerfile 使用 <code>ENTRYPOINT</code> 展示前台运行 Apache 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stable</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span><br><span class="line">EXPOSE 80 443</span><br><span class="line">VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure><h4><span id="shell-form-entrypoint-例子">Shell form ENTRYPOINT 例子</span></h4><p>这种方式会在 <code>/bin/sh -c</code> 中执行，会忽略任何 <code>CMD</code> 或者 <code>docker run</code> 命令行选项，为了确保 <code>docker stop</code> 能够停止长时间运行 <code>ENTRYPOINT</code> 的容器，确保执行的时候使用 <code>exec</code> 选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT exec top -b</span><br></pre></td></tr></table></figure><p>如果在 <code>ENTRYPOINT</code> 忘记使用 <code>exec</code> 选项，则可以使用 <code>CMD</code> 补上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT top -b</span><br><span class="line">CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推</span><br></pre></td></tr></table></figure><h3><span id="79-volume">7.9 VOLUME</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p><h3><span id="710-user">7.10 USER</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或 UID，后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 也会使用指定用户。</p><h3><span id="711-workdir">7.11 WORKDIR</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>最终路径是 <code>/a/b/c</code>。</p><p><code>WORKDIR</code> 指令可以在 <code>ENV</code> 设置变量之后调用环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure><p>最终路径则为 /path/$DIRNAME。</p><h3><span id="712-onbuild">7.12 ONBUILD</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p><p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Automatically run the following</span></span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><p>使用 <code>ONBUILD</code> 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p><h3><span id="713-dockerfile-examples">7.13 Dockerfile Examples</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># VERSION               0.0.1</span></span></span><br><span class="line"></span><br><span class="line">FROM      ubuntu</span><br><span class="line">MAINTAINER Victor Vieux &lt;victor@docker.com&gt;</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Firefox over VNC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># VERSION               0.3</span></span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install vnc, xvfb <span class="keyword">in</span> order to create a <span class="string">&#x27;fake&#x27;</span> display and firefox</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span><br><span class="line">RUN mkdir ~/.vnc</span><br><span class="line"><span class="meta">#</span><span class="bash"> Setup a password</span></span><br><span class="line">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> Autostart firefox (might not be the best way, but it does the trick)</span></span><br><span class="line">RUN bash -c &#x27;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#x27;</span><br><span class="line"></span><br><span class="line">EXPOSE 5900</span><br><span class="line">CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Multiple images example</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># VERSION               0.1</span></span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo foo &gt; bar</span><br><span class="line"><span class="meta">#</span><span class="bash"> Will output something like ===&gt; 907ad6c2736f</span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo moo &gt; oink</span><br><span class="line"><span class="meta">#</span><span class="bash"> Will output something like ===&gt; 695d7793cbe4</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /oink.</span></span><br></pre></td></tr></table></figure><h3><span id="714-docker-build">7.14 docker build</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage: docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build a new image from the source code at PATH</span><br><span class="line"></span><br><span class="line">  --force-rm=false     Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败</span><br><span class="line">  --no-cache=false     Do not use cache when building the image                              # 不实用 cache</span><br><span class="line">  -q, --quiet=false    Suppress the verbose output generated by the containers</span><br><span class="line">  --rm=true            Remove intermediate containers after a successful build               # 构建成功后移除过渡层容器</span><br><span class="line">  -t, --tag=&quot;&quot;         Repository name (and optionally a tag) to be applied to the resulting image in case of success</span><br></pre></td></tr></table></figure><p>参考文档:<a href="https://docs.docker.com/reference/builder/">Dockerfile Reference</a></p><h3><span id="715-dockerfile-最佳实践">7.15 dockerfile 最佳实践</span></h3><ul><li>使用 <code>.dockerignore</code> 文件</li></ul><p>为了在 <code>docker build</code> 过程中更快上传和更加高效，应该使用一个 <code>.dockerignore</code> 文件用来排除构建镜像时不需要的文件或目录。例如,除非 <code>.git</code> 在构建过程中需要用到，否则你应该将它添加到 <code>.dockerignore</code> 文件中，这样可以节省很多时间。</p><ul><li>避免安装不必要的软件包</li></ul><p>为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。</p><ul><li>每个容器都跑一个进程</li></ul><p>在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 <a href="https://docs.docker.com/userguide/dockerlinks/">Linking Containers Together</a>。</p><ul><li>最小化层</li></ul><p>我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于 <code>Dockerfile</code>，应该找到可读性和最小化层之间的平衡。</p><ul><li>多行参数排序</li></ul><p>如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用 <code>\</code> 换行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure><ul><li>创建缓存</li></ul><p>镜像构建过程中会按照 <code>Dockerfile</code> 的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在 <code>docker build</code> 时添加 <code>--no-cache=true</code> 选项。</p><p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比 <code>Dockerfile</code> 指令和子镜像就足够了。<code>ADD</code> 和 <code>COPY</code> 指令除外，执行 <code>ADD</code> 和 <code>COPY</code> 时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。<code>RUN apt-get -y update</code> 命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p><blockquote><p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p></blockquote><h4><span id="dockerfile-指令">Dockerfile 指令</span></h4><ul><li><code>FROM</code>: 只要可能就使用官方镜像库作为基础镜像</li><li><code>RUN</code>: 为保持可读性、方便理解、可维护性，把长或者复杂的 <code>RUN</code> 语句使用 <code>\</code> 分隔符分成多行<ul><li>不建议 <code>RUN apt-get update</code> 独立成行，否则如果后续包有更新，那么也不会再执行更新</li><li>避免使用 <code>RUN apt-get upgrade</code> 或者 <code>dist-upgrade</code>，很多必要的包在一个非 <code>privileged</code> 权限的容器里是无法升级的。如果知道某个包更新，使用 <code>apt-get install -y xxx</code></li><li>标准写法<ul><li><code>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</code></li></ul></li></ul></li></ul><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    aufs-tools \</span><br><span class="line">    automake \</span><br><span class="line">    btrfs-tools \</span><br><span class="line">    build-essential \</span><br><span class="line">    curl \</span><br><span class="line">    dpkg-sig \</span><br><span class="line">    git \</span><br><span class="line">    iptables \</span><br><span class="line">    libapparmor-dev \</span><br><span class="line">    libcap-dev \</span><br><span class="line">    libsqlite3-dev \</span><br><span class="line">    lxc=1.0* \</span><br><span class="line">    mercurial \</span><br><span class="line">    parallel \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1.9.1 \</span><br><span class="line">    ruby1.9.1-dev \</span><br><span class="line">    s3cmd=1.1.0*</span><br></pre></td></tr></table></figure><ul><li><code>CMD</code>: 推荐使用 <code>CMD [“executable”, “param1”, “param2”…]</code> 这种格式，<code>CMD [“param”, “param”]</code> 则配合 <code>ENTRYPOINT</code> 使用</li><li><code>EXPOSE</code>: Dockerfile 指定要公开的端口，使用 <code>docker run</code> 时指定映射到宿主机的端口即可</li><li><code>ENV</code>: 为了使新的软件更容易运行，可以使用 <code>ENV</code> 更新 <code>PATH</code> 变量。如 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 确保 <code>CMD [&quot;nginx&quot;]</code> 即可运行</li></ul><p><code>ENV</code> 也可以这样定义变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><ul><li><code>ADD</code> or <code>COPY</code>: <code>ADD</code> 比 <code>COPY</code> 多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li></ul><p>如不推荐这种方式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p>推荐使用 curl 或者 wget 替换，使用如下方式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /usr/src/things \</span><br><span class="line">    &amp;&amp; curl -SL http://example.com/big.tar.gz \</span><br><span class="line">    | tar -xJC /usr/src/things \</span><br><span class="line">    &amp;&amp; make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p>如果不需要添加 tar 文件，推荐使用 <code>COPY</code>。</p><p>参考文档:</p><ul><li><a href="https://docs.docker.com/articles/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li><li><a href="http://dockerone.com/article/131">Dockerfile最佳实践（一）</a></li><li><a href="http://dockerone.com/article/132">Dockerfile最佳实践（二）</a></li></ul><h2><span id="八-容器数据管理">八、容器数据管理</span></h2><p>docker管理数据的方式有两种：</p><ul><li>数据卷</li><li>数据卷容器</li></ul><h3><span id="81-数据卷">8.1 数据卷</span></h3><p>数据卷是一个或多个容器专门指定绕过 <code>Union File System</code> 的目录，为持续性或共享数据提供一些有用的功能：</p><ul><li>数据卷可以在容器间共享和重用</li><li>数据卷数据改变是直接修改的</li><li>数据卷数据改变不会被包括在容器中</li><li>数据卷是持续性的，直到没有容器使用它们</li></ul><h4><span id="添加一个数据卷">添加一个数据卷</span></h4><p>你可以使用 <code>-v</code> 选项添加一个数据卷，或者可以使用多次 <code>-v</code> 选项为一个 docker 容器运行挂载多个数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷</span></span><br><span class="line">bash-4.1# ls -ld /data/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/</span><br><span class="line">bash-4.1# df -Th</span><br><span class="line">Filesystem    Type    Size  Used Avail Use% Mounted on</span><br><span class="line">... ...</span><br><span class="line">              ext4     91G  4.6G   82G   6% /data</span><br></pre></td></tr></table></figure><p>创建的数据卷可以通过 <code>docker inspect</code> 获取宿主机对应路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker inspect data</span></span><br><span class="line">... ...</span><br><span class="line">    &quot;Volumes&quot;: &#123;</span><br><span class="line">        &quot;/data&quot;: &quot;/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9&quot;</span><br><span class="line">    &#125;, # 可以看到创建的数据卷宿主机路径</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>或者直接指定获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker inspect --format=<span class="string">&quot;&#123;&#123; .Volumes &#125;&#125;&quot;</span> data</span></span><br><span class="line">map[/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9]</span><br></pre></td></tr></table></figure><h4><span id="挂载宿主机目录为一个数据卷">挂载宿主机目录为一个数据卷</span></h4><p><code>-v</code> 选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --name web -v /<span class="built_in">source</span>/:/web -t -i ubuntu:14.04 /bin/bash</span></span><br><span class="line">bash-4.1# ls -ld /web/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/</span><br><span class="line">bash-4.1# df -Th</span><br><span class="line">... ...</span><br><span class="line">              ext4     91G  4.6G   82G   6% /web</span><br><span class="line">bash-4.1# exit</span><br></pre></td></tr></table></figure><p>默认挂载卷是可读写的，可以在挂载时指定只读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --rm --name <span class="built_in">test</span> -v /<span class="built_in">source</span>/:/<span class="built_in">test</span>:ro -t -i ubuntu:14.04 /bin/bash</span></span><br></pre></td></tr></table></figure><h3><span id="82-创建和挂载一个数据卷容器">8.2 创建和挂载一个数据卷容器</span></h3><p>如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。</p><p>创建数据卷容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d -v /<span class="built_in">test</span> --name <span class="built_in">test</span> ubuntu:14.04 <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure><p>使用 <code>--volumes-from</code> 选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d --volumes-from <span class="built_in">test</span> --name test1 ubuntu:14.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p>添加另一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d --volumes-from <span class="built_in">test</span> --name test2 ubuntu:14.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p>也可以继承其它挂载有 /test 卷的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p><img src="/img/docker/docker_data.png" alt="docker_data"></p><h3><span id="83-备份-恢复或迁移数据卷">8.3 备份、恢复或迁移数据卷</span></h3><h4><span id="备份">备份</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --rm --volumes-from <span class="built_in">test</span> -v $(<span class="built_in">pwd</span>):/backup ubuntu:14.04 tar cvf /backup/test.tar /<span class="built_in">test</span></span></span><br><span class="line">tar: Removing leading `/&#x27; from member names</span><br><span class="line">/test/</span><br><span class="line">/test/b</span><br><span class="line">/test/d</span><br><span class="line">/test/c</span><br><span class="line">/test/a</span><br></pre></td></tr></table></figure><p>启动一个新的容器并且从 <code>test</code> 容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份 test 卷中所有的数据为 test.tar，执行完成之后删除容器 <code>--rm</code>，此时备份就在当前的目录下，名为 <code>test.tar</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls        <span class="comment"># 宿主机当前目录下产生了 test 卷的备份文件 test.tar</span></span></span><br><span class="line">test.tar</span><br></pre></td></tr></table></figure><h4><span id="恢复">恢复</span></h4><p>你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i -d -v /<span class="built_in">test</span> --name test4 ubuntu:14.04  /bin/bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --rm --volumes-from test4 -v $(<span class="built_in">pwd</span>):/backup ubuntu:14.04 tar xvf /backup/test.tar -C /</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复之前的文件到新建卷中，执行完后自动删除容器</span></span><br><span class="line">test/</span><br><span class="line">test/b</span><br><span class="line">test/d</span><br><span class="line">test/c</span><br><span class="line">test/a</span><br></pre></td></tr></table></figure><h3><span id="84-删除-volumes">8.4 删除 Volumes</span></h3><p>Volume 只有在下列情况下才能被删除：</p><ul><li><code>docker rm -v</code> 删除容器时添加了 <code>-v</code> 选项</li><li><code>docker run --rm</code> 运行容器时添加了 <code>--rm</code> 选项</li></ul><p>否则，会在 <code>/var/lib/docker/vfs/dir</code> 目录中遗留很多不明目录。</p><p>参考文档：</p><ul><li><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes">Managing Data in Containers</a></li><li><a href="http://dockerone.com/article/128">深入理解Docker Volume（一）</a></li><li><a href="http://dockerone.com/article/129">深入理解Docker Volume（二）</a></li></ul><h2><span id="九-链接容器">九、链接容器</span></h2><p>docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。</p><h3><span id="91-容器命名">9.1 容器命名</span></h3><p>在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：</p><ul><li>1、给容器命名方便记忆，如命名运行 web 应用的容器为 web</li><li>2、为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db</li></ul><p>可以通过 <code>--name</code> 选项给容器自定义命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -d -t -i --name <span class="built_in">test</span> ubuntu:14.04 bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker  inspect --format=<span class="string">&quot;&#123;&#123; .Nmae &#125;&#125;&quot;</span> <span class="built_in">test</span></span></span><br><span class="line">/test</span><br></pre></td></tr></table></figure><blockquote><p>注：容器名称必须唯一，即你只能命名一个叫 <code>test</code> 的容器。如果你想复用容器名，则必须在创建新的容器前通过 <code>docker rm</code> 删除旧的容器或者创建容器时添加 <code>--rm</code> 选项。</p></blockquote><h3><span id="92-链接容器">9.2 链接容器</span></h3><p>链接允许容器间安全通信，使用 <code>--link</code> 选项创建链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -d --name db training/postgres</span></span><br></pre></td></tr></table></figure><p>基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -d -P --name web --link db:db training/webapp python app.py</span></span><br></pre></td></tr></table></figure><p><code>--link &lt;name or id&gt;:alias</code> 选项指定链接到的容器。</p><p>查看 web 容器的链接关系:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker inspect -f <span class="string">&quot;&#123;&#123; .HostConfig.Links &#125;&#125;&quot;</span> web</span></span><br><span class="line">[/db:/web/db]</span><br></pre></td></tr></table></figure><p>可以看到 web 容器被链接到 db 容器为 <code>/web/db</code>，这允许 web 容器访问 db 容器的信息。</p><p>容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加 <code>-p</code> 或 <code>-P</code> 指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。</p><p>Docker 主要通过以下两个方式提供连接信息给接收容器：</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件</li></ul><h4><span id="环境变量">环境变量</span></h4><p>当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。</p><p>首先，Docker 会在每个通过 <code>--link</code> 选项指定别名的目标容器上设置一个 <code>&lt;alias&gt;_NAME</code> 环境变量。如果一个名为 web 的容器通过 <code>--link db:webdb</code> 被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为 <code>WEBDB_NAME=/web/webdb</code>.</p><p>以之前的为例，Docker 还会设置端口变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run --rm --name web2 --link db:db training/webapp env</span></span><br><span class="line">. . .</span><br><span class="line">DB_NAME=/web2/db</span><br><span class="line">DB_PORT=tcp://172.17.0.5:5432</span><br><span class="line">DB_PORT_5432_TCP=tcp://172.17.0.5:5432  # &lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt; 协议可以是 TCP 或 UDP</span><br><span class="line">DB_PORT_5432_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_5432_TCP_PORT=5432</span><br><span class="line">DB_PORT_5432_TCP_ADDR=172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><blockquote><p>注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量</p></blockquote><h4><span id="更新-etchosts-文件">更新 <code>/etc/hosts</code> 文件</span></h4><p>除了环境变量，Docker 会在目标容器上添加相关主机条目到 <code>/etc/hosts</code> 中，上例中就是 web 容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t -i --rm --link db:db training/webapp /bin/bash</span></span><br><span class="line">root@aed84ee21bde:/opt/webapp# cat /etc/hosts</span><br><span class="line">172.17.0.7  aed84ee21bde</span><br><span class="line">. . .</span><br><span class="line">172.17.0.5  db</span><br></pre></td></tr></table></figure><blockquote><p><code>/etc/host</code> 文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。</p></blockquote><h2><span id="十-构建私有库">十、构建私有库</span></h2><p>Docker 官方提供了 docker registry 的构建方法 <a href="https://github.com/docker/docker-registry">docker-registry</a></p><h3><span id="101-快速构建">10.1 快速构建</span></h3><p>快速构建 docker registry 通过以下两步:</p><ul><li>安装 docker</li><li>运行 registry: <code>docker run -p 5000:5000 registry</code></li></ul><p>这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/">official image from the Docker hub</a></p><h3><span id="102-不使用容器构建-registry">10.2 不使用容器构建 registry</span></h3><h4><span id="安装必要的软件">安装必要的软件</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev</span></span><br></pre></td></tr></table></figure><h4><span id="配置-docker-registry">配置 docker-registry</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install docker-registry</span><br></pre></td></tr></table></figure><p>或者 使用 github clone 手动安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/dotcloud/docker-registry.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> docker-registry/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp config/config_sample.yml config/config.yml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /data/registry -p</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install .</span></span><br></pre></td></tr></table></figure><h4><span id="运行">运行</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-registry</span><br></pre></td></tr></table></figure><h4><span id="高级启动方式-不推荐">高级启动方式 [不推荐]</span></h4><p>使用 <code>gunicorn</code> 控制:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者对外监听开放</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><h3><span id="103-提交指定容器到私有库">10.3 提交指定容器到私有库</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker push 私有库IP:5000/ubuntu</span></span><br></pre></td></tr></table></figure><h3><span id="104-安装升级你的docker客户端">10.4 安装升级你的Docker客户端</span></h3><p>推荐安装1.6.0以上版本的Docker客户端。<br>您可以通过阿里云的镜像仓库下载：<a href="http://mirrors.aliyun.com/help/docker-engine">mirrors.aliyun.com/help/docker-engine</a><br>或执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span></span><br></pre></td></tr></table></figure><p>如何使用Docker加速器<br>针对Docker客户端版本大于1.10的用户<br>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://ejburpg5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125; EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>更多的配置选项推荐阅读官方文档:</p><ul><li><a href="https://github.com/docker/docker-registry/blob/master/README.md">Docker-Registry README</a></li><li><a href="https://github.com/docker/docker-registry/blob/master/ADVANCED.md">Docker-Registry advanced use</a></li></ul><p>引用参考：</p><ul><li><a href="http://blog.opskumu.com/docker.html">Docker 学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二章：Akka构建扩展、分布式应用</title>
      <link href="/2016/10/27/scala/12-akka-app/"/>
      <url>/2016/10/27/scala/12-akka-app/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>Akka背后哲学思想</li><li>Actor并发、STM、代理以及数据流</li><li>构建一个大型的可扩展应用：Akkaoogle</li></ol><p>本章介绍一个已有的Scala工具包：Akka，让你为JVM平台构建新一代的、事件驱动的、容错的、可伸缩的分布式应用。Akka提供了多并发的抽象，本章着重探索其内容。前面内容，仅介绍了Actor面向消息的(message-oriented)并发使用。这里将继续探索诸如 STM、Agent和Dataflow的并发抽象内容。</p><span id="more"></span><p>为了理解Akka各部分是如何整合在一起的，我们将使用Akka来构建一个真实的搜索应用：Akkaoogle。该应用类似于<a href="http://www.google.com/products">Froogle</a>，它是google的一个服务，用于搜索产品的最低价格。你将马上构建这个产品，这样你就可以看到应该在什么场合，使用怎样的Akka特性。</p><p><strong>注意</strong> 本章所有覆盖的Akka特性，同时都有相应的Java API。但不在本章阐述Java方面的内容，你可以查阅[文档](<a href="http://akka.io/docs/">http://akka.io/docs/</a> for details)了解该方面的内容。</p><p>Akka由Scala编写，却在Java和Scala APIs上开发了所有的特性。因为这里只介绍Scala方面的内容，也主要讨论Scala的API，当然也包含有Java的例子。你可以仿照Akkaoogle在Scala上的例子，构建一个Java的Akkaoogle版本，因为两者的API是相同的。最开始会先介绍Akka背后的哲学思想，理解之后将进入到Akka项目中，并尝试解决实际问题。</p><h3><span id="12~1the-philosophy-behind-akkap345">12~1〖The philosophy behind Akka〗P345</span></h3><p>Akka背后的哲学思想是简单的：使开发者更容易构建正确的、并发的、可伸缩的和容错的应用。为此，Akka提供了一个高层抽象，用于处理并发性、可伸缩性和错误问题。图12.1展示了3个核心模块concurrency、scalability和fault tolerance。</p><p><img src="/img/scala-in-action/chapter12/Figure_12_01.png" alt="Figure 12.1"></p><p>这些并发模块提供了处理并发性相关问题的选项。到目前为止，我确信你只会Actor(面向消息的并发性)。但Actor不是个从一而终的并发解决方案。你需要理解Akka模块的其它替代方案。在下面的小节将探索所有该内容。在内核，Akka是一个基于事件的(event-based)平台，依赖于Actor的消息传递和伸缩性。Akka任由你使用本地和远程的Actor。通过路由(routing)使用本地Actor，你可以向上扩展；使用远程Actor则帮助你水平扩展。在本章最后，将看到有关于此的更多详细内容。</p><h3><span id="12~2simple-concurrency-with-akkap346">12~2〖Simple concurrency with Akka〗P346</span></h3><p>为了拓展你的应用，使用并发。在第9章学习到，线程是实现并发的一个困难的、易出错的方式，它应该作为你的最后的一个选择方案。问题是最优的方案是什么，第二、第三方案呢？本小节将介绍如何选择合适的方案。表 12.1 描述了Akka中的所有可用并发技术。好消息是，你可以组合所有这些并发技术，它是大多数Akka开发者最终的做法。</p><table><thead><tr><th style="text-align:left">name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>Actors</code></td><td style="text-align:left">一个Actor是一个异步处理消息并封装状态的一个对象。Actor实现了消息传递的并发性。</td></tr><tr><td style="text-align:left"><code>STM(Software transactional memory)</code></td><td style="text-align:left">软件事务内存，模拟数据库事务的机制，控制在并行计算时对共享内存的访问控制。它是锁的一种替代机制，以及提供了可组合性。</td></tr><tr><td style="text-align:left"><code>Agents</code></td><td style="text-align:left">Agents提供了在可变数据(mutable data)上的抽象。它仅允许你通过一个异步的写(write)动作来改变数据。</td></tr><tr><td style="text-align:left"><code>Dataflow</code></td><td style="text-align:left">Dataflow并发性是确定的。这意味着每次执行都表现出相同的行为。因此你的应用最先是死锁的，它会始终是死锁，这有帮助你debug问题。Akka使用<code>Future</code>来实现 Oz-style 的dataflow</td></tr></tbody></table><p>这些选项提供了设计正确并发应用的灵活性。例如你可以使用Actor来建模一个应用，用STM或Agents来处理可变状态，以及使用Dataflow并发来组合多并发进程。这都有无尽的可能性。</p><p><strong>注意</strong> Akka不再包含STM模块，取而代之的是支持Scala STM。</p><p>下面开始Akka并发世界之旅————这会是一个有趣的旅程。</p><h3><span id="1221remote-actorsp347">12<sub>2</sub>1〖Remote actors〗P347</span></h3><p>在第9章我们详细探索了Actor内容。Actor编程不仅仅局限于单个JVM，因此每个Actor可以跨多个JVM进行交流。Akka的远程Actor允许你在远程设备上部署Actor，透明地来回发送消息。远程Actor是实现扩展的、分布式应用的一个很好的方式。这些消息，使用<a href="http://code.google.com/p/protobuf/">Google protocol buffer</a> 进行自动序列化，两个节点间的交流，通过使用<a href="http://www.jboss.org/netty">JBoss Netty</a> 处理。可以把Google protocl buffer 认为是小巧而又快速的XML，Netty认为是一个非IO阻塞(non-blocking I/O)的实现，它们让Akka高效地使用线程为I/O操作。</p><p><img src="/img/scala-in-action/chapter12/Figure_12_02.png" alt="Figure 12.2"></p><p>Akka实现了透明的远程调用，即在部署时Actor的运程(remoteness)被完全配置。你可以在构建方案时使用本地Actor，在部署期间为每个独立的Actor配置运程详情。</p><p><strong>注意</strong> 在将来的Akka版本，Netty将由一个基于Actor的I/O库 Actor I/O所代替。</p><p>在此之前，先让我们为远程Actor添加依赖项。Akka是模块化的，如其添加整个akka库，你仅需要添加Actor依赖库即可。下面是其远程依赖的<code>build.sbt</code>文件配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolvers ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;Akka Repo&quot;</span> at <span class="string">&quot;http://akka.io/repository&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Typesafe Repo&quot;</span> at <span class="string">&quot;http://repo.typesafe.com/typesafe/repo&quot;</span></span><br><span class="line">)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor&quot;</span> % <span class="string">&quot;2.3.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-remote % &quot;</span><span class="number">2.3</span><span class="number">.6</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><code>resolvers</code>定义了依赖的地址，<code>libraryDependencies</code>则添加远程Actor。</p><p>我们将使用第9章的word count例子，更改原来读取文本文件的方式，改为读取URL的内容。目的是链接到URL，并计算页面的单词数。在Java中要创建一个Akka Actor，你需要继承<code>akka.actor.UntypedActor</code>类，并重写<code>onReceive</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.UntypedActor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类被称为<code>UntypedActor</code>因为Akka包括有一个<code>TypedActor</code>概念。这个类型Actor实现了主动对象(active object)模式，即将任意的POJO接口，转变为一个异步的API。</p><p><strong>注意</strong> Akka的类型化Actor(typed actor)是主动对象模式(active object pattern)的一个实现。它将同步方法调用变为异步派遣。使用类型化Actor的一个优势在于，你可以有一个静态的编译的类型约定，这样你不需要定义消息。在Akka文档中读取更多有关内容。</p><p>因为你的<code>wordCountWorker</code>需要处理<code>FileToCount</code>消息，你需要将接收的参数消息转换类型为<code>FileToCount</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (message <span class="keyword">instanceof</span> FileToCount) &#123;</span><br><span class="line">FileToCount c = (FileToCount)message;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown message: &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>instanceof</code>来检验接收消息的类型，如果消息不是<code>FileToCount</code>类型，将抛出一个异常。在Scala代码，需要添加<code>countWords</code>方法到<code>FileToCount</code> case 类，以计算所有单词：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">url: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span> </span>= &#123;</span><br><span class="line">    <span class="type">Source</span>.fromURL(<span class="keyword">new</span> <span class="type">URL</span>(url)).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WordCountWorker</code> Actor，你可以调用 <code>countWords</code> 方法来统计单词数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileToCount</span> c = (<span class="type">FileToCount</span>)message;</span><br><span class="line"><span class="type">Integer</span> count = c.countWords();</span><br></pre></td></tr></table></figure><p>要给发送者回复一个响应，使用 <code>getSender().tell(...)</code> 方法。方法 <code>tell</code> 允许Actor向发送者回复。要向主干回复，子Actor需要构造<code>WordCount</code> 消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileToCount c = (FileToCount)message;</span><br><span class="line">Integer count = c.countWords();</span><br><span class="line">getSender().tell(<span class="keyword">new</span> WordCount(c.url(), count));</span><br></pre></td></tr></table></figure><p><code>getSelf</code> 方法返回当前Actor的引用。下面代码清单为完整的<code>WordCountWorker</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> countwords;</span><br><span class="line"><span class="keyword">import</span> akka.actor.UntypedActor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> FileToCount) &#123;</span><br><span class="line">            FileToCount c = (FileToCount)message;</span><br><span class="line">            Integer count = c.countWords();</span><br><span class="line">            getSender().tell(<span class="keyword">new</span> WordCount(c.url(), count), getSelf());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown message: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了利用好远程Actor，我们在一个JVM中，将所有worker actor从master actor分离。为此，需要创建两个Actor系统。配置Akka Actor最简单的方式是在classpath中提供一个配置文件。你可以在akka文档中找到所有配置属性的更多内容。下面例子定义两个Actor系统：主Actor系统和工作Actor系统。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">workersystem &#123;</span><br><span class="line">  akka &#123;</span><br><span class="line">    actor&#123;provider = &quot;akka.remote.RemoteActorRefProvider&quot;&#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      enabled-transports = [&quot;akka.remote.netty.tcp&quot;]</span><br><span class="line">      // transports = &quot;akka.remote.netty.NettyRemoteTransport&quot;</span><br><span class="line">      //log-sent-messages = on</span><br><span class="line">      //log-received-messages = on</span><br><span class="line">      netty.tcp &#123;</span><br><span class="line">        hostname = &quot;127.0.0.1&quot;</span><br><span class="line">        port = 2560</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainsystem &#123;</span><br><span class="line">  akka &#123;</span><br><span class="line">    actor.provider = &quot;akka.remote.RemoteActorRefProvider&quot;</span><br><span class="line">    remote.netty.tcp.hostname = &quot;127.0.0.1&quot;</span><br><span class="line">    actor &#123;</span><br><span class="line">      deployment &#123;</span><br><span class="line">        /wordCountMaster &#123;</span><br><span class="line">          remote = &quot;akka.tcp://workersystem@127.0.0.1:2560&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Actor系统提供的灵活性定义配置，将每个Actor系统进行分离。下面元素添加运程(remoteness)到Actor系统：</p><ul><li>Actor provider 改为 <code>akka.remote.RemoteActorRefProvider</code>。</li><li>添加主机名。并确保IP地址可访问。</li><li>添加远程Actor系统监听的端口号。</li><li>映射将被部署的Actor系统的名称。</li></ul><p>现在将上述配置保存到src/main/resources文件夹下的application.conf文件中。要是<code>workersystem</code>能够在一个不同的JVM上运行，在该终端执行下面代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package countwords</span><br><span class="line">import akka.actor._</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line">object WorkerSystem extends App &#123;</span><br><span class="line">val workerSystem = ActorSystem(&quot;workersystem&quot;,</span><br><span class="line">ConfigFactory.load.getConfig(&quot;workersystem&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将开启&quot;workersystem&quot;，并监听来自端口号为2560的消息。现在创建一个新的Actor。它用于运行主Actor系统：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">url: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span> </span>= &#123;</span><br><span class="line">    <span class="type">Source</span>.fromURL(<span class="keyword">new</span> <span class="type">URL</span>(url)).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>(<span class="params">url: <span class="type">String</span>, count: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCounting</span>(<span class="params">urls: <span class="type">Seq</span>[<span class="type">String</span>], numActors: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainActor</span>(<span class="params">accumulator: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;start&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> urls = <span class="type">List</span>(<span class="string">&quot;http://www.infoq.com/&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.dzone.com/links/index.html&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.manning.com/&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.reddit.com/&quot;</span>)</span><br><span class="line">        accumulator ! <span class="type">StartCounting</span>(urls, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = run</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">val</span> mainSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;main&quot;</span>, <span class="type">ConfigFactory</span>.load.getConfig(<span class="string">&quot;mainsystem&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> accumulator = mainSystem.actorOf(<span class="type">Props</span>[<span class="type">WordCountMaster</span>], name = <span class="string">&quot;wordCountMaster&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> m = mainSystem.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">MainActor</span>(accumulator)))</span><br><span class="line">    m ! <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在两个不同的JVM实例上开启<code>WorkerSystem</code>和<code>MainSystem</code>，将实现了workers Actor运行在一个JVM，而主Actor运行在另一个JVM上。现在你实现了Akka的分布式部署方案。</p><p><img src="/img/scala-in-action/chapter12/Figure_12_remote.png" alt="Figure 12.remote"></p><h3><span id="1222making-mutable-data-safe-with-stmp351">12<sub>2</sub>2〖Making mutable data safe with STM〗P351</span></h3><p>软件事务内存(STM, Software transactional memory)将一个Java堆栈变为一个事务数据集。STM类似于数据库事务，但是使用内存代替。因为STM不能在内存中实现持久化，你仅能获得事务ACID的前三个属性(atomicity,consistency,isolation,durability)：</p><ul><li>原子性——所偶修改应该遵循“all or nothing” 规则。在STM，所有修改由一个不可分割的事务处理，一项修改失败将导致所有的改动回滚。</li><li>一致性——表明一个STM事务将系统从一个一致状态到另一个一致性状态。如果你想要删除一个Map中的一个元素，再插入到另外一个Map，那么STM事务最终，两个Map都被适当地修改。</li><li>隔离性——STM的事务间相互不可见，彼此孤立，不互相干预。</li></ul><p>STM最好的部分是锁自由。它从异常中回滚，并且是可组合的。你可以将两个小的STM操作组合成为一个大的STM操作。在展示STM例子之前，先让我们理解一下STM的状态是什么，以及它是如何表示的。</p><p><strong>HOW STATE IS DEFINED IN STM</strong></p><p>让我们看看在命令式编程中状态是如何处理的。图12.3展示了状态是如何处理的。你直接访问内存中的数据，并改变这个数据。在图中，一个对象A，直接被B和C访问数据。问题是在并发世界这种方式无效。当一些其它驻留在B或C的线程或进程尝试访问数据，而A正尝试修改数据时，会怎样？结果显然不是我们所期望的。</p><p><img src="/img/scala-in-action/chapter12/Figure_12_03.png" alt="Figure 12.3"></p><p>要解决这种方式上的问题，STM定义了不同的可变状态。在STM中，<code>state</code>被定义为值，它是一个在特殊点上具体标识的实体。一个值<code>value</code>是指不会变化的(不可变的)。标识<code>identity</code>是指在一个给定的点上对一个值的引用。图12.4展示了STM的这种结构。可变部分是唯一标识的，它可一系列值相关联。STM使得从一个值到另一个值的可变引用具有原子性。当驻留在B和C的其它进程或线程，访问正在修改的A时，会发生什么？你会看到与B或C关联的值，因为STM事务被隔离的，事务的部分改变在外部不可见。</p><p>这种根据标识和值来定义状态的思想，来源于编程语言<a href="http://clojure.org">Clojure</a> 。现在看看在Akka中，STM是如何工作的。</p><p><strong>HANDLING MUTABLE DATA IN AKKA USING STM</strong></p><p>Akka使用Scala的STM库作为它的STM。在SBT项目中添加该库：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolvers += (<span class="string">&quot;Typesafe Repository&quot;</span> at <span class="string">&quot;http://repo.typesafe.com/typesafe/</span></span><br><span class="line"><span class="string">releases/&quot;</span>)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.scala-stm&quot;</span> %% <span class="string">&quot;scala-stm&quot;</span> % <span class="string">&quot;0.7&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.specs2&quot;</span> %% <span class="string">&quot;specs2&quot;</span> % <span class="string">&quot;1.13&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为演示STM如何工作，我们以一个小实例着手，你创建一个为可变Map删除和增加元素的原子操作。为了管理可变性，用<code>scala.concurrent.stm.Ref</code>来封装这个可变的值：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ref1 = <span class="type">Ref</span>(<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Any</span>](</span><br><span class="line"><span class="string">&quot;service1&quot;</span> -&gt; <span class="string">&quot;10&quot;</span>,</span><br><span class="line"><span class="string">&quot;service2&quot;</span> -&gt; <span class="string">&quot;20&quot;</span>,</span><br><span class="line"><span class="string">&quot;service3&quot;</span> -&gt; <span class="literal">null</span>))</span><br><span class="line"><span class="keyword">val</span> ref2 = <span class="type">Ref</span>(<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>]())</span><br></pre></td></tr></table></figure><p>这两个值不是别的，就是多并发参与者中的值的可变引用。上述代码片段创建了两个值，指向可变的HashMap。要在Ref上处理操作，你需要使用定义在STM包中的<code>atomic</code>方法。Scala的STM库创建事务对象，并授权调用者处理事务性的读和写操作。闭包内的任何<code>refs</code>的改变都在一个STM事务中完成。例如，下面代码中，由ref2向Map添加一个新的元素：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicInsert</span></span>(key: <span class="type">String</span>, value: <span class="type">Int</span>) = atomic &#123; <span class="keyword">implicit</span> txn =&gt;</span><br><span class="line">  <span class="keyword">val</span> oldMap = ref2.get</span><br><span class="line">  <span class="keyword">val</span> newMap = oldMap + ( key -&gt; value)</span><br><span class="line">  ref2.swap(newMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>ref2.get</code>得到当前由<code>Ref</code>关联的，使用<code>swap</code>替代的一个新值。如果操作失败，该操作将会回滚。事务参数被隐式标志，因此你不需要直接传递。</p><p>要从<code>ref1</code>中实现<code>key</code>的<code>atomic</code>删除，你需要使用定义在<code>Ref</code>的<code>transform</code>方法。方法<code>transform</code>允许你转换<code>Ref</code>引用的值：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicDelete</span></span>(key: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Any</span>] = atomic &#123;</span><br><span class="line">  <span class="keyword">val</span> oldMap = ref1.get</span><br><span class="line">  <span class="keyword">val</span> value = oldMap.get(key)</span><br><span class="line">  ref1.transform(_ - key)</span><br><span class="line">  value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>atomicDelete</code>返回删除了的 value。为什么返回 old value？因为之后会用到。</p><p>接着讨论关于STM的组合性。假设你构建了一个<code>atomicSwap</code>函数，用于将一个Map的一个元素，移动到另一个Map中。使用STM，这变的容易：你需要做的是封装<code>atomicDelete</code>和<code>atomicInsert</code>这两个函数，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicSwap</span></span>(key: <span class="type">String</span>) = atomic &#123; <span class="keyword">implicit</span> txn =&gt;</span><br><span class="line">  <span class="keyword">val</span> value: <span class="type">Option</span>[<span class="type">Any</span>] = atomicDelete(key)</span><br><span class="line">  atomicInsert(key, <span class="type">Integer</span>.parseInt(value.get.toString))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ref2</code>仅接收一个<code>Int</code>类型值，在插入之前先要解析为<code>Int</code>。为了完全理解<code>swap</code>的优雅所在，看下面规范：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Atomic operations in composition&quot;</span> should &#123;</span><br><span class="line">  <span class="string">&quot;rollback on exception&quot;</span> in &#123;</span><br><span class="line">swap(<span class="string">&quot;service3&quot;</span>)</span><br><span class="line">ref1.single().contains(<span class="string">&quot;service3&quot;</span>) must beEqualTo(<span class="literal">true</span>)</span><br><span class="line">ref2.single().contains(<span class="string">&quot;service3&quot;</span>) must beEqualTo(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STM的方法<code>single</code>可以不要求事务，访问<code>Ref</code>的上下文。当尝试转换&quot;service3&quot;时，<code>Integer.parseInt</code>会抛出一个异常。这时删除动作已经成功了，但多亏了STM，整个事务将回滚。锁(lock)可以做到这点吗？不能。</p><p>STM很好地构建了小型的一致性操作，以及能够组合这些操作。要学习有关STM的更多内容，查阅Scala STM文档。</p><h3><span id="1223agentsp354">12<sub>2</sub>3〖Agents〗P354</span></h3><p>Agent提供了对任何独立存储位置异步修改的绑定。一个Agent仅允许提供的一个动作改变这个位置内容。这个动作指的是函数，该函数被异步地应用于Agent的状态，其返回值成为Agent的新状态。 然而，从Agent读取一个值是瞬时的和同步的。因而<code>Ref</code>和<code>Agent</code>的不同在于，<code>Ref</code>是一个同步读和写；<code>Agent</code>是响应式的(reactive)。要任意异步地提供动作，Akka提供了两个方法：<code>send</code>和<code>sendOff</code>。<code>send</code>方法使用响应式的线程池分配给agent，而<code>sendOff</code>使用一个专有的线程，适用于一个长时间运行的操作。下面是一个Agent相关例子，通过<code>send</code>动作，向一个文件写日志信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.agent.<span class="type">Agent</span></span><br><span class="line"><span class="keyword">import</span> org.specs2.mutable.<span class="type">Specification</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Await</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;agentExample&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">FileWriter</span>(<span class="string">&quot;src/test/resources/log.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Agent</span>(writer)</span><br><span class="line">a.send &#123; w =&gt; w.write(<span class="string">&quot;This is a log message&quot;</span>); w&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for reply</span></span><br><span class="line"><span class="keyword">val</span> future = a.future</span><br><span class="line"><span class="type">Await</span>.result(future, <span class="number">100</span> seconds) should be(writer)</span><br><span class="line"></span><br><span class="line">writer.close</span><br></pre></td></tr></table></figure><p>Agent将运行，直到调用<code>close</code>方法。因为在其背后，agent由Actor被实现，你需要为agent创建一个Actor系统。如果你想要做更多的花费时间的事情，你需要使用<code>sendoff</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.sendOff &#123; someLongRunningProcess &#125;</span><br></pre></td></tr></table></figure><p>注意在任何时间，仅有一个<code>send</code>动作被调用。即使是多并发处理发送的操作，这些动作将按照顺序执行。注意这些动作可能在多线程间交错。</p><p>为了在你的项目中使用Agents，需要添加下列依赖项到SBT配置文件中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line"><span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor&quot;</span> % <span class="string">&quot;2.6.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-agent&quot;</span> % <span class="string">&quot;2.6.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.specs2&quot;</span> %% <span class="string">&quot;specs2&quot;</span> % <span class="string">&quot;3.8.5&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当使用<code>atomic</code>块，以及消息被挂起直到事务完成，Agent也参与到STM事务。这对于有side-effect的动作很有帮助，如记录日志文件，你不想以STM实现。为什么？因为STM事务如果失败，它们自动重试，意味着你的副作用操作被执行了多次。这可能不是你想要的，因此组合agent和STM，会是在STM事务间，执行副作用动作的一个很好的模式。有时候，Agent的异步性质，人们会迷惑因为agent和Actor类似，但是它们完完全全在设计方式上不同。Agent与数据相关联，你从外部，以一个函数的形式，向Agent发起行为。而Actor的行为定义在内部，数据则以消息的形式发送。</p><p>你将在使用Akkaoogle日志事务时再一次看到agent，但现在让我们继续我们下一个并发模型：dataflow。Dataflow是一个很好的从一个程序封装并发的实现方式。它可以顺序读取。</p><h3><span id="1224dataflowp355">12<sub>2</sub>4〖Dataflow〗P355</span></h3><p>数据流并发是一个确定性的并发模型。运行并工作时，它会一直处于工作中而不会有死锁。又或者，如果一开始是死锁，它会总是处于死锁中。这点在并发应用中是一个有力的保障，你可以更容易理解这些代码。数据流并发允许你编写顺序的代码，以并行处理这些操作。限制是你的代码应该是完全无副作用的。因为这些代码被用于处理有副作用操作时，你不能获得确定性的行为。</p><p>Dataflow在Akka中使用了Scala的分离延续(delimited continuations)编译器插件实现。要在SBT项目中使用该插件，在配置中添加下列内容：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scalacOptions += <span class="string">&quot;-P:continuations:enable&quot;</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> % <span class="string">&quot;akka-dataflow_2.10&quot;</span> % <span class="string">&quot;2.3.6&quot;</span></span><br><span class="line"></span><br><span class="line">autoCompilerPlugins := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">libraryDependencies &lt;+= </span><br><span class="line">scalaVersion &#123; v =&gt; compilerPlugin(<span class="string">&quot;org.scala-lang.plugins&quot;</span> % <span class="string">&quot;continuations&quot;</span> % v) &#125;</span><br></pre></td></tr></table></figure><p>要用到数据流并发，必须用到数据流变量。一个数据流变量像一个单赋值(single-assignment)变量。一旦被绑定，不会再改变，以及之后任何新值的绑定将被忽略。下列例子定义了一个数据流变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> messageFromFuture = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br></pre></td></tr></table></figure><p>这里的Akka <code>Promise</code>被用作创建一个数据流变量。一个<code>Promise</code>为一个值的读处理，该值会在将来的某个时候被用到。任何数据流操作，会在<code>Future.flow</code>块中被处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.flow &#123;</span><br><span class="line">messageFromFuture()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述调用会处于一个线程等待中，直到有一个值被绑定到<code>messageFromFuture</code>。<code>Future.flow</code>返回一个<code>Future</code>，这样你可以处理其它操作，而不用阻塞主线程的执行。你可以把<code>Future</code>认为是用于接收某些并发操作结果的数据结构。要为数据流变量指派一个值，使用<code>&lt;&lt;</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.flow &#123;</span><br><span class="line">messsageFromFuture &lt;&lt; <span class="string">&quot;Future looks very cool&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个值被绑定到一个数据流变量，所有<code>Future</code>将等待，该值将被非阻塞，以能继续执行。下面列出使用dataflow变量的一个完整例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.dataflow._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Promise</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataflowExample</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;dataflow&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> messageFromFuture, rawMessage, parsedMessage = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br><span class="line">  flow &#123;</span><br><span class="line">    messageFromFuture &lt;&lt; parsedMessage()</span><br><span class="line">    println(<span class="string">&quot;z = &quot;</span> + messageFromFuture())</span><br><span class="line">  &#125;</span><br><span class="line">  flow &#123;</span><br><span class="line">    rawMessage &lt;&lt; <span class="string">&quot;dlrow olleh&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  flow &#123;</span><br><span class="line">    parsedMessage &lt;&lt; toAscii(rawMessage())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toAscii</span></span>(s: <span class="type">String</span>) = s.reverse</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下个小节将使用Akka的概念，构建一个应用，实践Akka并发。</p><h3><span id="12~3building-a-real-time-pricing-system-akkaooglep357">12~3〖Building a real-time pricing system: Akkaoogle〗P357</span></h3><p>略，请参考本书源码。</p><h3><span id="12~4adding-asynchronous-http-support-with-play2-minip375">12~4〖Adding asynchronous HTTP support with Play2-mini〗P375</span></h3><p>略，像Play2、Lift、Spray这些REST框架，基本上都封装了并发接口。Play2框架使用的是Netty作为NIO，包含大量易上手的工具和模版。请参考官网用户指导手册了解详情。</p><h3><span id="12~5-summaryp379">12~5 〖Summary〗P379</span></h3><p>在构建框架和应用中，Akka是一个强大的工具。Akka使得并发对编程者来说更容易，它提升了一个抽象层次。Akka并发框架构建在Actor之上，但也提供了所有流行的并发抽象技术。使得你可以在构建下一代应用中有更多的选择。Akka的STM支持可变数据结构的操作，最重要的是，你可以通过组合小部分原子性操作来解决问题。另外我们还探索了另外一个并发模式Agent，它让你从外部发送行为，修改安全管理器内的数据。额外地，还学习了Dataflow并发，通过数据流，能够让我们编写流式的程序，而不用担心它们之间的并发问题，Dataflow并发代码也很好理解和掌握，但要注意dataflow不适用于处理带有副作用的操作。</p><p>Akkaoogle是一个典型的并发应用，通过构建该应用，探索了如何思考并发问题，如何约束，设计以及抉择方案。Akka提供丰富的选项、灵活的配置，你应该从Akka上，拾取一些更好的特性和选项，以更好地适应你的应用项目。Akka早已经实践在各种真实应用中，我们应该炙手可热尝试一番。</p>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章：Scala和Java相互集成</title>
      <link href="/2016/10/27/scala/11-jvm-integrate/"/>
      <url>/2016/10/27/scala/11-jvm-integrate/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>Scala中使用Java</li><li>使用Java泛型和集合</li><li>集成问题</li><li>使用Java框架构建Web应用</li></ol><p>最激动人心的事情是，Scala可以运行在JVM上。这带来的好处是你可以使用构建在JVM语言上的所有框架和工具。基于JVM，更有一些公司甚至不使用Java作为他们的首选编程语言。对于大多数企业软件项目，我坚信不支持JVM的语言，几乎不可能实现。</p><p>Scala的一个主要设计目的，是令其运行在JVM上，并提供对Java的相互协作。Scala被编译为Java字节码，所以你可以使用如javap(Java class file disassembler)工具，对有Scala编译器生成的字节码进行反编译。大部分情况下，Scala的特性被转换为Java的特性，因此Scala可以轻松和Java集成。例如，Scala使用类型擦除来兼容Java。类型擦除<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (Type erasure)也允许Scala对JVM的动态类型进行集成。一些Scala特性(如traits)，不会直接地映射为Java，在这种情况下，你需要灵活变通地使用。</p><p>虽然对Java的大部分集成都可轻松实现，我仍然更推荐你使用 pure Scala。我尝试查找两者之间某些等价的部分，以及Scala不能实现的，则使用Java来解决。使用Java库的不好的方面是，你必须处理可变性、异常、空值这些Scala中绝对不会出现的问题。在Scala中，需要特别小心地选择Java的库或者框架。以一个编码良好的Java库<a href="http://joda-time.sourceforge.net">Joda-Time</a>为例。</p><p>Scala和Java最通常的集成，是指部分项目由Scala编写的。小节11.4将介绍Scala中使用Java框架，Hibernate、Spring等的web项目构建。</p><span id="more"></span><p>多数情况下，Scala和Java之间的集成是无缝的，但也需要注意某些例外。本章的目的是讲述，如何轻松地在Scala和Java之间进行集成，以及练习避免集成问题。Java类和框架的集成，尽管本书没有阐述，相信你已经很好地处理，但这里，你面临是两个语言的集成问题，并吸收接纳彼此的优势。</p><p>在一个已有的Java项目中阐述Scala，最好的方式是在其中编写Scala代码，并证明其超越Java语言的优势，并逐渐把Java部分，重写为Scala。这种过渡的工作会出现多次。</p><p>让我们开始本章中两个语言间的集成例子。你会学习到，解决处理那些在Java中可用，在Scala中不可用的特性问题，如Java的static静态成员、exceptions异常处理，以及Scala的特性在Java中怎样解决处理。你也将会学习Scala的注解在集成中的帮助，例如，生成JavaBean-style的get和set。本章的最后，将带领你学习构建一个使用Java框架的web应用。</p><h3><span id="11~1using-java-classes-in-scalap324">11~1〖Using Java classes in Scala〗P324</span></h3><p>在Java中集成Scala是很容易的。因为在Java中使用日期总是一个痛苦的过程，下面Java代码片段使用了Joda-Time库，用于计算两个日期之间的天数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.Chronology;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.Days;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">daysBetween</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        Days d = Days.daysBetween(<span class="keyword">new</span> DateTime(start.getTime()), <span class="keyword">new</span> DateTime(end.getTime()));</span><br><span class="line">        <span class="keyword">return</span> d.getDays();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chronology <span class="title">getChronologyUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DateTime.now().getChronology();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SBT项目中，要将上述代码保存到src/main/java/chap11/java文件夹。SBT能够识别跨编译的Java代码和Scala代码。要在Scala中使用这个类，继承这个类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCalculator</span>(<span class="params">val payPerDay: <span class="type">Int</span> = 100</span>) <span class="keyword">extends</span> <span class="title">DateCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculatePayment</span></span>(start: <span class="type">Date</span>, end: <span class="type">Date</span>) = &#123;</span><br><span class="line">    daysBetween(start, end) * payPerDay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了daysBetween方法进行计算。该集成是无缝的，你不会发现有什么不同。</p><blockquote><h4><span id="compiling-java-and-scala-together">Compiling Java and Scala together</span></h4><p>SBT知道如何构建混有Scala和Java的项目。Scala编译器允许你同时构建Java类和Java源代码。这样，如果你有Java和Scala间的双向依赖，你可以同时构建它们，而不用担心顺序问题。</p><p>当然，你也可以在Maven工具中构建混有Java和Scala的项目。要这样做，你应该在Maven中添加额外的Scala插件。在本章的最后，你将会使用Maven来构建一个示例项目。</p></blockquote><p>下小节，你会学习在Scala中如何使用Java的static成员。</p><h3><span id="1111working-with-java-static-membersp325">11<sub>1</sub>1〖Working with Java static members〗P325</span></h3><p>当使用声明了static成员的Java类是，你需要理解它们在Scala中是如何解析的。</p><p>Scala没有任何静态关键字，Scal解析Java的静态成员方法时，把它们认为是一个伴生对象的方法。看看下面的例子是如何工作的。代码中添加一个静态方法，返回Chronology：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.Chronology;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.Days;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">daysBetween</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        Days d = Days.daysBetween(<span class="keyword">new</span> DateTime(start.getTime()), <span class="keyword">new</span> DateTime(end.getTime()));</span><br><span class="line">        <span class="keyword">return</span> d.getDays();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chronology <span class="title">getChronologyUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DateTime.now().getChronology();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要访问这个静态成员，你需要引用它，并定义在一个伴生对象中，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCalculator</span>(<span class="params">val payPerDay: <span class="type">Int</span> = 100</span>) <span class="keyword">extends</span> <span class="title">DateCalculator</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">chronologyUsed</span> </span>= <span class="type">DateCalculator</span>.getChronologyUsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过定义在DateCalculator访问一个伴生对象，对静态方法访问。</p><blockquote><h4><span id="visibility-issues-between-scala-and-java">Visibility issues between Scala and Java</span></h4><p>Scala和Java间的可见性实现不同。</p><p>Scala在编译期强制可见性，但在运行期所有都是public的。这样做的一个原因是：在Scala中，伴生对象被允许访问伴生类的protected成员，但在字节层面，如果不另所有为public，则不能对其编码(encode)。</p><p>Java则在编译和运行期都强制可见性规则。这会带来一些例外。例如，如果你有一个定义在Java类的protected静态成员，在Scala中则没有任何方式对其访问。唯一变通的方法，是转换为一个public成员，以对其访问。</p></blockquote><p>接下来，将看到如何处理Java的异常检查，因为Scala没有这些东西。</p><h3><span id="1112working-with-java-checked-exceptionsp326">11<sub>1</sub>2〖Working with Java checked exceptions〗P326</span></h3><p>Scala缺少异常检测，Java基础代码每次编译时执行异常检测，这会带来不少疑惑。在Scala中你调用下面Java方法，你不需要在try/catch块中封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(String content)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">&quot;tmoFile&quot;</span>, <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> FileWriter(f).write(content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scala，你可以不需要try/catch块调用这个方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def write(content: String) = &#123;</span></span><br><span class="line">  | val w = new Writer</span><br><span class="line">  | w.writeToFile(content)</span><br><span class="line">  | &#125;</span><br><span class="line">write: (content: String)Unit</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> write(<span class="string">&quot;This is a test&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>作为一个编程人员，你的职责是决定是否需要捕获异常。Scala编译器不会强迫要求你这样做。这里，当你需要捕获异常时，不要从Scala中抛出异常。这是一个不好的习惯。最好的方式是创建一个<code>Either</code> 或  <code>Option</code>类型的实例。下面代码片段调用了<code>writeToFile</code>方法，并返回<code>Either[Exception,Boolean]</code>的一个实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(content: <span class="type">String</span>): <span class="type">Either</span>[<span class="type">Exception</span>, <span class="type">Boolean</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> w = <span class="keyword">new</span> <span class="type">Writer</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    w.writeToFile(content)</span><br><span class="line">    <span class="type">Right</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: java.io.<span class="type">IOException</span> =&gt; <span class="type">Left</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处是，你可以组合这些结果。要永远记住，异常不应该进行组合。但有些时候，你需要抛出一个异常，因为某些框架或客户端代码期望异常的抛出，这种情况，你可以使用Scala的注解来生成抛出异常的字节码(小节11.2.1有更多这方面内容)。现在，让我们转到Java的泛型上面来。应理解Java泛型如何工作的，因为它们在Java集合中用到。</p><h3><span id="1113working-with-java-generics-using-existential-typesp327">11<sub>1</sub>3〖Working with Java generics using existential types〗P327</span></h3><p>Java泛型直接转换为Scala的类型参数。例如 <code>Comparator&lt;T&gt;</code> 转换为 <code>Comparamot[T]</code>，<code>ArrayList&lt;T&gt;</code> 转换为 <code>ArrayList[T]</code>。但类以通配符方式定义在Java中，会变得有趣。下面是两个Java集合带通配符类型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;?&gt; names = <span class="keyword">new</span> Vector&lt;?&gt;()</span><br><span class="line">List numbers = <span class="keyword">new</span> ArrayList()</span><br></pre></td></tr></table></figure><p>这两种情况，类型参数都是未知的。像这些在Scala中称作原生类型(raw types)，以及已有的类型让你处理这些原生类型。<code>Vector&lt;?&gt;</code> 在Scala中可以表示为 <code>Vector[T] forSome &#123;type T&#125;</code>。从左到右读取，这个类型表达式代表的是一个类型为 <code>T</code> 的向量。这个 <code>T</code> 类型未知，它可以表示为任何东西。但 <code>T</code> 固定为向量的某些类型。</p><p>让我们看看如何在Scala中使用Java的原生类型。下面创建了一个带通配类型的Java向量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaRawType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;?&gt; languages() &#123;</span><br><span class="line">    Vector languages = <span class="keyword">new</span> Vector();</span><br><span class="line">languages.add(<span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">languages.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">languages.add(<span class="string">&quot;Haskell&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> languages;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JavaRawType.languages</code>返回一个向量，但用通配符 <code>?</code> 表示。要在Scala中使用这个language 方法，你需要使用已有的类型。类型声明为 <code>Vector[T] forSome &#123; type T&#125;</code>，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Vector</span> =&gt; <span class="type">JVector</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printLanguages</span></span>[<span class="type">C</span> &lt;: <span class="type">JVector</span>[<span class="type">T</span>] <span class="keyword">forSome</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">T</span>&#125;](<span class="params">langs: <span class="type">C</span></span>)</span>:<span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until langs.size) println(langs.get(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型C的上边界为存在类型集合，并打印所有Java向量元素。</p><p>有一种占位符的语法<code>JVector[_]</code>。它和 <code>JVector[T] forSome &#123;type T&#125;</code>是同一个意思。因此，上述代码等价地表示为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printLanguages</span></span>[<span class="type">C</span> &lt;: <span class="type">JVector</span>[_]](langs: <span class="type">C</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> until langs.size) println(langs.get(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4><span id="working-with-java-collections">Working with Java collections</span></h4><p>一旦你习惯了Scala强大的集合库，在Scala中使用Java集合库会变得痛苦。理想情况下，在Scala代码中使用Scala集合，并等价转换为Java代码，反之亦然。这样，你既可以使用强大的Scala集合库，在需要的使用便可轻松集成到Java基础代码中。Scala库为此提供了两个工具类用于转换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala.collection.<span class="type">JavaConversions</span></span><br><span class="line">scala.collection.<span class="type">JavaConverters</span></span><br></pre></td></tr></table></figure><p>这两个类都提供了同样的特性，但实现方式不同。JavaConversions提供了一系列的隐式转换，来对Java集合和Scala集合的近似转换。JavaConverters使用了一个 “Pimp my Library” 模式对Java集合添加了asScala方法、对Scala则添加了asJava方法。我推荐使用JavaConverters，因为它是显式的转换。下面例子使用了JavaConverters将java.util.List转换为Scala，然后再转换为Java：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import java.util.&#123;ArrayList =&gt; JList &#125;</span></span><br><span class="line">import java.util.&#123;ArrayList =&gt; JList&#125;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val jList = new JList[Int]()</span></span><br><span class="line">jList: java.util.ArrayList[Int] = []</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> jList.add(1)</span></span><br><span class="line">res1: Boolean = true</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> jList.add(2)</span></span><br><span class="line">res2: Boolean = true</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import scala.collection.JavaConverters._</span></span><br><span class="line">import scala.collection.JavaConverters._</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> jList.asScala foreach println</span></span><br></pre></td></tr></table></figure><p>作用在jList的asScala方法，将java.util.ArrayList转换为scala.collection.mutable.Buffer，这样你可以调用foreach方法。下面为将scala的List转换为java.util.List：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2).asJava</span></span><br><span class="line">res4: java.util.List[Int] = [1, 2]</span><br></pre></td></tr></table></figure></blockquote><h3><span id="11~2using-scala-classes-in-javap329">11~2〖Using Scala classes in Java〗P329</span></h3><p>Scala语言最有趣的特性之一是特质(traits)，基础代码中被大量用到。如果你定义一个特质仅带有抽象方法，它可以编译得到Java接口，并直接在Java中使用，而不会带来任何问题。但如果这个特质带有具体的方法，则会有些微妙。让我们以一个例子来看看，这种情况下是如何编译成Java字节码的。</p><p>下面是一个Scala特质，它以混入的方式将对象持久化到数据库中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Persistable</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getEntity</span></span>: <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(): <span class="type">T</span> = &#123;</span><br><span class="line">    persistToDb(getEntity)</span><br><span class="line">    getEntity</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">persistToDb</span></span>(t: <span class="type">T</span>) = &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里带有一个抽象方法getEntity和两个具体方法，save和persistToDb。当这段代码被编译时，Scala编译器会生成两个类文件，<code>Persistable.class</code>和<code>Persistable$class</code>。要检验每个类文件的内容，你可以使用SBT控制台 <code>:javap</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :javap chap11.scala.Persistable</span></span><br><span class="line">Compiled from &quot;ScalaJavaMash.scala&quot;</span><br><span class="line">public interface chap11.scala.Persistable extends scala.ScalaObject&#123;</span><br><span class="line">public abstract java.lang.Object getEntity();</span><br><span class="line">public abstract java.lang.Object save();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :javap chap11.scala.Persistable<span class="variable">$class</span></span></span><br><span class="line">Compiled from &quot;ScalaJavaMash.scala&quot;</span><br><span class="line">public abstract class chap11.scala.Persistable$class extends</span><br><span class="line">  java.lang.Object&#123;</span><br><span class="line">public static java.lang.Object save(chap11.scala.Persistable);</span><br><span class="line">public static void $init$(chap11.scala.Persistable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件 Persistable.class 表示Java接口，包含所有定义在Persistable特质的公共方法，以及继承了scala.ScalaObject。Scala中所有用户定义的类都继承了scala.ScalaObject。另一方面，Persistable$class文件定义了一个抽象类，该抽象类定义特质中所有的具体方法。可以把这个抽象类认为是一个门面，作用在trait定义的所有具体方法。</p><p>在Java中，你将继承这个接口，并使用抽象类作为一个门面来访问特质中的具体方法。下面示例中Account实现了Persistable接口，并使用Persistable$class的静态方法，来访问Persistable特质的具体方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Persistable</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Account) Persistable$class.save(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Persistable接口的实现是直接的。 getEntity返回Account对象的一个实例，save方法代表Persistable$class类中的静态方法save，来访问trait的实现定义。注意当使用层叠的特质时，创建一个具体的Scala类，然后在Java中直接使用或继承会更好些。</p><p>当集成Scala和Java框架，第一个障碍是Scala类没有JavaBean-style的 get 和 set 方法。Scala注解提供了这样的灵活性，来指定让Scala编译器生成字节码。</p><h3><span id="1121using-scala-annotationsp331">11<sub>2</sub>1〖Using Scala annotations〗P331</span></h3><p>Scala不遵循标准的Java getter和  setter 模式。在Scala中，getters 和 setters看起来不一样。例如，要创建一个Scala-style的getter和setter的Scala类，你需要做的是将成员声明为var，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaBean</span>(<span class="params">var name: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>当被编译，该类生成下面字节码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :javap chap11.scala.ScalaBean</span></span><br><span class="line">Compiled from &quot;ScalaJavaMash.scala&quot;</span><br><span class="line">public class chap11.scala.ScalaBean extends java.lang.Object</span><br><span class="line">  implements scala.ScalaObject&#123;</span><br><span class="line">public java.lang.String name();</span><br><span class="line">public void name_$eq(java.lang.String);</span><br><span class="line">public chap11.scala.ScalaBean(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较下面代码，便会说得通：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = new chap11.scala.ScalaBean(<span class="string">&quot;Nima&quot;</span>)</span></span><br><span class="line">s: chap11.scala.ScalaBean = chap11.scala.ScalaBean@6cd4be25</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.name</span></span><br><span class="line">res0: String = Nima</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.name = <span class="string">&quot;Paul&quot;</span></span></span><br><span class="line">s.name: String = Paul</span><br></pre></td></tr></table></figure><p>如果你添加 scala.beans.BeanProperty注解到一个属性中，Scala编译器会生成相应的get 和 set方法。例如这里的name，便会生成getName 和 setName 方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaBean</span>(<span class="params">@scala.beans.<span class="type">BeanProperty</span> var name: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>使用javap检视，则有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :javap chap11.scala.ScalaBean</span></span><br><span class="line">Compiled from &quot;ScalaJavaMash.scala&quot;</span><br><span class="line">public class chap11.scala.ScalaBean extends java.lang.Object implements</span><br><span class="line">  scala.ScalaObject&#123;</span><br><span class="line">public java.lang.String name();</span><br><span class="line">public void name_$eq(java.lang.String);</span><br><span class="line">public void setName(java.lang.String);</span><br><span class="line">public java.lang.String getName();</span><br><span class="line">public chap11.scala.ScalaBean(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用BeanProperty注解，Scala编译器会同时生成Scala和Java风格的get和set方法。使用BeanProperty的确会增加生成class文件的大小，但对于和Java协作性方面是个很小的代价。现在，如果你想要生成JavaBean-compliant BeanInfo，你可以使用scala.beans.BeanInfo。</p><p>小节11.1展示了Scala不对异常检测作处理，因为Scala没有throws关键字来声明方法抛出异常。问题来了。例如，你想要使用Scala来声明一个java.rmi.Remote接口，你困惑的是Remote中每个声明的方法都需要抛出RemoteException。再一次，使用注解，你可以指明Scala编译器生成方法的throws。下面代码定义一个个RMI接口：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RemoteLogger</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span> </span>&#123;</span><br><span class="line">  <span class="meta">@throws</span>(classOf[java.rmi.<span class="type">RemoteException</span>])</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(m: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质RemoteLogger继承了标准java.rmi.Remote，标记该接口为一个RMI远程接口；要生成throws捕获，只需要使用Scala标准库中定义的scala.throws注解。查阅生成的字节码，你将看到 throws 从句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :javap chap11.scala.RemoteLogger</span></span><br><span class="line">Compiled from &quot;ScalaJavaMash.scala&quot;</span><br><span class="line">public interface chap11.scala.RemoteLogger extends java.rmi.Remote&#123;</span><br><span class="line">  public abstract void log(java.lang.String) throws</span><br><span class="line">java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用Scala的目标元注解的方式，来控制注解的位置，例如下面代码 @Id注解会仅添加到Bean getter的 getX上面：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.<span class="type">Id</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; @(<span class="type">Id</span> <span class="meta">@beanGetter</span>) <span class="meta">@BeanProperty</span> <span class="keyword">val</span> x = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>否则，默认地，字段上的注解最终在字段上面。这个很重要，因为当你处理某些Java框架时，有些特别要求注解的定义。下个小节将看到目标注解的一些用法，以及如何在Scala中使用流行框架，如Spring、Hibernate。</p><h3><span id="11~3building-web-applications-in-scala-using-java-frameworksp332">11~3〖Building web applications in Scala using Java frameworks〗P332</span></h3><p>本章介绍使用Scala和Java框架构建一个web应用。这个例子将展示在Java-heavy环境中使用Scala，当吸收或迁移到Scala，你不必丢弃你在Java框架上的投入和基础。显然，使用框架来构建Scala，某些示例代码会有出入。无碍，在没有接触任何Scala框架之前，学习Java框架同样重要。在本小节，你将构建一个web应用，使用到Spring和Hibernate框架。你将离开你最喜欢的构建工具，SBT，以及使用Maven来构建你的Java，因为它是Scala中最常用的。</p><p><strong>注意</strong> 本小节要求你已经掌握了Spring、Hibernate以及Maven构建工具来构建Java Web应用。如果没有，这会很难跟上。保守起见，如果你对Java框架不感兴趣，也可以跳过该小节。</p><p>在此之前，让我们理清你将构建一个怎样的应用。你将构建一个i额小的web应用，叫做topArtists，用于展示来自Last.fm的艺术家。Last.fm是一个流行的音乐网站，可以通过收音机频道进入访问。Last.fm同时也提供了一个API，通过该API可以获得各种各样的音乐排行榜。你将使用它的chart.getTopArtists的REST API来获取所有当前的艺术家，并保存到本地数据库中。你也将从本地数据库中展示所有的艺术家数据给用户。</p><p><strong>注意</strong> 你首先要做的是获得一个来自Last.fm的API key。你可以从Last.fm的 <a href="www.last.fm/api/authentication">网站</a>获得。</p><p>如果你做过Java开发，你可能最经常使用的是Maven。Maven知道如何编译Java源文件，但要编译Scala文件，你需要添加Maven的Scala插件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。要使用Maven创建一个空白web应用，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=scala.in.action -DartifactId=top.artists -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure><p>该项目的结构，实质上和SBT项目是一样的(SBT 遵循Maven的约定)。创建了pom.xml文件后，便可以配置所有的依赖。</p><p>对于topArtists应用，你将使用Spring来构建web层，并作为依赖注入框架。Hibernate则作为ORM层，应用保存所有artists到数据库中。作为练手，你将使用数据库HSQLDB。但要作REST请求，你将使用纯的Scala库 dispatch<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。 Dispatch是一个Scala库，构建在Async Http Client库上，使得它易于作web services<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。</p><h3><span id="1131building-the-model-view-and-controllerp334">11<sub>3</sub>1〖Building the model, view, and controller〗P334</span></h3><p>该topArtists应用展示了来自Last.fm的REST API。要看从Last.fm接收的信息，在任何浏览器窗口调用下面的URL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ws.audioscrobbler.com/2.0/?method=chart.gettopartists&amp;api_key=&lt;your api key&gt;</span><br></pre></td></tr></table></figure><p>但前提先确保你在 <a href="http://Last.fm">Last.fm</a> 拥有API Key。如果该请求成功，你可以看到艺术家的相关信息，如名字、播放次数、听众、链接等其它属性。为了使问题简单化，我们仅取来自第一页的结果，并存储艺术家的名字、播放次数、以及听众。这个领域模型看起来如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chap11.top.artists.model</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Artist</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">var</span> playCount: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> listeners: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用了Hibernate作为你的ORM工具，你需要使你的领域对象与Hibernate相适。首先使用@BeanProperty来生成JavaBean-style的get/set方法。再使用javax.persistence的注解标注属性。下面为完整的领域对象代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chap11.top.artists.model</span><br><span class="line"><span class="keyword">import</span> reflect.<span class="type">BeanProperty</span></span><br><span class="line"><span class="keyword">import</span> javax.persistence._</span><br><span class="line"><span class="keyword">import</span> scala.annotation.target.field</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Artist</span> </span>&#123;</span><br><span class="line">  @(<span class="type">Id</span> <span class="meta">@field</span>) @(<span class="type">GeneratedValue</span> <span class="meta">@field</span>) <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> playCount: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="meta">@BeanProperty</span></span><br><span class="line">  <span class="keyword">var</span> listeners: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Artist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, playCount: <span class="type">Long</span>, listeners: <span class="type">Long</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">Artist</span></span><br><span class="line">    a.name = name</span><br><span class="line">    a.playCount = playCount</span><br><span class="line">    a.listeners = listeners</span><br><span class="line">    a</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>Hibernate实现了Java Persistence API (JPA)，以及使用JPA注解Entity标明Hibernate将持久化该对象到数据库中。你可以使用Id注解来标识ID字段，以及使用scala.annotation.target来生成带有Id和GeneratedValue注解的字段。</p><p>为了将接收的艺术家信息保存到数据库中，需要用到Hibernate的session factory。创建一个ArtistDb封装。它将隐藏Hibernate规范的详细剩余内容。该类可以作为一个数据访问对象。因为你使用了Spring，你可以轻松地必要的Hibernate依赖到新类中。下面列出ArtistDb类的完整实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">List</span> =&gt; <span class="type">JList</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.scala.chapter6.top_artists.model.<span class="type">Artist</span></span><br><span class="line"><span class="keyword">import</span> org.hibernate.<span class="type">SessionFactory</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.<span class="type">Autowired</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.<span class="type">Repository</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.<span class="type">Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ArtistDb</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAll</span></span>: <span class="type">JList</span>[<span class="type">Artist</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(artist: <span class="type">Artist</span>): <span class="type">Long</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtistRepository</span> <span class="keyword">extends</span> <span class="title">ArtistDb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">var</span> sessionFactory: <span class="type">SessionFactory</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(artist: <span class="type">Artist</span>): <span class="type">Long</span> = currentSession.save(artist).asInstanceOf[<span class="type">Long</span>]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span>(readOnly = <span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAll</span></span>: <span class="type">JList</span>[<span class="type">Artist</span>] = currentSession.createCriteria(classOf[<span class="type">Artist</span>]).</span><br><span class="line">                               list().asInstanceOf[<span class="type">JList</span>[<span class="type">Artist</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">currentSession</span> </span>= sessionFactory.getCurrentSession</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类ArtistRepository类用Spring的原型注解Repository标识，这样Spring框架可以自动地浏览并装载。当Spring装载该类时，也设置了sessionFactory依赖。下个小节，将看到这些组件是如何配置的。现在，先假设sessionFactory在ArtistRepository是可以用的。save方法比较直接：使用当前Hibernate session，它将Artist的一个实例存储到数据库中。 <code>asInstanceOf[Long]</code>类型转换得到Long。在这里，你应该知道save操作返回对象Id。findAll方法，将查询数据库，并返回所有的artists。这里类型转换为list，Hibernate默认list方法返回一个List对象。至此，你已经可以将接收的领域对象保存到数据库中。下面来构建控制器。</p><p>前面讨论过，你将使用Spring来构建你的web应用层。这里，将使用Spring的原型注解@Controller来标识类为控制器。控制器的工作是获得来自Last.fm的艺术家信息，以及展示存储在本地数据库的艺术家信息。你已经有一个ArtistDb来获得来自数据库的艺术家信息，所以你可以注入一个ArtistDb的实例到控制器中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtistsController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">val</span> db: <span class="type">ArtistDb</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller添加一个URL的方法映射，并返回艺术家列表到视图：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="type">Array</span>(<span class="string">&quot;/artists&quot;</span>), method = <span class="type">Array</span>(<span class="type">GET</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadArtists</span></span>() =</span><br><span class="line"><span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">&quot;artists&quot;</span>, <span class="string">&quot;topArtists&quot;</span>, db.findAll)</span><br></pre></td></tr></table></figure><p>@RequestMapping注解映射地址 “/artists” URI到方法loadArtists中。该方法使用db.findAll来查找来自数据库的所有艺术家。ModelAndView的第一个参数为视图渲染名称。topArtists参数为db.findAll的响应内容。使用视图里面的topArtists名称，你可以访问所有调用findAll得到的艺术家。但在获取艺术家信息之前，先要得到来自Last.fm的信息列表。即允许用户刷新艺术家信息，并保存到本地数据库中。要实现刷新，调用Last.fm的REST API。<a href="http://xn--DispatchLast-ov8s620ozw1ai99bka1346h.fm">使用Dispatch库来调用Last.fm</a>。Dispatch提供了一个优秀的DSL或者Apache HttpClient库的转换器。下面代码片段创建一个Http请求对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rootUrl = <span class="string">&quot;http://ws.audioscrobbler.com/2.0/&quot;</span></span><br><span class="line"><span class="keyword">val</span> apiMethod = <span class="string">&quot;chart.gettopartists&quot;</span></span><br><span class="line"><span class="keyword">val</span> apiKey = sys.props(<span class="string">&quot;api.key&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> req = url(rootUrl + <span class="string">&quot;?method=&quot;</span> + apiMethod + <span class="string">&quot;&amp;api_key=&quot;</span> + apiKey)</span><br></pre></td></tr></table></figure><p>API key来自system属性。当运行该应用，你必须指定API key为一个系统属性。url方法接收一个字符URL作为输入，并返回一个Http请求实例。但创建一个Http请求不会再作更多内容，因此要告诉Dispatch如何处理接收来自请求的响应内容。你可以通过一个具体的操作实现。这里我们使用内建的 as.xml.Elem来处理这些XHTML响应：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Http</span>(req <span class="type">OK</span> as.xml.<span class="type">Elem</span>).map &#123;resp =&gt; ...&#125;</span><br></pre></td></tr></table></figure><p>Http返回scala.xml.Elem的Promise(因为每个HTTP请求都是异步处理的)，我们使用map来访问Promise对象的内容。因为我们没有使用Spring的异步支持，我们需要等待Promise来完成结果渲染。来自Last.fm的响应包含一个XML，它是个web service接口：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lfm</span> <span class="attr">status</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artists</span> <span class="attr">page</span>=<span class="string">&quot;1&quot;</span> <span class="attr">perPage</span>=<span class="string">&quot;50&quot;</span> <span class="attr">totalPages</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">total</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artist</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">artist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artist</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">artist</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">artists</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">lfm</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以使用Scala的本地XML解析该结果。Dispatch早已将response转换为一个NodeSeq实例，现在你可以解压这些艺术家信息，创建一个Hibernate Artist对象，并保存到数据库中。下面方法为解压操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">retrieveAndLoadArtists</span></span>() &#123;</span><br><span class="line">  <span class="keyword">val</span> rootUrl = <span class="string">&quot;http://ws.audioscrobbler.com/2.0/&quot;</span> </span><br><span class="line">  <span class="keyword">val</span> apiMethod = <span class="string">&quot;chart.gettopartists&quot;</span></span><br><span class="line">  <span class="keyword">val</span> apiKey = sys.props(<span class="string">&quot;api.key&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> req = url(rootUrl + <span class="string">&quot;?method=&quot;</span> + apiMethod + <span class="string">&quot;&amp;api_key=&quot;</span> + apiKey)</span><br><span class="line">  <span class="type">Http</span>(req <span class="type">OK</span> as.xml.<span class="type">Elem</span>).map &#123;resp =&gt;</span><br><span class="line">      <span class="keyword">val</span> artists = resp \\ <span class="string">&quot;artist&quot;</span></span><br><span class="line">      artists.foreach &#123;node =&gt;</span><br><span class="line">        <span class="keyword">val</span> artist = makeArtist(node)</span><br><span class="line">        println(artist.name)</span><br><span class="line">        db.save(artist)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()  <span class="comment">//applying the promise</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeArtist</span></span>(n: <span class="type">Node</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> name = (n \ <span class="string">&quot;name&quot;</span>).text</span><br><span class="line">  <span class="keyword">val</span> playCount = (n \ <span class="string">&quot;playcount&quot;</span>).text.toLong</span><br><span class="line">  <span class="keyword">val</span> listeners = (n \ <span class="string">&quot;listeners&quot;</span>).text.toLong</span><br><span class="line">  <span class="type">Artist</span>(name = name, playCount = playCount, listeners = listeners)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller的刷新动作需要用到retrieveAndLoad方法来装载并保存艺术家到数据库中，并展示到view。下面为该controller的完整实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chap11.top.artists.controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.<span class="type">Controller</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.<span class="type">Autowired</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.<span class="type">RequestMapping</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.<span class="type">RequestMethod</span>._</span><br><span class="line"><span class="keyword">import</span> chap11.top.artists.db.<span class="type">ArtistDb</span></span><br><span class="line"><span class="keyword">import</span> chap11.top.artists.model.<span class="type">Artist</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.<span class="type">ModelAndView</span></span><br><span class="line"><span class="keyword">import</span> dispatch._</span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">Node</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtistsController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">val</span> db: <span class="type">ArtistDb</span> = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="type">Array</span>(<span class="string">&quot;/artists&quot;</span>), method = <span class="type">Array</span>(<span class="type">GET</span>))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loadArtists</span></span>() =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">&quot;artists&quot;</span>, <span class="string">&quot;topArtists&quot;</span>, db.findAll)  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="type">Array</span>(<span class="string">&quot;/refresh&quot;</span>), method = <span class="type">Array</span>(<span class="type">GET</span>))  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">refresh</span></span>() = &#123;</span><br><span class="line">    retrieveAndLoadArtists()</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">&quot;artists&quot;</span>, <span class="string">&quot;topArtists&quot;</span>, db.findAll) </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">retrieveAndLoadArtists</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> rootUrl = <span class="string">&quot;http://ws.audioscrobbler.com/2.0/&quot;</span> </span><br><span class="line">    <span class="keyword">val</span> apiMethod = <span class="string">&quot;chart.gettopartists&quot;</span></span><br><span class="line">    <span class="keyword">val</span> apiKey = sys.props(<span class="string">&quot;api.key&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> req = url(rootUrl + <span class="string">&quot;?method=&quot;</span> + apiMethod + <span class="string">&quot;&amp;api_key=&quot;</span> + apiKey)</span><br><span class="line">    <span class="type">Http</span>(req <span class="type">OK</span> as.xml.<span class="type">Elem</span>).map &#123;resp =&gt;</span><br><span class="line">        <span class="keyword">val</span> artists = resp \\ <span class="string">&quot;artist&quot;</span></span><br><span class="line">        artists.foreach &#123;node =&gt;</span><br><span class="line">          <span class="keyword">val</span> artist = makeArtist(node)</span><br><span class="line">          println(artist.name)</span><br><span class="line">          db.save(artist)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;()  <span class="comment">//applying the promise</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeArtist</span></span>(n: <span class="type">Node</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> name = (n \ <span class="string">&quot;name&quot;</span>).text</span><br><span class="line">    <span class="keyword">val</span> playCount = (n \ <span class="string">&quot;playcount&quot;</span>).text.toLong</span><br><span class="line">    <span class="keyword">val</span> listeners = (n \ <span class="string">&quot;listeners&quot;</span>).text.toLong</span><br><span class="line">    <span class="type">Artist</span>(name = name, playCount = playCount, listeners = listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经有了model和controller，现在切换到view上。这个简单的视图接收来自controller的响应内容，并使用JSP渲染。该视图使用单纯的Java处理，但你完全可以使用有Java编写的模版库，如<a href="http://scalate.fusesource.org">Scalate</a>。你的JSP视图会接收topArtists参数，并迭代渲染响应内容。下面为该视图代码清单：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/functions&quot;</span> prefix=<span class="string">&quot;fn&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Top Artists from Last.fm&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">   &lt;a href=<span class="string">&quot;&lt;c:url value=&quot;</span>/refresh.html<span class="string">&quot;/&gt;&quot;</span>&gt;Refresh from Last.fm&lt;/a&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line">&lt;h2&gt;Top artists&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;fn:length(topArtists) == 0&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;No artists found in database. Refresh from Last.fm&lt;/h3&gt;</span><br><span class="line">  &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;th&gt;Name&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;Play count&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;Listeners&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;topArtists&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;artist&quot;</span>&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;artist.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;artist.playCount&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;artist.listeners&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>你使用topArtists来访问artists列表，并展示。下个小节你将集成Spring配置文件的所以片段。</p><h3><span id="1132configuring-and-running-the-applicationp340">11<sub>3</sub>2〖Configuring and running the application〗P340</span></h3><p>你会用到Spring的配置来配置Spring MVC和 Hibernate。这样Spring会确保所有需要的依赖被合适得初始化并注入。因为你遵循Spring配置层上的约定，在配置Scala类上，完全没问题。这在Scala和Java互操作上优越是明显的。下面为spring-context-data.xml文件，它应用配置模型和控制器对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;chap11.top.artists.db&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:hsqldb:mem:scala-spring-hibernate&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sa&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;annotatedClasses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>chap11.top.artists.model.Artist<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.HSQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>create<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件中，你配置了Hibernate方言为HSQLDB。以及使用Spring组件浏览方式来查找ArtistDb，以此初始化Hibernate的必要依赖项。接下来为spring-context-web.xml文件，它配置了控制器以及HTTP请求拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;chap11.top.artists.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;openSessionInViewInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.support.OpenSessionInViewInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;openSessionInViewInterceptor&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来为web.xml配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;scala-spring-hibernate&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-context-data.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-context-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有的Java web容易读取web.xml来初始化Java-based web应用。监听器listener属性允许应用监听由容器生成的事件，例如一个应用被加载或没被加载。这里，监听器的配置是ContextLoaderListener，该类通过读取context-param，知道如何配置Spring。要运行应用，你可以使用早以配置的jetty服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -Dapi.key=&lt;your-last.fm-pai-key&gt; jetty:run</span><br></pre></td></tr></table></figure><p>正如你所看，使用Scala和Java框架，建立并创建web应用是容易的。当使用Java框架是，某些样板配置是不可避免的，但你让然可以编写有趣的Scala代码。</p><h3><span id="11~4summaryp343">11~4〖Summary〗P343</span></h3><p>本章所阐述的是，Scala对Java的互操作是无痛的(pain-free)。很少地方你需要做防护措施，但对于大部分你都可以不用顾虑太多地集成已有的Java基础代码。额外要小心的，则是集成某些Scala特性，在Java中并不支持，反之亦然。在本章介绍了如何处理这种问题。因为Scala被设计来自渐渐成长的Java，大多数变通的地方都可以简单地学习和实现。</p><p>简单集成Java，意味着你可以容易地在已有代码中使用Scala。在最后的一个例子中证明了，你可以使用Scala和已有的流行的Java框架进行集成，而不用重写整个应用。</p><p>下个章节将进入到最激动人心的Scala框架：Akka。该框架让你使用丰富的并发模型来构建大型的、可伸缩的、分布式的应用。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Java Tutorials: Type erasure, <a href="http://download.oracle.com/javase/tutorial/java/generics/erasure.html">http://download.oracle.com/javase/tutorial/java/generics/erasure.html</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Maven Scala plug-in download, <a href="http://scala-tools.org/mvnsites/maven-scala-plugin/">http://scala-tools.org/mvnsites/maven-scala-plugin/</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Dispatch Scala library: <a href="http://dispatch.databinder.net/Dispatch.html">http://dispatch.databinder.net/Dispatch.html</a>.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">See “AsyncHttpClient/async-http-client,” <a href="https:/github.com/AsyncHttpClient/async-http-client">https:/github.com/AsyncHttpClient/async-http-client</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章：Scala之单元测试</title>
      <link href="/2016/10/27/scala/10-scala-test/"/>
      <url>/2016/10/27/scala/10-scala-test/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>ScalaCheck自动化</li><li>使用JUnit来测试Scala代码</li><li>使用依赖注入编写更好的测试</li><li>Specs行为驱动开发</li><li>基于actor系统测试</li></ol><p>截至目前为止，所展示的代码都没有单元测试——为什么我们现在要关心这个问题？围绕代码写测试，而又不提及它做了什么，是希望你更专注于Scala语言本身。现在，本章的目标是希望编写自动化的Scala单元测试，用于更好地构建高质量的软件。</p><p>编写精良<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的代码，从你编程单元测试开始。通常感性认识是很难编写单元测试，但这章要改变这种心态。我将为你展示，如测试驱动开发和持续集成的练习开始，如何在你的Scala项目中编写测试。测试驱动开发(test-driven development，TDD)就是指在你编写代码之前编写测试。我知道这有点落后，但我保证，这章结束后它将更有意义。你将学习的测试，更多的是设计一个测试，正如设计你的软件一样。你的设计工具将会是代码——更特别地，测试的代码。</p><p>我将由介绍自动化测试和开发者如何在真实环境中使用来开始。有两种自动化测试：一种是你自己写的，一种是从你的代码中生成的。首先要介绍的是代码生成的测试，使用ScalaCheck工具，因为它比较容易。Sala是一个强静态类型语言，利用这点，诸如ScalaCheck这样的工具可以为你构建在类型上的函数或类生成单元测试。ScalaCheck是自动化测试的一种很好实现。但要完全信服自动化测试带来的好处，你需要手动编写它们。</p><span id="more"></span><p>本章的主要重点是自动化测试。很多测试工具都可以用于Scala代码之中，但本章仅使用两个工具：JUnit(<a href="http://www.junit.org">www.junit.org</a>) 和 Specs (<a href="http://etorreborre.github.com/specs2/">http://etorreborre.github.com/specs2/</a> )。</p><p>如果你是一个Java开发者，并曾经使用过JUnit，在Scala中使用它则会很容易。Specs是一个用于Scala并由Scala编写的单元测试工具，它在你的Scala代码中提供了更多的表达式。我将带你编写这些测试，让该工具为你可用，以及设计技术让你可以使你的设计进行测试。你设计的可测试属性，决定了编写测试的难易程度。我将向你展示如何在Scala中实现依赖注入。</p><p>依赖注入是一个设计模式，以使得开发者更容易测试他们的代码。作为一门混编语言，Scala提供了大量的抽象技术，你可以使用这些技术实现依赖注入。本章将探索所有这些内容。我也将向你展示如何使用一个框架，如Spring，Java的一个流行的依赖注入框架，在Scala中的实现。</p><p>编写自动化测试通常说很难实现，但事实上你使用了正确的工具和技术它将变得容易。不带更多的等待，让我们由问题开始：什么是自动化？它们是如何在软件开发处理中融合？</p><h3><span id="10~1importance-of-automated-testingp284">10~1〖Importance of automated testing〗P284</span></h3><blockquote><p>我不关心你认为你设计写得如何好，如果在5分钟内我不能进入你的设计，并任意编写测试，它就没有你想象的那么好，无论你是否清楚，你将为它付出代价。——Michael Feathers</p></blockquote><p>自动化测试用于测试那些用于记录的、预编写的，能够被机器运行而不用手动干涉。允许你运行这些测试的工具称为 <em>自动化测试工具</em> 。前面提及过，有两种自动化测试：一是自己写的，一是由工具生成的。不管自动化测试如何创建，重要的是应该明白它们是如何运行的。为了体会它带来的好处，让我们探索下自动化测试如何融入到敏捷软件开发<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (agile software development)处理中。机会是你已经在做自动化测试，如果没有，这些测试仍然有很大的价值。</p><p>在敏捷软件开发进程中，团队不会分析和设计应用程序；他们使用演化设计[3] (evolutionary design)来构建。在这些开发进程，开发者仅设计今天的，不考虑明天的事情。他们只设计今天所知道的程序，并且明白今天的设计决定到了明天或许就是错误的。他们逐步实现程序的功能。在这种模式，应用程序的设计发展和经历了很多次的改变。两个重要的问题需要回答：</p><ul><li>自动化测试应该为发展中的设计做些什么？</li><li>为什么发展中的设计，比起应用程序预先的设计要好？</li></ul><p>第一个问题在本章来说比较重要。自动化测试是重要的，因为你的应用程序经历了多次的改变，你可能脱离了原来的功能。在这种不断变化的环境中，你不可能继续手动进行测试。你需要重复运行自动化测试，以确保你的应用表现为你所期待的，以及不会发生不期望的事情。</p><p>第二个问题是为什么演化设计更好。为什么不预先设计好应用，这样我们就不用频繁地去改变？在某些情况下，你会预先设计，如商业产品的集成，你不需要过渡控制它的源代码。</p><p>但更多的情况下是，你需要应付日益改变的需求。敏捷软件开发尝试减少这些改变带来的花销、修正这些预先设计，但面对需求的改变，这很难实现。最终变成了维护和更改预设计<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的开销。</p><p>你不能认为你实现了应用的所有功能，或者你应用上的各种各样的组件都能彼此正常工作。应用做得越大，预设计就变得越困难。敏捷处理强调更多的增量的实现，你构建了一点点，那么就测试一点点，并带客户重现这些功能，以让他们给反馈。自动化测试，并给予反馈以确保应用工作，这步是至关重要的。</p><p>自动化测试仅帮你发现问题，它们也作为应用的文档工作。如果你想要理解一个类或组件的行为，你可以查阅相关的单元测试。10.6小节将向你展示如何使用Specs开发可执行的文档。传统方式的文档的问题是，文档陈旧的很快，随着代码的改变我们大多数都会忘记去更新。但如果你扮演文档角色的测试，随着代码的改变，也将保持最新，因为每一个代码的改变都会预先于测试处理。</p><p>有很多种自动化测试类型，举几个来说：基于规范的(specification-based)、单元的、集成的、功能的、以及回归测试(regression)。本章专注于规范测试和单元测试的驱动测试软件。其它类型的测试同样扮演了重要的角色，但超出了本章的范围。在规范测试中，应用的行为表述为一个可执行的描述，测试生成工具打破这种描述。另一方面，单元测试就像是你编写了设计，以及验证。</p><p>如果你没有做过任何自动化测试，可能需要花些时间来习惯。但也不用担心，过早关心只会得不偿失。你将会迅速改变，因为现在你的测试需要提供反馈。</p><p>我会从使用ScalaCheck开始讨论如何生成自动化测试，以此你可以了解自动化测试带来的好处，当你在Scala项目中学习编写这些测试时。</p><blockquote><p>Specification Based Testing Technique is also known as Behavior Based Testing and Black Box Testing techniques because in this testers view the software as a black-box. As they have no knowledge of how the system or component is structured inside the box. In essence, the tester is only concentrating on what the software does, not how it does it.</p><p>Both Functional Testing and Non-Functional Testing is type of Specification Based Testing.</p></blockquote><blockquote><p>Specification Based Test Design Technique uses the specification of the program as the point of reference for test data selection and adequacy. A specification can be any thing like a written document, collection of use cases, a set of models or a prototype.</p></blockquote><h3><span id="10~2automated-test-generation-using-scalacheckp286">10~2〖Automated test generation using ScalaCheck〗P286</span></h3><p>ScalaCheck是一个用于Scala和Java的测试工具，生成的测试数据建立在属性规范上。它的基本原理是，定义一个属性指定代码片段的行为，ScalaCheck将自动生成随机的测试数据，以检测这些属性是否为true。这里不要把ScalaCheck的属性跟JavaBean的属性弄混。在ScalaCheck，一个属性是一个可测试的单元。为了在ScalaCheck中创建一个新的属性，你必须创建一个语句来描述你想要测试的行为。例如，下面我声明了reverse方法定义在String类中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> anyString = <span class="string">&quot;some string value&quot;</span></span><br><span class="line">anyString.reverse.reverse == anyString</span><br></pre></td></tr></table></figure><p>我想要在一个String实例中，reverse被调用两次，并得到相同的结果断言。ScalaCheck的任务就是由生成的随机测试数据伪造这些语句。下面我们小试一下。创建一个名为scalacheck的目录，添加build.sbt文件到该目录：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;ScalaCheckExample&quot;</span></span><br><span class="line">version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line">organization := <span class="string">&quot;Scala in Action&quot;</span></span><br><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">resolvers ++= <span class="type">Seq</span>(</span><br><span class="line"><span class="string">&quot;Sonatype Snapshots&quot;</span> at <span class="string">&quot;http://oss.sonatype.org/content/repositories/</span></span><br><span class="line"><span class="string">snapshots&quot;</span>,</span><br><span class="line"><span class="string">&quot;Sonatype Releases&quot;</span> at <span class="string">&quot;http://oss.sonatype.org/content/repositories/</span></span><br><span class="line"><span class="string">releases&quot;</span></span><br><span class="line">)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span> (</span><br><span class="line"><span class="string">&quot;org.scalacheck&quot;</span> %% <span class="string">&quot;scalacheck&quot;</span> % <span class="string">&quot;1.10.0&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// append options passed to the Scala compiler</span></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-deprecation&quot;</span>, <span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-feature&quot;</span>)</span><br></pre></td></tr></table></figure><p>项目会自动下载ScalaCheck依赖到项目中(别忘了reload 和 update)。你也可以在 (<a href="http://code.google.com/p/scalacheck/downloads/list">http://code.google.com/p/scalacheck/downloads/list</a>) 下载最新版本。本章的所有例子都将使用到SBT，因为需要频繁的构建和编译。下一个小节，你将创建你的第一个ScalaCheck测试，并验证reverse方法的断言。</p><h3><span id="1021testing-the-behavior-of-a-string-with-scalacheckp287">10<sub>2</sub>1〖Testing the behavior of a string with ScalaCheck〗P287</span></h3><p>要在ScalaCheck中创建一个新的属性，你需要使用org.scalacheck.Prop特质。ScalaCheck中的属性，由Prop特质的实例表示。这里有几种方式创建ScalaCheck属性的一个实例，其中一个方式是使用org.scalacheck.Prop.forAll。</p><p>forAll是一个工厂方法，它用于创建一个用于ScalaCheck的一个属性。该方法接收一个Boolean的函数参数，它可以接收任何类型的参数，只要有生成器。生成器(Generators)是有ScalaCheck用于生成测试数据的组件。(本节后面会介绍更多关于生成器的内容) 下面是一段属性的语法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prop</span>.forAll((a: <span class="type">String</span>) =&gt; a.reverse.reverse == a)</span><br></pre></td></tr></table></figure><p>上面这段代码的意思是：对于所有的字符串，表达式 <code>(a: String) =&gt; a.reverse.reverse == a</code> 应该始终为true。ScalaCheck会使用生成器为String类型生成任意的字符类型数据来验证该语句。要在SBT中运行该属性，你需要将它包装在类内部。org.scalacheck.Properties表示了ScalaCheck的一个集合属性，SBT内置支持运行Properties：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> checks</span><br><span class="line"><span class="keyword">import</span> org.scalacheck._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringSpecification</span> <span class="keyword">extends</span> <span class="title">Properties</span>(<span class="params">&quot;<span class="type">String</span>&quot;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;reverse of reverse gives you same string back&quot;</span>) = &#123;</span><br><span class="line">    <span class="type">Prop</span>.forAll((a: <span class="type">String</span>) =&gt; a.reverse.reverse == a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/scala-in-action/chapter10/Figure_10_01.png" alt="Figure 10.1"></p><p>将上述代码保存在 StringSpecification.scala文件，置于src/test/scala目录中，并在SBT命令提示符中运行test动作。如果设置正确下，你会发现ScalaCheck会尝试100次来篡改属性，直到失败。</p><p>100次测试后，它应该安全地告诉我们这个属性始终为true。让我们添加另外一个属性来验证两个字符x和y。表达式 <code>x.startWith(y)</code> 应该等于 <code>x.reverse.endsWith(y.reverse)</code>。下面是代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property(<span class="string">&quot;startsWith&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (x: <span class="type">String</span>, y: <span class="type">String</span>) =&gt;</span><br><span class="line">    x.startsWith(y) == x.reverse.endsWith(y.reverse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个为true吗？继续并尝试看看，ScalaCheck会不会出错。测试100次后，该属性为true。下面我们创建一个不总是为true的属性，看看ScalaCheck能否捕获到。这个语句是：对于任意两个字符x和y，表达式 <code>x &gt; y</code> 等于 <code>x.reverse &lt; y.reverse</code>。下面是该表述：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property(<span class="string">&quot;string comparison&quot;</span>) = <span class="type">Prop</span>.forAll &#123;(x: <span class="type">String</span>, y: <span class="type">String</span>) =&gt;</span><br><span class="line">    x &gt; y == x.reverse &gt; y.reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中情况，ScalaCheck会失败并显示哪个表达式不能为true。输出可能不总是可见的，因为ScalaCheck使用了从<code>Char.MIN_VALUE</code>到<code>Char.MAX_VALUE</code>的值。下面为该String 范类完整代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> checks</span><br><span class="line"><span class="keyword">import</span> org.scalacheck._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringSpecification</span> <span class="keyword">extends</span> <span class="title">Properties</span>(<span class="params">&quot;<span class="type">String</span>&quot;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;reverse of reverse gives you same string back&quot;</span>) = &#123;</span><br><span class="line">    <span class="type">Prop</span>.forAll((a: <span class="type">String</span>) =&gt; a.reverse.reverse == a)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;startsWith&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (x: <span class="type">String</span>, y: <span class="type">String</span>) =&gt;</span><br><span class="line">    x.startsWith(y) == x.reverse.endsWith(y.reverse)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;string comparison - WILL FALL&quot;</span>) =</span><br><span class="line">    <span class="type">Prop</span>.forAll &#123; (x: <span class="type">String</span>, y: <span class="type">String</span>) =&gt;</span><br><span class="line">      x.compare(y) == x.reverse.compare(y.reverse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码你为String类创建了一个范式，当然，你不需要指定该类的具体行为，但你可以看到ScalaCheck范式如何工作的。继承了Properties特质，以使得能够在SBT下运行。每个需要被验证的语句包装在ScalaCheck的属性中。你使用Prop.forAll工厂方法来创建一个新的属性，即传递一个函数，该函数的语句能够被ScalaCheck捕获并验证。ScalaCheck通过内建的生成器，传递任意的测试数据，并执行该函数。</p><p>现在，我希望你已经理解ScalaCheck属性是如何被创建，以及如何用于测试Scala行为代码。</p><p><strong>注意</strong> 自动化测试不是来源于ScalaCheck，而是来源于一个叫做QuickCheck<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>的测试工具，这个工具用于Haskell语言。有时这些工具也叫做 基于泛型的单元测试工具(specification-based unit testing tools)。你需要在属性词法内提供一个范式的的类或方法。这种基于范式的单元测试工具重度依赖于类型系统的正确性。因为Scala和Java都是静态类型语言，ScalaCheck有很好的方式来创建泛型，以及添加到你的项目中。</p><p>下小节讨论ScalaCheck生成器，当时机成熟，你可以为新类型创建自定义的生成器。</p><h3><span id="1022scalacheck-generatorsp289">10<sub>2</sub>2〖ScalaCheck generators〗P289</span></h3><p>上一小节，你编写了第一个ScalaCheck范式，不用理会生成器，为什么现在要讲？原因是，你不用担心生成器，对于String类型(其它类型也一样<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>)，ScalaCheck知道如何生成测试数据，但如果你创建了新的类型怎么办？这时要自己实现。好消息是ScalaCheck提供了所有的你需要生成器构建块。</p><p>ScalaCheck的生成器代表了生成测试数据，org.scalacheck.Gen类代表了这些数据。把生成器认为是接收某些生成参数、以及返回某些生成的值的函数。对于一些组合参数，该生成器可能不会生成任何值。一个代表类型 T 的生成器，可以由一个类型为 <code>Gen.Params =&gt; T</code> 的函数表示。ScalaCheck库中早已装载有各种各样的生成器，但其中一个特别重要：arbitrary生成器。它是一个特殊的生成器，它支持任意类型、可以生成任意值。在前面小节中，你用于String范式测试的生成器就是这个生成器。要运行任意范式，ScalaCheck需要一个生成器来生成测试数据，因此生成器在ScalaCheck中扮演了重要的角色。下小节为你展示如何创建这些自定义生成器。</p><h3><span id="1023working-with-scalacheckp290">10<sub>2</sub>3〖Working with ScalaCheck〗P290</span></h3><p>本小节将为你展示一个使用ScalaCheck的真实案例。在该案例中，你不需要为String类型编写范式，而是你将创建的类型。与其创建新的类型，让我们看看scala.Either 这个类。它和你创建的、或项目中处理的类型的复杂性，十分接近。在Scala，Either类型允许你表示两种可能的值：Left和Right。通常，按照惯例，Left表示失败、Right表示成功。</p><p>注意：查阅Either类型<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>的 <a href="http://www.scala-lang.org/api/current/index.html#scala.util.Either">scaladoc</a> 感知认识下你可以用该类型做些什么。</p><p>本节，将会为Either的API的方法添加范式测试。首先，我列出你需要测试的范式。明显地不是一个详尽的列出来，但却是一个好的起点：</p><ol><li>Either会有值Left或Right，但不会同时出现。</li><li>左折叠(fold on Left)产生的值由Left组成。</li><li>右折叠(fold on Right)产生的值由Right组成。</li><li>交换(swap)返回Left到Right的值，反之亦然。</li><li>getOrElse作用在Left，返回Left值，右边(Right)则返回给定的参数。</li><li>forAll作用于Right，如果是左边(Left)返回true；右边(Right)返回应用给定函数的值。</li></ol><p>这些范式的复杂度，往下越复杂，但你将看到如何轻松地实现这些范式。</p><p>首先，为Either类型，创建一个自定义的ScalaCheck生成器，因为还没有Either类型的内置生成器。在ScalaCheck中创建新的生成器，和组合已有的生成器一样简单。简单起见，仅为Left和Right创建可以生成Int的生成器(之后会介绍如何参数化这个生成器)。为Left创建一个新的生成器，使用存在的生成器为Int值创建Left实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Gen</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Arbitrary</span>.arbitrary</span><br><span class="line"><span class="keyword">val</span> leftValueGenerator = arbitrary[<span class="type">Int</span>].map(<span class="type">Left</span>(_))</span><br></pre></td></tr></table></figure><p>上述代码片段创建了一个Int类型生成器的新实例，并映射为Left创建值。类似地，创建Right实例，使用下面代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rightValueGenerator = arbitrary[<span class="type">Int</span>].map(<span class="type">Right</span>(_))</span><br></pre></td></tr></table></figure><p>要成功地创建Either类型的实例，你需要任意生成Left或Right的实例。为了解决这类问题，ScalaCheck Gen对象装载了辅组方法 如 oneOf 或 frequency，称为组合。它允许你组合多个生成器。例如，你可以使用 Gen.oneOf组合leftValueGenerator 和 rightValueGenerator 来创建Either类型的生成器。oneOf 确保 Left 和 Right值是任意生成的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> eitherGenerator = oneOf(leftValueGenerator, rightValueGenerator)</span><br></pre></td></tr></table></figure><p>通过定义生成器为一个 implicit val，你不需要传递它给ScalaCheck属性——ScalaCheck会自动拾取。这里你定义的生成器仅生成Int值，如果你需要处理其它类型，你也可以这样定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">arbitraryEither</span></span>[<span class="type">X</span>, <span class="type">Y</span>](<span class="keyword">implicit</span> xa: <span class="type">Arbitrary</span>[<span class="type">X</span>],</span><br><span class="line">            ya: <span class="type">Arbitrary</span>[<span class="type">Y</span>]): <span class="type">Arbitrary</span>[<span class="type">Either</span>[<span class="type">X</span>, <span class="type">Y</span>]] =</span><br><span class="line">    <span class="type">Arbitrary</span>[<span class="type">Either</span>[<span class="type">X</span>, <span class="type">Y</span>]](</span><br><span class="line">    oneOf(arbitrary[<span class="type">X</span>].map(<span class="type">Left</span>(_)), arbitrary[<span class="type">Y</span>].map(<span class="type">Right</span>(_)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为Left或Right定义的生成器都被参数化，因此它们将接收任何类型的、用于arbitrary定义的参数。</p><p>你也可以用Gen.frequency 来对每个独立的生成器和使用获得更多的控制。如果你想要 leftValueGenerator 比 rightValueGenerator高出 75%的使用次数，你可以使用Gen.frequency 这样实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> eitherGenerator = frequency((<span class="number">3</span>, leftValueGenerator), (<span class="number">1</span>, rightValueGenerator))</span><br></pre></td></tr></table></figure><p>生成器已经创建了。让我们移步到你的第一个范式。这个范式容易实现——你需要做的是检查Left和Right是不是同时出现。这种情况下，你需要使用Either类型的 isLeft 和 isRight 方法，这些方法将在Either是否包含类型时返回true或false。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property(<span class="string">&quot;isLeft or isRight not both&quot;</span>) = <span class="type">Prop</span>.forAll((e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>]) =&gt; e.isLeft != e.isRight)</span><br></pre></td></tr></table></figure><p>如果 isLeft 和 isRight 相等，你的范式不通过，因为明显Left和Right在同一时刻不会同时有值。</p><p>对于第二个范式和第三个范式，使用定义在Either类型中的方法 fold：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">property(<span class="string">&quot;left value&quot;</span>) = <span class="type">Prop</span>.forAll&#123;(n: <span class="type">Int</span>) =&gt; <span class="type">Left</span>(n).fold(x =&gt; x, b =&gt; error(<span class="string">&quot;fail&quot;</span>)) == n &#125;</span><br><span class="line">property(<span class="string">&quot;Right value&quot;</span>) = <span class="type">Prop</span>.forAll&#123;(n: <span class="type">Int</span>) =&gt; <span class="type">Right</span>(n).fold(b =&gt; error(<span class="string">&quot;fail&quot;</span>), x =&gt; x) == n &#125;</span><br></pre></td></tr></table></figure><p>如果访问错误的值，两种情况下都会出现错误。fold方法定义如下，它仅提供合适的函数参数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">X</span>](fa: <span class="type">A</span> =&gt; <span class="type">X</span>, fb: <span class="type">B</span> =&gt; <span class="type">X</span>) = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(a) =&gt; fa(a)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(b) =&gt; fb(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4><span id="customizing-the-number-of-tests-generated-by-scalacheck">Customizing the number of tests generated by ScalaCheck</span></h4><p>ScalaCheck 提供了配置选项，允许你控制如何验证你的属性。如果你想生成超过100个成功的测试，你可以通过SBT传递ScalaCheck参数给你的测试。技巧就是使用SBT的 test-only 动作。它允许你提供测试名作为参数，以及传递额外的测试参数。如果你不指定任何测试名，它会运行SBT环境下的所有测试。这里你可以改变默认的设置，设置默认最小成功次数从100到500，即在SBT中传递测试参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test-only -- -s 500</span><br></pre></td></tr></table></figure><p>通过 -s (ScalaCheck-specific configuration)，你设置了最小成功测试次数，它有ScalaCheck在属性成功之前生成。查阅ScalaCheck文档，了解更多配置选项。</p></blockquote><p>第四个范式有一点困难，但没有不能解决的。根据该范式，Either类型的方法swap可以交换Left和Right的值，反之亦然。这里你可以使用模式匹配来检测值属于Left，还是Right。例如，如果它是Left，交换之后，它的值应该在右边；反之Right时也一样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">property(<span class="string">&quot;swap values&quot;</span>) = <span class="type">Prop</span>.forAll&#123;(e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>]) =&gt; e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(a) =&gt; e.swap.right.get == a</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(b) =&gt; e.swap.left.get == b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面列出Either类型的完整范式的代码，包括范式5和6：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EitherSpecification</span> <span class="keyword">extends</span> <span class="title">Properties</span>(<span class="params">&quot;<span class="type">Either</span>&quot;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Arbitrary</span>.arbitrary</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Gen</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> leftValueGenerator  = arbitrary[<span class="type">Int</span>].map(<span class="type">Left</span>(_))</span><br><span class="line">  <span class="keyword">val</span> rightValueGenerator = arbitrary[<span class="type">Int</span>].map(<span class="type">Right</span>(_))</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> eitherGenerator = oneOf(leftValueGenerator, rightValueGenerator)</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;isLeft or isRight not both&quot;</span>) = <span class="type">Prop</span>.forAll((e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>]) =&gt; e.isLeft != e.isRight)</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;left value&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (n: <span class="type">Int</span>) =&gt; <span class="type">Left</span>(n).fold(x =&gt; x, b =&gt; sys.error(<span class="string">&quot;fail&quot;</span>)) == n &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;Right value&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (n: <span class="type">Int</span>) =&gt; <span class="type">Right</span>(n).fold(b =&gt; sys.error(<span class="string">&quot;fail&quot;</span>), x =&gt; x) == n &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;swap values&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>]) =&gt; e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(a) =&gt; e.swap.right.get == a</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(b) =&gt; e.swap.left.get == b</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;getOrElse&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>], or: <span class="type">Int</span>) =&gt; e.left.getOrElse(or) == (e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(a) =&gt; a</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(_) =&gt; or</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property(<span class="string">&quot;forall&quot;</span>) = <span class="type">Prop</span>.forAll &#123; (e: <span class="type">Either</span>[<span class="type">Int</span>, <span class="type">Int</span>]) =&gt;</span><br><span class="line">    e.right.forall(_ % <span class="number">2</span> == <span class="number">0</span>) == (e.isLeft || e.right.get % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用ScalaCheck提供的构建块，为类型Either创建了一个生成器。Arbitrary.arbitrary是这些构建块中的一个，它们用于创建自定义生成器。使用它，你可以创建包含Left和Right值的Either类型。之后，使用Gen对象提供的组合，创建Either类型的生成器。</p><p>有大量的Scala开源库，如Scalaz、Lift使用了ScalaCheck用于它们类的测试。你可以下载这些代码，查看各种各样的使用方式。</p><p>对于Java基础代码，使用ScalaCheck也可以方便进行测试。因为Scala和Java是相互操作的，你不需要为Java代码做任何特殊的。ScalaCheck也支持Java集合类测常规测试。</p><p>你可以想象出，ScalaCheck是一个强大的框架。例如，用20-25行代码，你管理生成600个测试。以及创建自定义生成器的能力，我确保你的项目中会用到ScalaCheck的价值的地方。</p><p>对于已实现的新功能会怎样？你不确定测试在类、特质、函数应该是什么样。下个小节介绍一个设计技术，叫做 驱动测试开发，它可能会解决你的问题。</p><h3><span id="10~3test-driven-development-cyclep294">10~3〖Test-driven development cycle〗P294</span></h3><p>测试驱动开发<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> (Test-driven development，TDD)，是使用测试来驱动软件开发的一门技术。最开始可能会误导，因为测试通常和软件的验证相联系。对软件进行测试，确保工作时是我们所期望的。它更像是软件发布所做的最后一件事情。TDD 则完全相反，它在软件周期中间环节进行测试。在敏捷软件开发中，TDD是最多的、或者说是最重要的实践之一。你不仅可以在敏捷开发中体会到TDD的好处，在任何处理中都可以用到。记住：TDD是一个设计工具。最终你会得到一个测试套件，但它更多的是次级效应。让我们开始理解TDD如何工作的，我将解析为什么它工作。</p><p>下图概述了TDD作为一个开发实践是如何工作的。首尾相连的测试，总是以一个失败开始。一个互联的测试，从头到尾执行着你的应用。这意味着测试可以使一个HTTP请求通过一个浏览器，以及检测响应。你可以编写一连串的单元测试来将问题分成小块，并使这些测试通过。当测试失败时你仅写了生产代码，当测试通过时仅进行重构。</p><p><img src="/img/scala-in-action/chapter10/Figure_10_02.png" alt="Figure 10.2"></p><p>让我们思考下面这些特性请求。作为一名财务分析，你想要计算一小部分的产品，以正确给客户开账单：</p><p>验收标准：</p><ul><li>一个百分比乘积，为消费+百分额。例如，150(消费)+20%=$180</li><li>所有以B开头的ID，应该使用一个外部的价格系统获得价格。</li></ul><p>这里，如果你选择第一条验收标准，你的工作应该实现该标准的一个测试。实现这个测试，你头脑中会出现下面这些问题：</p><ul><li>应该在什么地方实现这些计价逻辑？</li><li>应该创建一个trait或开始一个简单的函数？</li><li>函数应该接收什么参数？</li><li>应该怎样测试输出内容？</li><li>是否要访问数据库或文件系统来获取这些消费内容？</li></ul><p>该案例，你已经开始思考设计。但这时候，你的专注应该在手头的工作单元。这意味着你正在做验收标准。TDD最普遍的问题是提取最简单的解决方案以让它可能工作。这里最简单的解决方案是创建一个接收产品代码的函数，可以在一个Map中获取，并返回经验收标准公式计算的结果。可能，使用Map来作为查阅设计，在下一轮测试不会为true。如果发生，你会改变必要的代码，并从某些持久化存储中查找。做最简单的事情使工作可能实现，然后在应用中增加设计。</p><p>一旦你的测试跑起来了，你就有机会重构和清理。重构(Refactoring)是指你可以在已有代码的基础上提高设计，并且不改变原来的行为。这种 测试-编码-重构(test-code-refactor)在每个特性或步骤实现中重复循环。有时候这种循环被称为 红-绿-重构(red-green-refactor)循环。当测试失败，得到红色状态；测试通过后变为绿色。TDD是一个开发实践，它需要些时间慢慢习惯。所以你要做过一些例子，对它会变得明朗起来。</p><p>好消息是，Scala社区提供了大量的测试工具使用。我会专注于两款最流行的测试工具：JUnit和Specs。JUnit是Java开发者中最流行的，同时也容易地在Scala代码中使用。但大多数Scala编程人员使用Specs来对它们的Scala代码进行测试。</p><p>因为开始编写测试，你需要构建一个测试套件。如果你不经常使用，你不会从中获取到它所带来的便利。下个小节讨论设置一个持续集成环境<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>，以及其优势。</p><h3><span id="1031setting-up-your-environment-for-tddp296">10<sub>3</sub>1〖Setting up your environment for TDD〗P296</span></h3><p>一旦你或你的团队熟悉了TDD，你需要一个工具了来检出最后托管的源代码，并在VCS提交后，运行所有的测试。这样确保了软件应用一直可以工作。一个持续集成(CI，continuous integration)工具将自动为你处理这些工作。几乎已有的CI工具都可以工作于Scala项目。表 10.1 展示了一些Scala工具，一些可能会用到你的Scala项目中。</p><table><thead><tr><th style="text-align:left">name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Jenkins CI</td><td style="text-align:left">开源的持续继承工具，可以自动构建和测试你的项目。你可以配置它指向你的代码控制，并在托管每次更新时执行构建。实际上，所有的CI工具都有这些功能。你也可以为你的应用使用其它任何流行的CI工具。</td></tr><tr><td style="text-align:left">Jenkins SBT plugin</td><td style="text-align:left">允许你通过Jenkins执行SBT构建动作，以及使用Jenkins配置SBT。对于CI工具不提供SBT支持但支持Maven，你可以在SBT中使用make-pom命令来生成一个POM文件。</td></tr><tr><td style="text-align:left">Code coverage</td><td style="text-align:left">代码覆盖率(code coverage)是一个自动测试下的源代码测量指标。代码覆盖率工具帮助你标识哪些区域的代码没有被测试。几乎所有的Java代码覆盖率工具都可以用于Scala，但用于诸如SBT的构建工具，将会更好。</td></tr></tbody></table><p><em>TIP</em> SBT工具在市场上仍然很少占有率。如果有测试工具或CI环境不能很好地在SBT下工作。你可以使用Maven作为你的构建工具。Maven中有提供了Scala插件<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>，允许你编译和运行Scala测试。你也可以在SBT项目中使用make-pom动作来生成一个.POM文件。</p><p>我这里提及了为数不多的工具，你可以在你的项目中使用这些工具进行持续的反馈循环。围绕Scala的工具集一直在发展中，因此尝试一些工具，使用其中一个配对在你的项目中。下小节解释如何使用JUnit来测试你的Scala代码。</p><h3><span id="1032using-junit-to-test-scala-codep296">10<sub>3</sub>2〖Using JUnit to test Scala code〗P296</span></h3><p>JUnit是一个Java编写的测试框架。这个流行的测试框架被用于很多Java项目中。如果你之前使用过JUnit测试工具进行Java代码测试，我很高兴告诉你你也可以在Scala中使用JUnit。要在SBT项目中使用JUnit，添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += &quot;junit&quot; % &quot;junit&quot; % &quot;4.10&quot; % &quot;test&quot;</span><br></pre></td></tr></table></figure><p>默认地，SBT不会识别JUnit风格的test case，因此你需要添加额外的依赖，让SBT识别JUnit：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">&quot;com.novocode&quot;</span> % <span class="string">&quot;junit-interface&quot;</span> % <span class="string">&quot;0.8&quot;</span> % <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>工具junit-interface<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup>实现了SBT的测试接口使得SBT可以运行JUnit测试案例。reload 和 update SBT项目后，你便可以添加JUnit测试案例，并在SBT控制台使用test动作运行这些测试。这样做带来的好处是如果你要为Scala项目引入Java代码，或者同时有Java和Scala项目<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>在SBT中构建，JUnit都可以同样适用。</p><p>JUnit是编写自动化测试的一个好的开始，但它对于Scala项目不是一个合适的测试工具，因为它仍然不能友好地理解Scala。有大量开源的Scala测试工具可以用于编写富有表现力的测试。小节10.6会进入一个Scala大多数开发者使用的测试工具，叫做Specs，但现在更多的是让我们理解一个重要的概念——依赖注入(dependency injection)，它可以帮助用于测试应用的设计。</p><h3><span id="10~4better-tests-with-dependency-injectionp297">10~4〖Better tests with dependency injection〗P297</span></h3><p>依赖注入(DI，dependency injection)是一个设计模式，指从依赖处理中分离行为。这种模式帮助用于设计编写实现本质上的高度解耦。让我们看看一个简单例子，以理解DI是如何工作的。</p><p>这个例子是一个多种计价规则的商品计价。典型地，任何计价系统会有数百个规则，但为了简单，我仅介绍两个：</p><ul><li>cost-plus为现有价格加上百分比消费</li><li>从外部计价资源中获取商品价格</li></ul><p>有了这些的规则，计算价钱应该如下实现：</p><p><img src="/img/scala-in-action/chapter10/Figure_10_03.png" alt="Figure 10.3"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator            = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span>()</span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span>()</span><br><span class="line">  <span class="keyword">val</span> calculators                   = <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(costPlusCalculator) _,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(externalPriceSourceCalculator) _)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    calculators(priceType)(productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>): <span class="type">Double</span> =</span><br><span class="line">    c.calculate(productId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cost-plus规则由costPlusCalculator实现，外部计价规则由externalPriceSourceCalculator处理。两个计数器都实现了Calculator特质。类CalculatePriceService使用了这些计数器作用在priceType参数。现在priceType有两种可能的值 costPlus 和 externalPriceSource。让我们关联这个例子到DI上。CalculatePriceService的行为是使用合适的计数器来决定给的你给产品的价钱。同时这个类也解决了依赖注入问题。在管理你的依赖上有没有其它问题？</p><p><strong>注意</strong> 依赖注入是控制反转的具体形式，控制反转(inversion of control)指的是反转获得依赖的处理。</p><p>是的，有一些潜在的问题，特别是软件升级时。如果你的客户决定使用一个不同的外部计价资源来计算价格，或者针对一部分用户重新定义了cost-plus规则会发生什么？这时候出现了计价器的不同实现。这在某些场合可能适用，但如果作为一个组件以实现项目共享，则会有问题。</p><p>使用依赖注入，你可以轻松解决这个问题。如果依赖的计数器可以传递给CalculatePriceService，然后这个服务可以轻松配置各种不同的计数器实现。它将变得简单，你可以通过构造器传递这些calculators：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span>(<span class="params">val costPlusCalculator: <span class="type">Calculator</span>, val externalPriceSourceCalculator: <span class="type">Calculator</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> calculators = <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(costPlusCalculator) _,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(externalPriceSourceCalculator) _)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    calculators(priceType)(productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>): <span class="type">Double</span> = c.calculate(productId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比起上一个代码，唯一不同的是，现在两个计数器的实例通过构造器参数传递。这里，service职责是决定了依赖 price calculator和注入这些依赖到 service中。这使得service层高度解耦，因为它不用关心 costPlusCalculator 或 externalPriceSourceCalculator是如何被创建或实现的。这也给你设计上的自由，因为现在你可以轻松合并这些你客户要求的改变内容，实现不同的计价规则。</p><h3><span id="1041techniques-to-implement-dip299">10<sub>4</sub>1〖Techniques to implement DI〗P299</span></h3><p>DI在测试中可以做什么？在单元测试中，一个要点是理解你正在测试的单元。你测试的CalculatePriceService下的系统，不是costPlusCalculator 或 externalPriceSourceCalculator。但如果你不孤立这些calculators，测试会终止。使用一个集成测试是可以的，但不仅仅是测试CalculatePriceService的行为。在这个小例子中，可能很难看出区别，但在大型应用中不孤立这些依赖，你为每个所需要测试的组件，会一次一次初始化终止系统。如果你想要编写简单的、可管理的单元测试，孤立显得尤为重要。</p><p>第二个问题是，在紧耦合系统中的测试速度。快速的测试很重要。记住你的测试就是你的反馈机制，因此如果运行很慢，反馈就很慢。例如，每个calculators会访问数据库或web服务，这些都会减慢你的测试。</p><p><strong>定义</strong> <em>Test double</em> 是一个常规的涵盖性术语，指你系统测试下所依赖的，一个具体的等价的测试组件。</p><p>理想的情况下，你会为每个计数器创建一个测试版本，这样你可以专注于你的当前系统下的测试验证，即这里的CalculatePriceService。该计数器的测试版本下，你可以返回一个硬编码价格、或者使用一个内存数据库来加速。对于测试数据，你有更多的控制。TDD的一个关键方面是测试的可重复运行。如果你的测试重度依赖于外部数据，测试会变得很脆弱，因为外部数据会改变以及打破你的测试。</p><p><strong>注意</strong> 一个好的单元测试的措施是，它应该没有副作用，就和编写一个纯函数一样。</p><p>如果你遵循TDD作为你设计的驱动，你不应该过多担心耦合性问题——你的测试会强制你进行解耦设计。你会注意到你的函数、类、以及方法都遵循一个DI模式。</p><p>往下的小节讨论了在Scala中实现依赖注入的几种方式。表10.2为其清单。</p><table><thead><tr><th style="text-align:left">Technique</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Cake pattern</td><td style="text-align:left">Handles dependency using trait and abstract members</td></tr><tr><td style="text-align:left">Structural typing</td><td style="text-align:left">使用结构类型来管理依赖，Scala结构类型在一个类型安全管理器中提供了鸭子类型。<a href="http://en.wikipedia.org/wiki/Duck_typing">鸭子类型(Duck typing)</a>是一个动态类型风格，表示对象当前的行为由方法和属性决定</td></tr><tr><td style="text-align:left">Implicit parameters</td><td style="text-align:left">使用隐式参数来管理依赖，这样可以不用显式传递。依赖受作用范围控制。</td></tr><tr><td style="text-align:left">Functional programming style</td><td style="text-align:left">使用函数科里化控制依赖。函数科里化是指将带多个参数的函数，转换为多个接收一个参数的函数，并链接在一起。</td></tr><tr><td style="text-align:left">Using a DI framework</td><td style="text-align:left">Most of the techniques mentioned here will be home-grown. I show you how to use a DI framework.</td></tr></tbody></table><p>这些技术可以帮助编写更容易测试的代码，并为Scala提供了一个可伸缩的处理方案。让我们以熟悉的CalculatePriceService 为例，实现上述表格中提到的每项技术。</p><h3><span id="1042cake-patternp301">10<sub>4</sub>2〖Cake pattern〗P301</span></h3><p>一个蛋糕模式<sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup> (cake pattern)是一门在应用中构建多个间接层来帮助管理依赖的技术。蛋糕模式构建了三个抽象技术，描述如下表。</p><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Abstract members</td><td style="text-align:left">提供了一种方式抽象具体组件类型。使用抽象类型，你创建的组件可以不依赖具体类型，类型的信息由其它使用它的组件提供。</td></tr><tr><td style="text-align:left">Self type annotation</td><td style="text-align:left">允许你重新定义 <strong>this</strong> ，由组件声明依赖。使用特质混入，你可以注入依赖的各种实现。</td></tr><tr><td style="text-align:left">Mixin composition</td><td style="text-align:left">混入允许你使用Scala特质重载和添加新的功能。</td></tr></tbody></table><p>这些概念在chapter7中覆盖，因此让我们看看蛋糕模式如何帮助你将CalculatePriceService 从计数器中进行解耦，并使它更容易测试。第一件事你需要做的是提取出服务中的实例，并命名Calculators：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculators</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator: <span class="type">CostPlusCalculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator: <span class="type">ExternalPriceSourceCalculator</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质Calculator背后的思想是，一个组件命名空间提供所有的calculator给应用。相似地，让我们为CalculatePriceService创建一个组件命名空间，并通过自身类型声明它的依赖给Calculators：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CalculatePriceServiceComponent</span> </span>&#123;<span class="keyword">this</span>: <span class="type">Calculators</span> =&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> calculators = <span class="type">Map</span>(</span><br><span class="line">      <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(costPlusCalculator) _</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(externalPriceSourceCalculator) _)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">      calculators(priceType)(productId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>):<span class="type">Double</span> =</span><br><span class="line">      c.calculate(productId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你使用了自类型 <code>this: Calculators</code> 重定义了<code>this</code>。它静态地确保了不能创建CalculatePriceService 而不混入 Calculators特质。好处是你可以随意地同时引用costPlusCalculator和externalPriceSourceCalculator。自类型会确保它们在运行时可用。</p><p>你必须知道为什么两个计数器同时在Calculators特质内声明为抽象。因为你要控制这些计数器是被创建。上面测试提及过，你不需要使用计数器；实际上你需要使用一个假的或TestDouble版本的计数器。同时，你需要在真是产品模式下的计数器。这正是trait混入因素。对于产品某事，你可以通过组合所有真是版本组件来创建一个计价系统，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span></span></span><br><span class="line">                             <span class="keyword">with</span> <span class="type">Calculators</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计价系统由真实的costPlusCalculator和externalPriceSourceCalculator初始化，对于测试的计价可以创建使用假的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestPricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span></span></span><br><span class="line">                                <span class="keyword">with</span> <span class="type">Calculators</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StubCostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">CostPlusCalculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">0.0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StubExternalPriceSourceCalculator</span> <span class="keyword">extends</span></span></span><br><span class="line">    <span class="type">ExternalPriceSourceCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">0.0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> <span class="type">StubCostPlusCalculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">StubExternalPriceSourceCalculator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的TestPricingSystem，使用TestDouble实现计数器，因此可以帮助编写围绕测试的计价服务。在你的测试中，使用的TestPricingSystem代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.<span class="type">Assert</span>._</span><br><span class="line"><span class="keyword">import</span> org.junit.<span class="type">Test</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceTest</span> <span class="keyword">extends</span> <span class="title">TestPricingSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shouldUseCostPlusCalculatorWhenPriceTypeIsCostPlus</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> calculatePriceService = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">    <span class="keyword">val</span> price = calculatePriceService.calculate(<span class="string">&quot;costPlus&quot;</span>, <span class="string">&quot;some product&quot;</span>)</span><br><span class="line">    assertEquals(<span class="number">5.0</span>D, price, <span class="number">0</span>D)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shouldUseExternalPriceSourceCalculator</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> calculatePriceService = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">    <span class="keyword">val</span> price = calculatePriceService.calculate(<span class="string">&quot;externalPriceSource&quot;</span>, <span class="string">&quot;dummy&quot;</span>)</span><br><span class="line">    assertEquals(<span class="number">10.0</span>D, price, <span class="number">0</span>D)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你混入了计价系统到你的测试类中。这会自动使用测试内的假的计价器实现。这将简化你的测试，并让你更专注于CalculatePriceService上。两个测试都测试了CalculatePriceService是否使用了正确的计数器。</p><p>这种常规技术被Scala开发者用于管理依赖。在小项目，应该装配诸如PricingSystem 、TestPricingSystem这样的依赖实现，但对于大型项目，这样会变得难于管理。对于大型项目来说，更多的是使用DI框架，使你完全从业务逻辑中分离创建对象和注入对象。</p><h3><span id="1043structural-typingp303">10<sub>4</sub>3〖Structural typing〗P303</span></h3><p>在Scala中，结构类型是由自身结构来描述类型的一种方式。前面章节创建了Calculators特质作为所有计数器的一个命名空间，CalculatePriceService使用它用于独立的计数。这种结构下有两个抽象特质 vals：costPlusCalculator 和 externalPriceSourceCalculator，因为CalculatePriceService 不会关心这些内容。为了创建一个结构捕获这些信息，要确保Scala把它看作一个新的类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Calculators</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator: <span class="type">Calculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator: <span class="type">Calculator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码由指定的结构创建了一个新的类型Calculators。type关键字在Scala中用于创建新的类型或类型别名。现在你可以使用这个类型注入到计数器的各种实现中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span>(<span class="params">c: <span class="type">Calculators</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> calculators = <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(c.costPlusCalculator) _ ,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(c.externalPriceSourceCalculator) _)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    calculators(priceType)(productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>):<span class="type">Double</span> =</span><br><span class="line">    c.calculate(productId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用一个结构类型，你不需要为其命名——你可以在行内使用，即如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span>(<span class="params">c: &#123;</span></span></span><br><span class="line"><span class="params"><span class="class">  val costPlusCalculator: <span class="type">Calculator</span></span></span></span><br><span class="line"><span class="params"><span class="class">  val externalPriceSourceCalculator: <span class="type">Calculator</span></span></span></span><br><span class="line"><span class="params"><span class="class">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> calculators = <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(c.costPlusCalculator) _,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(c.externalPriceSourceCalculator) _)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    calculators(priceType)(productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>): <span class="type">Double</span> = c.calculate(productId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里类型构造器的参数被定义在行内。Scala中这种结构类型的优点是它是不可变的(mutable)以及类型安全的(type-safe)。Scala编译器会确保CalculatePriceService中的构造器参数同时实现了变量costPlusCalculator和externalPriceSourceCalculator的抽象。再一次，你可以创建两个类型的配置——一个用于测试环境，另一个用于开发环境：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ProductionConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator            = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span></span><br><span class="line">  <span class="keyword">val</span> priceService                  = <span class="keyword">new</span> <span class="type">CalculatePriceService</span>(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">5.0</span>D</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">10.0</span>D</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> priceService                  = <span class="keyword">new</span> <span class="type">CalculatePriceService</span>(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于你所做的，你可以灵活地进行合适的配置。这是我处理依赖方式中最喜欢的一个，因为它容易和简单。在内部，结构类型实现了反射，因此相比其它方法会较慢。有时这是可以接受的，但当使用结构类型时要意识到这点。</p><h3><span id="1044implicit-parametersp305">10<sub>4</sub>4〖Implicit parameters〗P305</span></h3><p>隐式参数提供了参数被发现的方式。只用这种技术，让Scala编译器注入合适的依赖到你的代码中。ScalaCheck使用了隐式参数来决定一个合适的生成器用于property。要声明一个隐式参数，你需要用关键字implicit标识。</p><p>下面例子将计数器作为一个参数注入到CalculatePriceService中，并标识为implicit：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">implicit val costPlusCalculator: <span class="type">CostPlusCalculator</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">implicit val externalPriceSourceCalculator: <span class="type">ExternalPriceSourceCalculator</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br></pre></td></tr></table></figure><p>隐式参数的美丽之处在于，如果在创建CalculatePriceService实例时不提供这些参数，Scala编译器会查找&quot;implicit&quot; 值匹配当前编译范围内的参数。如果编译器查找合适的隐式值时失败，则出现编译错误。</p><p>创建一个ProductionServices对象，用于定义这些产品代码的隐式值：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ProductionServices</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> costPlusCalculator            = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要为隐式参数提供值，需要让每个值标识为implicit——否则编译器不能识别。你还需要将这个对象导入到运行的代码中，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ProductionConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ProductionServices</span>._</span><br><span class="line">  <span class="keyword">val</span> priceService = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，对于测试环境，创建一个对象并提供该services的一个测试的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestServices</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> <span class="type">CostPlusCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">0.0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">ExternalPriceSourceCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">0.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ProductionServices</span>._</span><br><span class="line">  <span class="keyword">val</span> priceService = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不必总是为隐式参数使用值，因为你可以显式地传递参数。随着应用变得庞大，使用implicit来处理依赖，你可以避免无法控制的情况，除非是像上面配置对象一样组装在一起。否则，你的隐式声明和导入会被分散在代码中，并使得难于调试编译问题。注意隐式参数解决方案依赖于类型。取而代之的是定义costPlusCalculator和externalPriceSourceCalculator作为Calculator的一个类型，你应该提供更多具体的类型。有时这种约束会使的构建一个可伸缩的设计变得非常严谨。</p><h3><span id="1045dependency-injection-in-functional-stylep306">10<sub>4</sub>5〖Dependency injection in functional style〗P306</span></h3><p>依赖注入背后的思想是控制反转<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup> (Inversion of Control)。它从外部传递依赖，而不是由一个组件控制。当使用函数，DI早已经自动发生。如果你把一个函数看作是一个组件，把依赖看作是它的参数。这使得函数自然而然地可测试。如果你创建函数科里化，你也可以用其它模式隐藏依赖。函数科里化(Function currying)是一门函数转换技术，它接收多个参数，转化为单个参数的方法链。下面是仅使用函数的Calculators接口：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculators</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Calculator</span> </span>= <span class="type">String</span> =&gt; <span class="type">Double</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> findCalculator: <span class="type">String</span> =&gt; <span class="type">Calculator</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> calculate: (<span class="type">Calculator</span>, <span class="type">String</span>) =&gt; <span class="type">Double</span> = (calculator, productId) =&gt; calculator(productId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型Calculator为接收产品ID，返回价格的别名，即 <code>String =&gt; Double</code>。函数findCalculator由价钱类型决定计数器。最后的calculate是一个函数，它接收一个Calculator实例和productId用于计算产品价格。这和你早期设计的接口十分相似，但这里仅仅表示为函数。</p><p>你可以通过调用<code>curried</code>方法，将calculate函数转换为一个curried函数，这个curried定义在Scala的所有函数类型中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f: <span class="type">Calculator</span> =&gt; <span class="type">String</span> =&gt; <span class="type">Double</span> = calculate.curried</span><br></pre></td></tr></table></figure><p>curried方法接收带n个参数的函数，并转换为带一个参数的n个函数。在这里创建了一个接收Calculator参数的函数，并计算productId的价格。这样做的好处是，你现在有一个函数知道如何计算价钱，但对用户吟唱了Calculator。下面是Calculators实现的例子测试：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestCalculators</span> <span class="keyword">extends</span> <span class="title">Calculators</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator : <span class="type">String</span> =&gt; <span class="type">Double</span> = productId =&gt; <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSource: <span class="type">String</span> =&gt; <span class="type">Double</span> = productId =&gt; <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">val</span> findCalculator = <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; costPlusCalculator,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; externalPriceSource</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">priceCalculator</span></span>(priceType: <span class="type">String</span>): <span class="type">String</span> =&gt; <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> f: <span class="type">Calculator</span> =&gt; <span class="type">String</span> =&gt; <span class="type">Double</span> = calculate.curried</span><br><span class="line">    f(findCalculator(priceType))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法priceCalculator返回一个函数，它接收productId，返回该产品的价格，并封装依赖进行计算。这个例子就是如何使用函数式编程实现依赖注入。</p><h3><span id="1046using-a-dependency-injection-framework-springp307">10<sub>4</sub>6〖Using a dependency injection framework: Spring〗P307</span></h3><p>Scala抽象成员、自类型和混入提供了比Java更抽象的技术，但但依赖注入框架提供的下列附加服务，在这些抽象技术中并不可用：</p><ul><li>在对象初始化和从业务逻辑的创建，有明显的分割。这些框架提供了一个分离的生命周期，来创建应用初始化依赖的一部分。这里，代码装配组件变为透明。</li><li>这些框架可以在其它各种各样的框架中帮助使用。例如，你计划使用已有的Java Web框架，一个依赖框架作为依赖注入到你的Scala对象汇中。</li><li>大部分框架，如Spring、Guice，提供了面向切面编程<sup id="fnref:15"><a href="#fn:15" rel="footnote">15</a></sup> (AOP)，支持处理切点行为，如事务、日志。</li></ul><p>好消息是，你可以在你的Scala项目中使用任何Java DI框架。本小节向你展示如何使用Spring框架<sup id="fnref:16"><a href="#fn:16" rel="footnote">16</a></sup>应用到你的Scala项目中，作为一个DI框架。</p><p>Spring框架允许你以多种方式配置依赖。我将向你展示使用外部XML配置文件来配置使用。在Spring中，所有依赖被称为bean，因为所有对象遵循Java-Bean<sup id="fnref:17"><a href="#fn:17" rel="footnote">17</a></sup>转换。据此，一个类应该提供一个默认的构造器，并且类的属性带有get、set和is方法进行访问。</p><p>要令一个属性(property)为bean属性，Scala提供了一个便利的注解 <strong>@BeanProerty</strong> 。这个注解告诉Scala编译器自动生成getter和setter方法。下面例子清单展示了该便利性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scala.book</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.reflect._</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> costPlusCalculator           : <span class="type">Calculator</span> = _<span class="comment">// ①</span></span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> externalPriceSourceCalculator: <span class="type">Calculator</span> = _<span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculators</span> </span>= <span class="type">Map</span>(</span><br><span class="line">    <span class="string">&quot;costPlus&quot;</span> -&gt; calculate(costPlusCalculator) _,</span><br><span class="line">    <span class="string">&quot;externalPriceSource&quot;</span> -&gt; calculate(externalPriceSourceCalculator) _)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(priceType: <span class="type">String</span>, productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    calculators(priceType)(productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(c: <span class="type">Calculator</span>)(productId: <span class="type">String</span>): <span class="type">Double</span> = c.calculate(productId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的CalculatePriceService版本看起来和 10.3 小节的如出一辙，除了这里的costPlusCalculator 和 texternalPriceSourceCalculator被 @BeanProperty 注解声明为bean属性之外。这个 @BeanProperty 注解会为 costPlusCalculator 和 externalPriceSourceCalculator 属性生成下列getters 和 setters 方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCostPlusCalculator</span></span>: <span class="type">Calculator</span> = <span class="keyword">this</span>.costPlusCalculator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setCostPlusCalculator</span></span>(c: <span class="type">Calculator</span>) &#123; <span class="keyword">this</span>.costPlusCalculator = c &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getExternalPriceSourceCalculator</span></span>: <span class="type">Calculator</span> =</span><br><span class="line"><span class="keyword">this</span>.externalPriceSourceCalculator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setExternalPriceSourceCalculator</span> </span>(c: <span class="type">Calculator</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>. externalPriceSourceCalculator = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个计价器都已称为bean，它们提供了一个默认的构造器。唯一需要做的是装配依赖到服务中，在Spring中，你可以通过指定一个配置文件实现，如下面清单：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=</span><br><span class="line">       <span class="string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;</span>&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;bean id=<span class="string">&quot;costPlusCalculator&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;scala.book.CostPlusCalculator&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;externalPriceSourceCalculator&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;scala.book.ExternalPriceSourceCalculator&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;calculatePriceService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;scala.book.CalculatePriceService&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;costPlusCalculator&quot;</span> ref=<span class="string">&quot;costPlusCalculator&quot;</span> /&gt;</span><br><span class="line">      &lt;property name=<span class="string">&quot;externalPriceSourceCalculator&quot;</span> ref=<span class="string">&quot;externalPriceSourceCalculator&quot;</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;   </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这是一个标准的Spring配置文件，CalculatePriceService被定义了依赖。将该文件保存为application-context.xml文件，并置于SBT项目中的src/main/resources文件夹。该文件用于初始化应用bean。类似地，你也可以有一个测试版的配置，置于src/test/resources下面作为假的计价实现。并创建假的测试实例。现在先在SBT中加入框架的依赖项：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> spring = <span class="string">&quot;org.springframework&quot;</span> % <span class="string">&quot;spring&quot;</span> % <span class="string">&quot;2.5.6&quot;</span></span><br><span class="line"><span class="keyword">val</span> springTest = <span class="string">&quot;org.springframework&quot;</span> % <span class="string">&quot;spring-test&quot;</span> % <span class="string">&quot;2.5.6&quot;</span></span><br><span class="line"><span class="keyword">val</span> junit = <span class="string">&quot;junit&quot;</span> % <span class="string">&quot;junit&quot;</span> % <span class="string">&quot;4.4&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">val</span> junitInterface = <span class="string">&quot;com.novocode&quot;</span> % <span class="string">&quot;junit-interface&quot;</span> % <span class="string">&quot;0.5&quot;</span> % <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>这里同时添加了Spring 和 Spring test框架依赖。因为现在还没有学习有关Specs的内容，让我们使用JUnit作为测试工具。再一次说明，junitInterface是Java对SBT的测试接口，已使得能够运行JUnit单元测试。</p><p>要对CalculatePriceService进行测试，你可以在测试内部使用Spring来配置beans重载合适的calculator。要在JUnit中使用Spring，可以添加如下注解测试声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(classOf[<span class="type">SpringJUnit4ClassRunner</span>])</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="type">Array</span>(<span class="string">&quot;classpath:/application-context.xml&quot;</span>))</span><br></pre></td></tr></table></figure><p>RunWith注解允许JUnit测试访问定义在application context文件里面的beans。ContextConfiguration让你指定那个配置文件用于初始化beans。如果你有一个测试版的配置文件，则指明。在测试内，如果你用@Resource注解声明了CalculatePriceService的一个变量，Spring会创建并注入它的一个实例到测试中。这里是使用Spring配置的JUnit骨架：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(classOf[<span class="type">SpringJUnit4ClassRunner</span>])</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="type">Array</span>(<span class="string">&quot;classpath:/application-context.xml&quot;</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">var</span> calculatePriceService: <span class="type">CalculatePriceService</span> = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CalculatePriceService的实例会由Spring框架注入到测试中。这里，测试类被设置用于测试计算价格。下面是cost-plus计价和external的完整实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.<span class="type">Resource</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.<span class="type">Assert</span>._</span><br><span class="line"><span class="keyword">import</span> org.junit.<span class="type">Test</span></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.<span class="type">RunWith</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.<span class="type">ContextConfiguration</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.<span class="type">SpringJUnit4ClassRunner</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(classOf[<span class="type">SpringJUnit4ClassRunner</span>])</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="type">Array</span>(<span class="string">&quot;classpath:/application-context.xml&quot;</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringExampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">var</span> calculatePriceService: <span class="type">CalculatePriceService</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shouldUseCostPlusCalculatorWhenPriceTypeIsCostPlus</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> fakeCostPlusCalculator = <span class="keyword">new</span> <span class="type">Calculator</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">2.0</span>D</span><br><span class="line">    &#125;</span><br><span class="line">    calculatePriceService.setCostPlusCalculator(fakeCostPlusCalculator)</span><br><span class="line">    <span class="keyword">val</span> price = calculatePriceService.calculate(<span class="string">&quot;costPlus&quot;</span>, <span class="string">&quot;some product&quot;</span>)</span><br><span class="line">    assertEquals(<span class="number">2.0</span>D, price, <span class="number">0</span>D)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">testShouldReturnExternalPrice</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> fakeExternalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">Calculator</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">5.0</span>D</span><br><span class="line">    &#125;</span><br><span class="line">    calculatePriceService.setExternalPriceSourceCalculator(fakeExternalPriceSourceCalculator)</span><br><span class="line">    <span class="keyword">val</span> price = calculatePriceService.calculate(<span class="string">&quot;externalPriceSource&quot;</span>, <span class="string">&quot;dummy&quot;</span>)</span><br><span class="line">    assertEquals(<span class="number">5.0</span>D, price, <span class="number">0</span>D)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你声明了你的JUnit测试允许使用RunWith和指定配置文件来创建Spring bean。在大型项目中推荐使用一个测试版本的配置文件，该配置文件实现了假的依赖。你可以看到，不需要改动太多就可以在Scala中使用Spring框架。对于Java的其它依赖注入框架也一样道理。使用DI框架有些超前，但对于大型项目来说是值得的——除非你使用某些Scala框架提供依赖管理的本地支持。</p><p>本章讲解了大量的内容，我确保你所学习的技术会帮助你编写更解耦的、可测试的Scala系统。</p><p>下小节概述另外一个测试工具，叫Specs。JUnit是一个快速上手和运行的测试工具，但现在是时候使用基于Scala的测试框架，它更有表现力、以及更容易使用。</p><h3><span id="10~5behavior-driven-development-using-specs2p312">10~5〖Behavior-driven development using Specs2〗P312</span></h3><p>行为驱动开发(BDD，Behavior-driven development)，是从利益出发点描述行为实现一个应用。不久前我讨论了有关测试驱动开发，那为什么还讨论BDD？它和TDD有什么不同？</p><p>答案当然是不同了。BDD<sup id="fnref:18"><a href="#fn:18" rel="footnote">18</a></sup>做的是TDD相反的事情。第一是，BDD定义中完全没有谈及测试。这样做的目的是，TDD的一个设计缺陷是，一些人把用在测试上的时间比用在解决业务问题上更多。事实上，它推荐从利益层面看待应用。最终在一个项目中作BDD会有下面两个重要结果：</p><ul><li>快速传值(Delivering value quickly)——因为你从利益层面上看待应用，理解和传值是快速的。它帮助你理解问题，以及推荐合适的解决方案。</li><li>行为专注(Focus on behavior)——这是最重要的提升，因为时至今日，你实现的行为，正是你利益共同者想要的。专注于行为也减少了花费在预期设计、分析和文档上的付出，它很少给项目添加值。</li></ul><p>为了使开发者和利益共同者在同一个页面，你需要通用语言<sup id="fnref:19"><a href="#fn:19" rel="footnote">19</a></sup> (Ubiquitous language)，一个所有人在描述一个应用的行为时所说的通用语言。你也需要一个工具，这样你可以解析这些行为，并编写自动化规范对这些行为断言。</p><p><strong>注意</strong> test 和 specification 使用同义，但 specification 是一个更好的方式用来对 利益共同者讨论行为。考虑下面例子的一个 specification。</p><p>在BDD，开发时仍然遵循测试驱动开发声明周期。唯一改变的，看这些测试或规范的方式。是时候看一些BDD，接下来的小节，将向你介绍大多数Scala开发者使用的BDD工具：<strong>Specs2</strong>。</p><h3><span id="1051getting-started-with-specs2p313">10<sub>5</sub>1〖Getting started with Specs2〗P313</span></h3><p><strong>Specs2</strong><sup id="fnref:20"><a href="#fn:20" rel="footnote">20</a></sup> 是Scala的BDD库，由Scala编写，实际上BDD库被用于Scala开发者。开始使用Specs最简单的方式是，添加它的一个依赖到你的SBT项目中。添加下面代码到SBT的build.sbt文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">libraryDependencies += <span class="string">&quot;org.specs2&quot;</span> %% <span class="string">&quot;specs2&quot;</span> % <span class="string">&quot;2.3.1&quot;</span> % <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>如果你想要使用其它版本的Specs，请确保它对当前Scala版本是否适用。reload、update你项目，便可以使用Specs。精彩的部分是SBT知道如何自然地运行Specs规范。编写第一个Specs规范，使用前面小节相同的计价服务。为CalculatePriceService创建一个空的规范：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scala.book</span><br><span class="line"><span class="keyword">import</span> org.specs._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span></span></span><br></pre></td></tr></table></figure><p>要创建一个Specs规范，你总是需要导入org.specs2.mutable._并继承Specification特质。接下来，指定计价服务的行为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scala.book</span><br><span class="line"><span class="keyword">import</span> org.specs2.mutable._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">  <span class="string">&quot;Calculate price service&quot;</span> should &#123;</span><br><span class="line">    <span class="string">&quot;calculate price for cost plus price type&quot;</span> in &#123;&#125;</span><br><span class="line">    <span class="string">&quot;calculate price for external price source type&quot;</span> in &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你向规范添加了一个结构。首先你使用了should方法定义系统，由两个服务的行为描述。Specs框架添加如<code>should</code>和<code>in</code>方法，使用了隐式转换，这样你的规范变得更富有表现力和可读。当你在SBT中运行测试动作，你会看到如图10.4的输出。</p><p><img src="/img/scala-in-action/chapter10/Figure_10_04.png" alt="Figure 10.4"></p><p>如果你有一个ANSI终端窗口，Specs会展示不同的测试颜色。因为我没有实现任何specification，在图10.4中，它是黄色的。(如果实现了规范，绿色表示测试通过，红色表示失败)。</p><p>这里使用了cake pattern里面实现的service。在10.5.1小节中，创建了两个版本的service，一个是用于真实计价，另一个用于测试。下面是其测试版的CalculatePriceService：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestPricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span> <span class="keyword">with</span> <span class="title">Calculators</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StubCostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">CostPlusCalculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">5.0</span>D</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StubExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">ExternalPriceSourceCalculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>) = <span class="number">10.0</span>D</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> costPlusCalculator            = <span class="keyword">new</span> <span class="type">StubCostPlusCalculator</span></span><br><span class="line">  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> <span class="type">StubExternalPriceSourceCalculator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个计价器都返回硬编码价钱。要使用这个版本的计价系统，你需要在specification混入，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cakepattern._</span><br><span class="line"><span class="keyword">import</span> org.specs2.mutable._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span> <span class="keyword">with</span> <span class="title">TestPricingSystem</span> </span>&#123;</span><br><span class="line">  <span class="string">&quot;Calculate price service&quot;</span> should &#123;</span><br><span class="line">    <span class="string">&quot;calculate price for cost plus price type&quot;</span> in &#123;</span><br><span class="line">      <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">      <span class="keyword">val</span> price: <span class="type">Double</span> = service.calculate(<span class="string">&quot;costPlus&quot;</span>, <span class="string">&quot;some product&quot;</span>)</span><br><span class="line">      price must beEqualTo(<span class="number">5.0</span>D)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;calculate price for external price source type&quot;</span> in &#123;</span><br><span class="line">      <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">      <span class="keyword">val</span> price: <span class="type">Double</span> = service.calculate(<span class="string">&quot;externalPriceSource&quot;</span>, <span class="string">&quot;some product&quot;</span>)</span><br><span class="line">      price must be_==(<span class="number">10.0</span>D)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>must方法使用了隐式转换，这样specification上具有易读性。该例子证明了使用Specs编写一个富有表现力的规范是多么容易。下个小节探讨Specs特性内容。</p><h3><span id="1052working-with-specificationsp315">10<sub>5</sub>2〖Working with specifications〗P315</span></h3><p>要使Specs高效工作，你需要习惯规范和它的可用匹配器。匹配器是添加期望值的方式。<code>beEqualTo</code> 和 <code>must be_==</code>是这些匹配器的例子。Specs装载了大量的内建匹配器，你可以从Specs文档<sup id="fnref:21"><a href="#fn:21" rel="footnote">21</a></sup>中找到完整的列表。</p><p>前面小节你看了一个规范例子。现在向你展示一个变异的例子。根据你所描述的行为，选择合适的一个。</p><p>Specs规范的基本形式是，继承Specification特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> variousspecs</span><br><span class="line"><span class="keyword">import</span> org.specs2.mutable._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">  <span class="string">&quot;example1&quot;</span> in &#123;&#125;</span><br><span class="line">  <span class="string">&quot;example2&quot;</span> in &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看这些规范的一种方式是以组的方式描述。典型地，当你编写规范时，你会有一个描述行为的组件；这是在规范下的系统，你可以在规范下组织每个组的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SUSSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">  <span class="string">&quot;my system&quot;</span> should &#123;</span><br><span class="line"><span class="string">&quot;do this&quot;</span> in &#123;&#125;</span><br><span class="line"><span class="string">&quot;do that&quot;</span> in &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以嵌套例子，并把它添加的行为描述之中。如cost-plus计价系统：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;calculate price for cost plus price type&quot;</span> in &#123;</span><br><span class="line">  <span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">  <span class="keyword">val</span> price: <span class="type">Double</span> = service.calculate(<span class="string">&quot;costPlus&quot;</span>, <span class="string">&quot;some product&quot;</span>)</span><br><span class="line">  price must beEqualTo(<span class="number">5.0</span>D)        </span><br><span class="line">  </span><br><span class="line">  <span class="string">&quot;for empty product id return 0.0&quot;</span> in &#123;</span><br><span class="line"><span class="keyword">val</span> service = <span class="keyword">new</span> <span class="type">CalculatePriceService</span></span><br><span class="line">service.calculate(<span class="string">&quot;costPlus&quot;</span>, <span class="string">&quot;&quot;</span>) must beEqualTo(<span class="number">0.0</span>D)</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种在Specs声明规范的方式是使用 DataTable<sup id="fnref:22"><a href="#fn:22" rel="footnote">22</a></sup>。数据表可以让你执行例子中的集合测试数据。例如，你描述了一个cost-plus规则的计价例子，要对此进行测试，仅仅只测一条数据还不够。为了合适地描述这种行为，你需要一系列数据用于规则运算。Specs的DataTable便应运而生。它可以让你以表格的形式指定例子数据：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CostPlusRulesSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> <span class="keyword">with</span> <span class="title">DataTables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyCostPlusBusinessRule</span></span>(cost: <span class="type">Double</span>, serviceCharge: <span class="type">Double</span>) = &#123;</span><br><span class="line">    cost + (cost * <span class="number">0.2</span>) + serviceCharge</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;cost plus price is calculated using &#x27;cost + 20% of cost + given service charge&#x27; rule&quot;</span> in &#123;</span><br><span class="line">    <span class="string">&quot;cost&quot;</span> | <span class="string">&quot;service charge&quot;</span> | <span class="string">&quot;price&quot;</span> |&gt;</span><br><span class="line">      <span class="number">100.0</span> ! <span class="number">4</span> ! <span class="number">124</span> |</span><br><span class="line">      <span class="number">200.0</span> ! <span class="number">4</span> ! <span class="number">244</span> |</span><br><span class="line">      <span class="number">0.0</span> ! <span class="number">2</span> ! <span class="number">2</span> | &#123; (cost, serviceCharge, expected) =&gt;</span><br><span class="line">      applyCostPlusBusinessRule(cost, serviceCharge) must be_==(expected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例描述了规则，数据表则帮助捕获数据，并用来验证applyCostPlusBusinessRule方法。表格的第一行为标题，以易读性目的使用。第二行开始往下，则是例子数据，由一个闭包调用组成。在闭包内，你执行applyCostPlusBusinessRule方法来检验结果。为了在Specification使用DataTable，你需要混入DataTables特质。表格中的 <code>&gt;</code> 是必须的，相当于一个命令，<code>&gt;</code> 使得表格作为例子执行的一部分。</p><p>Specs的DataTable对于创建集合数据的测试非常有帮助。你也可以使用ScalaCheck来为Specs的DataTable生成测试数据。</p><p>下小节将探索如何在异步通讯中进行自动化测试。在第9章已学习的actors会作为消息系统的一个具体例子。现在让我们看看如何围绕它编写测试。</p><h3><span id="10~6testing-asynchronous-messaging-systemsp317">10~6〖Testing asynchronous messaging systems〗P317</span></h3><p>本章前面说过有关同步系统的测试和例子的创建，即是测试时调用系统，当系统处理完一个动作后，控制回到测试上面。但在异步“即发即弃”系统上，当系统正在执行时，控制也会回到测试上。该测试上，你不会得到任何反馈信息。为了克服这个问题，开发者将业务逻辑从消息层中提取出来，分离测试。这种方式的缺点就是，你不能从头到尾地测试。例如，为了验证一个actor是否给另一个actor发送了一个消息，你需要编写一个集成测试，它向一个actor发送消息，并等待它回复。围绕异步系统的集成测试，通常规则是检测无效的系统状态、或者等待带有timeout超时的通知。</p><p>为异步系统编写自动化测试是比较新的技术，以至于这方面的工具仍然处于维护之中。这里值得一提的工具是Awaitility<sup id="fnref:23"><a href="#fn:23" rel="footnote">23</a></sup>，它提供了一个非常好的测试DSL用于异步系统的测试。让我们看看Awaitility的一个处理例子。假设你有一个订单处理服务，用于异步地将订单保存到数据中，你通过发送一个PlaceOrder消息对订单进行放置。下面是虚拟的actor订单服务：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example.actors</span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrder</span>(<span class="params">productId: <span class="type">String</span>, quantity: <span class="type">Int</span>, customerId: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderingService</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">act</span> </span>= &#123;</span><br><span class="line">    react &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">PlaceOrder</span>(productId, quantity, customer) =&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在规范内，你将使用Awaitility的<code>await</code>方法进行等待，直到订单保存到数据库。如果定义没有保存到数据库，你会知道在处理消息时，哪里出了问题。下面是ordering service：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.specs2.mutable._</span><br><span class="line"><span class="keyword">import</span> example.actors._ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jayway.awaitility.scala._</span><br><span class="line"><span class="keyword">import</span> com.jayway.awaitility.<span class="type">Awaitility</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderingServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span> <span class="keyword">with</span> <span class="title">AwaitilitySupport</span> </span>&#123;</span><br><span class="line">  <span class="string">&quot;Ordering system&quot;</span> should &#123;</span><br><span class="line">    <span class="string">&quot;place order asynchronously&quot;</span> in &#123;</span><br><span class="line">      <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">OrderingService</span>().start</span><br><span class="line">      s ! <span class="type">PlaceOrder</span>(<span class="string">&quot;product id&quot;</span>, <span class="number">1</span>, <span class="string">&quot;some customer id&quot;</span>)      </span><br><span class="line">      await until &#123; orderSavedInDatabase(<span class="string">&quot;some customer id&quot;</span>) &#125;</span><br><span class="line">  </span><br><span class="line">      done</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">orderSavedInDatabase</span></span>(customerId: <span class="type">String</span>) = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的例子发送了一个异步消息给订单服务，并进入等待状态，知道订单保存到数据中。Awaitility的默认超时是10秒，你可以容易地通过重载await方法设置自定义timeout。在orderSavedInDatabase内，你可以检查数据源中是否保存了给定的customer id。</p><p>Awaitility没有提供任何的基础架构，帮助你测试异步系统，但它确实使你的例子可读。</p><h3><span id="10~7summaryp318">10~7〖Summary〗P318</span></h3><p>本章覆盖讲述了一个重要的主题，高质量软件的开发。用一个新的编程语言，并尝试使用它来构建一个大型的应用是困难的。在新的语言或编程环境，通常的障碍是编写自动化测试。本章则介绍了Scala项目下的一些测试工具使用。</p><p>最先介绍的是ScalaCheck自动化测试工具。并学习了如何在ScalaCheck定义规范，创建自定义测试数据生成器。ScalaCheck是一个很好的测试。</p><p>你学习了关于敏捷软件开发和其中的测试驱动开发。探索了TDD如何对依赖构建、如何帮助改进设计。要在Scala项目中练习TDD，你需要工具支持。我讲解了如何设置一个持续集成的环境、如何使用SBT作为构建工具。并列出了用于Scala项目的一些常见工具。</p><p>使用自动化测试构建应用，要求你的设计是可测试的。一个可测试设计的至关重要的特点是控制反转，它被用于Java、Ruby及其它语言中。Scala既是面向对象的、也是函数式的，拥有更多选项来创建抽象。小节10.5介绍了Scala的依赖注入。诸如自类型(self type)、抽象成员(abstract members)不仅可以用于抽象，事实上，你可以将这些抽象思想用于构建可复用的组件。</p><p>在TDD中，最常见的错误是，开发者把过多的精力放在测试上，而忽略了最重要的，应用的行为。BDD弥补了这个疑惑，使开发回到行为和客户协作上。这里介绍了Specs工具，它让你编写富有表现力的规范。我提及过你可以使用JUnit来测试你的Scala代码，但注意这并不推荐。使用Scala规范/测试工具将会提供你的测试的可读性，并帮助提高和其它Scala tools的集成。</p><p>下个章节将讨论函数式编程。你前面看到一些Scala的函数式编程的特性以及一些例子，但11章以函数式编程概念将这些特性紧密联系在一起，这样你可以编写更可靠的、更正确的Scala程序。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">“Manifesto for Software Craftsmanship,” <a href="http://manifesto.softwarecraftsmanship.org">http://manifesto.softwarecraftsmanship.org</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">“Agile software development,” <a href="http://en.wikipedia.org/wiki/Agile_software_development">http://en.wikipedia.org/wiki/Agile_software_development</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Martin Fowler, “Is Design Dead?,” May 2004, <a href="http://martinfowler.com/articles/designDead.html">http://martinfowler.com/articles/designDead.html</a>.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">“Waterfall model,” <a href="http://en.wikipedia.org/wiki/Waterfall_model">http://en.wikipedia.org/wiki/Waterfall_model</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">“Introduction to QuickCheck,” modified Oct 25, 2012, <a href="www.haskell.org/haskellwiki/Introduction_to_QuickCheck">http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck</a>.</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">“ScalaCheck user guide,” updated April 12, 2012, <a href="http://code.google.com/p/scalacheck/wiki/UserGuide">http://code.google.com/p/scalacheck/wiki/UserGuide</a>.</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">Scala Either, <a href="http://mng.bz/106L">http://mng.bz/106L</a>.</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">“Test-driven Development,” <a href="http://en.wikipedia.org/wiki/Test-driven_development">http://en.wikipedia.org/wiki/Test-driven_development</a>.</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">Martin Fowler, “Continuous Integration,” May 1, 2006, <a href="http://martinfowler.com/articles/continuousIntegration.html">http://martinfowler.com/articles/continuousIntegration.html</a>.</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;">maven-scala-plugin, version 2.14.2, Aug. 4, 2010, <a href="http://scala-tools.org/mvnsites/maven-scala-plugin/">http://scala-tools.org/mvnsites/maven-scala-plugin/</a>.</span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;">Stefan Zeiger, szeiger/junit-interface, <a href="https://github.com/szeiger/junit-interface">https://github.com/szeiger/junit-interface</a>.</span><a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">12.</span><span style="display: inline-block; vertical-align: top;">SBT, <a href="https://github.com/harrah/xsbt">https://github.com/harrah/xsbt</a>.</span><a href="#fnref:12" rev="footnote"> ↩</a></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">13.</span><span style="display: inline-block; vertical-align: top;">Martin Odersky and Matthias Zenger, “Scalable Component Abstractions,” presented at OOPSLA’05, Oct. 16-20, 2005, <a href="http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf">http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf</a></span><a href="#fnref:13" rev="footnote"> ↩</a></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">14.</span><span style="display: inline-block; vertical-align: top;">Martin Fowler, “Inversion of Control Containers and the Dependency Injection Pattern,” Jan. 23, 2004, <a href="http://martinfowler.com/articles/injection.html">http://martinfowler.com/articles/injection.html</a>.</span><a href="#fnref:14" rev="footnote"> ↩</a></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">15.</span><span style="display: inline-block; vertical-align: top;">“Aspect-oriented programming,” <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>.</span><a href="#fnref:15" rev="footnote"> ↩</a></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">16.</span><span style="display: inline-block; vertical-align: top;">“The IoC container,” Spring Framework, <a href="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html">http://static.springsource.org/spring/docs/2.5.x/reference/beans.html</a>.</span><a href="#fnref:16" rev="footnote"> ↩</a></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">17.</span><span style="display: inline-block; vertical-align: top;">“JavaBeans,” <a href="http://en.wikipedia.org/wiki/JavaBean">http://en.wikipedia.org/wiki/JavaBean</a>.</span><a href="#fnref:17" rev="footnote"> ↩</a></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">18.</span><span style="display: inline-block; vertical-align: top;">David Chelimsky, et al., The RSpec Book: Behaviour-Driven Development with RSpec, Cucumber, and Friends, Pragmatic Bookshelf, 2010, <a href="http://www.pragprog.com/book/achbd/the-rspec-book">www.pragprog.com/book/achbd/the-rspec-book</a>.</span><a href="#fnref:18" rev="footnote"> ↩</a></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">19.</span><span style="display: inline-block; vertical-align: top;">“UbiquitousLanguage,” <a href="http://martinfowler.com/bliki/UbiquitousLanguage.html">http://martinfowler.com/bliki/UbiquitousLanguage.html</a>.</span><a href="#fnref:19" rev="footnote"> ↩</a></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">20.</span><span style="display: inline-block; vertical-align: top;">Specs 2, <a href="http://etorreborre.github.com/specs2/">http://etorreborre.github.com/specs2/</a>.</span><a href="#fnref:20" rev="footnote"> ↩</a></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">21.</span><span style="display: inline-block; vertical-align: top;">Specs, MatchersGuide, “How to add expectations to your examples,” <a href="http://code.google.com/p/specs/wiki/MatchersGuide">http://code.google.com/p/specs/wiki/MatchersGuide</a>.</span><a href="#fnref:21" rev="footnote"> ↩</a></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">22.</span><span style="display: inline-block; vertical-align: top;">Specs, “How to use Data Tables,” updated March 30, 2010, <a href="http://code.google.com/p/specs/wiki/AdvancedSpecifications">http://code.google.com/p/specs/wiki/AdvancedSpecifications</a>.</span><a href="#fnref:22" rev="footnote"> ↩</a></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">23.</span><span style="display: inline-block; vertical-align: top;">Awaitility, <a href="http://code.google.com/p/awaitility/">http://code.google.com/p/awaitility/</a>.</span><a href="#fnref:23" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章：Scala之并发编程</title>
      <link href="/2016/10/27/scala/09-scala-concurrency/"/>
      <url>/2016/10/27/scala/09-scala-concurrency/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>并发编程挑战</li><li>actor编程模型</li><li>actor中的错误处理</li><li>并发编程中组合Future和Promise</li></ol><p>在本章将介绍Scala中最为激动人心的特性：actor库。可以把一个actor认为是一个对象，该对象处理一个消息(请求)并封装状态(actor间的状态是不共享的)。接收一个消息，并在相应中执行一个动作的能力，这样的对象称为一个actor。更高层面上讲，actors是你做面向对象编程(OOP)时应该实现的方式。要记得actor模型鼓励不共享状态的体系架构。在本章，我将解析为什么在任何并发编程里面，这是一个重要的性质。</p><p>Future 和 Promise以非阻塞(nonblocking)的方式提供了执行并发操作的抽象。这是一个很好的方式来创建多并发和平行计算，以此计算你的工作(job)。这和你如何组合函数很相似，但，在这里，函数被并发(concurrently)地或平行(parallel)地执行。Future可以认为是一个代理对象，你可以为一个以后会用到结果进行创建。你可以用Promise有提供的结果来完成一个Future。我们将在本章循序渐进得探索Promise 和 Future。首先，让我们先理解下我所理解的并发、并行编程。</p><span id="more"></span><h3><span id="9~1what-is-concurrent-programmingp256">9~1〖What is concurrent programming?〗P256</span></h3><p>并发，指的是当多于一个任务时，并在重叠的时间内，这些任务能够开始并完成。即使它们运行在同一个时刻(instant)也没有问题。你可以在单核CPU上编写并发程序，当且仅当只有一个任务可以执行在给定的时间点上。典型地，多个任务被执行在一个时间分片管理器(time-slice manager)上，该时间分片管理器就是指一个计划任务(例如JVM)将被确保每个处理在操作时间内被“切分”进行。这就给使用者感觉是并行的(parallelism)。普遍事实上的、标准的处理多任务应用的方式是使用线程。图Figure9.1展示了多任务应用是如何在单核CPU上共享的。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_1.png" alt="Figure 9.1"></p><p>正如Figure 9.1，两个线程正在执行由时间分片管理器应用生成的指令。这些指令组的大小各不相同，因为在调度器(schedulers)从一个线程执行结束到执行另外一个线程之前，你不知道有多少指令会被执行。记住，在其它进程运行的同时，需要CPU时间，你可以看到它是那么的不可预测。当有超过一个线程处于就绪状态(ready-to-run state)时，调度器(schedulers)会使用一个优先级机制来安排一个线程的运行。这样一来，当你有指令在占用着资源时，例如从socket或文件系统读取数据。在这种情况下，尽管该线程有机会使用CPU，但它却不能使用因为它处于等待数据的状态，CPU处于闲置状态。我会在9.4小节重现这个问题。</p><p>大多数人交替地使用 <em>并发(concurrency)</em> 和 <em>并行编程(parallel programming)</em> ，但有不同，在并行编程中，按字面上的意思，你可以在同一个时间运行多个任务，在多核处理器上是可行的。</p><p>一个并发编程，当它运行在多核环境上时，有时候是一个并行编程(在下个小节我将解释为什么并不总是)。这听起来棒极了，因为所有的CPU供应商都向多核CPU方向生产。但也给软件开发者摆出了难题，因为编写并发、并行应用是困难的。可以想象，当在并行模式中执行多任务应用，线程1需要来自线程2的数据，但这数据并不能用。在这种情况下，线程1会等待，直到它得到该数据，这样一来就不再是并行的了。你共享了线程越多的数据和状态，就越难在并行线程中对此进行管理。本章的全部内容，将尽量使你的并发编程运行在并行模式之中。</p><p>并发中另一个常用的术语是 <em>分布式计算(distributed computing)</em> 。这里定义的分布式计算是跨越网络的多个计算节点(计算机、虚拟设备)，它们在一个给定问题上工作在一起。一个并行进程会作为一个分布式进程运行在一个多网络节点上。在第12章，你将会看到一个例子——当我们在一个远程节点上部署actors以实现网络交流。现在让我们看看用手头上的工具来解决并发问题以及与此有关的各种挑战。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_2.png" alt="Figure 9.2"></p><h3><span id="9~2challenges-with-concurrent-programmingp258">9~2〖Challenges with concurrent programming〗P258</span></h3><p>第一章讨论了我们当前所面临的危机并以摩尔定律结束。作为一个软件工程师，我们没有选择并应支持多核处理。CPU制造业早已经以构建多核CPU为方向。在未来将看到16核、32核以及64核。我们在企业软件开发中的问题种类也变得越来越大。面对处理能力快速增长的需求，我们必须规划出一个方案来吸收这些多核处理器的有点——否则，我们的编程将变得越来越低效。</p><p>但是要编写一个正确的、没有错误的并发程序有困难。一下列出其原因：</p><ul><li>只有一般的程序员知道如何编写一个正确的、并发的应用或程序。程序的正确性(correctness)非常重要。</li><li>难于调试多线程程序。同样是死锁引起的问题，在本地调试时却不会有任何问题。有时则是好多年过去后才出现线程问题。</li><li>线程间鼓励共享状态并发性，这使得程序会由于锁、信号量(semaphores)、线程间依赖的原因难于并行运行。</li></ul><p>尽管多线程问题使得编写并发程序困难起来，但主要的罪魁祸首(culprit)是可变的状态(mutable state)。线程鼓励共享的状态并发。下一个小节将探讨共享状态并发有多难。</p><h3><span id="921difficulties-of-shared-state-concurrency-with-threadsp258">9<sub>2</sub>1〖Difficulties of shared-state concurrency with threads〗P258</span></h3><p>使用线程的问题是并发性是一个很底层的抽象。线程太接近硬件，它表示了CPU的任务调度方式。你需要的是可以封装这些线程，并给你某些东西让你可以更容易地实现编程。以Scala的集合为例：特质Traversable定义了一个抽象方法叫<code>def foreach[U](f: Elem =&gt; U)</code>，并让其它集合库类继承实现。可以想象，你仅仅需要使用foreach来做任何集合排序的操作，却不能使用其它map，fold，filters之类的方法。这样的话Scala编程将变得相当困难。这就是我尤其在线程问题上想说的：他们对于程序员来说太底层了。例如，在Java中，在引入<code>java.util.concurrent</code>包之前，我们只有<code>java.lang.Thread</code>，我们很难在其它类上实现并发应用。引入<code>java.util.concurrent</code>之后，事情变得明朗了。新的<code>java.util.concurrent</code>包中提供了一系列的非常有用的工具，并实现了流行的并发设计模式，尽管如此，我们仍然很难避免线程背后复杂的，来自可变共享数据的问题。它是一个设计上的问题，我们编程人员在使用线程时不得不处理该问题。为了防止数据损坏以及保持数据的一致性，我们使用了锁(locks)。我们使用锁来控制那些被修改和访问的共享数据，但是锁在编程中引入了问题。</p><table><thead><tr><th style="text-align:left">Problem</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">锁不能组合</td><td style="text-align:left">你不能通过组合小的线程安全的操作，实现一个高层次的、线程安全的行为</td></tr><tr><td style="text-align:left">用了太多或太新的锁</td><td style="text-align:left">你会在出现问题的时候才知道。这个问题可能不会在产品上显示(甚至好几年之后)，获取和释放锁是个昂贵的操作。</td></tr><tr><td style="text-align:left">死锁和竞价条件(race conditions)</td><td style="text-align:left">这是线程不确定性的本质。几乎不可能有确定性的编程代码。你可以使用设计模式，例如总是在正确的顺序中获得锁，为了避免死锁，这种机制给程序开发者增加了更多的负担。</td></tr><tr><td style="text-align:left">难于修复错误</td><td style="text-align:left">这更多的是线程问题，而不是共享状态问题。尽管如此他也是个大问题。在多线程编程中还没有一个清晰的机制修复这种错误。一般都是查看日志堆栈里面反馈的跟踪信息。</td></tr></tbody></table><p>最后但并不是最不重要的是，共享的可变数据使得它难于平行得运行程序，这已经在9.1小节讨论了。最大的问题是：如果线程难于使用，为什么多数程序要用到它？几乎所有多线程编码都有bug，但近期不会带来很大的问题。因为多核架构变得越来越流行，这些bug会出现得非常频繁。</p><p>线程问题应该留给一些少数的专家；即我们应该去找更高层的抽象，这个抽象隐藏了多线程的复杂性，并提供了一个易用的API。尽管如此，你也会遇到只能使用线程的场景，但99%的情况下你应该使用其它方式。这种变化会带来代价，这种代价就是我们所有人都要学习一种新的方式来编写或设计并发应用。本章将探索这其中一个新技术。</p><h3><span id="922new-trends-in-concurrencyp259">9<sub>2</sub>2〖New trends in concurrency〗P259</span></h3><p>讨论了足够多的线程、锁问题了，让我们着手如何解决。下面列出三种最流行的并发应用实现。</p><table><thead><tr><th style="text-align:center">name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:center">软件事务内存(STM)</td><td style="text-align:left">STM是一个并发控制机制，和数据库的事务类似。STM控制了共享内存的访问，而不是处理表、行。一个STM事务执行一小段代码，该代码读取和编写一个共享内存。这种典型的实现了一个无锁的方式并且是可组合的。我会在第12章讨论更多有关STM方面的内容。</td></tr><tr><td style="text-align:center">数据流并发</td><td style="text-align:left">数据流并发背后的原理是，在多任务、多线程间共享变量。这些变量在它的声明周期中只被赋值一次。但这些变量中的值可以被读取多次，即使这些变量没有赋值。这给你的编程有更多的确定性，不会有竞价条件和确定的死锁。第12章在akka框架中覆盖数据流并发设计。</td></tr><tr><td style="text-align:center">消息传递并发(message-passing concurrency)</td><td style="text-align:left">这是本章节所花费大篇幅要讲的内容。该并发模型中，组件间通过发送消息进行通信。消息既可以是同步的，也可以是异步的，但异步发送信息给其它组件更常用。这些消息是不可变的，并有独立组件的状态中分离出来。你不用共享状态问题——事实上，消息传递并发鼓励非共享架构。最成功的例子是actor模型，自Erlang编程语言开始，成功地使用了actor模型构建大型的、分布式的、并行通信的应用后，actor模型变得流行起来。Scala的actor库中就是这个消息传递并发模型的另外一种实现。</td></tr></tbody></table><p>本章剩余的部分将专注于使用Scala actor的消息传递并发内容，让我们现在开始。</p><h3><span id="9~3implementing-message-passing-concurrency-with-actorsp260">9~3〖Implementing message-passing concurrency with actors〗P260</span></h3><p>在该并发模型中，actor通过发送和接收消息彼此通信。一个actor处理收到的消息，并执行与之相关联的动作。典型地，这些消息是不可变的(immutable)，因为它们没有共享状态。</p><p>在一个actor中，有两种主要的通信抽象层：发送和接收。要给一个actor发送消息，你可以使用下面的表达式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ! msg</span><br></pre></td></tr></table></figure><p>你调用了 <code>!</code> 方法，给actor a 发送了msg消息。当你给一个actor发送消息时，它是一个异步操作，以及它的调用会立即得到返回。这些消息被存储到一个先进先出的队列中。可以认为队列是一个用于存储actor收到的信息的邮箱，每个actor都有自己的邮箱。<em>接收(receive)</em> 操作被定义为一个消息匹配模式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">receive &#123;</span><br><span class="line">  <span class="keyword">case</span> pattern1 =&gt;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> pattern =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别于其它对象，一个actor的不同之处在于用于对收到的消息给出响应动作。</p><p>Scala中以及包含有默认的actor库，从Scala 2.10开始，独立出来成为akka actors。虽然现在有许多actor库，但目前akka才是主流。</p><p><strong>注意</strong> 由Scala 2.10.1发行开始，Scala的actor库被分离出来，并可能会在将来被删除。为了便于迁移，Scala提供了一个AMK(Actor Migration Kit，迁移包)，以方便迁移旧版本的Scala代码到akka库中。</p><p>要创建一个actor，继承由Akka库提供的Actor特质，并实现里面的<code>receive</code>方法。下面例子创建了一个简单的actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Name</span>(n) =&gt; println(<span class="string">&quot;Hello &quot;</span> + n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GreetingsActor仅能处理类型Name的消息，我将说明，当发送的消息不匹配任何模式时会发生什么。请注意，你不必要为case class创建消息，你可以发送任何可以在Scala模式匹配中可以匹配到的内容。例如，要匹配字符类的消息，你可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> name: <span class="type">String</span> =&gt; println(<span class="string">&quot;Hello &quot;</span> + name)</span><br></pre></td></tr></table></figure><p>在发送任何消息给GreetingsActor之前，actor需要通过创建一个ActorSystem来初始化。可以认为一个ActorSystem是一个或多个actor的管理器。(ActorSystem在下一个小节介绍)这个 actor system提供了一个方法actorof，它接收一个配置对象(akka.actor.Props)，以及一个可选参数name：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;greetings&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = system.actorOf(<span class="type">Props</span>[<span class="type">GreetingsActor</span>], name = <span class="string">&quot;greetings-actor&quot;</span>)</span><br><span class="line">a ! <span class="type">Name</span>(<span class="string">&quot;Nilanjan&quot;</span>)</span><br><span class="line">system.shutdown()</span><br></pre></td></tr></table></figure><p>actor系统会为actor的运行创建基础设施需求。当完成后，system.shutdown()会关闭基础设施和所有actor。消息被异步处理，因此system.shutdown()会停止那些还没有处理完消息的actor。在运行上述代码片段之前，请确保你的构建文件中已经包含以下依赖：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor&quot;</span> % <span class="string">&quot;2.1.0&quot;</span></span><br></pre></td></tr></table></figure><p>下面为GreetingsActor的完整代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Name</span>(n) =&gt; println(<span class="string">&quot;Hello &quot;</span> + n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;greetings&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> a      = system.actorOf(<span class="type">Props</span>[<span class="type">GreetingsActor</span>], name = <span class="string">&quot;greetings-actor&quot;</span>)</span><br><span class="line"></span><br><span class="line">  a ! <span class="type">Name</span>(<span class="string">&quot;Nilanjan&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">50</span>)</span><br><span class="line">  system.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有按计划进行， 你应该在控制台看到&quot;Hello Nilanjan&quot;的信息。祝贺你！你实现了你的第一个Scala actors。现在让我们回过头来，理解为什么我们需要一个actor系统。</p><h3><span id="931what-is-actorsystemp262">9<sub>3</sub>1〖What is ActorSystem?〗P262</span></h3><p>一个actor系统是一个actor结构层次组，这个组共享一个通用的配置。它同时也是创建和查找actors的入口。典型地，一个基于actor设计的应用就像一个真实世界里面的一个工作组织一样。在一个组织中，工作在部门间彼此传递。每个部门可能会进一步分工，直到成为可由雇员可以管理的大小。相似地，actors形成一个层次结构，该结构中父类委派给子类actor，直到它可以由一个独立的actor处理。</p><p><strong>注意</strong> 一个ActorSystem是一个重量级的结构，允许1…N个线程，因此能为你的应用创建每一个逻辑子系统。例如，你可以有一个actor系统来处理后台数据库，另一个处理所有的web service调用，等等。Actors非常廉价。一个给定actor仅消费300字节，你可以轻松地创建成千上万个。</p><p>在结构层次的最顶部是家长actor，在每个actor系统中会自动创建。所有其它由给定的actor系统创建的actors都成为该家长actor的孩子。在actor系统中，每个actor都有自己的监护人(父actor)自动处理错误。因此，如果一个actor崩溃了，它的父actor会自动重启这个actor。</p><p>创建一个actor的最简单的方式是创建一个ActorSystem，并使用actorof方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(name = <span class="string">&quot;word-count&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> m: <span class="type">ActorRef</span> = system.actorof(<span class="type">Props</span>[<span class="type">SomeActor</span>], name = <span class="string">&quot;someActor&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码片段创建了一个名为&quot;word-count&quot;的ActorSystem，方法actorof用于创建一个SomeActor类的actor实例。Props是一个线程安全的、共享的ActorRef配置对象。Props有大量的工具方法用来创建actors。</p><p>注意当你在akka中创建一个actor时，你不能获得该actor的直接引用。相反回调了一个ActorRef(actor的引用)的actor。ActorRef最重要的目地是给它所代表的actor发送消息。它也扮演一个保护层，这样你不能直接访问actor和改变它的状态。ActorRef是序列化的，因此如果一个actor崩溃了，作为一个错误处理机制，你可以序列化ActorRef，把它发送给另外一个节点，并重启actor。客户端的actor不会注意。有不同类型的actor引用。在本章我们会浏览本地的actor引用(意思是所有actor运行在本地的单一的JVM上)；第12章会浏览远程的actor引用(actor运行在其它远程的JVM上)。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_3.png" alt="Figure 9.3"></p><p>actor系统的第二部分是actor路径。一个actor的路径不唯一标识在actor系统中。因为actors创建在层次结构中，它们组织了和文件系统相似的结构。因为一个路径在一个文件系统中指向了一个独立的资源，一个actor路径在一个actor系统中也唯一地标识了actor的引用。注意这些actor不一定要在一个机器上——它们可以是分布式的、多节点的。使用定义在ActorSystem里面的方法，你可以查阅的一个actor引用了actor系统中的哪个存在监护人(supervisor)。下面例子是使用 <code>system /</code> 来获得 WordCountWorker 的引用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(name = <span class="string">&quot;word-count&quot;</span>)</span><br><span class="line">system.actorOf(<span class="type">Props</span>[<span class="type">WordCountWorker</span>], name = <span class="string">&quot;wordCountWorker&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> path: <span class="type">ActorPath</span> = system / <span class="string">&quot;WordCountWorker&quot;</span></span><br><span class="line"><span class="keyword">val</span> actorRef: <span class="type">ActorRef</span> = system.actorFor(path)</span><br><span class="line">actorRef ! “some message”</span><br></pre></td></tr></table></figure><p><code>system /</code> 方法返回actor路径，以及方法actorFor返回该actor在给定path上的引用映射。如果actorFor在给定的path上查找失败，它会返回该actor系统的引用死信(dead-letter mailbox)。在所有消息未被释放时，它是一个合成的actor。</p><p>你可以从查找actors中重新创建actor path。可以在 <a href="http://doc.akka.io/docs/akka/2.1.0/general/addressing.html">这里</a> 获取更多有关akka的详细内容。</p><p>要在actor系统中关闭所有的actors，调用shutdown方法，该方法会优雅地关闭actors系统中的所有actor。父actor会首先停止所有孩子actors并发送所有未处理的消息到死讯邮箱中。最后重要的一步是actor系统的消息调度器。MessageDispatcher是使所有actors工作的引擎。下一小节将介绍actors是如何工作的。</p><h3><span id="932how-do-scala-actors-workp264">9<sub>3</sub>2〖How do Scala actors work?〗P264</span></h3><p>每个actor系统都带有一个默认的MessageDispatcher组件。它的职责是给该actor的邮箱发送一个消息，并执行actor的receive块。每个MessageDispatcher被一个线程池支撑，该线程池使用配置文件配置(更多内容在第12章介绍)。你可以为你的actor系统或指定的actor配置不同类型的dispatchers。至于本章的内容将使用默认的dispatcher(a.k.a event-based dispatcher)。图9.4展示了actor内发送和接收消息是如何工作的。</p><p>向一个actor发送一个消息更加简单。要发送一个消息到一个actor的邮箱，ActorRef首先会发送消息到actor关联的MessageDispatcher中(大多数情况下，MessageDispatcher由actor系统配置)。该actor中的MessageDispatcher立刻为邮箱中的消息进行排序。控制立即回到消息的发送方。这就是它如何工作的，当我们发送一个消息到greeting actor时。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_4.png" alt="Figure 9.4"></p><p>处理一个消息包含更多的调用过程，让我们继续图Figure 9.4的内容：</p><ol><li>当一个actor在它的邮箱中接收到一个消息时，MessageDispatcher为该actor安排执行计划。发送和处理消息发生在两个不同的线程。在线程池中，如果一个线程可以，则该线程被选择用来执行该actor。如果所有线程都处于繁忙状态，actor会在线程可用时执行。</li><li>可用线程从邮箱中读取消息。</li><li>某一时刻，该actor的receive方法被调用来传递一个消息。</li></ol><p>消息调度器(message dispatcher)总是确保一个单一线程总是执行一个给定的actor。该线程可能不是同一个，但总是有一个。这大大地确保了在并发世界里面，你可以安全地使用一个actor里面的可变状态(mutable state)，只要它不是共享的。现在，我想我们应该使用actor来构建一个应用程序。</p><h3><span id="933divide-and-conquer-using-actorsp266">9<sub>3</sub>3〖Divide and conquer using actors〗P266</span></h3><p>下述例子，要求实现从一个目录的所有文件中，统计单词的个数，并按升序排列。一种实现方式是，单线程下在该目录中遍历所有文件，在每个文件统计单词个数，最后将它们排序。但这是实现是顺序的(sequential)。要实现并行处理，我们要通过actor实现分治模式(divide-and-conquer，也称为fork-join)。我们将会有一些列的worker actor处理独立文件，以及一个主要的actor进行排序和计算结果。</p><blockquote><h4><span id="actor-api">Actor API</span></h4><p>特质akka.actor.Actor定义了唯一的抽象方法receive 来实现actor的行为。Actor额外定义的方法，对于声明周期钩子和故障处理很有帮助。下面列出一些比较重要的方法。(请查阅scaladoc获得完整的方法列表)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unhandled</span></span>(message: <span class="type">Any</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure><p>当给定的message不能匹配到actor方法receive中的任何一种模式时，unhandled方法会由akka.actor.UnhandledMessage 被调用执行。该方法默认是将message发布给actor系统的事件流(event stream)。你可以配置该事件流，并在日志文件中打印该unhandled messages。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> self: <span class="type">ActorRef</span></span><br></pre></td></tr></table></figure><p>这个字段持有对该actor的引用，你可以使用self来给自身发送一个小心：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">sender</span></span>: <span class="type">ActorRef</span></span><br></pre></td></tr></table></figure><p>该Actor的ActorRef会发送最后接收到的message。当你想要message发送方进行回复时，这会非常有用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> context: <span class="type">ActorContext</span></span><br></pre></td></tr></table></figure><p>这里为actor、message以及创建子actors的工厂方法，提供了一个上下文信息。该上下文也提供了对该actor系统的方法、以及其它actors声明周期钩子的监控。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span></span>: <span class="type">SupervisorStrategy</span></span><br></pre></td></tr></table></figure><p>该观察者定义了当探测到一个actor失败时将要如何处理，你可以重载并定义自己的观察者模式。我们会在本章中覆盖介绍。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>()</span><br></pre></td></tr></table></figure><p>该方法会在一个actor第一次启动时调用，它在所有message被处理之前执行。该方法可以用于该actor资源或函数的初始化操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preRestart</span></span>()</span><br></pre></td></tr></table></figure><p>Actors可能会在处理message发生错误时重启，该方法在该actor的当前实例中被调用。这里要澄清的是，默认实现是停止所有的子actor并调用postStop 方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>()</span><br></pre></td></tr></table></figure><p>而该方法则是在当前actor实例被停止是调用执行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postRestart</span></span>()</span><br></pre></td></tr></table></figure><p>当一个actor被重启，旧的actor实例被丢弃，新的actor实例通过actorOf方法被创建。然后<code>postRestart &gt;</code>在该新的实例上被调用。默认实现是调用preStart方法，它和preRestart的调用类似。</p></blockquote><p>为了使用actor来解决单词的计数问题，你将会创建两个actor类：一个用于浏览该目录的所有文件并计算结果，叫做WordCountMaster；另外一个叫做WordCountMaster，用于统计每个文件里面的单词。还有一点要考虑的是message会在actor间通信。首先你需要一个message用于初始化目录文件的计数，以及初始化actor的数量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCounting</span>(<span class="params">docRoot: <span class="type">String</span>, numActors: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>docRoot指定文件的位置，numActors会创建worker actors的个数。主程序会通过传递该消息给主actor开始计数处理。WordCountMaster 和 WordCountWorker彼此间通过消息进行交流。WordCountMaster需要一个message用于发送文件目录给worker actor进行计数，以及需要一个message携带单词计数信息和文件目录名，返回给主actor。下面是这些消息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">fileName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>(<span class="params">fileName: <span class="type">String</span>, count: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>为了理解这些消息是如何消费(consumed)的，看图 9.5 。该图仅仅显示了一个worker actor，但其它worker actor的数量取决于你在StartCounting中定义的个数。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_5.png" alt="Figure 9.5"></p><p>让我们开始 WordCountWorker，这是最容易的一个。这个actor仅处理FileToCount类型信息，该动作关联了 打开文件、统计该文件的单词个数 的消息。统计文件的单词个数，实际上和你之前看到的进程的例子类似：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWords</span></span>(fileName:<span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">    <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你使用scala.io.Source来打开文件，统计该文件的所有单词——这是最直接的做法。现在进入到最有趣的环节：receive方法。你已经知道需要处理哪些消息，你需要担心的是，当统计完单词，向WordCountMaster回复。</p><p>好消息是，Akka actor在运行时隐式地给sender引用的actor发送每个消息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileToCount</span>(fileName:<span class="type">String</span>) =&gt;</span><br><span class="line">        <span class="keyword">val</span> count = countWords(fileName)</span><br><span class="line">        sender ! <span class="type">WordCount</span> (fileName, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回复中，你将WordCount消息回发给WordCountMaster 的 actor。</p><blockquote><h4><span id="what-if-an-actor-performs-a-blocking-operation">What if an actor performs a blocking operation ?</span></h4><p>通常推荐的做法是，你不用从actor处理任何阻塞操作。当你在一个actor中创建一个阻塞时，你也阻塞了一个线程。前面说过，线程是有限资源。所以如果你最终有许多阻塞的actor，你不久将耗尽这些线程，导致actor系统停止。</p><p>有时你不会有阻塞之外的其它选择。这种情况下，推荐的做法是，分配不同的 message dispatchers将阻塞actors 从非阻塞actor中分离出来。这里提供了灵活的配置：附加额外的进程进行阻塞分离、吞吐量等等。额外添加这些的好处是，如果系统的一部分由于消息线程繁忙发生过载，其它部分会依然正常工作。</p></blockquote><p>下面是完整的 WordCountWorker 类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span></span>(fileName: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">    <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileToCount</span>(fileName: <span class="type">String</span>) =&gt;</span><br><span class="line">      <span class="keyword">val</span> count = countWords(fileName)</span><br><span class="line">      sender ! <span class="type">WordCount</span>(fileName, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;Worker actor is stopped: <span class="subst">$self</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的方法postStop被重构用于当actor停止时，打印消息到控制台上，这不是必要的。我们用这个来debug消息，确保actor被正确停止。当前的WordCountWorker 仅仅返回FileToCount消息。当它接收到消息，它会统计文件里面单词的个数，并告知主actor对其排序。其它消息会被丢弃，并被unhandled方法处理，因为它有下面提及的方面决定。</p><blockquote><h4><span id="what-is-actordsl">What is ActorDSL?</span></h4><p>如果你熟悉旧的Scala actors，ActorDSL看起来和Scala actor十分相似。在akka actor库中这是额外新添加的，可以帮助用于创建一次性的workers或在REPL下工作。要导入DSL的所有特性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorDSL</span>._</span><br></pre></td></tr></table></figure><p>要创建一个简单的Actor，使用定义在ActorDSL里面的方法 actor，并传递一个Act特质的实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> <span class="type">Act</span>&#123;</span><br><span class="line">    become &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ping&quot;</span> =&gt; sender ! <span class="string">&quot;pong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法become 方法添加了该actor需要处理的 message pattern。后台 Act继承了Actor特质，become方法添加了receive块的行为。使用该DSL语法，你不再需要创建一个类。下面是两个actor相互通信的例子，通过发送 ping-pong 信息交流：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorDSLExample</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> akka.actor.<span class="type">ActorDSL</span>._</span><br><span class="line">  <span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;actor-dsl&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> <span class="type">Act</span> &#123;</span><br><span class="line">    become &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ping&quot;</span> =&gt; sender ! <span class="string">&quot;pong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  actor(<span class="keyword">new</span> <span class="type">Act</span> &#123;</span><br><span class="line">    whenStarting &#123; testActor ! <span class="string">&quot;ping&quot;</span> &#125;</span><br><span class="line">    become &#123;</span><br><span class="line">      <span class="keyword">case</span> x =&gt;</span><br><span class="line">        println(x)</span><br><span class="line">        context.system.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该actor系统被声明为implicit值，因此我们不需要显式传递它的方法。whenStarting是该DSL生命周期prestart方法的钩子。</p></blockquote><p>WordCountMaster接收到StartCounting消息后开始计数。该消息包含了两个参数，目录名、worker actor的个数。要浏览目录中的文件，使用java.io.File类中定义了list方法，列出目录中的所有文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">scanFiles</span></span>(docRoot: <span class="type">String</span>) =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">File</span>(docRoot).list.map(docRoot + _)</span><br></pre></td></tr></table></figure><p>map方法用于带完整路径的list集合。这样，就不用担心子目录。要创建 worker actor，我们使用了numActors参数传递给StartCounting消息来创建多个actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createWorkers</span></span>(numActors: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numActors) <span class="keyword">yield</span></span><br><span class="line">    context.actorOf(<span class="type">Props</span>[<span class="type">WordCountWorker</span>], name = <span class="string">s&quot;worker-<span class="subst">$&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为worker actor是WordCountMaster的孩子，context.actorOf工厂方法被使用。</p><p>要实现排序，我们需要一个方法遍历所有文件名，并发送一个FileToCount消息给这些worker actor。因为要处理的文件的数量比worker actor的数量多，file以循环的方式发送给每个actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">beginSorting</span></span>(fileNames: <span class="type">Seq</span>[<span class="type">String</span>],</span><br><span class="line">                                workers: <span class="type">Seq</span>[<span class="type">ActorRef</span>]) &#123;</span><br><span class="line">  fileNames.zipWithIndex.foreach( e =&gt; &#123;</span><br><span class="line">    workers(e._2 % workers.size) ! <span class="type">FileToCount</span>(e._1)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法zipWithIndex对每个集合元素加索引配对，下面是一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).zipWithIndex</span></span><br><span class="line">res2: List[(java.lang.String, Int)] = List((a,0), (b,1), (c,2))</span><br></pre></td></tr></table></figure><p>当 WordCountMaster 接收到 StartCounting消息，将会创建worker actors并浏览文件，并将这些文件发送给每个worker。下面是 WordCountMaster 的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileNames  : <span class="type">Seq</span>[<span class="type">String</span>]        = <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">var</span> sortedCount: <span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StartCounting</span>(docRoot, numActors) =&gt;</span><br><span class="line">      <span class="keyword">val</span> workers = createWorkers(numActors)</span><br><span class="line">      fileNames = scanFiles(docRoot)</span><br><span class="line">      beginSorting(fileNames, workers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WordCount</span>(fileName, count) =&gt;</span><br><span class="line">      sortedCount = sortedCount :+(fileName, count</span><br><span class="line">      sortedCount = sortedCount.sortWith(_._2 &lt; _._2) </span><br><span class="line">      <span class="keyword">if</span> (sortedCount.size == fileNames.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;final result &quot;</span> + sortedCount)</span><br><span class="line">        finishSorting()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;Master actor is stopped: <span class="subst">$self</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createWorkers</span></span>(numActors: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numActors) <span class="keyword">yield</span> context.actorOf(<span class="type">Props</span>[<span class="type">WordCountWorker</span>], name = <span class="string">s&quot;worker-<span class="subst">$i</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">scanFiles</span></span>(docRoot: <span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">File</span>(docRoot).list.map(docRoot + _)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">beginSorting</span></span>(fileNames: <span class="type">Seq</span>[<span class="type">String</span>], workers: <span class="type">Seq</span>[<span class="type">ActorRef</span>]) &#123;</span><br><span class="line">    fileNames.zipWithIndex.foreach(e =&gt; &#123;</span><br><span class="line">      workers(e._2 % workers.size) ! <span class="type">FileToCount</span>(e._1)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">finishSorting</span></span>() &#123;</span><br><span class="line">    context.system.shutdown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段fileNames存储了所有我们需要处理的文件。我会最后将会使用这个字段来确保我们已经接收了所有的回复。sortedCount被用于存储结果。有一点要重要提醒的是，这里使用可变状态是安全的，因为actor系统会确保不会存在两个线程在同一时刻执行同一个actor的实例。但你需要确保 可变状态不会泄漏 在该actor系统的外部。</p><p>接下来，WordCountMaster需要处理来自WordCountWorker发送的WordCount消息。该消息包含了文件名和单词统计数。该信息被存储在sortedCount中，并被排序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">WordCount</span>(fileName, count) =&gt;</span><br><span class="line">  sortedCount ::= (fileName, count)</span><br><span class="line">  sortedCount = sortedCount.sortWith(_._2 &lt; _._2)</span><br></pre></td></tr></table></figure><p>最后一步是当所有文件被处理完后，终止操作。一种实现方式是，比较sortedCount的大小和文件个数，并在控制台上打印输出终止的actor信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sortedCount.size == fileNames.size) &#123;</span><br><span class="line">  println(<span class="string">&quot;final result &quot;</span> + sortedCount)</span><br><span class="line">  finishSorting()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用context.children来访问所有的worker actors并使用如下方式终止：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.children.foreach(context.stop(_))</span><br></pre></td></tr></table></figure><p>关闭一个actor系统的最简单方式是使用该actor系统的shutdown方法，我们可以通过context.system如下的方式来访问actor系统：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">finishSorting</span></span>() &#123;</span><br><span class="line">  context.system.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面列出 WordCountWorker 和 WordCountMaster 这两个actor的完整实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorRef</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"><span class="keyword">import</span> scala.io._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">fileName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>(<span class="params">fileName: <span class="type">String</span>, count: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCounting</span>(<span class="params">docRoot: <span class="type">String</span>, numActors: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span></span>(fileName: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">    <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileToCount</span>(fileName: <span class="type">String</span>) =&gt;               <span class="comment">// [7]. WordCountWorker 接收到FileToCount，开始countWords</span></span><br><span class="line">      <span class="keyword">val</span> count = countWords(fileName)</span><br><span class="line">      sender ! <span class="type">WordCount</span>(fileName, count)               <span class="comment">// [8]. sender 为 WordCountMaster</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;Worker actor is stopped: <span class="subst">$self</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileNames  : <span class="type">Seq</span>[<span class="type">String</span>]        = <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">var</span> sortedCount: <span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StartCounting</span>(docRoot, numActors) =&gt;           <span class="comment">// [1]. 主程序进入receive方法，匹配StartCounting</span></span><br><span class="line">      <span class="keyword">val</span> workers = createWorkers(numActors)            <span class="comment">// [2]. 根据参数创建worker actor个数</span></span><br><span class="line">      fileNames = scanFiles(docRoot)                    <span class="comment">// [3]. 列出目录下的所有文件名，存于Seq容器中</span></span><br><span class="line">      beginSorting(fileNames, workers)                  <span class="comment">// [4]. 排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WordCount</span>(fileName, count) =&gt;                  <span class="comment">// [9]. WordCount</span></span><br><span class="line">      sortedCount = sortedCount :+(fileName, count)</span><br><span class="line">      sortedCount = sortedCount.sortWith(_._2 &lt; _._2)   <span class="comment">// [10]. 对容器Seq[(String,Int)] 的 (String,Int)._2 排序</span></span><br><span class="line">      <span class="keyword">if</span> (sortedCount.size == fileNames.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;final result &quot;</span> + sortedCount)</span><br><span class="line">        finishSorting()                                 <span class="comment">// [11]. 结束上下文</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;Master actor is stopped: <span class="subst">$self</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createWorkers</span></span>(numActors: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numActors) <span class="keyword">yield</span> context.actorOf(<span class="type">Props</span>[<span class="type">WordCountWorker</span>], name = <span class="string">s&quot;worker-<span class="subst">$i</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">scanFiles</span></span>(docRoot: <span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">File</span>(docRoot).list.map(docRoot + _)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">beginSorting</span></span>(fileNames: <span class="type">Seq</span>[<span class="type">String</span>], workers: <span class="type">Seq</span>[<span class="type">ActorRef</span>]) &#123;</span><br><span class="line">    fileNames.zipWithIndex.foreach(e =&gt; &#123;               <span class="comment">// [5]. foreach 中 e._1 为 循环变量 ， e._2 为 index</span></span><br><span class="line">      workers(e._2 % workers.size) ! <span class="type">FileToCount</span>(e._1)  <span class="comment">// [6]. e._2 % workers.size平均分配任务，WordCountWorker开始receive</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">finishSorting</span></span>() &#123;</span><br><span class="line">    context.system.shutdown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WordCountWorker 和 WordCountMaster都被定义为actor。两者之间的交互发生于不可变的消息(immutable message)。当WordCountMaster接收到StartCounting消息，它便创建了给定数目的worker actor。一旦这个actor被启动，WordCountMaster发送FileToCount消息给所有worker actor。当worker actor完成了文件单词的统计后，它便想主actor发送WordCount消息。当sortedCount的大小和文件数目刚好相等，停掉所有的actor操作。</p><p>剩下来的内容就是Main方法还没有写。现在，不在创建一个新的actor，而是创建一个带Main方法的对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;word-count-system&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> m = system.actorOf(<span class="type">Props</span>[<span class="type">WordCountMaster</span>], name=<span class="string">&quot;master&quot;</span>)</span><br><span class="line">    m ! <span class="type">StartCounting</span>(<span class="string">&quot;src/main/resources/&quot;</span>, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本小节中，你学习了关于actor的许多有趣的内容。并学习了如何使用actor来设计你的应用。创建一个独立的不可变的消息(self-contained immutable message)，并终止actor之间的相互通讯，是actor操作的重要部分内容。对于理解“所有通信通过消息传递，并且只能由消息传递”同样重要。这引出了actors和OOP的相似之处。当 Alan Kay最先以OOP方式时，他的伟大想法是 “消息传递”。事实上，actor的操作有更多的面向对象。</p><p>假如发生错误会怎样？在并发/并行的编程世界里面许多事情都会出错。如果我们在读取文件时，出现IOException怎么办？下面让我们在基于actor的应用中，如何来处理这些错误。</p><h3><span id="933fault-tolerance-made-easy-with-a-supervisorp274">9<sub>3</sub>3〖Fault tolerance made easy with a supervisor〗P274</span></h3><p>akka鼓励非防御型的编程，也就是说，在应用声明周期中，即使是失败，也是一个有效的状态。作为一个编程人员，我们不能保留每个错误，所以，最好为你的应用准备errors。你可以通过akka提供的观察者层次结构(supervisor hierarchy)实现容错支持(fault-tolerance support)。</p><p>可以把这个观察者认为是一个actor，它链接了观察actors，以及当其中一个actor死亡后进行重启。一个观察者的职责是启动、终止、监控子actor。它和链接的机制相同。但akka提供了更好的抽象，叫做 <em>监管策略(supervision strategies)</em> 。</p><p>图 9.6展示了一个观察者层次结构的例子。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_6.png" alt="Figure 9.6"></p><p>你不会被限制于一个观察者。你可以有一个观察者链接到另外一个观察者。这样你可以观察另外一个观察者是否处于崩溃情况。很难用一个机箱来建立一个容错系统，因此我建议你在跨平台上有观察者层次的延伸。这样，如果一个节点(机器)坏了，你可以在不同的机箱中重启一个actor。谨记，，请委派工作，这样如果一个崩溃发生了，其它观察者可以恢复。现在让我们看看akka里面实现的容错策略。</p><p>SUPERVISION STRATEGIES IN AKKA</p><p>akka带来了两个重启策略：One-for-One 和 All-for-One。在One-for-One策略中。如果一个actor死亡，将重新创建。如果actor在系统中是独立的，这策略很棒。它不依赖其它正常工作的actor。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_7.png" alt="Figure 9.7"></p><p>如果在一个工作流中有多个actor参与，重启一个单独的actor可能会不起作用。这种情况下，使用 All-for-One 重启策略，即被观察者观察的一个actor死亡，则该观察者观察的所有actors都将被重启。</p><p><img src="/img/scala-in-action/chapter9/Figure_9_8.png" alt="Figure 9.8"></p><p>那么，这些在代码中怎样表示？在akka，默认地，每一个actor都有一个观察者，以及父actor为子actor的观察者。当没有观察者被定义，将使用默认策略(OneForOne)，即是在子actor有Exception失败时重启。下面例子配置了WordCounterWorker的OneForOneStrategy：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">SupervisorStrategy</span>._</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  . . .</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = <span class="type">OneForOneStrategy</span>(maxNrOfRetries = <span class="number">3</span>,</span><br><span class="line">        withinTimeRange = <span class="number">5</span> seconds) &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; <span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line">  . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你用你自己的故障处理方式，重载了actor的supervisorStrategy属性。例如，在java.lang.Exception情况，你的模式将会匹配，并直接让父actor丢弃旧的actor实例，并用一个新的actor实例代替。如果没有模式匹配，故障被升级为父actor。类似地，下面例子配置了WordCounterMaster使用AllForOneStrategy：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  . . .</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = <span class="type">AllForOneStrategy</span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;Restarting...&quot;</span>)</span><br><span class="line">      <span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line">  . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个带有观察者的单词统计的例子在本章的代码中。下一小节讨论在并发环境中可变数据的工作实现。</p><h3><span id="9~4composing-concurrent-programs-with-future-and-promisep276">9~4〖Composing concurrent programs with Future and Promise〗P276</span></h3><p>一个Future对象可以存放一个可用的值，顾名思义，Future就是之后的时间。它本质上扮演了一个真实值的代理，该值暂时不存在。通常该值由一些异步计算执行产生。创建一个 Future 最简单的方式就是使用apply方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">someFuture</span></span>[<span class="type">T</span>]: <span class="type">Future</span>[<span class="type">T</span>] = <span class="type">Future</span> &#123;</span><br><span class="line">  someComputation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 someFuture 存储计算结果，以及T表示结果的类型。因为Future是被异步执行，我们需要指定scala.concurrent.ExecutionContext.ExecutionContext是一个抽象于线程池的，所有执行的任务被提交到该线程池。这里的任务，由Future计算处理。有许多方式来配置并创建ExecutionContext，但本章我们将使用默认的、全局的scala库提供的执行上下文：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br></pre></td></tr></table></figure><p>当Future有值，它被认为是完整的。它也可以用一个exception表示。要在Future被完成后处理操作，我们可以使用onComplete回调函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someFuture.onComplete &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt; println(result)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; t.printStackTrace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Future可以是一个成功或失败状态，onComplete允许你同时处理这两种情况。(查阅 scala.concurrent.Future scaladoc 有关内容)</p><p>Future 也可以通过 Promise 创建。可以把 Promise 认为是一个可写的、单任务的容器。你可以用 Promise 来创建一个 Future，当 Promise 被一个值填充，Future被完成：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> promise: <span class="type">Promise</span>[<span class="type">String</span>] = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">val</span> future = promise.future</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> anotherFuture = <span class="type">Future</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  promise.success(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">  doSomethingElse()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">future.onSuccess &#123; <span class="keyword">case</span> msg =&gt; startTheNextStep() &#125;</span><br></pre></td></tr></table></figure><p>这里我们创建了两个Future，一个使用Future的方法，另一个由Promise创建。anotherFuture 完成 promise 由调用 success 方法实现(也可以使用 failure 方法完成 promise)。一旦 promise 被完成，你不能再调用 success。否则，将抛出一个异常。promise 会自动完成 future，以及 onSuccess 回调方法被自动调用。请注意，Future注册的回调方法，在 future 完成后仅被执行一次。Scala的 Future 和 Promise API有许多非常有用的方法，请检查scala文档了解更多内容。</p><p>现在你可能想知道什么时候使用 Future 什么时候使用 actor。一个通常使用 Future的情况是，处理一些并发计算，但又不需要actor做额外的效用。Scala Future库最引人注目的特性是，它允许我们组合并发操作，这在actor中很难实现。让我们使用Future 和 Promise实现单词计数问题。</p><h3><span id="941divide-and-conquer-with-futurep278">9<sub>4</sub>1〖Divide and conquer with Future〗P278</span></h3><p>现在使用Future重新实现单词计数问题。现在我们将单词计数问题分割成几个步骤，以便独立解决每个问题。因为Future允许函数式的组合，我们应该组合这些步骤来解决我们的问题。我们将该问题分成4步：</p><ol><li>在给定的目录中，浏览所有文件</li><li>对给定的一个文件进行单词统计</li><li>累加和排序结果</li><li>生成结果</li></ol><p>我们已经知道如何浏览给定目录中的文件，但这次希望异步处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">scanFiles</span></span>(docRoot: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = <span class="type">Future</span> &#123; </span><br><span class="line">  <span class="keyword">new</span> <span class="type">File</span>(docRoot).list.map(docRoot + _) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，在Future内部对给定的文件进行单词计数。如果出现问题，我们使用 recover 方法注册回调：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processFile</span></span>(fileName: <span class="type">String</span>): <span class="type">Future</span>[(<span class="type">String</span>, <span class="type">Int</span>)] =</span><br><span class="line">  <span class="type">Future</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">    <span class="keyword">val</span> wordCount = <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">    (fileName, wordCount)</span><br><span class="line">  &#125; recover &#123;</span><br><span class="line">    <span class="keyword">case</span> e: java.io.<span class="type">IOException</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;Something went wrong &quot;</span> + e)</span><br><span class="line">      (fileName, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当在Future内部出现 IOException异常时，recover回调被执行。因为每个文件在Future内部被处理，我们最终会得到一个 futures 集合：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futures: <span class="type">Seq</span>[<span class="type">Future</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = fileNames.map(name =&gt; processFile(name))</span><br></pre></td></tr></table></figure><p>问题来了。我们怎么知道所有的Future会完成？我们不可能为每个future注册回调，因为每个都是独立的、并且完成时间也不相同。如其是<code>Seq[Future[(String, Int)]]</code>，我们更希望得到的是<code>Future[Seq[(String, Int)]]</code>，这样我们就可以对结果进行累加和排序。这实际上就是Future.sequence被设计的原因。它接收一个futures集合，并得到一个Future：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> singleFuture: <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = <span class="type">Future</span>.sequence(futures)</span><br></pre></td></tr></table></figure><p>你可以调用map方法，并进行排序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processFile</span></span>(fileName: <span class="type">String</span>): <span class="type">Future</span>[(<span class="type">String</span>, <span class="type">Int</span>)] =</span><br><span class="line">  <span class="type">Future</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">    <span class="keyword">val</span> wordCount = <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">    (fileName, wordCount)</span><br><span class="line">  &#125; recover &#123;</span><br><span class="line">    <span class="comment">// recover 注册回调，用于失败处理</span></span><br><span class="line">    <span class="keyword">case</span> e: java.io.<span class="type">IOException</span> =&gt;</span><br><span class="line">      println(<span class="string">&quot;Something went wrong &quot;</span> + e)</span><br><span class="line">      (fileName, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果你没有猜到，Future是一个monad例子。它实现了map、flatMap以及filter操作，以及必要的函数式组件。现在你可以组合 scanFiles 和 processFiles 产生排序结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path                 = <span class="string">&quot;src/main/resources/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> futureWithResult: <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = <span class="keyword">for</span> &#123;</span><br><span class="line">  files &lt;- scanFiles(path)</span><br><span class="line">  result &lt;- processFiles(files)</span><br><span class="line">&#125; <span class="keyword">yield</span> &#123;</span><br><span class="line">  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的 for-comprehensions 组合了scanFiles 和 processFiles，并产生另外一个future。注意这里每个操作的处理都是异步的，我们以一种非阻塞的方式组合这些 futures。这里的 for-comprehensions 创建了另外一个future仅在scanFiles 和 processFiles 同时完成时创建。它在两个操作之间也扮演了管道的角色，即当scanFiles的所有输出发送给processFiles时。</p><p>最后一步，我们可以用一个Promise实现，当futureWithResult完成时。下面是使用Future实现单词统计例子的完整代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent._</span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">import</span> scala.util.&#123;<span class="type">Failure</span>, <span class="type">Success</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> promiseOfFinalResult = <span class="type">Promise</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]()</span><br><span class="line">  <span class="keyword">val</span> path                 = <span class="string">&quot;src/main/resources/&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> futureWithResult: <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = <span class="keyword">for</span> &#123;</span><br><span class="line">    files &lt;- scanFiles(path)</span><br><span class="line">    result &lt;- processFiles(files)</span><br><span class="line">  &#125; <span class="keyword">yield</span> &#123;</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  futureWithResult.onSuccess &#123; <span class="keyword">case</span> r =&gt; promiseOfFinalResult.success(r) &#125;</span><br><span class="line"></span><br><span class="line">  promiseOfFinalResult.future.onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt; result foreach (a =&gt; println(a._1.substring(<span class="number">1</span> + a._1.lastIndexOf(&#x27;/&#x27;), a._1.length) + <span class="string">&quot;  -&gt;  &quot;</span> + a._2))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; t.printStackTrace()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processFiles</span></span>(fileNames: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> futures: <span class="type">Seq</span>[<span class="type">Future</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = fileNames.map(name =&gt; processFile(name))</span><br><span class="line">    <span class="keyword">val</span> singleFuture: <span class="type">Future</span>[<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = <span class="type">Future</span>.sequence(futures)</span><br><span class="line">    singleFuture.map(r =&gt; r.sortWith(_._2 &lt; _._2))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processFile</span></span>(fileName: <span class="type">String</span>): <span class="type">Future</span>[(<span class="type">String</span>, <span class="type">Int</span>)] =</span><br><span class="line">    <span class="type">Future</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> dataFile = <span class="keyword">new</span> <span class="type">File</span>(fileName)</span><br><span class="line">      <span class="keyword">val</span> wordCount = <span class="type">Source</span>.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">      (fileName, wordCount)</span><br><span class="line">    &#125; recover &#123;</span><br><span class="line">      <span class="keyword">case</span> e: java.io.<span class="type">IOException</span> =&gt;</span><br><span class="line">        println(<span class="string">&quot;Something went wrong &quot;</span> + e)</span><br><span class="line">        (fileName, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">scanFiles</span></span>(docRoot: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = <span class="type">Future</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">File</span>(docRoot).list.map(docRoot + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到非常容易地开始使用Future，以及它非常强大，因为它允许你做函数式的组合。另一方面，actor允许你构造你的应用，并提供了一个故障处理策略。你不必要在它们两者之间选择。你可以把你的应用分割为actor，然后这些actor可以使用Future的构建块来处理异步操作。下一小节，我们将看看如何在actor内部使用Future。</p><h3><span id="942mixing-future-with-actorsp280">9<sub>4</sub>2〖Mixing Future with actors〗P280</span></h3><p>在使用Akka actor工作有两种普遍的模式调用：</p><ol><li>给一个actor发送消息，并从这个actor接收消息。我们使用了一个“即发即弃(fire-and-forget)” 方法 !。同样，获得一个响应也是一个常用的情况。(a.k.a ask pattern)</li><li>并发任务(Future)完成(a.k.a pipe pattern)，给发送方回复。</li></ol><p>让我们以一个例子来证明这两个模式。下面代码片段，我们有两个actor，一个父actor和子actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">5.</span>seconds) </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> messageActor = context.actorOf(<span class="type">Props</span>[<span class="type">GreetingsChildActor</span>])</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> name =&gt; </span><br><span class="line">      <span class="keyword">val</span> f: <span class="type">Future</span>[<span class="type">String</span>] = (messageActor ask name).mapTo[<span class="type">String</span>]</span><br><span class="line">      f pipeTo sender </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingsChildActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GreetingsActor接收 name 然后发送消息给子actor生成一个消息。在这里我们使用ActorRef的ask方法(你也可以使用 ? 表示)发送和接收消息。因为消息是异步处理的，ask方法会返回一个Future。mapTo 消息允许用户将消息从<code>Future[Any]</code>转换为<code>Future[String]</code>。问题是我们不知道消息什么时候准备好，以让我们回复给发送者。pipeTo 解决了这个问题，通过连结Future，只要当Future完成，便接收future内部的响应内容并向发送者发送消息。要看完整代码，请查阅本章基础代码内容。</p><h3><span id="9~5when-should-you-not-use-actorsp281">9~5〖When should you not use actors?〗P281</span></h3><p>本章着重讲述了actor在构建面向消息并发的应用中的构建。我们也讨论了可变数据是引起大多数并发问题之根本，以及actor如何消除使用这些非共享的构建。但我们如何在多个组件间进行状态共享？</p><ul><li><p>Shared State —— 一个典型例子，你想要将纸币进行转换，你想要在不同的应用之间有一致的观念。你需要更多的不仅是actor，你需要事务支持。如STM(软件事务内存)是解决这类问题的一个很好的选择，或者你需要在消息传递间构建事务。(第12章会看到相关例子)</p></li><li><p>Cost Of asynchronous programming —— 对于大多数编程开发者，要习惯异步编程，是一个思考模式的转变。它花费时间和精力来熟悉你未曾用过的。调试和测试大型的面向消息的应用是困难的。同时，异步消息的传递，使得它难于跟踪和隔离一个问题。这还不是别的，特别是使用actor model，更多的是继承了基于消息应用的复杂性。之后的 Akka TestKit 和 Typesafe console将帮助迁移这些测试和调试问题。</p></li><li><p>Performance —— 如果你的应用需要很高的性能处理，因为actors可能会增加开销，你可能最好需要用一个更底层的抽象，如线程。但相反，99.9%的应用，我认为actors的性能已经足够。</p></li></ul><h3><span id="9~6summaryp281">9~6〖Summary〗P281</span></h3><p>本章你学习了一个新的并发编程趁势，以及状态共享的并发问题处理。它清晰地指出，如果你建立更高的抽象层次，你就更容易构建并发应用程序。本章关注消息间传递的并发性，以及如何使用actor来实现。</p><p>我们也学习了关于Future 和 Promise 方面的内容，以及如何使用函数式的组件由组合小的并发操作 构建 大型的程序。构建容错性的应用的最大挑战在于，如何高效地处理错误并修复它们。通过学习观察者策略，解决了这些基于actor应用 的错误。这使得构建一个长期运行的应用能够自动化地从错误和异常中修复。</p><p>下一章将开始关注于Scala 应用的单元测试，以及探索如何通过各种各样的有用的工具来帮助编写Scala单元测试。这部分对应你来说不难。它还将介绍如何编写actor的单元测试。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Java thread states (download), <a href="http://mng.bz/w1VH">http://mng.bz/w1VH</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Herb Sutter, “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software,” December 2004, CPU trends graph updated August 2009, <a href="www.gotw.ca/publications/concurrency-ddj.htm">www.gotw.ca/publications/concurrency-ddj.htm</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Multicore CPU trend (graphic), <a href="www.gotw.ca/images/CPU.png">www.gotw.ca/images/CPU.png</a>.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">See “The Scala Actors Migration Guide,” <a href="http://docs.scala-lang.org/overviews/core/actors-migrationguide.html">http://docs.scala-lang.org/overviews/core/actors-migrationguide.html</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">See “Actor References, Paths, and Addresses,” version 2.1.0, <a href="http://doc.akka.io/docs/akka/2.1.0/general/addressing.html">http://doc.akka.io/docs/akka/2.1.0/general/addressing.html</a>.</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">Brian Goetz, “Java theory and practice: Stick a fork in it, Part 1,” developerWorks, Nov. 13, 2007, <a href="http://mng.bz/aNZn">http://mng.bz/aNZn</a>.</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">Alan Curtis Kay, <a href="http://en.wikipedia.org/wiki/Alan_Kay">http://en.wikipedia.org/wiki/Alan_Kay</a>.</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">Alan Kay, “Prototypes vs. classes was: Re: Sun’s HotSpot,” Oct 10, 1998, <a href="http://mng.bz/L12u">http://mng.bz/L12u</a>.</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">“Testing Actor Systems (Scala), TestKit Example,” <a href="http://doc.akka.io/docs/akka/2.1.0/scala/testing.html">http://doc.akka.io/docs/akka/2.1.0/scala/testing.html</a>.</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;">“Typesafe Console,” <a href="http://typesafe.com/products/console">http://typesafe.com/products/console</a>.</span><a href="#fnref:10" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章：构建可伸缩的、可扩展的组件</title>
      <link href="/2016/10/27/scala/08-scala-components/"/>
      <url>/2016/10/27/scala/08-scala-components/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>构建组件。</li><li>丰富的类型系统。</li><li>即时-多态(Ad hoc polymorphism)。</li><li>解决表述问题。</li></ol><p>我们有一段时间没有把专注力放在Scala的类型系统(type system)上。The type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.(类型系统是一个易于处理的语法方法，它通过计算得出的分类词汇，为该方法提供正确的缺省的编程处理)。</p><p>本章学习类型系统的要点是 理解其背后理论。这对学习类型系统基础很有帮助，本章不会过多在练习上关于理论内容。这里，将探索Scala提供给我们的各种各样的类型，并带有例子让我们更好理解。为什么类型系统如此重要？它提供了一下几点特性：</p><ul><li>Error detection：就像编译器编译单元测试，可以探测普通类型和其它编程错误。</li><li>Abstractions：本章重点。你将学习类型系统是如何提供抽象给构建组件。</li><li>Documentation：函数或方法签名，告诉你它是做什么的。</li><li>Efficiency：类型系统帮助编译器生成优化的二进制码。</li></ul><p>本章的主要目的是告诉你，Scala类型系统是如何构建重用组件的。这里的 <strong>组件(component)</strong> 是一个 涵盖性术语(umbrella term)，如重用的库、类、模组、框架、web service。</p><p>构建重用的组件并不简单。通过可装配组件(assembling components)来构建软件的目标仍然是梦一般的存在，甚至不能扩展成为我们想要的。构建可重用组件的挑战是，还要它所引用的上下文环境。典型地，修改组件以适应当前的需求，最终带来的是一个组件的多个版本。这导致了维护上的问题。在本章的第一小节，你会学习使用Scala类型系统来构建简单的、可重用的组件。</p><span id="more"></span><p>接下来你将学习Scala给我们提供的不同类型的Scala类型，以使得你的代码更有表现力和可重用。</p><p>你也将学习一个新的 polymorphism类型，多态(polymorphism)使用类型类(type classes)，允许你创建的抽象更容易扩展和缩放(scale)——一个强大的构造器来解决你日复一日的编程问题。</p><p>我们要清楚一个好的类型系统，并不仅仅为你服务，这点很重要。甚至，它可以提供足够的灵活性，以实现尽可能的创造性。带着你的咖啡坐下了，不用担心路途的颠簸。我相信，学完这章内容，将会有更大的收获。</p><h3><span id="8~1building-your-first-component-in-scalap225">8~1〖Building your first component in Scala〗P225</span></h3><p>如我所说，构建一个可伸缩的、可重用的组件是困难的。可伸缩的(scalable)意指小的或大的组件——特别是当你尝试使用一个类型安全的、面向对象的语言来构建时。Table 8.1展示了由Scala提供的三种抽象技术。</p><p>曾在第三章介绍过混入组件(mixin)。Scala特质允许你构建小的组件，并将它们组合成为大的组件。在开始构建组件之前，让我们探索一下抽象类型成员和自类型(self type)，因为它们是重要的构建模块。</p><table><thead><tr><th style="text-align:left">Technique</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>Modular mixin composition</code></td><td style="text-align:left">Scala特性中提供了一个机制——组合特质在设计可重用组件时不会带来继承上的问题。你按照约定使用它，并可以继承多个，或者你可以使用具体的方法来实现。</td></tr><tr><td style="text-align:left"><code>Abstract type members</code></td><td style="text-align:left">Scala中可以为类、特质、子类声明抽象类型成员， 类似于抽象方法和字段。</td></tr><tr><td style="text-align:left"><code>Self type</code></td><td style="text-align:left">混入类(mixin)不依赖于它所混入的类的任何方法或字段。但有时它所混入类的字段或方法是非常有用的。这种特性在Scala中被称之为 自类型(self type)。</td></tr></tbody></table><h3><span id="811abstract-type-membersp226">8<sub>1</sub>1〖Abstract type members〗P226</span></h3><p>Scala将抽象的思想超越了方法和字段的层面。你也可以在一个类或特质内声明一个抽象类型成员。抽象类型，就是在声明的时候，类型还不确切、不知道的。和具体的类型不同，抽象类型成员由具体的封闭类指定。下面例子在中，在特质Calculator内部声明了一个抽象类型成员：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">S</span> &#125;</span></span><br></pre></td></tr></table></figure><p>任何具体的类混入这个特质，都必须为 S type member 提供一个类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">String</span> &#125;</span><br></pre></td></tr></table></figure><p>抽象类型成员的好处是，它可以隐藏一个组件的内部信息。我会用一个例子来证明这个事实。假设你准备构建一个价格计算器，它接收一个产品ID，返回该ID的价钱。有很多种方式计算这个价钱，以及每种方式可以使用不同的数据资源类型来接收这个价格。你可以为零售公司出售的各种产品构建各种各样的类型，这些产品分别来自于不同的制造商(manufacturers)。常规的计算步骤如下：</p><ul><li>连接数据源(有多种类型)</li><li>使用该数据源计算价钱</li><li>关闭所连接的数据源</li></ul><p>编码这些步骤和架构，一个相当成功的做法是模版方法模式(Template Method pattern)，即根据多个子类实现一个通用算法。下面是父类Calculator特质使用模版方法模式的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>: <span class="type">DbConnection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(s: <span class="type">DbConnection</span>): <span class="type">Unit</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s = initialize</span><br><span class="line">    <span class="keyword">val</span> price = calculate(s, productId)</span><br><span class="line">    close(s)</span><br><span class="line">    price</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(s: <span class="type">DbConnection</span>, productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，DbConnection是一个用于从数据库接收数据的组件。因为所有需要的步骤都已经实现，每个计算器可以重载 <code>calculate(s: DAO, productId: String)</code> 方法。当前实现的问题是DAO是硬连接的，使用不同类型的数据库会导致该计算不可用。</p><p>你可以修改DbConnection的硬连接问题，通过创建一个抽象类型成员，并隐藏组件从数据库接收的类型。下面为带有抽象类型成员的Calculator特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractMember &#123;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">S</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>: <span class="type">S</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(s: <span class="type">S</span>): <span class="type">Unit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> s = initialize</span><br><span class="line">      <span class="keyword">val</span> price = calculate(s, productId)</span><br><span class="line">      close(s)</span><br><span class="line">      price</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(s: <span class="type">S</span>, productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator特质将数据库的连接作为类型抽象出来，方法<code>initialize</code>用于连接数据库，<code>close</code>方法用于关闭数据库。现在没有任何具体的计算实现，要实现所有抽象方法，需要为类型S提供类型信息。下面是使用MongoDB作为数据库的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">MongoClient</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(dao: <span class="type">MongoClient</span>) = dao.close</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(source: <span class="type">MongoClient</span>, productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类型成员的概念对于模拟类型家族多样性特别有帮助，下一小节介绍自类型，它可以帮助构建更小的组件。</p><h3><span id="812self-type-membersp228">8<sub>1</sub>2〖Self type members〗P228</span></h3><p>自类型注解允许你访问一个特质或类的成员，Scala编译器会确保在实例化这些类时，所有依赖已经被正确装载。自类型使得混入组件更加强大，因为它允许你通过其它类或特质静态地定义依赖。在下面例子，特质A定义了特质B的一个依赖：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b</span></span>():<span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  self: <span class="type">B</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">a</span></span>():<span class="type">Unit</span> = b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质<code>A</code>不能被混入到其它不是继承自<code>B</code>的具体类中。由于类型安全，你可以在<code>A</code>中访问<code>B</code>的成员，如上述代码。注意<code>self</code>是一个名称，它可以是任何有效的参数名。自类型注解常见名称有<code>this</code>、<code>self</code>。</p><p>这里使用一个例子来证明自类型(self type)如何在真实应用中工作。这个例子中，你构建一个产品搜索，它依赖于两个必须服务：一个数据库访问和一个日志记录。因为特质可以让你更容易地组合特性，可以把这两个必要服务分离成特质。下面是服务特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span></span>: <span class="type">Connection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>: <span class="type">Logger</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequiredServices特质声明了可能会被product finder用到的所有服务：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProductFinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">RequiredServices</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">findProduct</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> c = makeDatabaseConnection</span><br><span class="line">    c.query(productId)</span><br><span class="line">    log.info(<span class="string">&quot;querying database...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为RequiredServices用自类型注解this，你仍然可以访问这些服务，Scala编译器会确保最终混入的类中是否实现了RequiredServices。下面列出其实现复杂代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span></span>: <span class="type">Connection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>: <span class="type">Logger</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestServices</span> <span class="keyword">extends</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span> </span>= <span class="keyword">new</span> <span class="type">Connection</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>) = <span class="string">&quot;test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span> </span>= <span class="keyword">new</span> <span class="type">Logger</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>) = logger info l</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProductFinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">RequiredServices</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">findProduct</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> c = makeDatabaseConnection</span><br><span class="line">    c.query(productId)</span><br><span class="line">    log.info(<span class="string">&quot;querying database...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终对象需要组合所有的trait</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FinderSystem</span> <span class="keyword">extends</span> <span class="title">ProductFinder</span> <span class="keyword">with</span> <span class="title">TestServices</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">FinderSystem</span>.findProduct(<span class="string">&quot;1L&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个例子展示了如何通过使用自类型注解和混入组合来构建一个大型的组件。我们会在第十章单元测试部分在再一次介绍自类型。现在，我们进入到构建我们的第一个可重用组件——一个通用订单系统。</p><h3><span id="813building-a-scalable-componentp229">8<sub>1</sub>3〖Building a scalable component〗P229</span></h3><p>让我们构建一个通用产品订单系统，来看看如何构建一个可重用的组件。它将在任何类型的产品中重用。一个通用的订单系统将构建下面这些组件：</p><p><img src="/img/scala-in-action/chapter8/Figure_8_1.png" alt="Figure 8.1"></p><ul><li>一个订单组件，表示客户提供的。</li><li>一个产品库存清单组件，用于检查库存是否有产品，以提供订单。</li><li>一个航运组件，表示如何向客户运送的清单。</li></ul><p>真实世界里面的订单系统比这更加复杂，但这里附上简单的系统，因为你可以很容易将它扩展成一个大的环境。</p><p>你可以使用抽象类型成员来抽象出这些组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderingSystem声明了三个抽象成员——<code>O</code>，<code>I</code>，和<code>S</code>——同时为每个类型设置了上边界。类型<code>O</code>表示Order类型的子类型。类似地，<code>I</code>和<code>S</code>分别是Inventory和Shipping的子类型。以及为Order，Inventory，and Shipping的每个组件定义构造器：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Order</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span> </span>(i: <span class="type">I</span>):<span class="type">Unit</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Inventory</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">O</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Shipping</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">O</span>): <span class="type">Long</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些组件嵌入在特质(trait)下的好处是，它们都是聚合的并封装在同一个地方。现在你为每个组件提供了接口，但需要为其提供实现步骤，如下：</p><ul><li>检查订单条目是否存在于库存。</li><li>对库存订货。</li><li>安排订单发货。</li><li>如果条目不存在库存中，发货没有对上订货，尽快通知库存补充上产品。</li></ul><p>让我们在OrderingSystem内实现这些步骤的一个部分Ordering：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span> </span>&#123;<span class="keyword">this</span>: <span class="type">I</span> <span class="keyword">with</span> <span class="type">S</span> =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">O</span>): <span class="type">Option</span>[<span class="type">Long</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span>(itemExists(o)) &#123;</span><br><span class="line">      o.placeOrder (<span class="keyword">this</span>)</span><br><span class="line">      <span class="type">Some</span>(scheduleShipping(o))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了自类型注解的帮助，方法placeOrder实现了所有的步骤。订单现在依赖于库存方法<code>itemExists</code>和航运方法<code>scheduleShipping</code>。注意，你可以用<code>with</code>关键字指明多个自类型注解，这个特质的混入(mix in)类似。所有这些代码块合在一起组成了一个订单系统组件。下列为完整的代码清单：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>: <span class="type">I</span> <span class="keyword">with</span> <span class="type">S</span> =&gt;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">O</span>): <span class="type">Option</span>[<span class="type">Long</span>] = &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemExists(o)) &#123;</span><br><span class="line">        o.placeOrder(<span class="keyword">this</span>)</span><br><span class="line">        <span class="type">Some</span>(scheduleShipping(o))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Order</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(i: <span class="type">I</span>): <span class="type">Unit</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Inventory</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">O</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Shipping</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">O</span>): <span class="type">Long</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类型成员OrderingSystem表示需求业务，它可以在不同的上下文中重用。混入的特性使得可以通过组合Inventory和Shipping来构建特质。最后，自类型使得Ordering可以使用混入提供了的方法。如果你想要实现的具体的订单系统，你可以继承OrderingSystem实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BookOrderingSystem</span> <span class="keyword">extends</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">O</span> </span>= <span class="type">BookOrder</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">UPS</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">I</span> </span>= <span class="type">AmazonBookStore</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BookOrder</span> <span class="keyword">extends</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(i: <span class="type">AmazonBookStore</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">AmazonBookStore</span> <span class="keyword">extends</span> <span class="title">Inventory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">BookOrder</span>): <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">UPS</span> <span class="keyword">extends</span> <span class="title">Shipping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">BookOrder</span>): <span class="type">Long</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">BookOrdering</span> <span class="keyword">extends</span> <span class="title">Ordering</span> <span class="keyword">with</span> <span class="title">AmazonBookStore</span> <span class="keyword">with</span> <span class="title">UPS</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookOrderingSystem为BookOrdering提供了一个具体的实现。现在你通过导入进行使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">BookOrderingSystem</span>._</span><br><span class="line"><span class="keyword">val</span> place = <span class="type">BookOrdering</span>.placeOrder(<span class="keyword">new</span> <span class="type">BookOrder</span>)</span><br><span class="line">logger info <span class="string">f&quot;<span class="subst">$place</span>&quot;</span></span><br></pre></td></tr></table></figure><p>下一小节将为你展示如何使用你所学习的概念来解决表述问题。</p><h3><span id="814building-an-extensible-componentp232">8<sub>1</sub>4〖Building an extensible component〗P232</span></h3><p>软件工程的根本挑战是，在不改变已存在的代码的前提下，扩展一个软件组件，并把它集成到一个已存在的系统中。许多人用 表述问题(expression problem)来证明在一个软件组件的可扩展性下， 面向对象继承的失败。表述问题指的是，在不用编译和维护静态的类型安全前提下，使用case来定义数据类型，并可以为case添加一个新的类型，以及操作这个类型。通常它用来证明编程语言的优势和劣势。接下来，将为你展示Scala如何解决这个表述问题。但是接下来先看看表述问题具体是什么：</p><p><strong>THE EXPRESSION PROBLEM AND THE EXTENSIBILITY CHALLENGE</strong></p><p>目标是在该数据类型上定义一个数据类型和操作，它可以添加一个新的数据类型和操作，而不用编译已存在的代码，但仍然保留静态类型安全。<br>任何实现表述问题的，都应该满足一下这些要求：</p><ul><li>两个维度的可扩展性。你可以所有类型添加新的类型和操作。</li><li>强大的静态类型安全。类型转换和反射是不可能的。</li><li>不修改已存在的代码， 不能存在重复的代码。</li><li>单独编译。</li></ul><p>让我们用一个练习例子来探索该问题。你有一个为全职员工处理薪资的工资系统：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Payroll特质声明了processEmployees方法用于接收一个employee集合，并处理它们的薪资。它的返回值是Either，因为它可能是成功或失败。USPayroll和CanadaPayroll都实现了processEmployees方法，用于处理不同地区的薪资。</p><p>在当前业务处理中，你也需要为日本地区的全职工作者处理薪资。那很简单——再添加一个Payroll的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们需要讨论的表述问题(expression problem)。解决方案是类型安全，你可以将JapanPayroll单独编译，作为扩展或插件添加到已有的payroll系统中。</p><p>如果添加一个新的操作，会发生什么？在这种情况下,业务已经决定雇佣承包商了，你还要处理他们每月的薪资。新的Payroll接口看起来像：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是你不能从头修改Payroll，它会强制你修改更多的东西，你受到表述问题的约束。这段练习的问题是：如何在已存在的系统中增量地添加新特性，而不用做任何修改。为了理解处理表述问题有多难，让我们尝试另外一种方式：使用访问者模式来处理该问题。你会有一个处理雇员薪资的访问者：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(v: <span class="type">PayrollVisitor</span>) = v.visit(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(v: <span class="type">PayrollVisitor</span>) = v.visit(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeePayrollVisitor</span> <span class="keyword">extends</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型USPayroll和CanadaPayroll都接收一个payroll观察者。为了处理雇员的薪资，使用接口EmployeePayrollVisitor。为了处理承包商(contractors)每月的支出，你可以创建一个新的类ContractorPayrollVisitor，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContractorPayrollVisitor</span> <span class="keyword">extends</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用访问者模式，可以容易地添加一个新的操作，但怎么添加一个新的类型？如果你尝试添加一个新的类型JapanPayroll，这就有问题了。你需要重新修改访问者(visitor)，以允许它接收JapanPayroll类型。第一种方法中容易添加类型、第二种方法容易添加操作。那么有没有方法可以让我们改变这两个层面。下面将介绍使用Scala的抽象类型成员和特质混入来解决这个问题。</p><p><strong>SOLVING THE EXPRESSION PROBLEM</strong></p><p>你将使用Scala特质以及抽象类型成员(abstract type members)来解决表述问题(expression problem)。还是以payroll系统为例，我将展示如何轻松地添加新的操作到payroll系统中，同时添加一个新的类型，而不会打破类型安全。</p><p>首先，为payroll系统使用抽象类型成员来定义它的基础系统原型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">P</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">P</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再一次把所有东西嵌套进trait中，这样我们可以把它当作一个模组。类型<code>P</code>表示特质Payroll的子类型，它声明了一个抽象方法用于处理雇员的工资。方法processPayroll需要实例化，以处理一个给定的Payroll类型。下面是U.S.和Canada的payroll实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略了工资处理的具体操作，因为这不是重点。为了处理U.S.地区雇员的薪资，你可以实例化USPayrollSystem，并实现里面的processPayroll方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">USPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> employees: <span class="type">Vector</span>[<span class="type">Employee</span>] = <span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;emp1&quot;</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> result = p.processEmployees(employees)</span><br><span class="line">    <span class="type">Left</span>(<span class="string">&quot;Process successful&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里设置中，可以容易地为Payroll添加新的类型，创建一个特质继承自PayrollSystem：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在向Payroll添加一个新的特质，而不用编译所有的东西，使用Scala的影子特性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">p</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在ContractorPayrollSystem内的Payroll并没有重构来自于PayrollSystem里面的定义的Payroll，它作为影子替代。前者定义的Payroll在ContractPayrollSystem上下文环境中使用了super关键字，使其可访问。影子效应在代码中会产生不可预料的错误，但这里却扩展了原来的Payroll，而不用重构它。</p><p>另外一个需要注意的事情是，你重新定义了抽象类型成员<code>P</code>。<code>P</code>需要被Payroll的子类型识别，包括processEmployees和processContractors方法。为了处理U.S.和Canada的承包商(contractors)，继承ContractPayrollSystem特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">USPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">CanadaPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>影子定义了USPayroll和CanadaPayroll。同时混入了Payroll特质以实现processContractors方法。类型安全要求：如果你不混入Payroll，当你为USContractorPayrollSystem或CanadaContractorPayrollSystem实现具体类时，会发生一个错误。类似地，你可以添加processContractors操作到JapanPayrollSystem中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">JapanPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，你已经成功地解决了表述问题(expression problem)。下面列出完整的代码实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">P</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">P</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">USPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> employees: <span class="type">Vector</span>[<span class="type">Employee</span>] = <span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;emp1&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    p.processEmployees(employees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">p</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">USPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">CanadaPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">JapanPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JapanContractorPayrollInstance</span> <span class="keyword">extends</span> <span class="title">JapanContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">JapanPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">JapanContractorPayrollInstance</span>.<span class="type">JapanPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    p.processContractors(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;con1&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Scala的第一类对象模块支持，你可以转换一个对象内的所有特质和类，并扩展一个存在的软件组件，而不用强制重新编译所有东西，以及维护类型安全。注意新的和旧的Payroll接口都是可用的，实际使用了哪个取决于你传递了那个特质组件。要使用新的Payroll，你可处理employees和contractors，你必须混入ContractorPayrollSystem特质。下面例子阐述如何创建一个USContractorPayrollSystem，以及如何使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RunNewPayroll</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">USNewPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USContractorPayrollSystem</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">p</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USNewPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">      p.processEmployees(<span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>)))</span><br><span class="line">      p.processContractors(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">      <span class="type">Left</span>(<span class="string">&quot;payroll processed successful&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法processPayroll同时调用了Payroll特质的processEmployees和processContractors方法，这个仍然保留了USPayrollSystem的实现，你仍然可以继承它并使用里面的processPayroll方法。</p><p>这个例子足够证明了Scala类型系统的强大，抽象可用地构建可伸缩的、可扩展的组件。我们使用了Scala面向对象的抽象解决了该问题。在8.3小节，我将介绍用函数式编程的方式来解决该问题。但接下来我们继续讨论Scala另一个强大的类型抽象。</p><h3><span id="8~2types-of-types-in-scalap238">8~2〖Types of types in Scala〗P238</span></h3><p>Scala独有的一个特性是它的丰富的类型系统。和其它优秀类型系统一样，它提供了必要的抽象来构建可重用组件。本小节一起探讨Scala类型系统提供的丰富类型。</p><h3><span id="821structural-typesp238">8<sub>2</sub>1〖Structural types〗P238</span></h3><p>在Scala中，结构类型(structural type)是一种通过自身结构描述类型的一种方式，不通过自身名称，就如其它类型一样。如果你学习过动态类型语言，一个结构类型(structural type)会让你感觉像是一个类型安全的 鸭子类型(duck typing，动态类型的一种)。假设你想要关闭任何想要关闭的资源。实现方式是定义一个特质并声明一个close方法，并让所有资源实现类继承该特质。但使用一个结构类型，你可以容易地通过指定它的结构来定义一个新的类型，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(closable: &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;): <span class="type">Unit</span> = &#123;</span><br><span class="line">  closable.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里参数的类型由 <code>&#123;def close: Unit &#125;</code> 结构被定义。这种方式的灵活性在于，你可以传递任何类型的实例给该方法，只要它实现了 <code>def close: Unit</code>方法。当前这个新的类型没有任何名字，你可以使用 <code>type</code> 关键字为它提供一个名字(即类型别名)：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Closable</span> </span>= &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(closable: &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;): <span class="type">Unit</span> = &#123;</span><br><span class="line">  closable.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构类型并不局限于一个单一的方法，当定义多个方法时，要确保你使用了 <code>type</code> 关键字为其给定一个名字，否则，你的函数签名会看起来令人费解：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Profile</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>new</code> 关键字创建结构类型的新的值。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nilanjanProfile = <span class="keyword">new</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= “<span class="type">Nilanjan</span>”</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span> </span>= “<span class="type">Boulder</span>, <span class="type">CO</span>”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用结构类型来减少类层次结构，并简化基础代码。比如有下面类层次结构，表示百货商店工作者的多种类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bonusPercentage</span></span>: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HourlyWorker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hours</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FullTimeWorker</span>(<span class="params">val salary: <span class="type">BigDecimal</span>, val bonusPercentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PartTimeWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br></pre></td></tr></table></figure><p>这是小的层次结构，但你有了想法。每个worker的类型都是不同的；有全职的、兼职的。他们唯一共通的一点是都需要付薪。如果你需要在给定的月份中为工作者计算支付薪酬，你需要定义另外一个通用的类型来表示薪酬工作者：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bonusPercentage</span></span>: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HourlyWorker</span> <span class="keyword">extends</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hours</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FullTimeWorker</span>(<span class="params">val salary: <span class="type">BigDecimal</span>, val bonusPercentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PartTimeWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">amountPaidAsSalary</span></span>(workers: <span class="type">Vector</span>[<span class="type">SalariedWorker</span>]) = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸭子类型的好处是，它可以抽象出共性(commonalities)，而不用作为同一个类型的一部分。使用结构类型(structural type)可以容易地重写一个函数，而不用声明一个新的类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">amountPaidAsSalary2</span></span>(workers: <span class="type">Vector</span>[&#123;<span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span> &#125;]) = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以传递任何工作者的实例，并且不用考虑具体的类型。结构类型的好处是，去除了结构层次中不需要的类型定义，不好的方面是它相对比较慢，因为它底层使用了反射。</p><h3><span id="822higher-kinded-typesp240">8<sub>2</sub>2〖Higher-kinded types〗P240</span></h3><p>高级类类型(Higher-kinded types)是指为类型参数创建一个新的类型。因此高级类类型也称为类型构造器，type constructors——接收另一个类型作为参数，并创建一个新的类型。<code>scala.collections.immutable.List[+A]</code>为高级类类型的一个例子。它接收一个类型参数，并创建一个新的具体的类型。<code>List[String]</code>和<code>List[Int]</code>为List所创建的具体类型。种类之于类型，正如类型之于值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Kinds] --&gt; B[Types]</span><br><span class="line">    B --&gt; C[Values]</span><br></pre></td></tr></table></figure><blockquote><p><strong>MODULARIZING LANGUAGE FEATURES</strong></p><p>Scala定义了一大堆功能强大的特性，但并不是每个程序员都要全部运用这些特性。</p><p>从Scala 2.10 开始，你必须先使其高级特性可用，这归功于Scala语言特性模块化的思想。</p><p>scala.language为编程人员提供了语言特性可用操作。进入到scala.language文档，可以找到所有你可以操作的特性。例如，对于大型项目，你可以禁用掉一些滥用的Scala高级特性。如果被禁用的特性在代码中被使用到，编译器会生成一段警告(使用 -feature 显示警告信息)。例如，一个高级类类型(higher-kinded)作为一个高级特性，你需要显式地导入 import scala.language.higherKinds 使其可用。你也可以在编译时，使用 -language:higherKinds 完成同样的事情。</p><p>要启用所有高级特性，使用 <code>-language:_ parameter</code>传递给编译器。</p></blockquote><p>大部分集合类都很好地说明了为什么类型是如此强大的抽象工具。在第5章出现过高级类类型(higher-kinded types)的例子。下面看看更多的例子以了解其实用性。你尝试构建一个函数，它接收另外一个函数作为参数，并提供函数的一个指定类型。如，有一个vector参数，处理vector里面的所有元素：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Vector</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Vector</span>[<span class="type">B</span>] = xs map f</span><br></pre></td></tr></table></figure><p>fmap提供了给定的函数<code>f</code>操作vector的所有元素。相似地，要操作Option，你可以创建另外一个函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Option</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] = xs map f</span><br></pre></td></tr></table></figure><p>但这两个看起来都一样，仅仅是类型不同。问题是：如何定义一个通用的fmap方法，并以各种类型作方法签名？使用高级类类型，你可以抽象第一个参数的类型，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mapper</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">F</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质Mapper通过<code>F[_]</code>类型被参数化。F是一个高级类类型，因为它用 <code>_</code> 标记接收其它类型参数。如果你实现了Vector的fmap，你可以：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VectorMapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Vector</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Vector</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Vector</span>[<span class="type">B</span>] = xs map f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，Option的定义是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OptionMapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Option</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Option</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] = xs map f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用高级类类型，你可以提示抽象的层次，以及定义工作在多种类型上的接口。要实例化，你可以使用Mapper实现Function0的fmap：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Function0Mapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Function0</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Function0</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = <span class="keyword">new</span> <span class="type">Function0</span>[<span class="type">B</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>= f(r.apply())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function0表示一个函数，它不接收任何参数。例如，你可以使用上述Function0Mapper来组合两个函数，创建成为一个新的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newFunction = <span class="type">Function0Mapper</span>.fmap(() =&gt; <span class="string">&quot;one&quot;</span>, (s: <span class="type">String</span>) =&gt; s.toUpperCase)</span><br></pre></td></tr></table></figure><p>newFunction.apply将会返回结果&quot;ONE&quot;，第一个参数定义了一个不接收参数的函数，并返回&quot;one&quot;，第二个参数定义了另外一个函数，接收一个String参数，并使它大写。这里在Function类型中，执行apply方法来调用它的函数。</p><blockquote><h4><span id="type-projection">Type projection</span></h4><p>离开这个例子之前，在方便的时候，我想要解析一个窍门叫 type projection。类型投影(type project) <code>T#x</code> 引用的是类型<code>T</code>的类型成员<code>x</code>。类型投影允许方法给定类型的类型成员。你可以这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">E</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">EE</span> </span>= <span class="type">X</span>#<span class="type">E</span></span><br></pre></td></tr></table></figure><p>这为定义在<code>X</code>内的类型成员<code>E</code>，创建了一个新的别名。这在真是环境中有什么用？以Either作为例子。Either是一个类型构造器，它接收两个参数，一个用于Left，另一个用于Right。你可以如下方式创建一个Left或Right实例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Either</span>.cond(test = <span class="literal">true</span>, <span class="string">&quot;one&quot;</span>, <span class="keyword">new</span> <span class="type">RuntimeException</span>)</span><br><span class="line"></span><br><span class="line">res4: <span class="type">Either</span>[java.lang.<span class="type">RuntimeException</span>,java.lang.<span class="type">String</span>] = <span class="type">Right</span>(one)</span><br></pre></td></tr></table></figure><p>取决于第一个参数是否是true或false，据此来创建Either的Left或Right实例。你可以在Either类型上使用fmap吗？很难实现，因为fmap只接收带一个类型参数的类型，而Either则接收两个。但你可以使用类型投影(type projection)来隐藏一个类型参数，并实例化这个参数。</p><p>首先，你仅提供是Right的函数，由于Right表示成功，Left表示失败。fmap的实现看起来如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Either</span>[<span class="type">X</span>, <span class="type">B</span>] = r <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(c) =&gt; <span class="type">Left</span>(c)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(x) =&gt; <span class="type">Right</span>(f(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现有趣的部分是类型参数<code>X</code>。这里<code>X</code>由创建Mapper的函数指定，使用类型投影，你可以在Mapper特质中隐藏<code>X</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EitherMapper</span></span>[<span class="type">X</span>] = <span class="keyword">new</span> <span class="type">Mapper</span>[(&#123;<span class="class"><span class="keyword">type</span> <span class="title">E</span>[<span class="type">A</span>] </span>= <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>]&#125;)#<span class="type">E</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Either</span>[<span class="type">X</span>, <span class="type">B</span>] = r <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(c) =&gt; <span class="type">Left</span>(c)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(x) =&gt; <span class="type">Right</span>(f(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型投影<code>({type E[A] = Either[X, A]})#E</code>引用了类型别名<code>E[A] = Either[X, A]</code>。这这个例子中，<code>X</code>表示类型<code>Left</code>，以及你不需要担心该类型——这是为什么你隐藏它，并保留由<code>A</code>表示的类型<code>Right</code>。类型投影看起来有点不同寻常，但在你实际需要的时候会很有帮助。</p></blockquote><p>第一次尝试时，会稍微难写出像fmap这样的通用函数。我推荐先从具体的实现开始，在创建抽象之前，先理解这种模式。一旦你理解了这种模式，高级类类型创建抽象。我鼓励你查阅Scala集合<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>以学习更多关于高级类类型的用法。</p><h3><span id="823phantom-typesp243">8<sub>2</sub>3〖Phantom types〗P243</span></h3><p>幻类型(Phantom types)指的是类型不提供任何构造器来创建值。这些类型只在编译期用于增强约束。如果没有例子，很难理解它是怎么用的。我们以订购系统为例。一张订单表示了订货条目和货运地址：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">itemId: <span class="type">Option</span>[<span class="type">Item</span>], address: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br></pre></td></tr></table></figure><p>要下订单，你需要指定订单条目和发货地址。订单系统的客户端提供一个订单，指定发货地址，然后下单：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>(item: <span class="type">String</span>, o: <span class="type">Order</span>) =</span><br><span class="line"><span class="type">Order</span> (<span class="type">Some</span>(item), o.shippingAddress)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>(address: <span class="type">String</span>, o: <span class="type">Order</span>) =</span><br><span class="line"><span class="type">Order</span> (o.itemId, <span class="type">Some</span>(address))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span> </span>(o: <span class="type">Order</span>) = &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这方式的问题是，这些方法会被订单以外调用。例如，一些客户会错误地先placeOrder，而没有addShipping。这样依赖，你需要在placeOrder方法内部实现一些必要的校验，但使用类型系统来增强这方面会显得更好。这里你就可以使用phantom类型来增强一些必要性校验。首先，我们看看下列表示订单状态的phantom type：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderCompleted</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">InCompleteOrder</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ItemProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoItem</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">AddressProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoAddress</span></span></span><br></pre></td></tr></table></figure><p>每个类型都表示订单的一个确切状态，在处理这些订单流程中，将会使用到这些类型。当订单被初始化时，订单没有条目、没有地址，以及状态是incomplete的。这可以容易地使用幻类型(phantom type)来表示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](<span class="params">itemId: <span class="type">Option</span>[<span class="type">String</span>], shippingAddress: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emptyOrder</span> </span>= <span class="type">Order</span>[<span class="type">IncompleteOrder</span>, <span class="type">NoItem</span>, <span class="type">NoAddress</span>](<span class="type">None</span>, <span class="type">None</span>)</span><br></pre></td></tr></table></figure><p>类型Order接收3个类型参数，空的订单用IncompleteOrder, NoItem 以及 NoAddress表示。为了在订单的每个操作上增强某些约束，你需要组合这些类型。例如，你只能向一个没有条目的订单新增条目，一旦添加完成后，类型参数由NoItem变为ItemProvided。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>[<span class="type">A</span>, <span class="type">B</span>](item: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">NoItem</span>, <span class="type">B</span>]) =</span><br><span class="line">o.copy[<span class="type">A</span>, <span class="type">ItemProvided</span>, <span class="type">B</span>](itemId = <span class="type">Some</span>(item))</span><br></pre></td></tr></table></figure><p>addItem方法添加订单条目，并改变第二个参数NoItem为ItemProvided，创建了一个新的订单。类似地，addShipping也创建了一个新的订单，并更新了地址：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>[<span class="type">A</span>, <span class="type">B</span>](address: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">NoAddress</span>]) =</span><br><span class="line">o.copy[<span class="type">A</span>, <span class="type">B</span>, <span class="type">AddressProvided</span>](shippingAddress = <span class="type">Some</span>(address))</span><br></pre></td></tr></table></figure><p>为了下订单，前提条件是订单包含条目和地址，因此你可以在编译时期使用类型来验证：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]) = &#123;</span><br><span class="line">o.copy[<span class="type">OrderCompleted</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>placeOrder方法仅接收条目和地址为完成了的订单。如果你尝试调用不包含条目和地址的订单，会发生编译错误。调用placeOrder方法而不指定地址，会有如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[error] found :</span><br><span class="line">phantomtypes.Order[phantomtypes.InCompleteOrder,phantomtypes.ItemProvide</span><br><span class="line">d,phantomtypes.NoAddress]</span><br><span class="line">[error] required:</span><br><span class="line">phantomtypes.Order[phantomtypes.InCompleteOrder,phantomtypes.ItemProvide</span><br><span class="line">d,phantomtypes.AddressProvided]</span><br></pre></td></tr></table></figure><p>下面列出幻类型(Phantom types)的完整示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderCompleted</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">InCompleteOrder</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ItemProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoItem</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">AddressProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoAddress</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](<span class="params">itemId: <span class="type">Option</span>[<span class="type">String</span>], shippingAddress: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emptyOrder</span> </span>= <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">NoItem</span>, <span class="type">NoAddress</span>](<span class="type">None</span>, <span class="type">None</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 订单的操作处理，改变了原来的订单状态</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>[<span class="type">A</span>, <span class="type">B</span>](item: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">NoItem</span>, <span class="type">B</span>]) =</span><br><span class="line">    o.copy[<span class="type">A</span>, <span class="type">ItemProvided</span>, <span class="type">B</span>](itemId = <span class="type">Some</span>(item))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>[<span class="type">A</span>, <span class="type">B</span>](address: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">NoAddress</span>]) =</span><br><span class="line">    o.copy[<span class="type">A</span>, <span class="type">B</span>, <span class="type">AddressProvided</span>](shippingAddress = <span class="type">Some</span>(address))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]) = &#123;</span><br><span class="line">    o.copy[<span class="type">OrderCompleted</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用该订单系统，你需要逐步为订单添加详细的信息：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o = <span class="type">Order</span>.emptyOrder</span><br><span class="line"><span class="keyword">val</span> o1 = addItem(<span class="string">&quot;some book&quot;</span>, o)</span><br><span class="line"><span class="keyword">val</span> o2 = addShipping(<span class="string">&quot;some address&quot;</span>, o1)</span><br></pre></td></tr></table></figure><p>这时，如果客户端不适当地提交订单，便会得到编译错误。你也可以使用该技术来实现类型安全的构建者模式(Builder pattern)，使用幻类型(phantom types)，可以确保所有被需求的值都是填充的。</p><p>Scala并不仅局限这些类型。它所包含的种类比这里所讲的还要多。例如有类型叫做方法依赖类型<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> (method dependent type)，它允许你指定返回基于类型参数的类型，有路径依赖类型(path-dependent types)则允许你通过object来约束类型，还有更多的。我的建议是多和这门语言接触，我可以确保你会熟悉Scala的类型。</p><h3><span id="8~3ad-hoc-polymorphism-with-type-classesp246">8~3〖Ad hoc polymorphism with type classes〗P246</span></h3><p>一个类型类的类型系统概念是支持即时-多态(ad hoc polymorphism)。即时-多态是一类多态函数可以提供不同的类型参数。即时多态可以为类型添加任何需要的特性。不要把类型类(type classes)看作是OOP概念的类；把它们看作是一个范畴(category)。类型类是定义类型集合的一种方式。在本小节将学习类型类如何帮助构建抽象。</p><h3><span id="831modeling-orthogonal正交-concerns-using-type-classesp246">8<sub>3</sub>1〖Modeling orthogonal(正交) concerns using type classes〗P246</span></h3><p>一个例子将证明如何在Scala中实现类型类(type classes)。下面的例子使用类型类实现了一个适配器模式。在一个对象适配器模式中，适配器(转换对象)包含了一个要转换了实例类。适配器模式是类型函数式组合实现的一个好方法。下面是你尝试要解决的问题：有一个Movie类型，由case class表示，你需要将它转换为XML：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, rating: <span class="type">Double</span></span>)</span></span><br></pre></td></tr></table></figure><p>一个快速的、但又恶劣的解决方案是在case class里面添加toXml方法。但大多数情况下并不适用，因为转换为XML对于Movie类是一个完全的正交责任链(orthogonal responsibility)，并且不应该作为Movie类型的一部分。</p><p>第二种解决方案是使用对象适配器模式。定义一个通用接口XmlConverter，并使用类型参数化：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span> [<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及为Movie实例提供一个对象适配器：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MovieXmlConverter</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span>[<span class="type">Movie</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>) =</span><br><span class="line">  &lt;movie&gt;</span><br><span class="line">  &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">  &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">  &lt;rating&gt;&#123;a.rating&#125;&lt;/rating&gt;</span><br><span class="line">  &lt;/movie&gt;.toString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MovieXmlConverter为Movie类型实现了toXml方法。为了转换Movie的一个实例为XML，你客户端要做的是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = <span class="type">Movie</span>(<span class="string">&quot;Inception&quot;</span>, <span class="number">2010</span>, <span class="number">10</span>)</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;MovieXmlConverter.toXml(p) &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上述实现的问题是MovieXmlConverter产生了偶然性复杂度。转换器隐藏了你正在处理的对象movie，进入toXml方法的处理仍然认为是一个优雅的处理方案。第二个问题是这个实现的刚性设计。使得它很难为Movie提供一个分割XML转换器。让我们看看如何用类型类来增进这个方案。</p><p>第一个类型类的作用是定义一个概念。这个概念是XML转换可以容易地被XmlConverter特质代替：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span> [<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该特质被任何类型A所泛化。你暂时没有任何约束机制。第二个作用是根据通用算法(generic algorithm)自动传递约束逻辑。例如，你可以创建一个新的方法叫toXml，该方法接收一个类型实例，并将它转换为XML：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(converter: <span class="type">XmlConverter</span> [<span class="type">A</span>] ) = converter.toXml(a)</span><br></pre></td></tr></table></figure><p>但这并没有太大改进，因为你仍然要创建一个转换器实例，并把它传递给方法。Scala中是类型类实用的是implicit关键字。它可以使converter 参数隐式地允许Scala编译器在提供了参数，却没有找到时跳到相应的类型上：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(<span class="keyword">implicit</span> converter: <span class="type">XmlConverter</span>[<span class="type">A</span>]) = converter.toXml(a)</span><br></pre></td></tr></table></figure><p>现在你可以通过传递一个Movie实例调用toXml方法，Scala会自动提供类型相当的converter。事实上，你可以传递类型的任何实例，只要你隐式定义了相应的XmlConverter知道如何转换该类型。下面是该示例的完整代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, rating: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(<span class="keyword">implicit</span> converter: <span class="type">XmlConverter</span>[<span class="type">A</span>]) = converter.toXml(a)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">MovieConverter</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span> [<span class="type">Movie</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>): <span class="type">String</span> =</span><br><span class="line">      &lt;movie&gt;</span><br><span class="line">        &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">        &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">        &lt;rating&gt;&#123;a.rating&#125;&lt;/rating&gt;</span><br><span class="line">      &lt;/movie&gt;.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Converters</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = <span class="type">Movie</span>(<span class="string">&quot;Inception&quot;</span>, <span class="number">2010</span>, <span class="number">10</span>)</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;toXml(p)&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>你创建了一个类型类XmlConverter，以及为它提供了一个隐式定义。当使用toXml方法时，你需要确保该隐式定义在编译范围内是可用的，之后Scala编译器会做完剩余的工作。这种实现的灵活性在于，如果你想为Movie提供一个不同的XML转换，你只需要显式地将它作为参数传递给toXml方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MovieConverterWithoutRating</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span> [<span class="type">Movie</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>): <span class="type">String</span> =</span><br><span class="line">    &lt;movie&gt;</span><br><span class="line">      &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">      &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">    &lt;/movie&gt;.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;toXml(p)(MovieConverterWithoutRating)&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>事实上，你也可以将MovieConverterWithoutRating隐式定义。但要确保这两个定义不能同时存在编译环境范围内，否则，将会得到一个 “ambiguous implicit values” 编译错误。为一个给定的类型使用多种隐式定义的一种方式是，在一个窄范围内导入(import)，比如方法内部。下面两个方法为Movie类型使用了不同的XML转换器：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXmlDefault</span></span>(a: <span class="type">Movie</span>) = &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Converters</span>._</span><br><span class="line">  toXml(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXmlSpecial</span></span>(a: <span class="type">Movie</span>) = &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">SpecialConverters</span>._</span><br><span class="line">  toXml(a)(<span class="type">SpecialConverter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MovieConverterWithoutRating被隐式定义在SpecialConverters对象内部。</p><p>类型类显得非常有用，并常见于大多数标准库中。例如，看List中的sum方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span> </span>[<span class="type">B</span> &gt;: <span class="type">A</span>] (<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span></span><br></pre></td></tr></table></figure><p><code>Numeric[B]</code>不是别的，就是类型类，我们运行看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val l = List(1, 2, 3)</span></span><br><span class="line">l: List[Int] = List(1, 2, 3)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> l.sum</span></span><br><span class="line">res0: Int = 6</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val ll = List(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span></span><br><span class="line">ll: List[java.lang.String] = List(a, b, c)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> ll.sum</span></span><br><span class="line">&lt;console&gt;:9: error: could not find implicit value for parameter num:</span><br><span class="line">        Numeric[java.lang.String]</span><br><span class="line">        ll.sum</span><br><span class="line">        ^</span><br></pre></td></tr></table></figure><p>Scala库提供了<code>Numberic[Int]</code>的隐式定义，但却没有<code>Numberic[String]</code>，这就是你为什么或得到隐式编译错误的原因。类型地，Scala集合库里面定义的min方法，使用了<code>Ordering[B]</code>作为类型类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> cmp: <span class="type">Ordering</span>[<span class="type">B</span>]): <span class="type">A</span></span><br></pre></td></tr></table></figure><blockquote><h4><span id="new-syntax-for-declaring-implicit-parameters">New syntax for declaring implicit parameters</span></h4><p>从Scala 2.8开始，使隐式参数匿名，方法或函数声明隐式参数有了更简洁的方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>: <span class="type">XmlConverter</span>](a: <span class="type">A</span>) = implicitly[<span class="type">XmlConverter</span>[<span class="type">A</span>]].toXml(a)</span><br></pre></td></tr></table></figure><p>使用<code>A: XmlConverter</code>，你声明toXml方法接收一个类型为<code>XmlConverter[A]</code>的隐式参数。因为隐式参数的名字不可用，你可以使用定义在scala.Predef里面的方法implicitly来获得引用隐式参数。下面是定义在scala.Predef的方法定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicitly</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> e: <span class="type">T</span>) = e</span><br></pre></td></tr></table></figure><p>为了更容易描述代码，我仍然显式地声明隐式参数。但当添加额外的参数并显得易读性差时，你可以尝试使用这个新语法。</p></blockquote><p>对于类型类的普遍困惑是，人们倾向于认为它是一个接口。接口和类型类不同的关键点是，接口专注于子类多态性(subtype polymorphism)，类型类则专注于参数多态性(parametric polymorphism)。在Java世界里面你会认为参数多态性是泛型(generics)，但更合适的名称是 <em>parametric polymorphism</em> 。另外一种区别是，子类型存在于面向对象(OOP)世界。参数多态性(parametric polymorphism)存在于函数式编程世界。事实上，类型类的概念最先发现于纯函数式编程语言Haskell。</p><p>类型类是模拟一个正交(orthogonal)抽象问题的灵活方式，并且不用对抽象硬连线。类型类在逆向模型(retroactive modeling)上也有帮助，因为你可以在任何时刻为一个类型添加一个类型类。唯一局限性就是类型类的实现是静态的——没有任何动态分配。这种局限的好处在于，所有隐式处理发生在编译时期，因此不会在运行期有关联消耗。类型类有了解决表述问题(expression problem)的所有东西，让我们看看它是如何处理的。</p><h3><span id="832solving-the-expression-problem-using-type-classesp250">8<sub>3</sub>2〖Solving the expression problem using type classes〗P250</span></h3><p>前面说到过，工资的处理由两个抽象层驱动。一是你所在的国家，二是收款方。USPayroll类看起来是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">pagees: <span class="type">Seq</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A类型表示收款方；它可以表示一个雇佣或者承包商。类似地，加拿大地区的薪资类看起来会像：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了表示薪资处理的一类，你需要定义下列特质，以及参数化区域和收款方：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.higherKinds</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PayrollProcessor</span>[<span class="type">C</span>[_], <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">A</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C是一个高级类类型(high-kinded type)表示一个薪资类型。判断是高级类类型的依据是，他同时接收USPayroll和CanadaPayroll作为一个类型参数。A表示收款方。注意你现在还没在任何地方使用到C，除了作为一个参数类型外，像一个幻类型(phantom type)。只有当我创建了第二个类型类的构建块时才有意义，它隐式定义在PayrollProcessor特质中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessors</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeclass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>,<span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeclass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;us employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeclass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;canada employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意你使用了第一类型 PayrollProcessor 参数类型来标识定义所在的区域。为了使用这些隐式定义，你需要使用隐式类型参数USPayroll 和 CanadaPayroll：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>] (<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段处理代码片段也证明了另外一个要点：你也可以在类定义中使用隐式参数。现在当你创建一个USPayroll 或 CanadaPayroll实例，Scala编译器将尝试为隐式参数提供值。下面是完整的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollSystemWithTypeClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @tparam C 高级类类型(high-kinded types)，表示Country[US,Canada,...]</span></span><br><span class="line"><span class="comment">    * @tparam A 类型类(type classes)，表示薪资收款方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">PayrollProcessor</span>[<span class="type">C</span>[_], <span class="title">A</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">A</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>] (<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessors</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>,<span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeClass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;us employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeClass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;canada employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollProcessors</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r = <span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>))).processPayroll</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$r</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这里再次将隐式定义分组在一起，以便于导入使用。注意当你使用实例化的USPayroll，你提供了一个Employee集合，并有Scala编译器隐式处理。在这里，隐式处理由USPayrollProcessor提供。现在，断言它是类型安全的。创建一个新的类型Contractor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>因为在类型payee上没有严格限制(由A表示，没有任何边界约束)，你可以容易地创建一个供应商集合，并传递给USPayroll：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;a&quot;</span>))).processPayroll</span><br></pre></td></tr></table></figure><p>但在编译时，会报编译错误，因为还没有对USPayroll的Contractor类型的隐式定义。但你仍然受类型系统的保护——这非常好。</p><p><strong>注意</strong> 你可以在你的类型类上加<code>@implicitnotfound</code>注解，当编译器找不到该类型隐式值时将得到错误信息帮助。</p><p>让我们继续使用类型类(type classes)处理更多的表述问题(expression problem)。在当前设置中添加一个新类型显得有点琐屑；添加一个新类，并隐式定义薪资处理器：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollSystemWithTypeClassExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Vector</span>[<span class="type">A</span>]</span>) (<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessorsExtension</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClassExtension</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">JapanPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Employee</span>]) = <span class="type">Left</span>(<span class="string">&quot;japan employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为供应商(contractors)提供相应的隐式定义，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;us contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;canada contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">JapanContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;japan contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现所有这些隐式定义，我们就可以在代码中直接执行调用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClassExtension</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollProcessorsExtension</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = <span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;a&quot;</span>))).processPayroll</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$c</span>&quot;</span></span><br></pre></td></tr></table></figure><p>你导入了所有必要的类和隐式定义，并为Japan定义了处理薪资。你再一次成功地解决了表述问题(expression problem)，这次使用的是函数式编程技术。</p><p>如果你是一个Java编程人员，类型类或少或多会使用到，当你熟练了它们，它们可以提供强大的逆向建模(retroactive modeling)，这意味着，你可以快速改变它们。</p><h3><span id="8~4summaryp254">8~4〖Summary〗P254</span></h3><p>这一章，在理解Scala类型系统各种应用上，是一个重要的里程碑。当你理解并探索之后，Scala类型系统帮助在构建可复用和可扩展组件上。一个好的类型系统不仅仅提供了类型安全，它也提供了足够的抽象来快速地构建组件和库。你学习了抽象类型成员(abstract type members)和自类型(self-type)注解，以及如何使用他们来构建组件。你也探索了Scala的类型类，以及如何使用它们来构建应用创建抽象。</p><p>编程语言中，判断该语言强弱的一个最通常方式是表述问题(expression problem)。你实现了解决表述问题(expression problem)的两种方式，清晰地证明了Scala类型系统的强大。Scala是多模式的(multiparadigm)，你同时使用了面向对象和函数式编程两种方式解决了这个问题。面向对象的方式是实现了抽象类型成员和特质。为了解决这个问题，你学习了类型类。类型类是一个强大解决在运行时的多态问题的方式。这还没有真正深入到Scala类型系统中。这章仅可能覆盖更多的内容，但我相信你的好奇心促使你探索更多的内容。</p><p>下一章将覆盖Scala最流行的特性：actor。Scala的actor使得构建高并发应用更容易，并一步到位(hassle-free)。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Benjamin C. Pierce, Types and Programming Languages, 2002, The MIT Press, <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">www.cis.upenn.edu/~bcpierce/tapl/</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Martin Odersky and Lex Spoon, “The Architecture of Scala Collections,” adapted from Programming in Scala,second edition, Odersky, Spoon and Venners, Artima Inc., 2011, <a href="http://mng.bz/Bso8">http://mng.bz/Bso8</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">“What are some compelling use cases for dependent method types?” Answered by Miles Sabin on stackoverflow, Oct 22, 2011, <a href="http://mng.bz/uCj3">http://mng.bz/uCj3</a>.</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：连接到数据库</title>
      <link href="/2016/10/27/scala/07-fp-database/"/>
      <url>/2016/10/27/scala/07-fp-database/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>SBT构建数据库。</li><li>webKanban中，通过Squeryl连接数据库。</li><li>完善weKanban。</li></ol><p>第六章，我们学习了如何使用SBT(Simple Build Tool)和Scalaz HTTP模组构建一个简单的Web应用。但这个应用在前面章节中未算竣工。原因是：构建一个函数式的Kanban应用，你的应用需要存储信息，即存储到持久化环境中。</p><p><strong>注意</strong> 本章是第六章的延续，如果你未曾读过上一章节，一些本章节的相关部分很难跟进。</p><p>本章将完成上一个章节未完成的部分。你将学习如何检索数据并存储到关系型数据中。我将介绍一个Scala ORM(Object Relational Mapping)工具——Squeryl。并将探索如何安全地模拟数据字典。你将构建一个应用存储，以及在Kanban面板上展示该存储数据。在此过程中，你将探索Scala中如何与数据库工作。尽管本章关注于数据库方面的内容，也会介绍到Scalaz和SBT在数据库方面的使用。在构建应用之前，让我们回顾一下我们所需要实现weKanban应用的用户故事：</p><p>As a customer I want to create a new user story so that I can add stories to the ready phase.<br>As a developer I want to move cards (stories) from one phase to another to signal progress.</p><p>下面开始构建基于用户故事的weKanban应用。</p><span id="more"></span><h3><span id="7~1adding-a-new-story-to-a-wekanban-boardp194">7~1〖Adding a new story to a weKanban board〗P194</span></h3><p>首先要做的是在面板中添加案例，如果不添加根本做不了任何事情。添加案例意味着你需要担心持久化存储。企业开发者使用关系型数据库将信息存储到表中，这里建议使用开源的Java数据库 <a href="http://www.h2database.com/html/main.html">H2</a>。实际上，你还可以自由地选取下面的数据库：<code>Postgres</code>、<code>Oracle</code>、<code>MySQL</code>，<code>DB2</code> 。这里之所以列出这几个数据库的原因是，你所使用的ORM库Squeryl，仅支持这几种数据。</p><p><strong>注意</strong> 使用诸如MongoDB这种模式自由的数据库，在这里有些许争议，这里希望专注于一个事务型的关系型数据库的解决方案，以及展示Scala是如何在关系型数据库管理系统(RDBMS)中工作。你也可以自由地尝试其它类型的数据库。</p><h3><span id="711connecting-to-a-database-using-squerylp194">7<sub>1</sub>1〖Connecting to a database using Squeryl〗P194</span></h3><p>那么，为什么使用Squeryl来访问数据库？首先是它在Scala社区内非常流行，以及它提供了一个良好的、简单的DSL对接数据库。尽管直接在Scala中使用JDBC也未尝不可，使用Squeryl，你则直接学习了一整个ORM工具。Scala强大的类型系统正很好地用来创建一个类型安全的ORM工具。这里鼓励你使用其它的Scala ORM，如ScalaQuery<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>、Querulous<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>作为选择。</p><p>现在，Squeryl和H2作为weKanban的项目依赖，添加到构建文件中，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;weKanban&quot;</span></span><br><span class="line">organization := <span class="string">&quot;scalainaction&quot;</span></span><br><span class="line">version := <span class="string">&quot;0.2&quot;</span></span><br><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-deprecation&quot;</span>)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-core&quot;</span> % <span class="string">&quot;6.0.3&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-http&quot;</span> % <span class="string">&quot;6.0.3&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-servlet&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-webapp&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;test,container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.h2database&quot;</span> % <span class="string">&quot;h2&quot;</span> % <span class="string">&quot;1.2.137&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.squeryl&quot;</span> % <span class="string">&quot;squeryl_2.10&quot;</span> % <span class="string">&quot;0.9.5-6&quot;</span></span><br><span class="line">)</span><br><span class="line">seq(com.github.siasia.<span class="type">WebPlugin</span>.webSettings :_*)</span><br></pre></td></tr></table></figure><p>现在，你要做的是update构建依赖。对于weKanban项目，面板案例应该有三个属性：唯一标识，标题描述，以及案例段落。下面你如何构建的案例类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Story</span>(<span class="params">val number: <span class="type">String</span>, val title: <span class="type">String</span>, val phase:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>要使该类在Squeryl下工作，你还必须进行大量的设置。首先，你需要告诉Squeryl你需要一个table存储所有这些story。Squeryl中的实现是，创建org.squeryl.Schema的子类。该类等效地看作是数据库的schema，下面代码定义了一个schema表为&quot;STORIES&quot;的Story类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.squeryl._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KanbanSchema</span> <span class="keyword">extends</span> <span class="title">Schema</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> stories = table[<span class="type">Story</span>](<span class="string">&quot;STORIES&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该文件保存为KanbanSchema.scala，置于src/main/scala/com/kanban/models。这里要注意的是我定义了一个类型安全的管理器。stories表示数据库表&quot;STORIES&quot;，你可以对stories执行各种各样的查询，而不用担心story类型对象的返回问题。</p><p><strong>注意</strong> 大多数ORM工具使用了各种内建配置文件来指定数据库的schema和domain model映射信息。因为Scala是一个DSL友好的表达式语言，Scala工具通常都使用Scala语言本身作为配置。目前所看到的SBT、Squeryl就是个以Scala语言为DSL的明显的例子。下一次，你想你应该需要一个内置配置、属性文件，以及如何用Scala语言表述这些配置信息。</p><p>下一步，为Squeryl配置使用H2数据库。在连接数据库之前，首先有确保H2数据库服务已经运行。开启H2数据库服务很简单，你需要把h2.jar文件添加到路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ~/.ivy2/cache/com.h2database/h2/jars/h2*.jar org.h2.tools.Server</span><br></pre></td></tr></table></figure><p>这看起来很丑陋，因为你需要在本地存储ivy中运行你的依赖。如果可以想Jetty那样运行H2数据库就好了，不幸的是，SBT内建(built-in)不支持H2，所以你要为H2数据库创建tasks。一个好消息是，SBT构建tasks是十分容易的，所以，我们需要修改build.scala文件。SBT提供了大量的辅助方法来构建自定义tasks，但这里的tasks由方法实现。代码清单如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sbt._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Keys</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">H2TaskManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> process: <span class="type">Option</span>[<span class="type">Process</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">H2</span> = config(<span class="string">&quot;h2&quot;</span>) extend <span class="type">Compile</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> startH2 = <span class="type">TaskKey</span>[<span class="type">Unit</span>](<span class="string">&quot;start&quot;</span>,<span class="string">&quot;Starts H2 database&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> startH2Task = startH2 in <span class="type">H2</span> &lt;&lt;= (fullClasspath in <span class="type">Compile</span>) map &#123;</span><br><span class="line">    cp =&gt;</span><br><span class="line">      startDatabase &#123;</span><br><span class="line">        cp.map(_.data)</span><br><span class="line">        .map(_.getAbsolutePath())</span><br><span class="line">        .filter(_.contains(<span class="string">&quot;h2database&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startDatabase</span></span>(paths: <span class="type">Seq</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    process <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> cp = paths.mkString(<span class="type">System</span>.getProperty(<span class="string">&quot;path.separator&quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> command = <span class="string">&quot;java -cp &quot;</span> + cp + <span class="string">&quot; org.h2.tools.Server&quot;</span></span><br><span class="line">        println(<span class="string">&quot;Starting Database with command: &quot;</span> + command)</span><br><span class="line">        process = <span class="type">Some</span>(<span class="type">Process</span>(command).run())</span><br><span class="line">        println(<span class="string">&quot;Database started ! &quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt;</span><br><span class="line">        println(<span class="string">&quot;H2 Database already started&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> stopH2 = <span class="type">TaskKey</span>[<span class="type">Unit</span>](<span class="string">&quot;stop&quot;</span>, <span class="string">&quot;Stops H2 database&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> stopH2Task = stopH2 in <span class="type">H2</span> :=&#123;</span><br><span class="line">    process <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">&quot;Database already stopped&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt;</span><br><span class="line">        println(<span class="string">&quot;Stopping database...&quot;</span>)</span><br><span class="line">        process.foreach&#123;_.destroy()&#125;</span><br><span class="line">        process = <span class="type">None</span></span><br><span class="line">        println(<span class="string">&quot;Database stopped...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line"><span class="keyword">import</span> <span class="type">H2TaskManager</span>._</span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> scalazVersion = <span class="string">&quot;6.0.3&quot;</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> jettyVersion = <span class="string">&quot;7.3.0.v20110203&quot;</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> wekanban = <span class="type">Project</span>(</span><br><span class="line">  <span class="string">&quot;wekanban&quot;</span>,</span><br><span class="line">  file(<span class="string">&quot;.&quot;</span>)).settings(startH2Task, stopH2Task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的build.scala文件做了两件事。一是，定义了项目的<code>name</code>，<code>locations</code>，<code>settings</code>。项目工程的settings通过继承Build获得默认值，并添加两个新任务：<code>startH2Task</code>和<code>stopH2Task</code>。这两个任务现在作为项目settings的一部分，并可以用开启和停止H2数据库。</p><p>二是，scalazVersion和jettyVersion被声明为<code>lazy val</code>。这个好处是，你不用在build.sbt文件中重复声明多次：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-core&quot;</span> % scalazVersion,</span><br><span class="line">  <span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-http&quot;</span> % scalazVersion,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-servlet&quot;</span> % jettyVersion % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-webapp&quot;</span> % jettyVersion % <span class="string">&quot;test, container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % jettyVersion % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.h2database&quot;</span> % <span class="string">&quot;h2&quot;</span> % <span class="string">&quot;1.2.137&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.squeryl&quot;</span> % <span class="string">&quot;squeryl_2.10&quot;</span> % <span class="string">&quot;0.9.5-6&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>是的，你可以共享build.scala的settings和vals到build.sbt文件。事实上，常规做法是，build.scala通常用于声明，build.sbt则使用其声明内容用于构建。最好，所有settings由多个文件组合成为一个settings队列中。</p><p>重载构建定义之后，你可以看到两个新的tasks，<strong>h2:start</strong> 和 <strong>h2:stop</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> h2:st</span></span><br><span class="line">start stop</span><br></pre></td></tr></table></figure><blockquote><h4><span id="how-h2start-and-h2stop-tasks-are-implemented">How h2:start and h2:stop tasks are implemented</span></h4><p>在SBT中创建一个新的任务是简单的：创建一个TaskKey，委派一个闭包实现这个task。因为你需要和其它自定义tasks和内建tasks做的更贴切，为H2任务创建一个新的范围：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">H2</span> = config(<span class="string">&quot;h2&quot;</span>) extend (<span class="type">Compile</span>)</span><br></pre></td></tr></table></figure><p>这里创建一个新的配置&quot;h2&quot;，继承自Compile。Compile配置会提供必需的classpath设置setting。新的配置&quot;h2&quot;创建了一个新的范围，即Compile，以及&quot;h2&quot;在该范围起作用。</p><p>任务startH2通过startDatabase方法实现。该方法要求一个指向H2数据库 .jar文件的路径序列。因为&quot;h2&quot;配置继承了Compile，你可以使用来自于Compile的settings键fullClasspath接入到classpath中。方法<code>&lt;==</code>则帮助创建一个新setting，该setting依赖于其它settings。下面代码片段中，将Compile 范围的fullCpasspath映射到新的任务中，并创建一个新的函数，该函数将在该任务开启是被执行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> startH2Task = startH2 in <span class="type">H2</span> &lt;&lt;= (fullClasspath in <span class="type">Compile</span>) map &#123;</span><br><span class="line">cp =&gt;</span><br><span class="line">  startDatabase &#123;</span><br><span class="line">    cp.map(_.data)</span><br><span class="line">    .map(_.getAbsolutePath())</span><br><span class="line">    .filter(_.contains(<span class="string">&quot;h2database&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法startDatabase存储了进程对象的引用，这样可以在<code>stopDatabase</code>方法中使用。<code>stopDatabase</code>和<code>h2:stop</code>任务相关联。</p></blockquote><p>这会帮助你不用离开舒适的SBT控制台，就可以在使用H2进行工作。当你执行<code>h2:start</code>，它会自动在端口为8082上开启H2数据库，并在默认浏览器上开启H2登录视窗，如图Figure 7.1。</p><p><img src="/img/scala-in-action/chapter7/Figure_7_1.png" alt="The H2 Console"></p><p>(如果浏览器没有打开，需要直接在浏览器输入 <a href="http://localhost:8082">http://localhost:8082</a> )因为H2服务已经在运行，我们专注于Squeryl连接到该服务的处理上。要连接到H2服务，使用下面的Driver和URL：</p><ul><li>[x] JDBC Driver class: org.h2.Driver</li><li>[x] Database URL: jdbc:h2:tcp://localhost/~/test</li><li>[x] User name: sa</li></ul><p>更多有关这方面的信息，请参考 <a href="www.h2database.com/html/quickstart.html">www.h2database.com/html/quickstart.html</a>。下面列出一个init方法，该方法用于连接 H2 数据库。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">DriverManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.squeryl.<span class="type">PrimitiveTypeMode</span>._</span><br><span class="line"><span class="keyword">import</span> org.squeryl._</span><br><span class="line"><span class="keyword">import</span> org.squeryl.adapters._</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author Barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KanbanSchema</span> <span class="keyword">extends</span> <span class="title">Schema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> stories = table[<span class="type">Story</span>](<span class="string">&quot;STORIES&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>() = &#123;</span><br><span class="line">    <span class="type">Class</span>.forName(<span class="string">&quot;org.h2.Driver&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">SessionFactory</span>.concreteFactory.isEmpty) &#123;</span><br><span class="line">      <span class="type">SessionFactory</span>.concreteFactory = <span class="type">Some</span>(() =&gt;</span><br><span class="line">        <span class="type">Session</span>.create(<span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:h2:tcp://localhost/~/test&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="keyword">new</span> <span class="type">H2Adapter</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KanbanSchema表示weKanban应用数据库schema定义。第一件事要做的是，把Story DOM用方法table定义的STORIES进行映射。</p><p>方法init为与正在运行的H2数据库进行连接。在该方法中，<code>import org.squeryl.SessionFactory。SessionFactory</code>类似于数据库连接工厂，它用于创建新的连接。下一步，用<code>Class.forName(&quot;org.h2.Driver&quot;)</code>载入H2 jdbc驱动。该驱动在创建一个新的连接时使用。</p><p>在Squeryl创建一个新的连接，意味着创建一个新的Session。这种方式和Java流行ORM框架Hibernate很相似，即把连接封装为Session。把Squeryl的session看作为一个基于数据库的连接转换器，该连接可以控制数据库的事务。其中Squeryl 的 session实例提供了额外的方法如log，这些方法用于绑定/解绑session到当前线程。注意，Session将这些数据库连接保存到一个ThreadLocal<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>变量中，这样，每个线程都可以获取到它自己的连接。这在web应用中的好处是，可以有多个用户在任何节点访问应用。</p><p>在Squeryl中，创建一个新的session机制是需要定义一个concreteFactory变量，它定义在SessionFactory对象中。默认地，该值为<code>None</code>。如果不为<code>None</code>，则说明它已经被初始化。Squeryl要求concreteFactory作为一个函数用于创建新的sessions。下面为该函数的使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">() =&gt;</span><br><span class="line">    <span class="type">Session</span>.create(<span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:h2:tcp://localhost/~/test&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="keyword">new</span> <span class="type">H2Adapter</span>))</span><br></pre></td></tr></table></figure><p>这里真正被调用的方法，是Session对象里面的create方法，由传递一个数据库连接和一个适配器adapter执行。其中，Java DriverManager接收URL、用户名和密码。Squeryl提供的适配器用于它所支持的数据库类型，这里的适配器为H2Adapter，表示数据库为H2的连接。因为concreteFactory的类型是<code>Option[()=&gt;Session]</code>，你需要用Option值Some进行转换。</p><p>因为你定义了stories对象来表示&quot;STORIES&quot;表，它不会在数据库中创建表。某些情况下你可能会用SQL脚本来创建数据库表结构，但这里你可以使用Squeryl来创建这些Schema。添加一个main方法入口，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">    println(<span class="string">&quot;initializing the weKanban schema&quot;</span>)</span><br><span class="line">    init</span><br><span class="line">    inTransaction &#123;drop;crete&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在Squeryl的方法inTransaction在数据库事务中执行并关闭。这里表示drop所有的表，并重新创建。现在，唯一定义的表是&quot;STORIES&quot;，你可以在SBT控制台下运行这个main方法，它将在数据库中创建一个新的Schema。在运行main之前，请确保H2数据库服务正在运行。下面继续讲解如何将数据存储到数据库上。</p><h3><span id="712saving-a-new-story-to-the-databasep200">7<sub>1</sub>2〖Saving a new story to the database〗P200</span></h3><p>要通过Squeryl向数据库插入一条新的记录，你需要调用定义在org.squeryl.Table类里面的方法insert，该方法接收一个model实例，并存储到数据库中。Schema中已经定义了执行数据库表的&quot;STORIES&quot;。你现在需要创建一个传递给insert方法的实例Story，该实例代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Story</span>(<span class="params">val number: <span class="type">String</span>, val title: <span class="type">String</span>, val phase: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>在将Story实例存储到数据库之前，你需要为其添加验证。例如，Story的两个属性<code>number</code> 和 <code>title</code> 都不能为空，以及<code>number</code>是唯一标识的，下面为该验证的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationException</span>(<span class="params">message: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">message</span>)</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">validate</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">if</span>(number.isEmpty || title.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidateException</span>(<span class="string">&quot;Both number and title are required&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将方法validate添加到Story类中，并在save动作之前调用。这里创建了一个自定义异常ValidationException用于所有验证失败处理。</p><p><strong>注意</strong> 这里没有定义主键，而仅仅是把number声明为唯一键。在小应用中这样做没什么问题，但是，在真实环境中，你应该将它代替为主键。要给你的domain类添加一个自动递增的主键id，你可以继承<code>KeyedEntity[A]</code>特质，你也可以使用<code>KeyedEntity</code>来创建组合<code>keys</code>。关于更多信息内容，参考Squeryl官方文档。</p><p>为了检查number字段的唯一性，你需要检查&quot;STORIES&quot;表，确保没有其它记录有相同的number。Squeryl提供了一个很好的方法<code>where</code>，在表对象中，你可以很容易地实现。<code>where</code>方法接收一个断言函数，并过滤得出结果。下面是使用<code>where</code>方法来检查number的唯一性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!stories.where(a =&gt; a.number === number).isEmpty) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidationException</span> (<span class="string">&quot;The story number is not unique&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了函数<code>a =&gt; a.number === number</code> (<code>===</code> Squeryl定义的等价操作符)，这表示你查询的结果匹配给定number。如果查询的结果为空，则给定的number不是唯一的。注意<code>where</code>方法返回一个<code>lazy iterable</code> 叫做 Query ，它定义在<code>org.squeryl.Query</code>。查询仅在动作开始时向数据库发送信息。添加完这些验证后，<code>validate</code>方法现在看起来像下面：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">validate</span></span>() = &#123;</span><br><span class="line"><span class="keyword">if</span> (number.isEmpty || title.isEmpty) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidationException</span>(<span class="string">&quot;Both number and title are required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stories.where(a =&gt; a.number === number).nonEmpty) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidationException</span>(<span class="string">&quot;The story number is not unique&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在插入Story记录到数据库之前，你需要调用这个validate方法，以确保是否有效。你还需要在数据库事务上提交或者回滚。现在，我们为该Story类添加一个<code>save</code>方法。但，这个方法应该返回什么？当创建记录成功时，你可以返回成功信息，但创建失败时怎么表示好？在这里我推荐使用<code>scala.Either</code>，它可以允许你同时返回成功和失败信息。它使得save方法可以优雅地处理问题。下面是完整的Story类方法，它包含<code>validate</code>和<code>save</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kanban.models.<span class="type">KanbanSchema</span>._</span><br><span class="line"><span class="keyword">import</span> org.squeryl.<span class="type">KeyedEntity</span></span><br><span class="line"><span class="keyword">import</span> org.squeryl.<span class="type">PrimitiveTypeMode</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Story</span>(<span class="params">val id: <span class="type">Long</span>, val number: <span class="type">String</span>, val title: <span class="type">String</span>, val phase: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="type">Long</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">validate</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">if</span> (number.isEmpty || title.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidationException</span>(<span class="string">&quot;Both number and title are required&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stories.where(a =&gt; a.number === number).nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ValidationException</span>(<span class="string">&quot;The story number is not unique&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span>(): <span class="type">Either</span>[<span class="type">Throwable</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">    tx &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        validate()</span><br><span class="line">        stories.insert(<span class="keyword">this</span>)</span><br><span class="line">        <span class="type">Right</span>(<span class="string">&quot;Story is created successfully&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> exception: <span class="type">Throwable</span> =&gt; <span class="type">Left</span>(exception)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Story</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(number: <span class="type">String</span>, title: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Story</span>(<span class="number">0</span>, number, title, <span class="string">&quot;ready&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationException</span>(<span class="params">message: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">message</span>)</span></span><br></pre></td></tr></table></figure><p>number 和 title两个字段都不能为空，如果为空，你可以抛出一个异常。第二个验证是从数据库检验number是否是唯一的。这里使用了一个内建方法<code>where</code>，该方法用用于所有表对象，它接收一个函数作为参数，函数参数是一个Boolean表达式，并根据表达式过滤搜索查询。代码中匹配 <code>a =&gt; a.number === number</code>，用于查询数据库中和number相等的记录，如果存在该记录，将抛出异常，表示不能插入不唯一的记录。</p><p>在save方法之前，最先调用validate方法，以此验证是否插入重复数据。这两个方法都处于闭包环境tx方法中。方法tx表示初始化SessionFactory.concrete 和 数据库事务。该方法在 KanbanSchema里面定义。因为save返回结果包含成功和失败，所以这个使用了Either作为save方法的返回类型。在Scala公共方法中，使用<code>scala.Either</code>作为返回 更通常于抛出异常。另外，你创建了Story的伴生对象Story来创建新的实例，phase的默认值为&quot;Ready&quot;。</p><p>方法tx在前面的代码片段中，确保了SessionFactory被正确初始化，以及开启了一个新的事务。方法tx接收一个函数作为参数，并以函数作为返回类型。函数参数可以是任何闭包或者代码块，下面是完整的KanbanSchema对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">DriverManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.squeryl.<span class="type">PrimitiveTypeMode</span>._</span><br><span class="line"><span class="keyword">import</span> org.squeryl._</span><br><span class="line"><span class="keyword">import</span> org.squeryl.adapters._</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author Barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KanbanSchema</span> <span class="keyword">extends</span> <span class="title">Schema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> stories = table[<span class="type">Story</span>](<span class="string">&quot;STORIES&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>() = &#123;</span><br><span class="line">    <span class="type">Class</span>.forName(<span class="string">&quot;org.h2.Driver&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">SessionFactory</span>.concreteFactory.isEmpty) &#123;</span><br><span class="line">      <span class="type">SessionFactory</span>.concreteFactory = <span class="type">Some</span>(() =&gt;</span><br><span class="line">        <span class="type">Session</span>.create(<span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:h2:tcp://localhost/~/test&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="keyword">new</span> <span class="type">H2Adapter</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tx</span></span>[<span class="type">A</span>](a: =&gt; <span class="type">A</span>): <span class="type">A</span> = &#123;</span><br><span class="line">    init()</span><br><span class="line">    inTransaction(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;initializing the weKanban schema&quot;</span>)</span><br><span class="line">    init()</span><br><span class="line">    inTransaction &#123;</span><br><span class="line">      drop; create</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法tx接收一个函数，并在事务中执行该函数。方法<code>inTransaction</code>定义在Squeryl，它会检查线程中是否有其它事务，如果有，加入进程中的事务，否则创建一个新的事务。方法tx最先会执行init以确保<code>SessionFactory.concrete</code>和事务被初始化；以及方法<code>inTransaction</code>用于执行事务处理。</p><h3><span id="713building-the-create-story-web-pagep204">7<sub>1</sub>3〖Building the Create Story web page〗P204</span></h3><p>接下来完成Story的新增页面内容，并在weKanban应用中完成下面这些特性：</p><p>As a customer, I want to create a new user story so I can add stories to the ready phase.</p><p>在web页面中，你可以有很多方式创建动态web页面。你可以使用JSP，Scala模版引擎 <a href="http://scalate.fusesource.org">Scalate</a> <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，或者使用Scala内建的XML支持来创建XHTML。这里使用Scala的内建XML来生成XHTML web页面，它的特点是简单、易测试、以及有明显的Scala XML性能。对于复杂的大型的应用，这种方式不能扩展。在Chapter12你会探索Scala web框架如何更容易地构建大型web应用。</p><p>为了用XML来表示每一个页面dom，你需要创建一个视图对象，用于WeKanbanApplication类来发送响应内容。图Figure 7.2为我们需要构建的页面内容。</p><p><img src="/img/scala-in-action/chapter7/Figure_7_2.png" alt="Figure 7.2"></p><p>要创建上图页面内容，你需要创建下列代码CreateStory，置于src/main/com/kanban/views：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.views</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CreateStory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(message: <span class="type">String</span> = <span class="string">&quot;&quot;</span>) =</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;title&gt;<span class="type">Create</span> <span class="keyword">new</span> <span class="type">Story</span>&lt;/title&gt;</span><br><span class="line">        &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/css/main.css&quot;</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">&quot;text/css&quot;</span> media=<span class="string">&quot;screen&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">          &#123;message&#125;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;createStory&quot;</span>&gt;</span><br><span class="line">          &lt;form action=<span class="string">&quot;/card/save&quot;</span> method=<span class="string">&quot;post&quot;</span> accept-charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">              &lt;legend&gt;<span class="type">Create</span> a <span class="keyword">new</span> <span class="type">Story</span>&lt;/legend&gt;</span><br><span class="line">              &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;section&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">for</span>=<span class="string">&quot;storyNumber&quot;</span>&gt;<span class="type">Story</span> <span class="type">Number</span></span><br><span class="line">                  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;subtle&quot;</span>&gt;(uniquely identifies a story)&lt;/span&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">&quot;text&quot;</span> size=<span class="string">&quot;10&quot;</span> maxlength=<span class="string">&quot;10&quot;</span> minlength=<span class="string">&quot;3&quot;</span> name=<span class="string">&quot;storyNumber&quot;</span> id=<span class="string">&quot;storyNumber&quot;</span>/&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;section&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">for</span>=<span class="string">&quot;title&quot;</span>&gt;<span class="type">Title</span></span><br><span class="line">                  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;subtle&quot;</span>&gt;(describe the story)&lt;/span&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;textarea rows=<span class="string">&quot;5&quot;</span> cols=<span class="string">&quot;30&quot;</span> name=<span class="string">&quot;title&quot;</span> id=<span class="string">&quot;title&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;section&quot;</span>&gt;</span><br><span class="line">                &lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">&quot;submit&quot;</span>&gt;<span class="type">Save</span>&lt;/button&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">          &lt;/form&gt;</span><br><span class="line">          &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;linkLabel&quot;</span>&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;/kanban/board&quot;</span>&gt;<span class="type">Go</span> to <span class="type">Kanban</span> board&lt;/a&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的apply方法为创建页面所需要的HTML代码，尽管它是HTML，在Scala代码中，不论是XML或HTML都是有效的。这里的apply方法的返回类型是scala.xml.NodeSeq，它是一系列XML节点，NodeSeq会被渲染为String，并返回真是的HTML代码。现在要为其指定一个URL。其中，静态链接内容分别在webapp/js 和 webapp/css目录下。</p><p>到目前为止，Scalaz中的application已经使用resource方法处理了这些静态资源：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>, servletRequest:</span><br><span class="line"><span class="type">HttpServletRequest</span>, request: <span class="type">Request</span>[<span class="type">Stream</span>]) = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]) : <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">resource(found, <span class="type">NotFound</span>.xhtml)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要处理这些静态资源，在application方法中调用handle方法，该方法接收application方法相同的参数，并在请求对象上匹配URL。典型地，web框架使用了分割配置文件来将URL映射为一个资源或函数。基于约定(convention-based)框架如：Rails、playframework 中，URL包含了足够的信息来映射到 合适的函数或动作中。Scalaz使用了一个不同的方式——Scala强大的类型匹配，当URL进入到HTTP方法，URL被分成List。例如，一个URL地址为 <a href="http://localhost:8080/card/create">http://localhost:8080/card/create</a>  匹配为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>,<span class="string">&quot;card&quot;</span>::<span class="string">&quot;create&quot;</span>::<span class="type">Nil</span>) =&gt;   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodParts是一个<code>Extractor object</code>，它接收一个Scalaz请求Request，并返回HTTP方法的Option，以及URL的List对象。前面提供的代码片段中，<code>GET</code>为HTTP请求资源方法，第二个参数为拆分为List的URL。</p><blockquote><h4><span id="how-an-extractor-object-works">How an Extractor object works</span></h4><p>第三章中介绍了case class是如何进行模式匹配的，但模式匹配并不仅限于case class。几乎任何对象都可以用做模式匹配，只要它定义了方法unapply。包含unapply方法的对象称为Extractor object。例如，Scalaz中定义的MethodParts代码为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MethodParts</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>[<span class="type">IN</span>[_]](r : <span class="type">Request</span>[<span class="type">IN</span>]) : <span class="type">Option</span>[(<span class="type">Method</span>,</span><br><span class="line">    <span class="type">List</span>[<span class="type">String</span>])] = &#123;</span><br><span class="line">    <span class="type">Some</span>(r.method, r.parts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的unapply方法接收一个Scalaz 请求实例，并返回一个包含method 和 parts的 <code>Some</code>。parts方法返回所有由 <code>/</code> 分割的路径。</p><p>当Scala遇到诸如<code>MethodParts(...)</code> 这种模式，会转换为一个<code>MethodParts.unapply</code>方法的调用，即由模式匹配引用传递对象(这里是Scalaz的request实例)。注意，apply方法对于模式匹配(pattern matching)不是必须的。典型使用最小构造器，例如，在Story实例中使用apply来创建一个新的Story实例。</p><p>我们规定，如果你想要从unapply方法中得到返回值，则返回类型必须为scala.Option的转换。</p></blockquote><p>有时候，你会通过请求参数来请求资源。例如，当一个Story被成功创建后，你会回到原来的页面，并附带一个创建成功消息。从URL中获取请求参数，需要用到Scalaz Request对象中的方法 <code>!</code>。下面我们创建一个私有方法<code>param</code>，该方法用于返回一个字符串值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>]) = (request ! name).getOrElse(<span class="type">List</span>[<span class="type">Char</span>]()).mkString(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>方法 ! 返回<code>Option[List[Char]]</code>，这里把它转换为字符串。下面创建handle方法将它们组合起来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>], servletRequest: <span class="type">HttpServletRequest</span>): <span class="type">Option</span>[<span class="type">Response</span>[<span class="type">Stream</span>]] = &#123;</span><br><span class="line">  request <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;create&quot;</span> :: <span class="type">Nil</span>) =&gt; </span><br><span class="line">      <span class="type">Some</span>(<span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; <span class="type">CreateStory</span>(param(<span class="string">&quot;message&quot;</span>)))</span><br><span class="line">      <span class="type">Some</span>(moveCard)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，当request匹配HTTP method类型和URL，会创建一个调用CreateStory产生的Response。<code>OK(ContentType,&quot;text/html&quot;)</code>创建一个空的Response，该Response带有HTTP响应标头(header)类型content-type。方法 <code>&lt;&lt;</code> 表示向Response 添加额外内容。因为Scala鼓励创建不可变对象(immutable objects)，所以，每次调用 <code>&lt;&lt;</code> 方法时，都会创建一个新的Response对象。</p><p><strong>注意</strong> handle方法里面使用的 strict 称为 <em>doctype</em> 。文档类型不是一个HTML标签。它用于告诉浏览器当前页面使用的是哪个版本的标记语言。这里使用了strict HTML 标准，在例子中使用 strict 。</p><p>接下来，我们需要在application方法中使用handle方法。原来方法中保留resource方法，用来加载静态资源。要在application方法中添加handle方法处理，Scalaz内核提供了一个方法 <code>|</code> 用于Option类，使用它可以组合handle方法和resource方法，这样，当handle方法返回None时，则调用resource方法作为静态资源处理。下面是改变之后的application方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>,</span><br><span class="line">  servletRequest: <span class="type">HttpServletRequest</span>, request: <span class="type">Request</span>[<span class="type">Stream</span>]) = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]) : <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">    handle | resource(found, <span class="type">NotFound</span>.xhtml)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为所有传递给handle方法的参数都是隐式的，你可以不用显式给它传递参数。使用了 <code>| </code>方法，如果handle方法返回的是None，则方法resource会被调用。当URL找不到匹配的资源时，则会返回NotFound.xhtml。</p><p><strong>注意</strong> Scalaz使用Scala的隐式方法转换将 <code>|</code> 方法添加到 Option类中。如果你曾经使用过Ruby,Groovy或其它编程语言的 元程序(metaprogramming)，隐式转换是Scala实现 元程序(metaprogramming) 的方式，但有更多控制。你会在下一章节了解更多隐式转换的详细内容。</p><p>在运行应用之前，先看看经过修改后的完整代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scalaz._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Scalaz</span>._</span><br><span class="line"><span class="keyword">import</span> scalaz.http._</span><br><span class="line"><span class="keyword">import</span> response._</span><br><span class="line"><span class="keyword">import</span> request._</span><br><span class="line"><span class="keyword">import</span> servlet._</span><br><span class="line"><span class="keyword">import</span> <span class="type">HttpServlet</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Slinky</span>._</span><br><span class="line"><span class="keyword">import</span> com.kanban.views._</span><br><span class="line"><span class="keyword">import</span> com.kanban.models._</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeKanbanApplication</span> <span class="keyword">extends</span> <span class="title">StreamStreamServletApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Request</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Response</span>._</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> charset = <span class="type">UTF8</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">param</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>]) =</span><br><span class="line">  (request ! name).getOrElse(<span class="type">List</span>[<span class="type">Char</span>]()).mkString(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>],</span><br><span class="line">    servletRequest: <span class="type">HttpServletRequest</span>): <span class="type">Option</span>[<span class="type">Response</span>[<span class="type">Stream</span>]] = &#123;</span><br><span class="line">    request <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;create&quot;</span> :: <span class="type">Nil</span>) =&gt;</span><br><span class="line">          <span class="type">Some</span>(<span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt;</span><br><span class="line">          <span class="type">CreateStory</span>(param(<span class="string">&quot;message&quot;</span>)))</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> application = <span class="keyword">new</span> <span class="type">ServletApplication</span>[<span class="type">Stream</span>, <span class="type">Stream</span>] &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>,</span><br><span class="line">  servletRequest: <span class="type">HttpServletRequest</span>, request: <span class="type">Request</span>[<span class="type">Stream</span>]) = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]) : <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">      handle | resource(found, <span class="type">NotFound</span>.xhtml)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加了两个新的方法handle和param，handle方法用于将匹配请求到函数。它使用了一个Scalaz 的Extractor对象 MethodParts，该对象将Scalaz请求拆分为请求类型和URL部分。HTTP GET请求 <a href="http://localhost:8080/card/create">http://localhost:8080/card/create</a> 会被拆分为 GET请求类型 和 URL <code>&quot;card&quot;::&quot;crate&quot;::Nil</code> 这两部分。当请求匹配后，创建一个Scalaz Response 来渲染页面 <code>Some(OK(ContentType, &quot;text/html&quot;) &lt;&lt; strict &lt;&lt; CreateStory(param(&quot;message&quot;)))</code>。其中 CreateStory为一个view对象，<code>OK(ContentType, &quot;text/html&quot;) &lt;&lt; strict</code> 创建一个空的Response，并粘滞有strict HTML文档类型。</p><p>方法param用于获取request请求参数，这里使用了Scalaz定义的 <code>!</code> 方法，方法param将 <code>!</code> 方法处理的结果转换为String类型。Scalaz默认使用<code>List[Char]</code>表示请求参数值的类型。</p><p>当请求URL不匹配定义的handle方法时，返回默认的None。再由 <code>|</code> 方法进行 “或” 处理，执行resource方法载入静态资源。</p><p>现在进入SBT控制台，执行 <code>jetty-run</code>命令开启服务器，在浏览器中输入 <a href="http://localhost:8080/card/create">http://localhost:8080/card/create</a> 进行访问，并点击上面的按钮进行操作。</p><p>单击save按钮时，还没有任何动作，因此，要在application中添加save URL的匹配case：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>],</span><br><span class="line"> servletRequest: <span class="type">HttpServletRequest</span>): <span class="type">Option</span>[<span class="type">Response</span>[<span class="type">Stream</span>]] = &#123;</span><br><span class="line">  request <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;create&quot;</span> :: <span class="type">Nil</span>) =&gt;</span><br><span class="line">    <span class="type">Some</span>(<span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt;</span><br><span class="line">    <span class="type">CreateStory</span>(param(<span class="string">&quot;message&quot;</span>)))</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">POST</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;save&quot;</span> :: <span class="type">Nil</span>) =&gt;</span><br><span class="line">    <span class="type">Some</span>(saveStory)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="type">None</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法saveStory会读取request里面post过来的参数，并实例化一个Story，然后调用save方法。为了读取post里面的方法，需要添加一个工具方法，但和param方法不同，因为是post请求，通常意味着有副作用，所以改用 <code>!</code> 方法来处理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_!</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>]) =</span><br><span class="line">  (request | name).getOrElse(<span class="type">List</span>[<span class="type">Char</span>]()).mkString(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>Story里面的save方法的返回类型是<code>scala.Either[Throwable, String]</code>，就是说如果出现错误返回左边的异常；否则返回右边的成功信息。Left和Right是Either的唯一子类型。因此可以用模式匹配进行处理。当save成功时，你便重定向到应用的创建页面，并带有成功信息；同样，当创建失败时，则在页面显示失败信息。下面是saveStory方法的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">saveStory</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>],</span><br><span class="line">  servletRequest: <span class="type">HttpServletRequest</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> title = param_!(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> number = param_!(<span class="string">&quot;storyNumber&quot;</span>)</span><br><span class="line">    <span class="type">Story</span>(number, title).save <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(message) =&gt;</span><br><span class="line">    redirects[<span class="type">Stream</span>, <span class="type">Stream</span>](<span class="string">&quot;/card/create&quot;</span>, (<span class="string">&quot;message&quot;</span>, message))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(error) =&gt; <span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; transitional &lt;&lt;</span><br><span class="line">    <span class="type">CreateStory</span>(error.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法redirects定义在Response对象中，它表示页面的重定向。</p><p>在运行应用之前，请确保H2数据库服务处于开启状态，下面列出完整的application类代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeKanbanApplication</span> <span class="keyword">extends</span> <span class="title">StreamStreamServletApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Request</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Response</span>._</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> charset = <span class="type">UTF8</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">param_!</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>]) = (request | name).getOrElse(<span class="type">List</span>[<span class="type">Char</span>]()).mkString(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">param</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>]) = (request ! name).getOrElse(<span class="type">List</span>[<span class="type">Char</span>]()).mkString(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>], servletRequest: <span class="type">HttpServletRequest</span>): <span class="type">Option</span>[<span class="type">Response</span>[<span class="type">Stream</span>]] = &#123;</span><br><span class="line">    request <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;create&quot;</span> :: <span class="type">Nil</span>) =&gt; </span><br><span class="line">        <span class="type">Some</span>(<span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; <span class="type">CreateStory</span>(param(<span class="string">&quot;message&quot;</span>)))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">POST</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;save&quot;</span> :: <span class="type">Nil</span>) =&gt;  </span><br><span class="line">        <span class="type">Some</span>(saveStory)      </span><br><span class="line">      <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">GET</span>, <span class="string">&quot;kanban&quot;</span> :: <span class="string">&quot;board&quot;</span> :: <span class="type">Nil</span>) =&gt; </span><br><span class="line">        <span class="type">Some</span>(<span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; <span class="type">KanbanBoard</span>())</span><br><span class="line">      <span class="keyword">case</span> <span class="type">MethodParts</span>(<span class="type">POST</span>, <span class="string">&quot;card&quot;</span> :: <span class="string">&quot;move&quot;</span> :: <span class="type">Nil</span>) =&gt; </span><br><span class="line">        <span class="type">Some</span>(moveCard)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveCard</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>], servletRequest: <span class="type">HttpServletRequest</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> number = param_!(<span class="string">&quot;storyNumber&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> toPhase = param_!(<span class="string">&quot;phase&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> story = <span class="type">Story</span>.findByNumber(number)</span><br><span class="line">    story.moveTo(toPhase) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Right</span>(message) =&gt; <span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; message</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Left</span>(error) =&gt; <span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; error.getMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">saveStory</span></span>(<span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">Stream</span>], servletRequest: <span class="type">HttpServletRequest</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> title  = param_!(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> number = param_!(<span class="string">&quot;storyNumber&quot;</span>)</span><br><span class="line">    <span class="type">Story</span>(number, title).save() <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Right</span>(message) =&gt; redirects[<span class="type">Stream</span>, <span class="type">Stream</span>](<span class="string">&quot;/card/create&quot;</span>, (<span class="string">&quot;message&quot;</span>, message))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Left</span>(error) =&gt; <span class="type">OK</span>(<span class="type">ContentType</span>, <span class="string">&quot;text/html&quot;</span>) &lt;&lt; strict &lt;&lt; <span class="type">CreateStory</span>(error.toString)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> application = <span class="keyword">new</span> <span class="type">ServletApplication</span>[<span class="type">Stream</span>, <span class="type">Stream</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>, servletRequest: <span class="type">HttpServletRequest</span>, request:</span><br><span class="line">    <span class="type">Request</span>[<span class="type">Stream</span>]): <span class="type">Response</span>[<span class="type">Stream</span>] = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]): <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">      handle | <span class="type">HttpServlet</span>.resource(found, <span class="type">NotFound</span>.xhtml)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>现在已经实现了Story的新增功能，删除、修改功能与之类似。这样，我们就可以开始构建完整的weKanban项目了。</p><h3><span id="7~2building-the-kanban-board-pagep212">7~2〖Building the Kanban board page〗P212</span></h3><p>(略… 剩余部分内容为上述内容的重复操作，此处省略)</p><h3><span id="7~3summaryp223">7~3〖Summary〗p223</span></h3><p>在第6、7章我们开始构建我们的第一个中小型Scala应用。我们也由此从REPL环境切换到了SBT环境。你学习了如何使用SBT，如何配置SBT，以及如何通过SBT导入依赖、管理依赖来构建我们的项目。紧接着，我们学习了使用Scalaz HTTP 模组来构建我们的web应用，以及学习了函数式编程的概念是如何运用到web应用中。Scalaz使用了Scala的高阶函数(higher-order functions)和模式匹配暴露了优秀的APIs。构建企业级应用程序意味着你需要和关系型数据库打交道。我们学习了Squeryl，Scala的ORM工具，并学习了如何在Scala应用中构建关系型数据模型。</p><p>本章已经提供了足够的基础使用各种Scala工具来构建我们的应用。我鼓励使用不同的Scala ORM工具、视图模版引擎、web框架来构建或扩展这些应用。我希望这两章学习的这些概念和工具之后，可以使你更舒适地在各种Scala工具市场中驾驭。</p><p>在本章，我们稍稍瞥见了隐式转换和隐式参数。下一章我们将深入到Scala的类型系统，以及如何使用类型来构建抽象的层面。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">A fork of SLICK to keep old links to the ScalaQuery repository alive, <a href="http://github.com/szeiger/scala-query">http://github.com/szeiger/scala-query</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Querulous, an agreeable way to talk to your database, <a href="http://github.com/nkallen/querulous">http://github.com/nkallen/querulous</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">“Class ThreadLocal<t>,” Java Platform Standard Ed. 6, <a href="http://mng.bz/cqt0">http://mng.bz/cqt0</a>.</t></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">“Scalate: Scala Template Engine,” Scalate 1.5.3, <a href="http://scalate.fusesource.org">http://scalate.fusesource.org</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">“Group and Aggregate Queries,” <a href="http://squeryl.org/group-and-aggregate.html">http://squeryl.org/group-and-aggregate.html</a>.</span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章：构建函数式风格的Web应用</title>
      <link href="/2016/10/27/scala/06-functional-webapp/"/>
      <url>/2016/10/27/scala/06-functional-webapp/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>使用SBT(Simple Build Tool)工具构建项目。</li><li>Scalaz HTTP 模块。</li><li>创建一个WEB应用程序weKanban。</li></ol><p>本书的第二部分开始，将关注于Scala函数式编程的实际应用。现在早已有Web应用框架 <a href="http://liftweb.net">Lift</a> 和 <a href="http://www.playframework.org">Playframework</a> 开构建web应用程序。但是本章介绍的是一个有趣的Scala http库——Scalaz。这个简单的库让你更加专注于函数式web应用的构建，而不用担心全栈的Web框架带来的复杂性问题。<br>HTTP 请求并产生一个HTTP响应。每个URL端点被映射到一个函数中，这个函数则用来处理request。因为你创建的是一个函数式风格，web应用程序的状态被显式地被指定在每个请求中。这样想的好处是，你可以将web应用程序进行组合或者使用高阶的组合。web框架的对应策略是无状态的和可变的。在本章内容中，你将学习到使用函数式编程来构建一个web应用框架。<br>要到达终点，首先要知道如何创建一个应用程序，如何使用。或许我们使用过了比较多的构建工具，但是比较标准的构建工具是SBT。这里将介绍如何配置和使用SBT来构建Scala Web项目。</p><span id="more"></span><h3><span id="6~1building-wekanban-a-simple-web-based-kanban-boardp170">6~1〖Building weKanban: a simple web-based kanban board〗P170</span></h3><p>你准备构建一个web应用程序——看板娘<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。主要业务流程有：</p><ul><li>作为客户，你想要创建一个新的用户故事，这样我可以将故事添加到准备状态。</li><li>作为开发者，我想要将cards(stories)从一个状态移到另外一个状态，这样我可以对操作进行标记。</li></ul><p>在此之前，首先让我们学会使用SBT构建我们的应用程序。</p><h3><span id="6~2building-scala-applications-using-simple-build-toolp171">6~2〖building Scala applications using Simple Build Tool〗P171</span></h3><p>SBT<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 是一个Java和Scala的构建工具，完全用Scala编写，你可以用Scala代码或者SBT内建的DSL语言来构建项目和依赖。之所以使用SBT构建的好处定义是来自于强大的功能和类型安全的语言。他和Maven和Ant有所不同，Maven和Ant构建配置写在XML中。<br>SBT提供了持续的编译和测试，这意味着，SBT会在你的代码发生改变时自动编译和测试。所以你应该使用这些特性在Web服务自动部署上。<br>下面的一小部分内容将向你介绍SBT，从安装到环境变量，以及SBT的目录结构。我将从构建webKanban项目开始全面介绍。</p><h3><span id="621setting-up-sbtp172">6<sub>2</sub>1〖Setting up SBT〗P172</span></h3><p>最简单的方式是直接下载<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> SBT的相应jar文件，并直接使用脚本运行，依赖于不同的操作系统。</p><p>UNIX<br>创建一个SBT文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:MaxPermSize=384M -jar `dirname <span class="variable">$0</span>`/sbt-launch.jar <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><p>把SBT文件放在~/bin文件夹中，并和下载的jar放在一起，配置好环境变量。当然，你需要设置文件的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chmod u+x ~/bin/sbt</span><br></pre></td></tr></table></figure><p>CMSClassUnloadingEnabled表示可以允许垃圾回收机制。</p><p>WINDOWS</p><p>使用下面命令来创建批文件sbt.bat，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set SCRIPT_DIR=%~dp0</span><br><span class="line">Java –Xmx512M –jar <span class="string">&quot;%SCRIPT_DIR%sbt-launch.jar&quot;</span> %*</span><br></pre></td></tr></table></figure><p>再把下载的jar放置在相同的目录中，并使改目录可以被访问。</p><p>MAC</p><p>对于MAC的用户则比较简单，使用Homebrew 或者 MacPorts来直接安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install sbt</span><br><span class="line">sudo port install sbt</span><br></pre></td></tr></table></figure><p>你不用下载jar文件，如果你设置了HTTP代理，你需要传递相应的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword -Xmx512M</span><br><span class="line">-jar `dirname <span class="variable">$0</span>`/sbt-launch.jar <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h3><span id="622understanding-the-basics-of-sbtp173">6<sub>2</sub>2〖Understanding the basics of SBT〗P173</span></h3><p>对于理解SBT的基础内容比较重要。SBT是一个富特性(feature-rich)的构建工具，本小节的主要目标是理解SBT的基础内容。更多详细内容，请参考 <a href="http://scala-sbt.org">http://scala.sbt.org</a>。<br>有三种方式通过SBT来构建项目：</p><ul><li>使用 .sbt 文件来配置项目的构建定义。</li><li>使用 .scala 文件来构建定义。它允许你可以在配置中编写Scala 代码。</li><li>使用 .sbt 和 .scala 文件同时构建。</li></ul><p>第一种方式是最简单的方式。它是一种DSL定义。但在更加复杂的构建中，你需要用到 .scala 构建文件。这就是为什么通常会看到有 .sbt 和 .scala 两个构建文件在Scala的典型项目中。之后，我将解析什么时候需要用到 .scala文件，现在让我们开始SBT的文件构建路程。</p><p><strong>BUILDING THE FIRST SBT BUILD FILE</strong></p><p>SBT按照习惯约定工作。你可以在基础目录中看到Scala的源文件，它位于 src/main/scala 和 src/main/java 文件夹中。一个有效的SBT项目的最低要求是在基础目录中要有一个源文件。让我们从创建Hello world!开始。下面代码片段创建了一个空的文件夹test，并创建一个hello world应用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;object HW &#123; def main(args: Array[String]): Unit = println(&quot;Hello</span></span><br><span class="line"><span class="string">world!&quot;) &#125;&#x27;</span> &gt; hw.scala</span><br></pre></td></tr></table></figure><p>趁热打铁，开始对其进行编译和运行。在SBT的命令提示符环境中，你可以调用编译任务来对源文件进行编译。编译好了之后，调用run 命令来运行这个示例。你应该得到如下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; run</span><br><span class="line">[info] Running HW</span><br><span class="line">Hello world!</span><br><span class="line">[success] Total time: 0 s, completed ...</span><br></pre></td></tr></table></figure><p>SBT智能地选择项目中基础目录中的源文件，运行run任务时，会查找classpath中的所有类中定义了main方法的类。所有编译了的生成的class文件会放置在target目录下。要查看所有SBT的可用任务命令，可以在SBT提示符中输入tasks查看到。<br>默认地，SBT会使用SBT自带的Scala版本对项目的源文件进行编译。这里使用的是2.10.6。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scala-version</span><br><span class="line">[info] 2.10.6</span><br><span class="line">[info] Reapplying settings ...</span><br><span class="line">[info] Set current project to default-afcdbe...</span><br></pre></td></tr></table></figure><p>你可以容易地更改SBT的默认Scala版本，即通过set命令进行。如下命令可以不用SBT命令提示符的情况下改变项目的名称和版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> name := <span class="string">&quot;Testing SBT&quot;</span></span><br><span class="line">[info] Reapplying settings...</span><br><span class="line">[info] Set current project to Testing SBT</span><br><span class="line">&gt; <span class="built_in">set</span> version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line">[info] Reapplying settings...</span><br><span class="line">[info] Set current project to Testing SBT</span><br></pre></td></tr></table></figure><p>每次你调用set，它会更改项目的设置。简言之，在SBT中，<code>scalaVersion</code>、<code>name</code> 和 <code>version</code> 是预定义的 <code>keys</code>，它们的 <code>values</code> 是<code>String</code>类型。每个keys都是 <code>SettingKey[T]</code> 类型，T就是 值 的运行类型。</p><blockquote><h4><span id="settings-in-sbt">Settings in SBT</span></h4><p>SBT的Settings 就是存储构建定义。它定义了一系列的<code>Setting[T]</code> 的键值对。有三种类型的keys:</p><ol><li><code>SettingKey[T]</code>是value只计算一次的类型。如name 、 scalaVersion。</li><li><code>TaskKey[T]</code>不需要每次重新计算的key-value类型，TaskKey用于创建任务，例如编译和打包。</li><li><code>InputTask[T]</code>是一个task key，用于接收命令行输入的参数。</li></ol><p>所有这些预设keys被定义在sbt.Keys对象中。</p></blockquote><p>为了持久化这些设置，可以在SBT命令提示符中调用session save任务。它会将这些设置保存到基础目录下的build.sbt文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat build.sbt</span><br><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">name := <span class="string">&quot;Testing SBT&quot;</span></span><br><span class="line">version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>现在，你已经创建了你的第一个SBT构建文件。在构建文件中，每一行都是一个表达式，并且每行的表达式都要用空白行隔开，否则，SBT不能对这些表达式进行区分。这些表达式在构建文件中为SBT创建了一些列的设置。SBT的构建定义不是别的，就是表示<code>Setting[T]</code>的一个列表。当所有这些设置被执行，SBT会创建一个不可变的Map键值对。这就是你的构建定义。例如下面的会创建一个<code>Setting[String]</code>设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;Testing SBT&quot;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>:=</code> 是一个key为name的方法调用，上面的表达式你也可以这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name .:=(<span class="string">&quot;Test SBT&quot;</span>)</span><br></pre></td></tr></table></figure><p>所有可用的keys被定义在sbt.Keys对象中，在build.sbt文件中会自动为你导入。你也可以在build.sbt内指定要导入的语句，但要放在文件的开头。build.sbt是配置构建设置的重要地方。例如，你可以添加<code>-unchecked</code>和<code>-deprecation</code>值到键scalacOptions里面，使unchecked和deprecation生效：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-deprecation&quot;</span>)</span><br></pre></td></tr></table></figure><p>方法 <code>++=</code> 可以让你添加多个值到scalacOptions。这里有一点需要重要说明的是，SBT 构建文件都是类型安全的。key的类型确定了value的类型。例如，organizationHomePage可以设置一个组织的home page，它是一个<code>Option[URL]</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> organizationHomepage := <span class="string">&quot;22&quot;</span></span><br><span class="line">&lt;<span class="built_in">set</span>&gt;:1: error: <span class="built_in">type</span> mismatch;</span><br><span class="line">found : java.lang.String(<span class="string">&quot;22&quot;</span>)</span><br><span class="line">required: Option[java.net.URL]</span><br><span class="line">organizationHomepage := <span class="string">&quot;22&quot;</span></span><br></pre></td></tr></table></figure><p>目前对于类型安全的构建工具有不少争议，但我认为对于你的代码、构建文件，类型安全是个好东西。对于一些中大型项目，你会为你的系统编写非常大量的代码，而SBT提供的类型安全机制则可以有更快的信息反馈。下一小节你将学习使用SBT来构建一个更加正式的项目。</p><p><strong>BUILDING A PROJECT STRUCTURE FOR SBT</strong></p><p>如果你此前使用过SBT 0.7+，你会惊讶于SBT并没有创建一个Maven-style风格的的项目结构。但是不用担心，现在你可以有更多的方式来创建你的项目了。你可以使用下面的代码片段来创建所有典型的文件目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p src/&#123;main,<span class="built_in">test</span>&#125;/&#123;scala,java,resources&#125; lib project</span><br></pre></td></tr></table></figure><p>它会为一个典型的Scala应用创建所有的目录文件。另外一个选项是，你可以使用SBT插件来创建一个新的项目。一个SBT插件通过添加新的任务和设置来扩展构建定义。因为插件可以用来构建SBT项目，因此它可以作为一个全局插件添加。全局的插件被添加自动添加到所有SBT项目中；添加一个插件到一个项目中，则只限于当前的项目。若要添加为全局的插件，可以创建一下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch &lt;home-directory&gt;/.sbt/plugins.sbt</span><br><span class="line">$ touch &lt;home-directory&gt;/.sbt/build.sbt</span><br></pre></td></tr></table></figure><p>你现在要使用np插件<a href="https://github.com/softprops/np">np plug-in</a>来生成一个新的项目。要使用它，你需要将下面的行添加到plugins.sbt：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSbtPlugin(<span class="string">&quot;me.lessis&quot;</span> % <span class="string">&quot;np&quot;</span> % <span class="string">&quot;0.2.0&quot;</span>)</span><br><span class="line">resolvers += <span class="type">Resolver</span>.url(<span class="string">&quot;sbt-plugin-releases&quot;</span>,</span><br><span class="line">url(<span class="string">&quot;http://scalasbt.artifactoryonline.com/scalasbt/sbt-plugin-releases/&quot;</span>))(</span><br><span class="line"><span class="type">Resolver</span>.ivyStylePatterns)</span><br></pre></td></tr></table></figure><p>键resolvers告诉SBT到哪里去找这个依赖项，<code>+=</code>表示把一个新的<code>resolvers</code>添加到已有的，函数<code>addSbtPlugin</code>表示添加一个新的插件到SBT构建系统中。现在把下面的行添加的build.sbt文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq(npSettings: _*)</span><br></pre></td></tr></table></figure><p>把它添加到build.sbt表示这个设置将会对所有的SBT项目生效。我们将在不久更详细地介绍SBT的设置。现在我们通过一下命令来创建一个新的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir &lt;your project name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;your project name&gt;</span><br><span class="line">$ sbt np</span><br></pre></td></tr></table></figure><p>插件np也会创建一个默认的build.sbt文件，你可以修改并添加你的设置。</p><p>还有另外一个方式是，使用<a href="https://github.com/n8han/giter8">giter8</a>。它是一个命令行工具，通过在Github上发布的模版，用它来生成文件和目录。这慢慢地变成了创建Scala项目的一个标准方式。一旦giter8被安装了，你可以选择一个模版来生成项目的结构。</p><p><strong>提示</strong> 你不需要在SBT提示符里面执行SBT任务——你可以在命令行里面执行。例如，sbt compile run命令将同时执行compile和run。</p><p>不管你如何创建项目结构；它的目录结构看起来和Maven是相似的，因为SBT使用了Maven的目录结构。实际上，如果你在Maven里使用了<a href="http://scala-tools.org/mvnsites/maven-scala-plugin/">Scala plug-in</a>来创建一个项目，最终你会得到近似相同的目录结构。如果你的项目包含了Java源文件有包含了Scala源文件，你需要同时有一个java目录位于src/main 和 src/test。</p><p>图6.2为一个完整的SBT项目，并展示了所有可能的构建配置。就像你看到的build.sbt一样，它是一个简单构建工具，它允许你设置各种与构建相关的settings和dependencies。dependencies的配置之后将学习到。</p><p><strong>提示</strong> 有一个争论是如何命名<em>build</em>，如build.sbt 或 build.scala，但实际上你可以使用任何名字。这也意味着，你可以在一个项目中拥有多个.sbt 和 .scala构建文件。</p><p>构建文件build.scala带给你SBT的全部能力。你可以在build.scala中编写Scala代码来配置你的构建，而不是使用DSL(Domain Specific Language，领域专用语言)。在旧版本的SBT，配置构建文件仅仅只能使用SBT DSL来编写。但在 “新” SBT中，这个方式被推荐用于简单的构建定义(build.sbt 文件)，只有当被需要时，则再创建 build.scala。对于你现在的项目weKanban，你将会两个都用到。</p><p>另外一个文件 build.properties 允许你设置SBT的版本，并用于该项目中。例如，我的build.properties配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt.version=0.12.0</span><br></pre></td></tr></table></figure><p>设置的版本会被用于项目中。project/plugins.sbt 文件，典型地用于配置SBT插件的。另外请注意，项目中用build.scala 和 plugin.sbt来构建项目是可选的，只有真正被用到时才需要添加。target文件夹则是用于存储生成的classes、.jar文件；其它的artifacts (如project、java、resources、scala等文件夹)则由配置生成。</p><p><img src="/img/scala-in-action/chapter6/sbt_project_structure.png" alt="Figure 6.2"></p><p><strong>注意</strong> 总是从.sbt文件开始构建项目，.scala文件仅仅只有在被需要时添加。经验法则是，.sbt文件定义所有的设置，.scala文件则是当你需要引入一个变量、对象、方法定义时使用。在多项目的工程中，build.scala文件被用于定义功能的设置和任务。</p><p>SBT项目结构是递归的。也就是说，一个项目如果在另外一个项目内，它将遵循父级项目的构建。并且project/project知道如何构建父级项目。.scala构建配置是一个SBT项目。</p><p><strong>ADDING DEPENDENCIES AND CUSTOM TASKS</strong></p><p>使用SBT，你有两种方式来管理依赖关系(dependencies)： <em>手动</em> 和 <em>自动</em>。对于手动的方式，则是 拷贝.jar文件到 lib 文件夹，SBT会在编译、运行、测试时，将这些 .jar添加到 classpath环境变量。缺点就是，你需要负责管理这些 .jar、更新和添加.jar。在SBT项目中，最常见和被推荐的方式是让SBT来为你管理这些依赖关系。对于自动的方式，你需要在构建文件中指定依赖，然后SBT处理这些结果。例如，下面在build.sbt添加一个jetty依赖关系：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % <span class="string">&quot;9.3.7.v20160115&quot;</span></span><br></pre></td></tr></table></figure><p>其中，libraryDependencies 是 settings 的 key，用于添加依赖项，并让SBT自动处理。该 key 将存储所以依赖关系的序列对。下面为build.sbt依赖关系构建 value 的格式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupID % artifactID % version</span><br></pre></td></tr></table></figure><p>这种依赖引用的方式，实际上就是Maven POM文件的处理方式。任何依赖由上面的三个属性唯一标识。</p><p><strong>注意</strong> 如果你在groupID 后面使用 <code>%%</code> ，SBT会自动为artifactID添加上版本号，如 <code>&quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.0-M7&quot;</code>，它实际上等价于 <code>&quot;org.scalatest&quot; % &quot;scalatest_2.10&quot; % &quot;3.0.0-M7&quot;</code>。每个scala库都有不同的SBT版本。</p><p>SBT使用了一系列的resolvers来链接项目依赖并下载。在SBT中，一个resolver是依赖host的一个URL(和Maven repository类似)。默认地，SBT使用Maven2 和 Typesafe ivy releases<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> 来处理这些依赖。你可以使用resolvers 来添加一个存在的依赖链接。</p><blockquote><h4><span id="using-sbt-on-existing-maven-scala-projects">Using SBT on existing Maven Scala projects</span></h4><p>以为SBT沿用了Maven项目结构并使用了Maven依赖，为Maven项目创建SBT则显得容易。你如果在构建文件中使用了<code>externalPom()</code>方法，SBT可以读取定义在POM文件的依赖定义。注意，你仍然需要自定repository：<br>可选地，你可以创建一个项目定义文件，配置其使用本地的Maven仓库：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvers += <span class="string">&quot;Local Maven Repository&quot;</span> at <span class="string">&quot;file://&quot;</span>+<span class="type">Path</span>.userHome+<span class="string">&quot;/.m2/repository&quot;</span></span><br></pre></td></tr></table></figure></blockquote><p>SBT自动地拾取构建文件的改变，你也可以显式地运行 reload 和 update 任务来重新编译并处理依赖。</p><p><strong>注意</strong> SBT使用了Apache的Ivy实现和管理依赖关系。Apache Ivy是一个灵活的、可配置的依赖管理器。</p><p>你也可以声明依赖的作用范围scope，即在依赖声明的版本号后面额外添加一个配置。如下面为specs库添加一个依赖声明，但仅仅作用于test配置：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">&quot;org.scala-tools.testing&quot;</span> % <span class="string">&quot;specs&quot;</span> % <span class="string">&quot;1.6.2&quot;</span> % <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>现在，该依赖项仅会作用于src/main/test，下面是build.sbt改变后的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">name := <span class="string">&quot;Testing SBT&quot;</span></span><br><span class="line">version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-deprecation&quot;</span>)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line"><span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % <span class="string">&quot;7.0.0.RC2&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.scala-tools.testing&quot;</span> % <span class="string">&quot;specs&quot;</span> % <span class="string">&quot;1.6.2&quot;</span> % <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p>另外一个最常的SBT操作就是为项目创建自定义任务。对于自定义任务，.scala构建定义文件被用到，因为.sbt构建文件不支持。创建自定义任务遵循以下几个步骤：</p><ol><li>创建一个TaskKey。</li><li>为TaskKey提供一个 value。</li><li>把任务放置在项目下的.scala构建文件。</li></ol><p>TaskKey 和 SettingKey相似，但它是用来定义任务的。主要不同是，SettingKey 的 value 只被执行一次，但 TaskKey 的 value在该key每次被访问时执行。这就使得tasks可以一次又一次地被执行。但两者都会产生settings(key-value 对)。下面展示了一个简单的build.scala文件，该文件仅定义了一个hello world任务：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sbt._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Keys</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExampleBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 创建一个TaskKey</span></span><br><span class="line">  <span class="keyword">val</span> hello                          = <span class="type">TaskKey</span>[<span class="type">Unit</span>](<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Prints &#x27;Hello World&#x27;&quot;</span>)</span><br><span class="line">  <span class="comment">// 2. 定义task</span></span><br><span class="line">  <span class="keyword">val</span> helloTask: <span class="type">Setting</span>[<span class="type">Task</span>[<span class="type">Unit</span>]] = hello := &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> project                        = <span class="type">Project</span>(</span><br><span class="line">    <span class="string">&quot;example&quot;</span>,</span><br><span class="line">    file(<span class="string">&quot;.&quot;</span>)).settings(helloTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目的名称只是一个例子，文件 Build.scala应该在example/project目录下。首先创建一个新的TaskKey，包含name和description，这里的name参数为hello，并被用于命令提示符调用。声明一个闭包来定义一个任务helloTask，并被用于所在的项目。</p><p>项目的构建定义应该继承sbt.Build，继承以访问默认的构建设置。每个构建定义应该定义一个或多个项目。这里只有一个项目，对于多项目工程，你应该在这里声明所有的子项目。多项目的构建定义超出了本书的范围，你可以在 <a href="http://scala-sbt.org">这里</a> 获取到更多详细内容。因为要将hello任务添加到项目，你需要在该项目的SBT环境下执行如下操作：</p><p><img src="/img/scala-in-action/chapter6/sbt_task.png" alt="sbt task"></p><blockquote><h4><span id="debugging-project-definition-in-interactive-mode">Debugging project definition in interactive mode</span></h4><p>取决于你所工作的scala项目的大小，构建定义会变得非常大。为了在定义中对任何问题进行故障排除，SBT提供了一个task叫做 <em><code>console-project</code></em> 。如果你在SBT控制台内执行该构建命令，SBT会构建定义中载入Scala解析器。如果你运行 console-project 命令，它会加载所有你的构建和插件定义，并使得它们可以访问。在example例子中运行console-project ，你可以访问它的 settings 和 tasks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; get(name)</span><br><span class="line">res2: String = Testing SBT</span><br><span class="line">scala&gt; get(scalaVersion)</span><br><span class="line">res3: String = 2.10.0</span><br><span class="line">scala&gt; runTask(hello, currentState)</span><br><span class="line">Hello World</span><br><span class="line">res11: (sbt.State, Unit) = (sbt.State@4fae46d5,())</span><br></pre></td></tr></table></figure><p>runTask 用于运行构建中的任务。在这里的task是 hello task。currentState 跟踪SBT的命令。</p><p>相似地，你可以运行 console 构建命令的 Scala 解析器。</p></blockquote><p>截至目前，你已经有了所有有关SBT的基础知识内容，以及用它来构建一个web应用。下一小节开始构建webKanban项目结构，以及如何使用SBT来构建web应用。</p><h4><span id="setting-up-the-wekanban-project-with-sbt">Setting up the weKanban project with SBT</span></h4><p>为了建立weKanban项目，首先创建如下项目结构。</p><p><img src="/img/scala-in-action/chapter6/weKanban.jpg" alt="Figure 6.3"></p><p>除了添加了一个webapp之外，项目结构和 Figure 6.2相同。</p><p>首先是设置SBT的版本，在 weKanban 项目 project/build.properties 中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt.version = <span class="number">0.12</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>文件build.properties的唯一目的就是设置 sbt.version 版本号。这里设置为 0.12.0。如果本地SBT版本不可用，则会自动下载该文件定义的相应的版本。下一步，添加与项目相关的构建信息到build.sbt文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;weKanban&quot;</span></span><br><span class="line"></span><br><span class="line">version := <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">scalaVersion := <span class="string">&quot;2.10.6&quot;</span></span><br><span class="line"></span><br><span class="line">organization := <span class="string">&quot;Scala in depth&quot;</span></span><br><span class="line"></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-deprecation&quot;</span>, <span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-feature&quot;</span>)</span><br></pre></td></tr></table></figure><p>记住每个settings表达式要空一行，SBT才能解释.sbt文件的每个表达式。当SBT加载一个 .sbt 文件，便为每个定义在 .sbt 文件中的所有表达式创建了一个<code>Seq[Setting[T]]</code>。</p><p>为了让项目支持web，你需要使用 <a href="https://github.com/siasia/xsbt-web-plugin">SBT web插件</a> ，该插件使用的是jetty服务器，并添加tasks到SBT，以启动、结束jetty服务器。下面是添加该插件的表达式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies &lt;+= sbtVersion &#123; v =&gt; <span class="string">&quot;com.github.siasia&quot;</span> %% <span class="string">&quot;xsbt-web-plugin&quot;</span> % (v+<span class="string">&quot;-0.2.11.1&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个web插件作为一个依赖添加到项目中，添加一个插件，实际上就是在构建定义中添加一个库依赖。其中方法 <code>&lt;+=</code> 表示从其他keys计算一个新的list集合。这里的 sbtVersion，用于决定确切的插件版本。实际上，它的apply语法糖就是用来统计插件的版本的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies &lt;+= sbtVersion.apply &#123; v =&gt; <span class="string">&quot;com.github.siasia&quot;</span> %% <span class="string">&quot;xsbt-web-plugin&quot;</span> % (v+<span class="string">&quot;-0.2.11.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>在使用插件启动、结束web服务之前，你还要添加相应的jetty依赖项到build.sbt中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-servlet&quot;</span> % <span class="string">&quot;9.3.7.v20160115&quot;</span> % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-webapp&quot;</span> % <span class="string">&quot;9.3.7.v20160115&quot;</span> % <span class="string">&quot;test,container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % <span class="string">&quot;9.3.7.v20160115&quot;</span> % <span class="string">&quot;container&quot;</span>,</span><br><span class="line">  <span class="string">&quot;commons-logging&quot;</span> % <span class="string">&quot;commons-logging&quot;</span> % <span class="string">&quot;1.1.1&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意，jetty依赖项被添加到container scope，另外，jetty-web被添加到test scope。这里的scope 指的是sbt 键-值的上下文范围。你可以把scope认为是一个命名空间机制(name-spacing mechanism)，表示一个key，在不同的范围(scopes)有不同的值。例如，在一个多项目构建中，你可以在不同的项目中，设置不同sbtVersion版本。这点对于插件来说非常有用，因为不同插件创建的任务不会和其他任务发生冲突。要将插件的所有任务引入到你的项目中，你必须将插件项目的settings，导入到你的build.sbt文件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq(com.github.siasia.<span class="type">WebPlugin</span>.webSettings :_*)</span><br></pre></td></tr></table></figure><p>在SBT命令提示符中，如果没有出错，将看到下面的附加任务(你可能需要执行reload)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; container:</span><br><span class="line">apps classpath-types configuration</span><br><span class="line">configuration-files configuration-xml custom-configuration</span><br><span class="line">discovered-contexts full-classpath managed-classpath port</span><br><span class="line">reload start</span><br><span class="line">state stop streams thisproject-</span><br><span class="line">ref update</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 该插件的新版本已经迁移，请以新版本为准。</p><p>为了运行该web服务，请在控制台中运行<code>container:start</code>任务，它将开启jetty端口为8080服务。因为sbt开启的jetty server的一个分支，你可以在控制台上执行其它构建动作。在浏览器http://localhost:8080/，你可以看到一个webapp的文件夹。至此，你已经完成了你的构建设置。你可能需要添加更多的依赖项。现在，让我们转换话题，谈论一下Scalaz，一个用于构建Scala web应用的框架。</p><h3><span id="6~3introducing-the-scalaz-http-modulep183">6~3〖Introducing the Scalaz HTTP module〗P183</span></h3><p>Scalaz(读作：“Scala-zed”)是一个用Scala编写的库。Scalaz背后的思想是提供一个标准Scala API所没有提供的通用函数。本小节介绍的HTTP模块就是来源于Scalaz核心部分。当你使用HTTP模块功能时，我们将接触到Scalaz的核心APIs。下面首先讲解下Scalaz中会被用于webKanban项目的模块内容。</p><h3><span id="631how-the-scalaz-http-library-worksp183">6<sub>3</sub>1〖How the Scalaz HTTP library works〗P183</span></h3><p>简单来说，Scalaz HTTP 库就是Java Servlet APIs的一个转换。Scalaz HTTP的主要目的就是实现一个转换一个HTTP请求为一个响应的方式。实际上就是我们第6.1所讲的，将HTTP URLs映射为functions，该function以request作为参数，response作为返回值。下面是一个Scalaz中的web Application 特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Application</span>[<span class="type">IN</span>[_], <span class="title">OUT</span>[_]] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(<span class="keyword">implicit</span> req: <span class="type">Request</span>[<span class="type">IN</span>]): <span class="type">Response</span>[<span class="type">OUT</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质Application定义了一个单一的apply方法，该方法接收一个request实例，并返回一个response实例。实现该方法，创建一个工厂方法，接收一个用于转换request为response的function参数。如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">application</span></span>[<span class="type">IN</span>[_], <span class="type">OUT</span>[_]](f: <span class="type">Request</span>[<span class="type">IN</span>] =&gt; <span class="type">Response</span>[<span class="type">OUT</span>])</span><br><span class="line">    = <span class="keyword">new</span> <span class="type">Application</span>[<span class="type">IN</span>,<span class="type">OUT</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(<span class="keyword">implicit</span> req: <span class="type">Request</span>[<span class="type">IN</span>]) = f(req)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法application通过传递函数，接收一个请求，并返回一个响应实例，最终创建一个Application实例。特质Application里面的参数看起来和以往的有点不一样，在Scala中，称之为 <strong><em>高级类类型(higher-kinded types)</em></strong> 。你可以认为是它是参数类型的指定类型(类型的类型)。这里很难理解，下面分解讲述下：</p><blockquote><h4><span id="another-example-of-higher-kinded-types">Another example of higher-kinded types</span></h4><p>在Scalaz库中，我们已经看过了 高级类类型，现在通过学历一个例子，来理解为什么高级类类型如此强大。现在知道，高级类类型就是一个 类型组，以及我们可以编写一个函数来操作该 类型组，高级类类型是该函数的常见实现形式。例如，我们要实现一个函数sum，该函数可以操作Scala集合里面的所有类型。如何实现？通常的实现方式是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumList</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = xs.foldLeft(<span class="number">0</span>)(_ + _)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumArray</span></span>(xs: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = xs.foldLeft(<span class="number">0</span>)(_ + _)</span><br></pre></td></tr></table></figure><p>但是这种实现方式并不高效，但如果我们为所有集合类型创建一个抽象，并编写一个通用的sum函数作用于这个抽象。也就是说，让sum函数接收一个包含所有类型的实现+function。为了实现这个功能，创建一个特质Summable，参数化类型为A：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summable</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，所有类型都支持+function，并实现这个特质。下面是Int和String类型的实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntSummable</span> <span class="keyword">extends</span> <span class="title">Summable</span>[<span class="type">Int</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a1: <span class="type">Int</span>, a2: <span class="type">Int</span>): <span class="type">Int</span> = a1 + a2</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringSummable</span> <span class="keyword">extends</span> <span class="title">Summable</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>): <span class="type">String</span> = a1 + a2</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，你可以实现其它类型。现在，要实现所有集合类型的sum逻辑，使用foldLeft函数，但是这时应该首先创建高级类类型foldLeft函数的抽象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foldable</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>](xs: <span class="type">F</span>[<span class="type">A</span>], m: <span class="type">Summable</span>[<span class="type">A</span>]) : <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在为每个集合类型实现该特质：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListFoldLeft</span> <span class="keyword">extends</span> <span class="title">Foldable</span>[<span class="type">List</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>](xs:<span class="type">List</span>[<span class="type">A</span>],m:<span class="type">Summable</span>[<span class="type">A</span>]) =</span><br><span class="line">  xs.foldLeft(m.init)(m.plus)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ArrayFoldLeft</span> <span class="keyword">extends</span> <span class="title">Foldable</span>[<span class="type">Array</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>](xs:<span class="type">Array</span>[<span class="type">A</span>],m:<span class="type">Summable</span>[<span class="type">A</span>]) =</span><br><span class="line">  xs.foldLeft(m.init)(m.plus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用该特质，实现你的sum函数，你的通用sum函数接收三个参数：集合、foldable特质的实例、给定的Summable特质类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">F</span>[_], <span class="type">A</span>](xs: <span class="type">F</span>[<span class="type">A</span>], f: <span class="type">Foldable</span>[<span class="type">F</span>], m: <span class="type">Summable</span>[<span class="type">A</span>]): <span class="type">A</span> = f.foldLeft(xs, m)</span><br></pre></td></tr></table></figure><p>这里你为集合类型和集合接收类型，类型参数化sum函数。现在处理string数组和整形列表，你可以使用下面的操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="type">ListFoldLeft</span>, <span class="type">IntSummable</span>)</span><br><span class="line">sum(<span class="type">Array</span>(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>), <span class="type">ArrayFoldLeft</span>, <span class="type">StringSummable</span>)</span><br></pre></td></tr></table></figure><p>不可否认，这个sum函数看起来有点冗余，还不如<code>sum(List(1,2,3))</code>和<code>sum(Array(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;))</code>来得清楚，不过我们会在下个章节进行定义实现。在小规模上下文中，这种方式看起来做了大量的工作，但在大规模的上下文，这是创建抽象的强大方式，你会在下个章节看到一些真是案例。</p></blockquote><p>不管是request或者response，都要从输入流和输出流进行HTTP参数的读写。但是如果我们能够把输入、输出流看作一个集合，岂不妙哉？request和response都包含集合类型byte，这样我们可以对此使用所有的集合API方法。Scalaz特别允许使用类型参数。开箱即用，你可以使用<code>scala.collection.Stream</code> 或 <code>scala.collection.Iterator</code> 参数化<code>Request</code> 或 <code>Response</code>。下面是调用application方法的一种方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Application</span>.application &#123; req: <span class="type">Request</span>[<span class="type">Stream</span>] =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Response</span>[<span class="type">Stream</span>]&#123;</span><br><span class="line">      ...    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处是，你可以使用所有集合API方法处理读、写，而不用太关心输入、输出流。又因为Scala的Stream是一个 nonstrict collection(也称为lazy collection，表示集合不会马上执行，仅在被真正调用时执行)，你可以在你需要它的时候进行读取。既然这样，为什么还需要一个高级类类型(higher-kinded type)？因为Stream是一个集合，拥有自己的参数类型，你需要指明Stream是那个参数的。这里，Stream是byte的，因此，参数<code>IN[_]</code> 和 <code>OUT[_]</code> 在运行时会被调用为<code>Stream[Byte]</code>。</p><p><strong>注意</strong> 从inputStream 到 <code>Request[Stream]</code> 的转换，Scalaz HTTP模块中，通过调用<code>scalaz.http.InputStream</code>实现。该类使用Scalaz核心库将inputStream 转换为Scala Stream。</p><p>要在Jetty或其它容器中部署你的web应用，你必须熟悉Java Servlet API。前面提及到，Scalaz提供了对Java Servlets的一个封装，因此使用时，不需要过多关心Servlet。图 Figure 6.4 展示了Web容器中，HTTP请求在Scalaz中是如何处理的。</p><p>和标准Java web应用一样，Scalaz使用web.xml配置。典型地，所有URLs映射为<code>scalaz.http.servlet.ScalazServlet</code>的子类。在这里，你会使用到<code>scalaz.http.servlet.StreamStreamServlet</code>。通常，Servlet通过application类名配置，并处理所有的request和response。在weKanban应用中，你需要写application。Servlet类的主要职责是，实例化application类，并将HTTP servlet request 和 servlet response 转换为 Scalaz的 <code>scalaz.http.request.Request</code> 和 <code>scalaz.http.response.Response</code> 对象。</p><p>当web服务接收一个HTTP请求，它将调用ScalazServlet的service方法。该service方法内实现了从HTTP servlet request到Scalaz Request object的转换，并调用web.xml配置的Application特质里面的application方法。application方法一旦返回Scalaz response，它将该response object 在此转换为HTTP servlet response，并反馈给web 服务器，最终反馈给服务器的调用者。带着这些新只是，让我们在SBT配置Scalaz，之后，你就可以实现你的webKanban应用了。</p><p><img src="/img/scala-in-action/chapter6/Figure_6_4.png" alt="Figure 6.4 The way HTTP requests are handled by Scalaz"></p><blockquote><h4><span id="servlet-lifecycle">Servlet lifecycle</span></h4><p>Servlet的声明周期，由其部署的Web容器所控制。当容器接收一个请求并映射到一个Servlet，容器处理下面几个步骤：</p><ol><li>如果Servlet实例不存在，创建一个。</li><li>调用Servlet里面的init方法，初始化该实例。你可以在所处的Servlet接收请求之前，重载该init方法。你也可以将参数传递给init方法。ScalazServlet重载该init方法，并通过该方法参数初始化application类。</li><li>Servlet的service方法，通过传递request 和 response对象进行调用。典型地，一些基于Servlet的框架就是通过重载service方法来调用框架里面的指定的类。例如，ScalazServlet，service方法实现了将HTTP request 、response转换为Scalaz 指定的request、reponse实例，并调用application类处理请求。每个基于Scalaz的web应用都会提供该application的实现。</li></ol></blockquote><h3><span id="632configuring-scalaz-with-sbtp187">6<sub>3</sub>2〖Configuring Scalaz with SBT〗P187</span></h3><p>要在SBT中配置Scalaz，Scalaz必须作为一个依赖项添加到你的webKanbanProjectDefinition.scala文件中。下面清单为Scalaz依赖项配置：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;weKanban&quot;</span></span><br><span class="line">organization := <span class="string">&quot;scalainaction&quot;</span></span><br><span class="line">version := <span class="string">&quot;0.1&quot;</span></span><br><span class="line">scalaVersion := <span class="string">&quot;2.10.0&quot;</span></span><br><span class="line">scalacOptions ++= <span class="type">Seq</span>(<span class="string">&quot;-unchecked&quot;</span>, <span class="string">&quot;-deprecation&quot;</span>)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line"><span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-core&quot;</span> % <span class="string">&quot;6.0.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.scalaz&quot;</span> %% <span class="string">&quot;scalaz-http&quot;</span> % <span class="string">&quot;6.0.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-servlet&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;container&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-webapp&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;test,</span></span><br><span class="line"><span class="string">container&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.eclipse.jetty&quot;</span> % <span class="string">&quot;jetty-server&quot;</span> % <span class="string">&quot;7.3.0.v20110203&quot;</span> % <span class="string">&quot;container&quot;</span></span><br><span class="line">)</span><br><span class="line">seq(com.github.siasia.<span class="type">WebPlugin</span>.webSettings :_*)</span><br></pre></td></tr></table></figure><p>添加完依赖项，当你在scala console 进行reload 或者 update，SBT会从repository下载需要的 Scalaz .jar文件。SBT会自动插件于当前Scala版本兼容的依赖版本。注意，在构建定义中，对于scalaz-core 和 scalaz-http 使用了 %% 而不是 %。这表示SBT会查找与当前Scala版本相匹配的依赖项。如果配置了多个Scala版本，它会为每个版本下载对应的依赖。理想的情况下，你应该使用这种方式来构建项目，但实际上，并不是所有的依赖项都有相对应的Scala兼容。</p><p>在前面小节介绍了Scalaz是如何在Java web server环境工作的，现在我们开始进行配置。首先要构建web.xml文件，对于该文件，不会做太多的介绍。在web.xml文件中有两个比较重要的需要配置的是，Scalaz Servlet 和 application类。下面列出该文件的内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Scalaz<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>scalaz.http.servlet.StreamStreamServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>application<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.kanban.application.WeKanbanApplication<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Scalaz<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，你可以使用StreamStreamServlet作为你的Servlet类。该Servlet会创建<code>scala.collection.Stream</code>类型的request 和 response。com.kanban.application.WeKanbanApplication为所使用的application。当Scalaz初始化后，application传递init-param里面的参数用于初始化。最后，保存web.xml到src/webapp/WEB-INF中。</p><p>开运行该应用之前，你还需要创建WeKanbanApplication。</p><h3><span id="633building-your-first-web-page-using-scalazp189">6<sub>3</sub>3〖Building your first web page using Scalaz〗P189</span></h3><p>你的application类需要继承scalaz.http.servlet.StreamStreamServletApplication特质。该特质声明了<code>scalaz.http.servlet.ServletApplication</code>的抽象，实例化这个特质，就完成了设置。</p><blockquote><h4><span id="what-if-i-want-to-roll-my-own-servlet">What if I want to roll my own servlet?</span></h4><p>通过继承ScalazServlet可以很容易地创建一个servlet。你所要做的事情是，为request和response提供参数类型值，以及提供application的实现类型。例如，下面是你使用的StreamStreamServlet的源代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamStreamServlet</span> <span class="keyword">extends</span> </span></span><br><span class="line"><span class="type">ScalazServlet</span>[<span class="type">Stream</span>,<span class="type">Stream</span>,<span class="type">StreamStreamServletApplication</span>](classOf[<span class="type">StreamStreamServletApplication</span>])</span><br></pre></td></tr></table></figure><p>因为<code>StreamStreamServletApplication</code>为application类，继承该类作为application。application类唯一要求是提供一个<code>ServletApplication</code>的方法或者值调用application。</p></blockquote><p>特质ServletApplication定义的唯一抽象方法是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>,</span><br><span class="line">servletRequest: <span class="type">HttpServletRequest</span>,</span><br><span class="line">request: <span class="type">Request</span>[<span class="type">IN</span>]) : <span class="type">Response</span>[<span class="type">OUT</span>]</span><br></pre></td></tr></table></figure><p>因为你使用一个Servlet来处理HTTP request 和 response，Scalaz为HttpServlet 和 HttpServletRequest提供了访问。</p><p>该方法看起来不同的地方是，在参数前面使用了implicit关键字。声明implicit参数<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>的优雅之处在于，如果该方法漏掉了隐式参数(implicit parameters)，编译器会在闭包环境中，自动查找与之匹配的类型参数，提供给该方法作为此参数。Scala的Implicit是一个强大的概念。第7章将深入了解该内容。我想你早已经实现了Scalaz application类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeKanbanApplication</span> <span class="keyword">extends</span> <span class="title">StreamStreamServletApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> application = <span class="keyword">new</span> <span class="type">ServletApplication</span>[<span class="type">Stream</span>, <span class="type">Stream</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>,</span><br><span class="line">      servletRequest: <span class="type">HttpServletRequest</span>,</span><br><span class="line">      request: <span class="type">Request</span>[<span class="type">Stream</span>]) = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了StreamStreamServletApplication来创建你的application类，它由Scalaz servlet执行处理所有的HTTP request 和 response。唯一的抽象值是要实现application，这里通过实现application方法处理实现。现在，该方法不作任何事情。</p><p>要从web上下文(这里是src/main/webapp)载入静态资源，Scalaz提供了一个很有用的方法resource。通过该方法，你可以载入任何存在的资源请求：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServlet</span>.resource(x =&gt; <span class="type">OK</span> &lt;&lt; x.toStream, <span class="type">NotFound</span>.xhtml)</span><br></pre></td></tr></table></figure><p>这里resource方法会在关联的上下文环境中加载资源，如果找到，执行第一个参数进行传递。第一个参数是一个函数，该函数接收<code>Iterator[Byte]</code>并返回一个<code>Response[Stream]</code>。因此，上述代码和下面等价：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]) : <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">resource(found, <span class="type">NotFound</span>.xhtml)</span><br></pre></td></tr></table></figure><p><code>OK(scalaz.http.response.OK)</code>是一个HTTP状态code伴生类(case classes)，它对应于状态code 200。当你在一个Scalaz状态代码调用<code>&lt;&lt;</code>方法，它会转换为一个空的Scalaz Response对象。一旦转换为Response对象，<code>&lt;&lt;</code>会将stream流追加到response。使用<code>OK &lt;&lt; x.toStream</code>，你由请求资源创建了一个Scalaz Response对象。类似地，NotFound也是一个伴生类，表示HTTP状态404；当调用xhtml方法，它隐式地转换为 &quot;application/xhtml+xml&quot;标头的Scalaz Response。这是使用高阶函数和组合函数的一个很好的例子。第四章内容详细地讨论了高阶函数和函数组合。将上述这些代码片段组合在一起后，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanban.application</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scalaz.<span class="type">Scalaz</span>._</span><br><span class="line"><span class="keyword">import</span> scalaz.http.<span class="type">Slinky</span>._</span><br><span class="line"><span class="keyword">import</span> scalaz.http.request._</span><br><span class="line"><span class="keyword">import</span> scalaz.http.response._</span><br><span class="line"><span class="keyword">import</span> scalaz.http.servlet._</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author Barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeKanbanApplication</span> <span class="keyword">extends</span> <span class="title">StreamStreamServletApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> charset = <span class="type">UTF8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> application = <span class="keyword">new</span> <span class="type">ServletApplication</span>[<span class="type">Stream</span>, <span class="type">Stream</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">application</span></span>(<span class="keyword">implicit</span> servlet: <span class="type">HttpServlet</span>, servletRequest: <span class="type">HttpServletRequest</span>, request:</span><br><span class="line">    <span class="type">Request</span>[<span class="type">Stream</span>]): <span class="type">Response</span>[<span class="type">Stream</span>] = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">found</span></span>(x: <span class="type">Iterator</span>[<span class="type">Byte</span>]): <span class="type">Response</span>[<span class="type">Stream</span>] = <span class="type">OK</span> &lt;&lt; x.toStream</span><br><span class="line">      <span class="type">HttpServlet</span>.resource(found, <span class="type">NotFound</span>.xhtml)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebkankanApplication即为Servlet的 application，它通过继承StreamStreamServletApplication特质实现。</p><p>StreamStreamServletApplication特质定义了类型为ServletApplication的一个单一的抽象值application，你需要重载该值实现自己的application。</p><p>ServletApplication特质也定义了一个抽象方法，叫做application，该方法接收servlet，HTTP request，以及Scalaz请求作为参数。该方法是所有基于Scalaz web应用程序的核心，它的调用通过映射为ScalazServlet的请求实现。</p><p>到目前为止，你的应用仅仅只能处理静态上下文(下一章实现其它内容)，已经通过resource方法来接收两个参数。该方法的第一个参数是一个函数，<code>Iterator[Byte] =&gt; A</code>(这里指Stream) 会载入上下文静态资源请求，并作为bytes输入。在内嵌函数found中，实现了将该<code>Iterator[Byte]</code>转换为Scalaz Response得到相应内容；第二个参数为另一个函数，该函数用于当static 上下文不存在时被执行。NotFound是一个伴生类，它表示HTTP状态代码404，以及xhtml会创建一个404的Scalaz Response。</p><p>下面让我们创建一个index.html文件，该文件位于src/main/webapp，用于web应用的默认界面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>weKanban board will come shortly<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在进入你的SBT控制台，并运行<code>jetty-run</code>构建动作，将开启jetty服务，并将你的web应用部署在服务器上。在浏览器地址栏输入 <a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a> ，将看到该文件页面内容。</p><p><strong>注意</strong> 新版的jetty插件已经迁移，更多请查看 <a href="https://github.com/earldouglas/xsbt-web-plugin%E3%80%82%E6%AD%A4%E5%A4%84jetty%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%BA">https://github.com/earldouglas/xsbt-web-plugin。此处jetty执行命令为</a><code>jetty:start</code> 以及 <code>jetty:stop</code>命令。</p><p>现在，基于SBT和Scalaz web应用已经搭建起来了，我们将继续前进学习更多内容。</p><h3><span id="6~4summaryp192">6~4〖Summary〗P192</span></h3><p>本章是你构建中小型Scala应用的第一步。第一次离开RPEL环境来构建一个Scala应用。你使用了SBT。你学习了如何用它工作，如何配置，如何管理依赖来构建大型Scala应用。你还学习了用Scalaz来构建你的Web应用程序。还学习了函数式编程是如何应用于web应用中。以及，Scalaz中使用了Scala的高阶函数和模式匹配暴露优秀的APIs。</p><p>本章提供了处理各种Scala工具来构建应用的基础知识。在本章，你花了大部分的时间来学习构建 webKanban应用，但不能存储数据。你需要想出一个存储的idea。下一章将探讨Scala在数据库方面的一些有用的工具，一次完成我们的web应用开发。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://en.wikipedia.org/wiki/Kanban">“Kanban”</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">David J. Anderson, Kanban: Successful Evolutionary Change for Your Technology Business, Blue Hole Press, April 7, 2010.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Install, features, and getting started, SBT 0.12.1, <a href="http://scala-sbt.org">http://scala-sbt.org</a>.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">SBT download, <a href="http://mng.bz/1E7x">http://mng.bz/1E7x</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">Index of ivy-releases, <a href="http://repo.typesafe.com/typesafe/ivy-releases">http://repo.typesafe.com/typesafe/ivy-releases</a>.</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">David R. MacIver, “An Introduction to Implicit Arguments,” March 3, 2008, <a href="http://mng.bz/TqwD">http://mng.bz/TqwD</a>.</span><a href="#fnref:6" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章：函数式编程</title>
      <link href="/2016/10/27/scala/05-fp-practise/"/>
      <url>/2016/10/27/scala/05-fp-practise/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容</span></h4><ol><li>为什么函数式编程</li><li>FP和OOP</li><li>各种形式的函数</li><li>Monads以及应用实例</li></ol><p>前面部分或多或少介绍了Scala的函数式编程，或在Scala的面向对象结构中混入了函数式编程。本章将专注于函数式编程概念，以及它们是如何在Scala中实现的。本章主要目的是使你对函数式编程有个清晰的感知，并帮助你编写函数式编程风格代码。</p><p><em>函数式编程</em> 是一个编程范式，将计算行为模拟为表达式的求值。而这个表达式使用函数构建，不带有可变状态和副作用。函数式编程的起源是值得探索的<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 。相信与否，函数式编程始于约1930，Alonzo Church 介绍的 λ演算<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。一个λ演算是一套用于研究函数定义、函数应用和递归的形式系统。λ演算的函数都是第一类值(first-class value）；函数可以接收其它函数作为参数，返回函数作为输出(高阶函数)。</p><span id="more"></span><p>一个带有两个参数的函数，在λ演算中可以写作：</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%CE%BBx.%20%CE%BBy.%20x%20%2B%20y%0A"></p><p>这个的<code>λx. λy. x + y</code>表示一个匿名函数，它接收<code>x</code>参数，返回新的匿名函数<code>λy. x + y</code>，新的匿名函数带有一个<code>y</code>参数，并返回结果<code>x + y</code>。在λ演算中，所有函数都是匿名的，并由符号 <code>λ</code>表示(因而得名lambda)。</p><p>λ演算是函数式编程的主要灵感所在。函数式编程语言以一些约束和类型来实现λ演算。不是所有的编程语言有诸如第一类函数(first-class functions)，模式匹配(pattern matching)之类的特性，但却可能在几乎所有编程语言中作函数式编程。接下来将介绍函数式编程的详细内容。</p><h2><span id="51-什么是函数式编程">5.1 什么是函数式编程？</span></h2><p>函数式编程，顾名思义就是以函数的形式实现编程。在这里不必要花太多来理解函数是什么。根据数学的定义，函数就是存在<code>x∈D</code>，总存在唯一的<code>f(x)</code>与之对应。因此，在Scala中，你可以将一个函数作如下标识：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">X</span> =&gt; <span class="type">Y</span></span><br></pre></td></tr></table></figure><p>一个函数提供了可预测性,对于一个给定的输入你总会得到相同的输出。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def add(a: Int, b: Int): Int = a + b</span></span><br><span class="line">add: (a: Int,b: Int)Int</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> add(10, 10)</span></span><br><span class="line">res0: Int = 20</span><br></pre></td></tr></table></figure><p>这里函数<code>add:(Int,Int)=&gt;Int</code>匹配了函数的定义，因为对于给定的输入，它总是返回相同的结果。<br>但是函数由内部状态决定使得并不能总是返回相同的结果又是怎么样？这类函数也是函数，但是它们不是纯的函数。纯函数不会有副作用。像更新一个全局的或静态的变量，将一个数据写入文件系统，在屏幕上展示这类称之为“副作用(side-effecting)”函数，抛出异常等都是术语副作用例子。纯函数的行为是不依赖于任何内部行为或状态。不允许改变参数的状态或者调用一个带有副作用的函数到另一个纯函数，如下的weather函数不是一个纯函数，因为weather状态会在调用的时候改变:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weather</span></span>(zipCode: <span class="type">String</span>) = &#123;</span><br><span class="line"><span class="keyword">val</span> url =</span><br><span class="line"><span class="string">&quot;http://api.wunderground.com/auto/wui/geo/GeoLookupXML/index.xml?query=&quot;</span></span><br><span class="line"><span class="type">Source</span>.fromURL(url + zipCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要如此关心纯函数？纯函数编程的值(value)又是什么？<br>值是引用透明性的。引用透明(Referential transparency)是指一个属性即一个表达式可以取代它的值而不影响它的程序。下面例子让我们看看引用透明是如何工作的。假设下面是函数程序的一部分:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">val</span> v = add(<span class="number">10</span>, <span class="number">10</span>) + add(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为add是一个纯函数，我可以用函数的调用<code>add(10, 10)</code>来替代它的值20，并且不改变程序的行为。相似地，我也可以用<code>add(5, 5)</code>来代替结果10而不影响程序。那我们为什么要如此关系引用透明？它有什么优势？</p><h3><span id="511-引用透明的好处">5.1.1 引用透明的好处</span></h3><p>引用透明提供了代码的推导能力。通过替换纯函数以及使用纯函数的值，将一个复杂表达式简化为一个简单的表达式。甚至你可以在你的脑海里计算出一个程序的结果。这种代码的思考能力帮助编程工作者更好地调试和解决复杂的问题。它正是函数式编程之所在。面对各种不同的困难，你可以在任何编程语言中做函数式编程。函数式编程的本质是引用透明，它的好处是引用透明——更容易找的问题并修复。因为Scala是类型安全的，你可以在编译之前捕获到更多的异常。</p><p>在Scala中，函数式编程被烤制带有面向对象的特性，因此有时难于区分编程语言中你定义了方法还是定义了函数。这将在本节阐述，但现在需要记住的是，Scala中的方法没有任何类型；类型只关联闭包类，相反函数则由类型和对象所表示。</p><p>不幸的是，目前提出一个函数式语言的定义仍然显得困难。每个人都有他自己的定义机制，但是尽管函数式编程可能会出现在所有语言中，也并不意味着你应该使用它。它可能会出现在OOP编程语言中，但是也可能非常困难地实现，并且用起来很痛苦。在Scala中，编写函数式编程则是非常简单的，下一小节开始掌握。</p><h3><span id="512-一个纯函数式编程">5.1.2 一个纯函数式编程</span></h3><p>一个纯函数式编程是一个单引用透明表达式(single referentially transparent expression)。一个表达式由一个子表达式的组合创建。一个表达式总是求一个结果。如下面是一个纯函数的例子:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PureFunctionalProgram</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = singleExpression(args.toList)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">singleExpression</span></span>: <span class="type">List</span>[<span class="type">String</span>] =&gt; (<span class="type">List</span>[<span class="type">Int</span>], <span class="type">List</span>[<span class="type">Int</span>]) = &#123; a =&gt;</span><br><span class="line">    a map (_.toInt) partition (_ &lt; <span class="number">30</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的main方法是我们纯函数的入口，剩余部分定义了一个单表达式，它接收一个字符集合参数并返回一个<code>Tuple</code>。返回内容有两个子表达式组成: <code>a map (_.toInt)</code> 和 <code>&lt;result of first sub expression&gt; partition(_ &lt; 30)</code>。你可以认为是由一个子表达式集合组合成为一个单引用透明的表达式，你实现了一个纯函数程式。当然，你还需要从控制台或者系统中读取输入参数，但是不管输入内容是什么，纯函数的行为是不会改变的。</p><h2><span id="52-从oop到fp">5.2 从OOP到FP</span></h2><p>Java、C#或者C++编程开发者已经早已熟悉类和对象的概念并更习惯于OOP。那如何从更多的OOP经验过渡到更多的函数式编程风格上呢？在这方面，Scala允许你组合一个优雅的和设计良好的代码风格。它可以从只关注的面向对象开始，你可能慢慢地过渡到一个更多的函数式编程风格。在这个章节将强调一些技术关于函数式编程风格以及目前保留的OO技术和风格支持实现。</p><h3><span id="521-纯与不纯编程">5.2.1 纯与不纯编程</span></h3><p>咋看之下，在纯与不纯的层面上比较面向对象编程与函数式编程，可能会觉得奇怪。尽管你可以编写面向对象代码而不会有side effects，但在编写OOP中更容易充斥着不良的负面效果。典型地，OO-style的应用程序在程序内部会通过大量的对象构建了一系列的可变状态的概念(冗余作用)。<br><strong>面向对象的解决方案是一个环绕着类和对象的模型，这些模型倾向于承载方法的集合，以及共享这些方法或偶尔使这些数据发生变异。</strong> 函数编程风格仅仅解决在函数处理数据中问题的值。因为数据只由值表示，每一个应用中的函数将产生一个新的值而不会带有任何负面效果。<br>另一个区别就是函数式编程提高了在OOP中的抽象层次。OOP有时感觉像机器从属的(machine-dependent)——值传递、引用传递、相等性以及同一性，并基于程式如何在运行时被解析和执行的定义。如果你仅仅对值(values)作处理，那么你的函数式编程如何被解析和执行变得无关紧要。记住，你可以通过纸和笔计算纯函数程序的结果；使用机器运行则是细节实现。</p><p>在诸如Haskell和Clojure语言中，当你仅仅只有函数，你不需要担心不纯问题。但Scala是一门同时包含面向对象和函数编程的语言，因此你必须特别小心副作用(side effects)。在Scala中你仍然需要定义类(或特质traits)和对象来组织你的方法和函数值。并且，你作为一个开发者，你的职责应该确定你不在类内部定义依赖于可变数据。<br>如下面例子，一个矩形带有一个方法用于计算面积:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>(<span class="params">var side: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= side * side</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的问题是side的属性是可变的，area方法依赖于side计算的值。很明显它不是一个纯的处理，因为area方法的结果依赖于外部的状态——这里是side属性。同时也很难推出area方法的值，因为你必须时刻保持与side属性的联系。要实现Square的纯函数，你会用到<code>Successor Value pattern</code>模式<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> ——也叫函数对象模式，即每个状态的改变都返回自身新状态的一个拷贝。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PureSquare</span>(<span class="params">val side: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newSide</span></span>(s: <span class="type">Int</span>): <span class="type">PureSquare</span> = <span class="keyword">new</span> <span class="type">PureSquare</span>(s)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= side * side</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，每次side属性被修改，一个新的PureSquare拷贝会被返回，因此你不需要担心可变状态和area方法的结果，因为它已经被关联到一个新的对象了，PureSquare。这个常用的模式被用于模拟一个可能会更改的状态。Java的String类在通篇全书中使用的例子就是一个函数对象模式。现在你的挑战是以相似的形式设计你的对象，因为它很容易地降低了副作用的无意产生。注意所有你的方法中依赖的vars和setters并尽量使他们是纯的。以后我们要记住: 引用透明是一个良好的设计标准。</p><h3><span id="522-函数式编程的面向对象设计模式">5.2.2 函数式编程的面向对象设计模式</span></h3><p>设计模式在OOP作为交流的工具，在FP中同样重要。一些设计模式，诸如单例(Singleton)、工厂(Factory)、观察者(Vistor)早已作为语言的一部分实现。你可以使用Scala对象轻松地实现单例和工厂模式。你可以使用Scala的模式匹配来实现观察者模式。看看策略模式(Strategy pattern)<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> 。该模式允许你在运行时选择算法，并简单地使用高阶函数实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(product: <span class="type">String</span>, taxingStrategy: <span class="type">String</span> =&gt; <span class="type">Double</span>) = &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> tax = taxingStrategy(product)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>taxingStrategy</code>被定义为一个函数，你可以传递不同的实现strategy。类似地，你也可以使用高阶函数来实现模板方法(template method)模式。</p><p>高阶函数对于处理依赖注入(DI)也很有帮助。你可以使用函数科里化来注入依赖。例如，你可以为tax strategy定义一个类型，以及一个基于strategy和product code的函数，用于计算：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TaxStrategy</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATaxStrategy</span> <span class="keyword">extends</span> <span class="title">TaxStrategy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTaxStrategy</span> <span class="keyword">extends</span> <span class="title">TaxStrategy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>: <span class="type">TaxStrategy</span> =&gt; <span class="type">String</span> =&gt; <span class="type">Double</span> = s =&gt; p =&gt; s.taxIt(p)</span><br></pre></td></tr></table></figure><p>现在我有两个<code>TaxStrategy</code>的实现，<code>ATaxStrategy</code>和<code>BTaxStrategy</code>。其中<code>taxIt</code>为封装的返回<code>String=&gt;Double</code>类型的方法。基于这些设置，你可以更容易地创建一个新函数实现注入不同的策略:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt_a</span></span>: <span class="type">String</span> =&gt; <span class="type">Double</span> = taxIt(<span class="keyword">new</span> <span class="type">ATaxStrategy</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt_b</span></span>: <span class="type">String</span> =&gt; <span class="type">Double</span> = taxIt(<span class="keyword">new</span> <span class="type">BTaxStrategy</span>)</span><br></pre></td></tr></table></figure><p>你有关OO设计模式的知识，在Scala中依然很有用，但是它的实现方式发生了改变。函数式编程带来了一些你之前没有遇到过的设计模式，而这些主要和迭代编程有关。</p><h2><span id="523-建模纯函数式程序">5.2.3 建模纯函数式程序</span></h2><p>前面已经关注过实现纯函数的解决方案，但像编写socket或database这些，如何处理副作用？你不能避免这些问题，实际上任何企业开发的程序都可能有副作用。就此放弃吗？不！一个自欺的做法就是尽量将副作用推向更远一些。你可以创建一个不纯的层，如图，并尽量使应用剩余的部分作为纯函数。在5.5小节你会学习如何在包含必要副作用的代码中建立抽象。</p><p><img src="/img/scala-in-action/chapter5/modeling-purely.png" alt="Separating pure and side-effecting(impure)code.The side-effecting code should form a thin layer around the application"></p><p>为了说明它是如何工作的，你要创建一个简单的HTTP服务器，它用于处理从服务端开启的目录文件。你需要实现HTTP的GET命令。任何服务器一样，HTTP服务器充斥了各种副作用(side effects)，比如写入socket，从文件系统读取文件，等等。现在你对这个服务器设计目标是:</p><ul><li>代码分层，纯代码从副作用代码中分离。</li><li>返回基于HTTP GET请求的一个文件的上下文。</li><li>当请求missing时，返回一个404信息。</li></ul><p>这个问题的实质上是：解析请求，获取请求的文件的名称，定位资源，并返回响应。让我们用适当的类型和函数来表示。Http 请求是一个字节流客户端，建立纯模式(pure model)中不需要担心如何接收，我们只需要关心字节集合:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Request</span> </span>= <span class="type">Iterator</span>[<span class="type">Char</span>]</span><br></pre></td></tr></table></figure><p>相似地，响应也可以用一个字符串集合表示。为了简化，用<code>List[String]</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Response</span> </span>= <span class="type">List</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure><p>资源定位符类型应该能够检测文件是否存在、接收文件内容、并检测内容长度。第一个功能用于确定是否返回200还是404页码。下面是<code>ResourceLocator</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ResourceLocator</span> </span>= <span class="type">String</span> =&gt; <span class="type">Resource</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>: <span class="type">Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contents</span></span>: <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contentLength</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourceLocator</code>作为一个函数类型，<code>String =&gt; Resource</code>传入资源名称并返回Resource。Resource表示定义中的Resource，他提供了将被用于HTTP响应的所有方法。这里关键的是，你创建了一个抽象层，且抽象层允许你通过 <em>值</em> 和 <em>纯函数</em> 设计你的应用。如下代码为完整的纯实现，并在GET成功时返回 HTTP 200，失败时返回 HTTP 404。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Pure</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>: <span class="type">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contents</span></span>: <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contentLength</span></span>: <span class="type">Int</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ResourceLocator</span> </span>= <span class="type">String</span> =&gt; <span class="type">Resource</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Request</span> </span>= <span class="type">Iterator</span>[<span class="type">Char</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Response</span> </span>= <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse HTTP request for filename</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(req:<span class="type">Request</span>)(<span class="keyword">implicit</span> locator:<span class="type">ResourceLocator</span>):<span class="type">Response</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> requestedResponse = req.takeWhile(x =&gt; x != &#x27;\n&#x27;).mkString.split(<span class="string">&quot; &quot;</span>)(<span class="number">1</span>).drop(<span class="number">1</span>)</span><br><span class="line">    (_200 orElse _404)(locator(requestedResponse))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">_200</span></span>:<span class="type">PartialFunction</span>[<span class="type">Resource</span>,<span class="type">Response</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> resource <span class="keyword">if</span> resource.exists =&gt; <span class="string">&quot;HTTP/1.1 200 OK&quot;</span> </span><br><span class="line">    :: (<span class="string">&quot;Date &quot;</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>) </span><br><span class="line">    :: <span class="string">&quot;Content-Type: text/html&quot;</span> </span><br><span class="line">    :: (<span class="string">&quot;Content-Length: &quot;</span> + resource.contentLength) </span><br><span class="line">    :: <span class="type">System</span>.getProperty(<span class="string">&quot;line.separator&quot;</span>) </span><br><span class="line">    :: resource.contents</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">_404</span></span>: <span class="type">PartialFunction</span>[<span class="type">Resource</span>, <span class="type">Response</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">List</span>(<span class="string">&quot;HTTP/1.1 404 Not Found&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，GET方法会接收请求的文件名，然后根据给定的定位器<code>locator</code>对文件进行定位。偏函数<code>_200</code>和<code>_400</code>被定义为表示成功和失败。如果文件存在则调用<code>_200</code>，否则调用<code>_400</code>。<br>现在，服务点的核心部分已经实现了，你需要将它至于真实案例中。首先，你需要开启一个socket端口用于监听请求，你也需要异步处理每个线程，以使当处理旧的请求时监听一个新的请求。在Scala中，你可以找到NanoHttpServer.scala对此的完全实现。下面让我们来关注Resource和ResourceLocator的实现:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Pure</span>._</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">IOResource</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exists</span> </span>= <span class="keyword">new</span> <span class="type">File</span>(name).exists</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contents</span> </span>= <span class="type">Source</span>.fromFile(name).getLines().toList</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contentLength</span> </span>= <span class="type">Source</span>.fromFile(name).count(x =&gt; <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ioResourceLocator: <span class="type">ResourceLocator</span> = name =&gt; <span class="type">IOResource</span>(name)</span><br></pre></td></tr></table></figure><p>其中<code>IOResource</code>使用<code>scala.io.Source</code>从本地文件系统读取文件，<code>ResourceLocator</code>函数接收文件名，并创建一个IOResource实例。唯一剩下的问题是对socket进行读写。可以看到你已经成功地将side effects 从纯函数代码中分离出来了。这是一项重要的技术，记住，当你设计你的应用时: <strong>push the side<br>effects to the edge of the world</strong>。</p><h2><span id="53-各种各样的函数">5.3 各种各样的函数</span></h2><p>函数式编程就是关于函数方面的，你能在Scala中创建各种形式的函数。函数在Scala中是第一类值(first-class values)。这意味着可以把函数看作如<code>Int</code>或<code>String</code>类型值一样。因此函数可以作为值创建、作为参数传递到其它函数、以及组合这些函数来创建新的函数。</p><h3><span id="531-方法-vs-函数">5.3.1 方法 vs. 函数</span></h3><p>通常被定义为一个类成员的函数。被称为方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseResourece</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(r:<span class="type">Resource</span>): <span class="type">Boolean</span> = &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>use</code>是类<code>UseResource</code>定义的一个方法。使用方法时有个缺点是，它容易依赖于封闭类定义的状态，该状态指没有显式传递其依赖的参数，因此要小心，它会使你远离纯函数。和函数不同，方法不会有任何类型的关联。Scala通过将函数转换为对象来实现函数式编程的OOP注入。<br>例如，你可以赋值一个函数字面量(匿名函数)的值:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> succ = (x:<span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里succ函数的关联类型为<code>Int =&gt; Int</code>，它是如下定义的一种简写:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> succFunction = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x:<span class="type">Int</span>) : <span class="type">Int</span> = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个定义是等价的。函数在Scala中通过一个类型和对象表示，但是方法不是。方法仅仅关联它的封闭类。好消息是，Scala允许你使用一个称为Eta扩展的转换过程将方法转换为函数。你可以将任意存在的方法后加<code> _</code> 下划线来创建函数。如下面代码创建了一个函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> use_func:<span class="type">Resource</span> =&gt; <span class="type">Boolean</span> = (<span class="keyword">new</span> <span class="type">UseResource</span>).use _</span><br></pre></td></tr></table></figure><p>在Scala中，将方法转换为函数，并传递给另外一个函数的情况，在Scala中非常普遍。下一小节你将看到有关高阶函数的例子，以及它是如何帮助解决问题。</p><h3><span id="532-高阶函数">5.3.2 高阶函数</span></h3><p>高阶函数就是，接收函数参数或以函数作为返回值的函数。在前面已经介绍了大量有关高阶函数的内容。尤其在Scala集合中每一个地方都用到高阶函数。例如，过滤掉List中的所有偶数，你会如下写:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val l = List(1, 2, 3, 5, 7, 10, 15)</span></span><br><span class="line">l: List[Int] = List(1, 2, 3, 5, 7, 10, 15)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> l.filter(_ % 2 == 0)</span></span><br><span class="line">res0: List[Int] = List(2, 10)</span><br></pre></td></tr></table></figure><p>这里的 <code>% 2 == 0</code>是一个函数字面量。现在让我们看看如何用高阶函数来处理日积月累的问题。一个最常见的编程问题是资源管理。例如，在TCP连接上发送数据，你必须打开一个socket，发送数据，然后关闭socket。类似地，在一个文件系统中读取文件，你必须要打开文件，读数据，然后关闭文件的句柄。典型的处理资源的方法是将它们包装在try-finally块里面:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r: <span class="type">Resource</span> = getResource()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">useResourceToDoUsefulStuff(r)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">r.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你获得了对资源操作的一个句柄，并在try-finally(有时包含catch)块里面操作。现在让我们看看如何将该资源管理部分分离出来,并通过高阶函数use实现:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use</span></span>[<span class="type">A</span>, <span class="type">B</span> &lt;: <span class="type">Resource</span> ](r: <span class="type">Resource</span>)(f: <span class="type">Resource</span> =&gt; <span class="type">A</span>): <span class="type">A</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">f(r)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">r.dispose()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的use函数接入资源管理，以及函数参数<code>f</code>允许你使用资源而不用担心释放或处理的问题。现在socket的发送代码变为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use(socketResource) &#123; r=&gt; sendData(r) &#125;</span><br></pre></td></tr></table></figure><p>资源管理的抽象实现移除了代码的重复并在资源暴露之后进行集中管理，而不会混乱try-finally块的代码。要实现这个抽象，你需要定义一个通用的类型Resource。在Scala中这是一个常见的模式 借贷模式Loan pattern<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> (在面向对象中被称为模版方法模式)。<br>下面一个例子会证明高阶函数对复杂设计编程的强大之处。下面常见的几点逻辑可能是你处理问题的步骤:</p><ul><li>创建或查找某些存在的实例。</li><li>处理某些包含副作用的操作。</li><li>在其他部分代码中使用实例。</li></ul><p>在你开始使用实例之前你会进行1、2步，问题是，包含副作用的代码有数据结构关联，并且它和步骤1、3混在一起使用。让我们看看下面的伪代码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">x.setInfo(someInfo)</span><br><span class="line">println(<span class="string">&quot;log: new person is created&quot;</span>)</span><br><span class="line">mailer.mail(<span class="string">&quot;new person joined &quot;</span> + x)</span><br><span class="line">x.firstName</span><br></pre></td></tr></table></figure><p>在使用实例之前，你需要先完成1、2步，问题是在访问时可能没有调用者命名空间的上下文。例如，mailer的引用在前面的代码片段仅仅在调用者的上下文有效，而在Person实例内部无效。处理该问题的一个方法是使用高阶函数。这里定义一个函数<code>tap</code>，该函数接收一个实例和一个包含副作用的函数。该函数提供了副作用函数到实例的处理并返回实例。如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tap</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(sideEffect: <span class="type">A</span> =&gt; <span class="type">Unit</span>): <span class="type">A</span> = &#123;</span><br><span class="line">sideEffect(a)</span><br><span class="line">a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个<code>tap</code>函数，你的代码将获得某些结构:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">tap(x) &#123; p =&gt;</span><br><span class="line"><span class="keyword">import</span> p._</span><br><span class="line">setInfo(someInfo)</span><br><span class="line">println(<span class="string">&quot;log: new person is created&quot;</span>)</span><br><span class="line">mailer.mail(<span class="string">&quot;new person joined &quot;</span> + x)</span><br><span class="line">&#125;.firstName</span><br></pre></td></tr></table></figure><p>这正是你想要的，但你仍然可以通过隐式转化进行增强使用。因为它非常普遍，你需要使该函数对所有类型生效。下面给出它的完整实现例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Combinators</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">kestrel</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="keyword">new</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tap</span></span>(sideEffect: <span class="type">A</span> =&gt; <span class="type">Unit</span>): <span class="type">A</span> = &#123;</span><br><span class="line">      sideEffect(a)</span><br><span class="line">      a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">firstName: <span class="type">String</span>, lastName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Mailer</span>(<span class="params">mailAddress: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mail</span></span>(body: <span class="type">String</span>) = &#123;</span><br><span class="line">    println(<span class="string">&quot;send mail here...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> <span class="type">Combinators</span>._</span><br><span class="line"><span class="type">Person</span>(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>).tap(p =&gt;&#123;</span><br><span class="line">  println(<span class="string">&quot;First name &quot;</span> + p.firstName)</span><br><span class="line">  <span class="type">Mailer</span>(<span class="string">&quot;some address&quot;</span>)</span><br><span class="line">&#125;).lastName</span><br></pre></td></tr></table></figure><p>比较先前的伪代码有所不同，现在代码更简洁和结构良好的，并且副作用不会泄漏。该模式设计最好的部分是可以让你不再依赖指令序列的组合。这同时也是一个常见的组合器(高阶函数)，在函数式编程中被称为Kestrel<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> 。Kestrel是To Mock a Mockingbird书中定义的多个组合器中的一个。组合逻辑包含在本书范围，但是我更推荐To Mock a Mockingbird。我在这里强调，一旦你开始使用高阶函数，你将有机会提取可重用的代码，这在之前还认为是不可能的事情。让我们想一想，例如定义在Scala集合库中的<code>foldRight</code>和<code>foldLeft</code>提供的二元函数。高阶函数的应用程序让你编写不重复的代码(don’t-repeat-yourself DRY)并可以尽可能地使用。下一小节将讨论偏函数，以及它们如何在函数组合起到帮助。</p><h3><span id="533-函数科里化">5.3.3 函数科里化</span></h3><p>函数科里化是一门技术，指的是将原来带多个参数的函数，转换为带一个参数的函数。如下面定义的接收两个参数的函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> trait TaxStrategy &#123; def taxIt(product: String): Double &#125;</span></span><br><span class="line">defined trait TaxStrategy</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val taxIt: (TaxStrategy, String) =&gt; Double = (s, p) =&gt; s.taxIt(p)</span></span><br><span class="line">taxIt: (TaxStrategy, String) =&gt; Double = &lt;function2&gt;</span><br></pre></td></tr></table></figure><p>函数<code>taxIt</code>接收<code>TaxStrategy</code>和<code>String</code>参数并返回<code>Double</code>。要将该函数科里化，你可以调用函数类型的<code>curried</code>方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> taxIt.curried</span></span><br><span class="line">res2: TaxStrategy =&gt; String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure><p>它将<code>taxIt</code>函数转换为一个接收一个参数并返回另外一个接收第二个参数函数的函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class TaxFree extends TaxStrategy &#123; override def taxIt(product:</span></span><br><span class="line">String) = 0.0 &#125;</span><br><span class="line">defined class TaxFree</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val taxFree = taxIt.curried(new TaxFree)</span></span><br><span class="line">taxFree: String =&gt; Double = &lt;function1&gt;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> taxFree(<span class="string">&quot;someProduct&quot;</span>)</span></span><br><span class="line">res3: Double = 0.0</span><br></pre></td></tr></table></figure><p>使用函数科里化的好处是什么？它将一个普通的函数转换为一个特殊的。例如，将taxIt函数科里化后得到一个taxFree。这和OOP中的DI(Dependency injection，依赖注入)相似。这里我将<code>taxStrategy</code>作为依赖注入到科里化函数，并使用依赖创建一个新的函数。你也可以使用占位符<code>_</code>来转换为科里化函数。如下实现所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def taxIt(s: TaxStrategy, product: String) = &#123; s.taxIt(product) &#125;</span></span><br><span class="line">taxIt: (s: TaxStrategy, product: String)Double</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val taxItF = taxIt _</span></span><br><span class="line">taxItF: (TaxStrategy, String) =&gt; Double = &lt;function2&gt;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> taxItF.curried</span></span><br><span class="line">res4: TaxStrategy =&gt; String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure><p>你也可以使用多参数集来定义科里化风格的方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def taxIt(s: TaxStrategy)(product: String) = &#123; s.taxIt(product) &#125;</span></span><br><span class="line">taxIt: (s: TaxStrategy)(product: String)Double</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val taxFree = taxIt(new TaxFree) _</span></span><br><span class="line">taxFree: String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure><p>你已经使用多参数集为高阶函数传递匿名函数，现在还学习了函数科里化的另一个内容:依赖注入。</p><h3><span id="534-函数组合和偏函数">5.3.4 函数组合和偏函数</span></h3><p>一个偏函数是指，一个函数仅仅为输入值子串定义。它和一个纯函数的定义不同，纯函数为所有输入参数定义。如图5.3所示，一个偏函数<code>f: X-&gt;Y</code>，表示仅定义了<code>X=1</code>和<code>X=3</code>，不包含<code>X=2</code>。</p><p><img src="/img/scala-in-action/chapter5/partial-functions.png" alt="Function composition and partial functions"></p><p>在Scala中，偏函数通过<code>PartialFunction[-A,+B]</code>以及继承<code>scala.Function1</code>特质被定义。和所有函数类型一样，<code>PartialFunction</code>声明了apply方法以及一个额外的方法<code>def isDefinedAt(a:A):Boolean</code>。这个<code>isDefinedAt</code>方法决定了给定的偏函数是否为一个给定的参数定义。<br>创建一个偏函数的最简单的方法是通过使用模式匹配定义一个匿名函数。如下代码例子定义了上图所述的偏函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToChar</span></span>:<span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">Char</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; &#x27;a&#x27;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> =&gt; &#x27;c&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，Scala编译器会将前面的代码片段转换为如下内容:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">Char</span>]&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(i:<span class="type">Int</span>) = i <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; &#x27;a&#x27;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; &#x27;c&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(i:<span class="type">Int</span>):<span class="type">Boolean</span> = i <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质<code>PartialFunction</code>提供了两个有趣的结合方法<code>orElse</code>和<code>andThen</code>。方法<code>orElse</code>可以将当前的偏函数和其他偏函数组合。它和if-else很相似，当当前的偏函数没有被定义时，则另外一个将被调用。你可以创建if-else if来匹配多项。另外一个<code>andThen</code>可以组合转换一个偏函数作用于一个由偏函数产生的结果。一个例子会证明函数组合的强大。</p><p><strong>注意：</strong><br><em><strong>理解偏函数的有用性是重要的。它让你编写更聪明的函数，记住单一职责原则，然后将它们组合在一起来创建一个完整的函数。小心性能的损耗。当组合偏函数时，要记住每个组合偏函数中的isDefinedAt可以被调用了多次。</strong></em></p><p>假设你要构建一个价格系统来为所有的病人提供发票。典型地，这个系统是复杂的，因此我将简化一些内容。价格由索票的类型和区域决定，此外，区域被分为state code或ZIP code。每个这些因素会影响最终发票的价格。同时，也不是所有的索票有具体的计价逻辑关联，因此你必须有一个捕获所有默认情况，以至于你可以总是能够计算得到发票的价钱。我可以肯定这听起来和你的业务逻辑很相似。让我们用偏函数来实现这个小问题。首先定义索票类型:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Claim</span> </span>&#123; <span class="keyword">val</span> claimId: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Full</span>(<span class="params">val claimId: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Partial</span>(<span class="params">val claimId: <span class="type">Int</span>, percentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>(<span class="params">val claimId: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br></pre></td></tr></table></figure><p>每一个claim包含一个claimId的唯一标识并有可选的某些属性关联claim。要索取发票，对方应该提供相应的索取信息，地址和标识。这里可以使用case classes实现:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">stateCode: <span class="type">Option</span>[<span class="type">String</span>], zipCode: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Req</span>(<span class="params">productId: <span class="type">String</span>, location: <span class="type">Location</span>, claim: <span class="type">Claim</span></span>)</span></span><br></pre></td></tr></table></figure><p>处理Generic索赔，每个索赔的计价由具体的业务逻辑决定，以及所有的计价开始于一些基本的价格关联。为了决定最终的产品索赔价格，你需要提供请求信息和基本的价格。你可以捕获这个类型变量:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PC</span> </span>= <span class="type">Tuple2</span>[<span class="type">Req</span>,<span class="type">Option</span>[<span class="type">Double</span>]]</span><br></pre></td></tr></table></figure><p>这个的<code>Option[Double]</code>表示产品价格的基础。下列代码则实现业务逻辑关联的每个<code>Full</code>和<code>Partial</code>索赔:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFullClaim</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, l, <span class="type">Full</span>(claimId)), basePrice) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePartialClaim</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, l, <span class="type">Partial</span>(claimId, percentage)), basePrice) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，最终的价格受区域影响。区域基础的逻辑也可以用偏函数实现，如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleZipCode</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, <span class="type">Location</span>(_, <span class="type">Some</span>(zipCode)), _), price) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleStateCode</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, <span class="type">Location</span>(<span class="type">Some</span>(stateCode), _), _), price) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要为计价提供一个最终的解决方案，你可以组合这些偏函数来解决问题。根据商业规则，你应该首先决定索赔的价格基础，然后完善基于区域的价格计算。使用前面学习的<code>orElse</code>和<code>andThen</code>组合器，你可以非常容易的组合这些函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">claimHandlers</span> </span>= handleFullClaim orElse handlePartialClaim</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locationHandlers</span> </span>= handleZipCode orElse handleStateCode</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">priceCalculator</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] =</span><br><span class="line">claimHandlers andThen locationHandlers</span><br></pre></td></tr></table></figure><p>上面的代码实现了你所描述的业务规则。计算索赔价格、然后完善区域的计算。当业务规则或新的索赔类型被添加到系统中，你可以容易地修改组合然后添加新的偏函数。例如，你还没有处理Generic索赔类型，你可以通过在claimHandlers中添加另外一个orElse块就很容易地将它添加到最终解决方案中。</p><p>偏函数可以被应用到更多你可能想到的场景中。例如，从一个函数或一个方法中抛出异常可以考虑偏函数。总之，在Scala中，使用了函数组合后的偏函数是强大的，在编写代码时要时刻记住。</p><h3><span id="535-递归">5.3.5 递归</span></h3><p>递归就是调用自身的函数。在函数式编程工具箱中递归是一个有用的工具。它可以让你将问题分解成子问题，子问题再分解成子问题。这样就可以将解决的子问题组合在一起并产生最终结果。可以认为递归是函数式编程语言的拼接。</p><p>递归的好处是可以让你创建不会变异的解决方案。在下面的小练习中，你需要计算出List中所有元素的和而不使用任何变异。你可以通过使用函数库得到许多方法来解决这个问题，但是让我们重新开始构建。这个问题的命令式解决方案如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var sum = 0</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span>(e &lt;- List(1,2,3)) &#123; sum += e &#125;</span></span><br></pre></td></tr></table></figure><p>你可以声明一个可变变量并对集合的元素结果进行迭代累加。因此递归的解决方案为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; x + sum(ys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的是，基于递归的解决方案没有用到任何可变的临时变量，并将问题分解称为若干小块。在Scala中，典型的实现递归的方法就是使用模式匹配了。模式匹配可以实现将问题分解成为子问题，每个case就表示一个子问题。递归通常看起来容易，使用起来困难。下小节将介绍如何通过简单的步骤递归地思考问题。</p><h2><span id="递归思想">递归思想</span></h2><p>假设给你一个元素list，你需要将list中的重复元素去掉，例如，给你<code>List(0,1,2,3,2,1,0)</code>，那么输出的结果应该是<code>List(0,1,2,3)</code>。下面将一步一步来说明如何通过基于递归来解决<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> 。</p><p>第一步是确定类型。你需要根据输入参数和函数值返回类型类确定递归的类型。因此<code>removeDups</code>方法的类型应该是:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeDups: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="type">List</span>[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure><p>下一步就是声明你需要处理的所有case，这里removeDups的case有:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt;</span><br><span class="line"><span class="keyword">case</span> x::ys <span class="keyword">if</span>(ys.contains(x)) =&gt;</span><br><span class="line"><span class="keyword">case</span> x::ys =&gt;</span><br></pre></td></tr></table></figure><p>第一个case为list空的情况，第二个为有重复的情况，第三个case表示没有重复的情况。<br>下一步就是实现各个case案例，因为递归需要有两个必要条件，即迭代实现和终止条件，显然，第二个case案例为迭代实现，第三个case为终止条件。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line"><span class="keyword">case</span> x :: ys <span class="keyword">if</span>(ys.contains(x)) =&gt; removeDups(ys)</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; removeDups(ys) :+ x</span><br></pre></td></tr></table></figure><p>加上类型声明后的完整代码为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDups</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line"><span class="keyword">case</span> x :: ys <span class="keyword">if</span>(ys.contains(x)) =&gt; removeDups(ys)</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; removeDups(ys) :+ x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练使用递归的需要多进行练习，熟悉这些步骤后，便可自然地编写递归的解决方案了。</p><h3><span id="541-尾递归">5.4.1 尾递归</span></h3><p>在讨论尾递归之前，让我们解析一下头递归是如何工作的。<code>Head recursion</code>是大多数传统递归的实现方式，即方法中首先进行递归，然后接收返回值后再执行其他计算。<br>尾递归(tail recursion)是先执行计算处理，然后再结果传递给递归操作处理。我会提供一个例子来证明你要如何编写递归函数，以及尾递归实现。<br>一般地，当你调用一个函数时，一个实体被添加到了当前运行的线程堆栈中，堆栈的下限是它定义了大小，一旦超出了边界会抛出StackOverflowError异常。这就是为什么Java开发者更喜欢用迭代容器而不用递归。因为Scala运行在JVM上，Scala同样也有这样的问题。一个好消息是从Scala2.8.1开始，Scala通过尾部调用优化克服了这个限制。如下面是尾部调用优化的例子，代码片段将计算List的长度:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; <span class="number">1</span> + length(ys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个典型的头递归调用例子，当你执行的List较大时，你会获得一个StackOverflowError异常。现在用尾递归重写该方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length2</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_length</span></span>(xs: <span class="type">List</span>[<span class="type">A</span>], currentLength: <span class="type">Int</span>): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; currentLength</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; _length(ys, currentLength + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">_length(xs, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，计算操作不是在递归调用之后，计算处理发生在每一步，并向下一步传递。问题是，那个更好，在Scala中更推荐使用尾递归，因为Scala实现了尾递归函数的优化工作。Scala的尾部调用优化发生在编译时期，编译器会将一个尾递归转换为一个循环。这样就不需要添加额外的实体到堆栈中。但是Scala不能优化每一个尾递归 —— 只能优化函数不能优化类变量的方法。要知道Scala是否对你的尾递归进行了优化，最好的方法是在尾递归中使用@tailrec注解，因为当Scala编译器不能优化你的函数或者方法时，编译器会在此注解的方法中抛出一个异常。例如下面:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length2</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_length</span></span>(xs: <span class="type">List</span>[<span class="type">A</span>], currentLength: <span class="type">Int</span>): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; currentLength</span><br><span class="line">    <span class="keyword">case</span> x :: ys =&gt; _length(ys, currentLength + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _length(xs, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现尾递归函数的常见方式是，使用上面如<code>_length</code>这样的本地函数来构建。本地函数访问允许你添加一个额外的参数来传递当前的结果到下一步操作。记住，实现一个调用优化的尾递归函数，你的递归操作总是在最后一步做处理。</p><h2><span id="55-代数数据类型">5.5 代数数据类型</span></h2><p>代数数据类型(Algebraic data type,ADT)是一种分类方法。通常地，一个数据类型是值的集合(例如Int类型作为所有整形值的标识)。你可以通过枚举集合中的所有值来定义一个代数类型，除非每个值都有它自己的数据结构。当然，你可以通过模式匹配来对类型进行解组。这听起来像是一个抽象的概念，我们来看看一个例子。不久你将学会ADT就是一种表示值集合的类型。ADTs可以表示一个有限的或无限的值集合。首先，让我们看看一个闭合ADT(有限值集合)的例子，以及探索为什么它们是有价值的。<br>在Scala中，定义代数类型的最简单方式是使用case classes。如下例子代码定义了一个Account类型以及它的可能的值:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ADT</span> </span>&#123;</span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Account</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span>(<span class="params">accountId: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingAccount</span>(<span class="params">accountId: <span class="type">String</span>, limit: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Account</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PremiumAccount</span>(<span class="params">corporateId: <span class="type">String</span>, accountHolder: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Account</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了三个account类型，每个类型都带有自己的构造器以及接收不同的参数。同时也声明了Account特质是sealed的。这意味着不可以在trait外部创建一个新的Account类型，只能在Account的同一个文件中创建。你已经创建的一个有限的ADT，但是仍然不明白为什么case classes是ADTs实现的最好选择。原因是模式匹配。一旦你创建了ADTs，你在函数中使用。如果实现了case classes，ADTs将变得更容易处理，因为模式匹配工作在外部。下面代码片段printAccountDetails打印出每个account的详情:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ADT</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAccountDetails</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = account <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">CheckingAccount</span>(accountId) =&gt;</span><br><span class="line">println(<span class="string">&quot;Account id &quot;</span> + accountId)</span><br><span class="line"><span class="keyword">case</span> <span class="type">SavingAccount</span>(accountId, limit) =&gt;</span><br><span class="line">println(<span class="string">&quot;Account id &quot;</span> + accountId + <span class="string">&quot; , &quot;</span> + limit)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伴随着值和构造器，ADTs可以通过模式匹配进行解组，这样你可以在函数中更容易地使用他们。一个强大的概念:一旦你创建一个代数数据类型，你应该准备提供模式匹配来在函数中使用。</p><p>在函数<code>printAccountDetails</code>中，我有意地忽略<code>PremiumAccount</code>的代码，目的是让你在编译前面的代码时会发生什么。你将会看到如下警告:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[warn] missing combination PremiumAccount</span><br><span class="line">[warn] def printAccountDetails(account: Account): Unit = account match &#123;</span><br></pre></td></tr></table></figure><p>有限的代数数据类型的另外一个好处是，Scala编译器会检测函数是否对所有可能的case代数数据类型进行了处理，并提供提示。有两种方法让你避免这些告警:提供PremiumAccount的case实现，或者将Account类型为nonsealed不进行密封。但是移除sealed关键字的负面影响 —— 任何人都可以继承Account来创建一个新的类型。在这种情况，你应该如何编写像<code>printAccountDetails</code>一样处理所有account类型的实现？我喜欢有限的(闭合的)代数类型，并更推荐使用，因为我可以在Scala编译期走得更远。<br>最大的一个好处是编写全函数(total functions)。全函数是指对一个代数数据类型的所有值进行处理，并总是产生返回的结果。这意味着在编译期函数可以处理所有输入。在本书，你将会使用ADT一段时间，而不仅仅是知道它。在Scala中两个最好的著名的例子是<code>scala.Either</code>和<code>scala.Option</code>。</p><h2><span id="56-why-does-functional-programming-matter">5.6 Why does functional programming matter?</span></h2><p>你已经探索了有关函数式编程的大量理论和例子。函数式编程，和命令式编程不同。这是另一种编程思想。为什么费心去学习这个新技术？这将给你带来什么？<br>首先，学习一门新的编程范式是好事，因为可以让你成为更好的程序员。另外一个益处是函数式编程所带来的并发和多核编程。函数式编程可以让你编写更简单、更高效的并发程式。企业级软件开发者要处理复杂的业务问题和大规模的软件开发，并发是其重要的一部分。这或许不足以说服所有的开发者，但在剩余的小节将举例说明，为什么函数式编程这么重要，以及它如何帮助你处理复杂的问题。<br>著名的计算机科学家John Hughes，在他的《Why Functional Programming Matters》一书中描述了函数式编程是如何帮助处理复杂问题。事实上，本小节的标题正是受该书的启发。<br>以Unix的管道为例。Unix管道即指像管道一样当程序被链接成为一个管道(通过它们的输入输出流)  时。例如，下面命令接收来自通过URL的标识文件的大小:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s &quot;htttp://www.manning.com/raychaudhuri/&quot; | wc -c</span><br></pre></td></tr></table></figure><p>这里使用<code>curl</code>进程来获取来自服务器的数据，并通过<code>wc</code>进程来计算我从服务器获得的字节。符号 <code>|</code> 是Unix的管道命名，表示从一个进程得到的输出内容被作为管道输入到另外一个命令中执行。可以肯定，<code>curl</code>的作者和<code>w</code>c的作者不会想到某人会组合这两个进程来处理一个操作。事实上，你甚至可以使用任何多个Unix进程，组合这些进程来创建一个新的命令。这就是类Unix系统中最有用和最强大的思想。所有这些Unix程序背后的设计哲学是什么？所有Unix程序遵循下面两个简单的规则:</p><ol><li>Write programs that do one thing and do it well. 编写做一件事的程式并做好。</li><li>Write programs to work together. 编写程式来一起工作。</li></ol><p>从这简单的规则中你收获了什么？答案是 <strong>可组合性</strong> composability。Unix程序给我们展示了可组合性的强大。Unix程序就像乐高积木(LEGO blocks)。你可以以任意顺序组装它们，组合他们来创建新的程序，给这些新程序命名，在这些新程序之上再构建新的程序，…。那么这些内容如何映射到函数式编程上？一个Unix管道就像一个函数式编程语言一样。如果你把每个进程看作一个函数，一个Unix管道让你使用 <code>| </code>符号来组合这些函数；在Scala，它就是函数式组合。相似地，如下有一系列函数在你的Scala代码中:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even</span></span>: <span class="type">Int</span> =&gt; <span class="type">Boolean</span> = _ % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not</span></span>: <span class="type">Boolean</span> =&gt; <span class="type">Boolean</span> = !_</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">A</span>](criteria: <span class="type">A</span> =&gt; <span class="type">Boolean</span>)(col: <span class="type">Traversable</span>[<span class="type">A</span>])=col.filter(criteria)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>)(col: <span class="type">Traversable</span>[<span class="type">A</span>]) = col.map(f)</span><br></pre></td></tr></table></figure><p>这些函数就像Unix的进程一样，每个只处理一件事。函数<code>even</code>用于当给定的整数为偶数时返回true；<code>not</code>用于切换输入的Boolean参数；<code>filter</code>函数用于接收<code>Traversable</code>类型集合和<code>criteria</code>函数，并根据criteria函数的规则进行对Traversable参数的过滤；<code>map</code>函数则用于对给定的方法<code>f</code>对<code>Traversable</code>参数进行遍历。现在，假设你的问题是你需要查找给定集合中的所有偶数并对其乘2。用这些给定的函数，你可以组合这些函数多步处理，就可以容易地构建问题的解决方案。首先，构建一个filter来处理偶数，以及构建一个double函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evenFilter</span> </span>= filter(even) _</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>: <span class="type">Int</span> =&gt; <span class="type">Int</span> = _ * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里的evenFilter我使用了函数科里化来创建一个指定的filter版本。为了将这两个函数组合在一起，Scala提供了一个<code>andThen</code>方法，可以作用于所有函数类型，但不包含参数的函数除外。这个<code>andThen</code>方法行为和Unix管道相似——结合了两种函数序列并创建一个函数。因为所有Scala函数被编译为一个<code>scala.  Function</code>特质，你可以使用这个组合方法来合并两个函数。为了过滤掉奇元素并乘2，创建下面函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleAllEven</span> </span>= evenFilter andThen map(double)</span><br></pre></td></tr></table></figure><p>evenFilter函数过滤后，map函数接着遍历结果内容并进行double处理。任务完成。但是如果你需要对所有的奇数乘2呢？你有现成的可以用了，只需要对其进行不一样的组合:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span></span>: <span class="type">Int</span> =&gt; <span class="type">Boolean</span> = not compose even</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddFilter</span> </span>= filter(odd) _</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleAllOdd</span> </span>= oddFilter andThen map(double)</span><br></pre></td></tr></table></figure><p>这里提供给<code>odd</code>的组合方法是<code>compose</code>。<code>andThen</code>和<code>compose</code>的唯一不同的是执行顺序，<code>compose</code>是从右往左的。<code>odd</code>函数会找到所有的偶元素并去掉。<br>手头上的这个例子是幼稚的、简单的。但是目标明确: 可组合性允许你从小小的功能块组合构成解决方案，而这些小块的功能正是你解决复杂问题的关键。反过来，当你设计一个大型的、复杂的问题解决方案时，你将问题分解成各个小问题，又甚至将小问题再分解成更小的问题，直到你到达可以更容易理解这个问题的点上。解决这些独立的小块，再收集在一起构建最终的大块，这是一个古老的技术。</p><p>这种分解、消化问题跨越软件开发的所有层面。函数式组合让你在你的应用中构建了数学微观世界。在这些数学微观世界中你能够明确问题，因为他们都是由纯函数创建，你可以轻易地使用函数组合构建。在微观世界中，你可以实现大部分应用程序的复杂性，以及函数组合给你一个清晰的、定义明确的方式来将问题分解成小块的函数，并之后对其组合。</p><p>在今天的企业，软件分离已经不足够。你需要尽可能分离得更快。这就是抽象(abstraction)和组合(composability)的益处所在。你作为一名开发者可以不通过改造和复制的实现组合小函数，从而节省时间。</p><p>纯函数世界的另外一个益处是调试。你不再需要担心事件序列问题的发生，因为纯函数没有副作用(side effect)。你也不用担心序列中哪个函数被执行了，因为函数的行为只通过输入参数集合驱动，即惰性执行。和命令式编程相比，函数式编程微观世界更容易找到瑕疵。为了使所有这些可能，遵循Unix的设计哲学:</p><ol><li>Write pure functions that do one thing and do it well.</li><li>Write functions that can compose with other functions.</li></ol><p>第一条规则是单一职责原则。第二条规则作为第一条的附加补充。所以在设计时，应当使函数功能尽量小、纯，这样组合就更容易。实现函数尽量小的一个方法就是使其只接收一个参数，如上面使其实现科里化(尽管事实上你会接收很多参数来实现组合多样性的事情)。</p><p>第二条规则是编写函数时，应当时刻记住使其实现科里化(currying)，或者使用偏函数。当声明函数时，要确保你的参数顺序从更具体的，到更通用的。它可以帮助其他人需要用到其他地方的场景，替换为通用的参数，或者最好使其只包含一个参数。</p><p>作为一门面向对象语言，函数式编程在处理核心和复杂部分时也使得你的应用更容易编写和维护。<br>那么，函数的副作用(side effects)部分怎么办？难道它们在组合方面毫无希望？不，在下一小节，将展示如何围绕副作用部分内容创建抽象，以使得它们可以参与到组合(composition)中来。</p><h2><span id="57-基于monad的高级抽象构建">5.7 基于Monad的高级抽象构建</span></h2><p>如果你从OOP背景走来，你可能涉足过设计模式。本小节将讲解一个函数式编程设计模式，monads。monads的出现有点神秘。关于monads的通常误解来源于难理解，你需要有足够好的数学底子才能完全适应它们。的确，monads来源于范畴论<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup> (category theory)的一个分支，范畴论正式化抽象数学概念为集合(collections)和态射(arrows)。但它提供了一个好的抽象层来帮助结构化你的代码。<br>有许多实现monads的例子，并且每个用于解决一类具体的问题。事实上，你已经用过了monads，两个最常见的就是<code>List</code>和<code>Option</code>。List monad抽象了计算可能返回0，1，或者更多可能结果的情况。Option monad则抽象了计算可能不返回的情况(Some or None)。Monads通常被认为是一个先进的函数式编程概念。作为一名开发者，我强烈认为有必要将它引入到本书内容中，因为它有足够的使用益处。</p><ol><li>Monads可以让你组合你那些组合不好的函数，如有副作用的函数。</li><li>Monads可以让你不用函数式编程就可以模拟动作队列的计算顺序。</li></ol><p>使用函数式编程技术设计应用程序时，这两点是重要的、强大的，应当一起关注。我会先从第二点入手，因为它经常被用到，甚至即使你的数学微观世界中没有副作用。在最后这个小节，我会向你展示如何在函数式编程风格中组合包含副作用的函数。</p><h3><span id="571-managing-state-using-monads">5.7.1 Managing state using monads</span></h3><p>当我介绍函数式编程时，我提及到不用关心函数或操作的顺序，因为函数都是纯的。让我们挑战另外一个零售价格的例子。这个应用需要计算一个产品的售价，计算按如下要求:</p><ul><li>找到产品的原价。</li><li>提供对原价特定代码的打折。</li><li>提供对上一步操作中，进行指定产品的折扣打折。</li><li>基于以上步骤后，提供扣税得到最终价格。</li></ul><p>这个模式在企业软件中比较普遍。你需要在序列中通过每个步骤操作的结果传递到下一个操作，怎么做？命令式的回答是使用一个可变变量在每个动作之间进行共享，这是一个差的想法，原因我已经在通篇全书中提及到。那试试将所有动作在一个函数中实现怎么样？是的，这个可以在一个大的函数中得到结果，因为每个步骤可能有10到20行代码。所以，一个最好的回答是将每个步骤以函数的形式实现，并以管道将当前动作的结果传递到下一个动作。下面列出这些实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PriceCalculatorWithoutMonad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Stubs</span>._</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceState</span>(<span class="params">productId:<span class="type">String</span>,stateCode:<span class="type">String</span>,price:<span class="type">Double</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(productId:<span class="type">String</span>,stateCode:<span class="type">String</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> basePrice = findTheBasePrice(productId)</span><br><span class="line">    <span class="type">PriceState</span>(productId,stateCode,basePrice)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> discount = findStateSpecificDiscount(ps.productId,ps.stateCode)</span><br><span class="line">    ps.copy(price = ps.price - discount)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> discount = findProductSpecificDiscount(ps.productId)</span><br><span class="line">    ps.copy(price = ps.price - discount)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tax = calculateTax(ps.productId,ps.price)</span><br><span class="line">    ps.copy(price = ps.price + tax)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(productId:<span class="type">String</span>,stateCode:<span class="type">String</span>):<span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a = findBasePrice(productId,stateCode)</span><br><span class="line">    <span class="keyword">val</span> b = applyStateSpecificDiscount(a)</span><br><span class="line">    <span class="keyword">val</span> c = applyProductSpecificDiscount(b)</span><br><span class="line">    <span class="keyword">val</span> d = applyTax(c)</span><br><span class="line">    d.price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将无关紧要的Stubs代码部分放置到另外一个文件中，下面是该文件的硬编码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stubs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findTheBasePrice</span></span>(productId: <span class="type">String</span>) = <span class="number">10.0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findStateSpecificDiscount</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>) = <span class="number">0.5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findProductSpecificDiscount</span></span>(productId: <span class="type">String</span>) = <span class="number">0.5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculateTax</span></span>(productId: <span class="type">String</span>, price: <span class="type">Double</span>) = <span class="number">5.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，最有趣的部分是<code>calculatePrice</code>方法，他调用了每一个独立函数，每一个方法的结果传递到下一个方法中，形成一个队列。命名变量<code>a,b,c</code>不是一个好的想法，但是它很好的展示了<code>PriceState</code>实例的传递。这种解决方法的实现使用了函数式编程风格，但是每个独立函数的API则显得丑陋。为了返回唯一个price价格，方法<code>applyStateSpecificDiscount</code>，<code>applyProductSpecificDiscount</code>和<code>applyTax</code>就必须返回PriceState的实例。每个方法的最后一行方法apply显示了问题。<br>另外一个问题是方法<code>calculatePrice</code>。它容易在处理PriceState时出错，在更复杂的问题中，这种方式变得十分混乱。当然一个高阶的抽象或许对这种状态管理会有所帮助。这就出现了<code>State monad</code>。之所以被称为<code>State monad</code>是因为它在多个操作状态改变时实现了透明。在这个例子中，你将实现一个<code>State monad</code>，这样你就不需要在多个方法调用PriceState时对其进行管理。但是你需要有足够的通用实现以使得它可以在其它相似问题的地方被使用。<br>在Scalaz库中实现了大量的这些monads，考虑到直接使用不会达到学习的效果。让我们自己实现一个State monad。<br>在实现State monad之前，先将原来的Stubs中的方法改一下，让API看起来更清晰一些:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stubs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些方法将接收一个PriceState实例参数，并返回计算结果。你的工作就是实现一个State monad来序列这些方法，并计算出最终价格。<br>这个State monad封装一个转换函数，将初始状态转换为一个(newState,value)对。这在Scala中很容易表示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>): (<span class="type">S</span>, <span class="type">A</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法apply表示函数转换，为了实现这个特质，你需要提供一个方法，用于接收S并返回(S,A)。你可以很容易就实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象将用在你需要使用State monad的地方。在这里，添加两个方法使生命周期更易于管理:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>[<span class="type">S</span>]: <span class="type">State</span>[<span class="type">S</span>, <span class="type">S</span>] = state[<span class="type">S</span>, <span class="type">S</span>](s =&gt; (s, s))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">modify</span></span>[<span class="type">S</span>](f: <span class="type">S</span> =&gt; <span class="type">S</span>) =init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (f(s), ())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>init</code>为State monads的创建提供了转换函数<code>(s =&gt; (S,S))</code>骨骼。可以把它认为是State monad的默认构造器。方法<code>modify</code>则让你在monad的内容对当前的状态进行修改，它用一个新的状态修改并用Unit返回给定函数和值的<code>(S,A)</code>对。你可以使用这个方法来实现你的解决方案。<br>为了把State特质看作是第一类的monad，你要实现<code>map</code>方法和<code>flatMap</code>方法。记住<code>map</code>和<code>flatMap</code>是monad接口至关重要的部分，没有它们，Scala中任何函数都不可能成为monad。<br>实现map和flatMap方法是容易的，因为你知道如何创建一个State monad的实例。下面为表示State moand的特质</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StateMonad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">State</span>._</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>): (<span class="type">S</span>, <span class="type">A</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>] = state(f = apply(_) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> (s, q) =&gt; (s, f(q))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">      state(apply(_) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> (s, q) =&gt; f(q)(s)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>[<span class="type">S</span>]: <span class="type">State</span>[<span class="type">S</span>, <span class="type">S</span>] = state[<span class="type">S</span>, <span class="type">S</span>](s =&gt; (s, s))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify</span></span>[<span class="type">S</span>](f: <span class="type">S</span> =&gt; <span class="type">S</span>) =</span><br><span class="line">      init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (f(s), ())))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法map用于在State monad内部实现值的转换。另一方面，flatMap则用于从一个状态，到另一个状态的转换。如果所有这些感到有些抽象，不用担心，当你使用这些结构时便会觉得很有意义。<br>不久你将学习到State monad通过方法调用来处理线程状态的变化，这样你就不用担心线程调用的问题。但是具体的业务规则中你仍然要在序列中调用individual pricing方法。序列一系列方法调用的最好地方是一个for-comprehension。这保证了每步特定的进入都会执行；同时也可以将每个需要运行的内容独立起来。在这个案例中，会像如下代码所示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PriceCalculatorWithMonad</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">  _ &lt;- modifyPriceState(findBasePrice)</span><br><span class="line">  _ &lt;- modifyPriceState(applyStateSpecificDiscount)</span><br><span class="line">  _ &lt;- modifyPriceState(applyProductSpecificDiscount)</span><br><span class="line">  _ &lt;- modifyPriceState(applyTax)</span><br><span class="line">&#125; <span class="keyword">yield</span> ()</span><br></pre></td></tr></table></figure><p>许多事情都在这段小代码中开始，让我们从头到尾看看。方法modifyPriceState是一段极好的方法，它接收一个有关pricing的方法，并将该方法搬运入箱成为一个新的方法，这样你就可以调用对象State内部的方法modify。<br>每个modifyPriceState方法创建一个State monad实例。当你在for-comprehension内部调用时，你获得一个State monad返回，该返回封装了方法被调用的序列以及知道如何创建一个最终的价格状态。注意现在stateMonad持有一个转换函数，它是一个被定义在for-comprehension中的所有计价方法的组合函数。这种方式的好处是，在应用编码中线程的状态总是不可见的，它隐藏在monad内部。通过State monad实例，当你的程式执行至此时，可以通过初始状态得到最终计算的价格:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line"><span class="keyword">val</span> finalPrice = finalPriceState.price</span><br></pre></td></tr></table></figure><p>它是如何工作的？秘密在map和flatMap。for-comprehension不是别的而是<code>map/flatMap</code>的语法糖。你已经在List和Option用过了for-comprehension表达式 —— 因为它们都实现了map和flatMap。第四章可以获得更多详细的内容，而在本章我将仔细剖析上面的for-comprehension，并向你展示它是如何转换成为map/flatMap组合。<br>注意上面代码for-comprenhension中左边的下划线<code>_</code>。它表示键值对中的值，这个例子中你不需要关心它们。我将会用另外一个例子来说明这个key-value中的value将被更高效地使用——下面的代码列表展示了完整的使用StateMonad重新实现的零售计价。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PriceCalculatorWithMonad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Stubs</span>._</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceState</span>(<span class="params">productId: <span class="type">String</span>, stateCode: <span class="type">String</span>, price: <span class="type">Double</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    findTheBasePrice(ps.productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    findStateSpecificDiscount(ps.productId, ps.stateCode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    ps.price - findProductSpecificDiscount(ps.productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    ps.price + calculateTax(ps.productId, ps.price)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line">    <span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">      _ &lt;- modifyPriceState(findBasePrice)</span><br><span class="line">      _ &lt;- modifyPriceState(applyStateSpecificDiscount)</span><br><span class="line">      _ &lt;- modifyPriceState(applyProductSpecificDiscount)</span><br><span class="line">      _ &lt;- modifyPriceState(applyTax)</span><br><span class="line">    &#125; <span class="keyword">yield</span> ()</span><br><span class="line">    <span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line">    <span class="keyword">val</span> finalPrice = finalPriceState.price</span><br><span class="line">    finalPrice</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StateMonad是一个通用的抽象层，它允许你为需要共享状态的动作序列构建计算。<br>你可以看到状态键-值对 和 值在State monad中的实现具有一定的相关性。尽管你不总是需要它们，当你的计算需要依赖当前的monad状态时，你可以用状态的值来处理你的计算。假设你需要为零售计价实现日志，以及为每一步的结果输出日志。<br>为了实现logging，你需要暴露State对象超过一个的方法，该方法称为<code>gets</code>。这个方法让你方法当前的state，因此你可以创建log message，并作为value存储到monad的内部。下面为它的实现:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gets</span></span>[<span class="type">S</span>,<span class="type">A</span>](f: <span class="type">S</span> =&gt; <span class="type">A</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] =</span><br><span class="line">init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (s, f(s))))</span><br></pre></td></tr></table></figure><p>和方法modify相似，但允许你提供一个接收<code>S</code>和放回<code>A</code>的函数。方法gets同时也使用value和返回给定的函数 <code>f</code> 创建了一个新的State monad实例。现在你可以序列这些计价步骤操作，并记录。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePriceWithLog</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceStateWithLog</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logStep</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">String</span>) = gets(f)</span><br><span class="line"><span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(findBasePrice)</span><br><span class="line">  a &lt;- logStep(s =&gt; <span class="string">&quot;Base Price &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyStateSpecificDiscount)</span><br><span class="line">  b &lt;- logStep(s =&gt; <span class="string">&quot;After state discount &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyProductSpecificDiscount)</span><br><span class="line">  c &lt;- logStep(s =&gt; <span class="string">&quot;After product discount &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyTax)</span><br><span class="line">  d &lt;- logStep(s =&gt; <span class="string">&quot;After tax &quot;</span> + s)</span><br><span class="line">&#125; <span class="keyword">yield</span> a :: b :: c :: d :: <span class="type">Nil</span></span><br><span class="line"><span class="keyword">val</span> (finalPriceState, log) = stateMonad.apply(<span class="type">PriceState</span>(productId,</span><br><span class="line">  stateCode, <span class="number">0.0</span>))</span><br><span class="line">finalPriceState.price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先你创建了一个logStep方法来封装gets方法，然后你在每个状态被修改后序列这个logStep，这样你就可以跟踪状态的改变。最后你将每个步骤的信息组合成为一个List。可以看到使用State mond来添加依赖于状态改变的行为是如此的简单。</p><h3><span id="572-building-blocks-for-monads">5.7.2 Building blocks for monads</span></h3><p>在Scala中，Monads的构建块即是<code>flatMap</code> 和 <code>map</code>的组合。如果你把一个Monad看作是一个容器，那么flatMap 和 map 就是唯一两个可能的存储当前值的内部容器。flatMap 和 map 都接收一个函数参数，并通过提供函数组合创建一个新的monad实例，两者最终得到另外一个monad实例。为了从monad中接收值，你需要用不同的技术。在我们的例子中，我使用了apply方法来定义StateMonad。在有些类型monad中，你可以使用模式匹配。例如，<code>scala.Option</code>是一个monad，你可以使用模式匹配来接收来自Some实例的值。<br>现在，最重要的部分是要理解为什么需要flatMap 和 map 方法。两者看起来有相似的行为。为了阐明为什么，我们试试将calculatePrice改为不用for-comprehension实现:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePrice2</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) =</span><br><span class="line">  modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="keyword">val</span> stateMonad = modifyPriceState(findBasePrice) flatMap &#123; a =&gt;</span><br><span class="line">  modifyPriceState(applyStateSpecificDiscount) flatMap &#123; b =&gt;</span><br><span class="line">    modifyPriceState(applyProductSpecificDiscount) flatMap &#123; c =&gt;</span><br><span class="line">      modifyPriceState(applyTax) map &#123; d =&gt; () &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line"><span class="keyword">val</span> finalPrice = finalPriceState.price</span><br><span class="line">finalPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的价格状态使用flatMap来进行链接，而不是for-comprehension语法糖。你可以看到，我这里同时使用了flatMap 和 map。这实际上就是Scala对for-comprehension表达式如何转换的一种替代。我们现在比较一下map 和 flatMap的方法签名:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>方法map让你创建一个StateMonad实例；方法flatMap让你遍历这个嵌套状态。没有flatMap你最终会得到一个嵌套的State monad，因为每个modifyPriceState的调用会返回一个State monad的实例。可以改变上面的代码，用map 来代替 flatMap 看看效果的不同。</p><p>这里有一些创建一个monad的诀窍:</p><ul><li>为接口同时定义flatMap 和 map。</li><li>设计一个获取monad值的方式(模式匹配或者apply)。</li><li>符合<a href="https://wiki.haskell.org/Monad_laws">一元法则,monadic laws</a>。</li></ul><p>Monads几乎无处不在——可能用了也不知道。一个最常的monad你未有见过的 I/O monad。它可以让你组合带有副作用的函数。可以在Scalaz库中一探它的实现。现在你知道如何创建monads，以及在外面认出monad。Moands是一个很好的提升抽象层次的方式。你可以发明monads。</p><h2><span id="58-summary">5.8 Summary</span></h2><p>本章介绍了Scala的函数式编程。尽管你已经在前面的章节中使用函数式编程，这章则着重解析函数式编程的详细内容。可以从本书开始到本章看到函数式编程以及一些纯函数编程的例子。<br>企业开发者很难会不担心副作用的发生，因为任何业务编程之外都有或多或少讨论到外界接触。你已经学会了如何在代码中构建纯函数的模块，并尽可能将副作用放置离核心代码更远的地方，这将有助于你构建充满自信的、正确的应用程式。以及更少时间的debugging调试、必要的孤立可变状态避免更多的错误发生。<br>函数式编程最至关重要的得益之处是组合，即你通过提供基础属性构建大的编程。通过Scala的强大的抽象类型，最终你可以构建一个代码复用的组件。<br>同时，我们还学习了函数式编程的一种设计模式——Monad。它可以让你的组合直面副作用。最初它们看起来是复杂的，当你使用时，你会发现在很多地方都用到了这种设计模式，包括标准Scala库。使用Monads，你仅仅接触了函数式编程设计模式、概念的表面。我强烈推荐更进一步探索函数式编程的概念。最好的一个开始是阅读《Scala in Depth》。<br>函数式编程并不仅局限于Scala。你可以在你学过的任何编程语言中使用。时刻记住函数式编程的关键是创建一个引用透明的表达式，如果在你的语言中可以实现，那么go for it。函数式编程也应该能够组合。简言之，一门语言比其他编程语言更加函数式在于它比其它编程语言更容易组合。<br>第六章将会探索Java代码基于集成Scala的更多优势。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.defmacro.org/ramblings/fp.html">Slava Akhmechet, “Functional Programming for the Rest of Us,” June 19, 2006,</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/tWaV">Lloyd Anderson, “Lambda Calculus</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/b27e">Michael Feathers, “The Successor Value Pattern, March 22, 2009</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="http://en.wikipedia.org/wiki/Strategy_pattern">“Strategy pattern,” February 2011</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://wiki.scala-lang.org/display/SYGN/Loan">Kevin Wright (added), “Loan pattern,” last edited May 25, 2011</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/WKns">Reg Braithwaite, “Kestrels”</a></span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.cs.nott.ac.uk/~gmh/book.html">Graham Hutton, Programming in Haskell (Cambridge University Press, 2007)</a>.</span><a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">14.</span><span style="display: inline-block; vertical-align: top;"><a href="http://en.wikipedia.org/wiki/Category_theory">“Category Theory”</a></span><a href="#fnref:14" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：函数数据结构</title>
      <link href="/2016/10/27/scala/04-fp-structure/"/>
      <url>/2016/10/27/scala/04-fp-structure/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>类型参数化的协变和逆变(Covariance and contravariance)</li><li>高阶函数(high-order function)</li><li>自定义函数对象(function objects)</li><li>容器层次和并行容器(collection hierachy and parallel collection)</li></ol><p>本章将介绍Scala中有趣的部分: Scala集合完全支持两种类型的数据结构——可变和不可变。<br>在理解Scala集合优越性之前，你需要知道两个概念: 类型参数化(type parameterization)和高阶函数(higher-order functions)。类型参数化允许你创建的类型是其他参数的类型（类似于Java的泛型(generics)）。高阶函数则是你创建 的函数可以将其他函数作为参数。这两个概念使得你可以创意通用的、可重用的组件，如Scala集合。<br>Scala集合是所有Scala特征中最强大的一部分。Scala库中实现了所有你需要的通用数据结构，他对于所有Scala开发者来说都是必不可少的。最新添加的集合库是并行集合。并行集合使得处理数据并行性问题变得容易。你将会看到并行集 合在大数据集中如何处理，这部分将踏进有趣的路程。</p><span id="more"></span><h3><span id="4~1introducing-type-parameterizationp94">4~1〖Introducing type parameterization〗P94</span></h3><p>在编程语言中，类型参数化即是指允许你根据类型来定义方法和类，并且该类型在使用时才具体声明。它就像为类型创建了一个占位符一样。类型参数化这个概念和Java、C#的泛型相似，Scala提供了对这类泛型的附加扩展。<br>在第三章MongoDB的例子中介绍了方法只接收一个文档对象的findOne方法，问题是如果MongoDB的collection为空则返回一个null数据类型，但是并没有具体的null数据类型。一个处理办法就是添加注释，但是添加注释显然不是解决该问题的手段。<br>相似地，我们可以调用一个Option。Option是Scala的集合类型，和其他集合类型不一样，一个Option包含一个最大的元素。他代表着两种可能的值:None和Some。None表示“没有值”Some表示“某些值”。通过返回Option类型的方法，就可以解决某一个方法没有返回值的情况。<br>在这个小节中，抛弃所谓的Option类型实现自定义的数据类型。例如，你要创建一个函数用于返回列表中某一值对应的下标，这时你需要考虑各种不同类型的List列表，它会可能是整数，长整数或字符串。那么如何为所有类型建立一个函数呢？那就是 <strong>使用参数化类型</strong> ，如我们定义一个参数化类型的函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">position</span></span>[<span class="type">A</span>](xs:<span class="type">List</span>[<span class="type">A</span>],value:<span class="type">A</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">  xs.indexOf(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的A表示只有当这个函数被调用时类型才最终被确定。其中List和alue必须是相同的类型。不同于Java和C#，Scala使用方括号([])声明类型参数。当这个函数被调用并且list是整形时，A就表示是Int。相似地，如果改list是字符型，那么A就表示是String。现在用两个不同的参数测试一下这个方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> xs = <span class="type">List</span>(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>)</span><br><span class="line">xs: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(one, two, three)</span><br><span class="line"></span><br><span class="line">scala&gt; position(xs,<span class="string">&quot;two&quot;</span>)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ys = <span class="type">List</span>(<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line">ys: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; position(ys,<span class="number">40</span>)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; position[<span class="type">Int</span>](ys,<span class="number">300</span>)</span><br><span class="line">res2: <span class="type">Int</span> = <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>在最后一个例子中尽管你明确指定了参数化类型的具体值，实际上它是可选的。Scala类型参数化取决于具体传递参数的类型。<br>现在例子中当没有匹配到元素时，position会返回-1表示。现在，为了取代Int返回结果，希望返回一个新的类型，则可以创建一个容器来封装这个结果，把原来的position 方法修改为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 参数化的方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">position</span></span>[<span class="type">A</span>](xs:<span class="type">List</span>[<span class="type">A</span>],value:<span class="type">A</span>):<span class="type">Maybe</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> index = xs.indexOf(value)</span><br><span class="line">  <span class="keyword">if</span>(index != <span class="number">-1</span>) <span class="type">Just</span>(index) <span class="keyword">else</span> <span class="type">Nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果返回结果不是-1，方法position将返回<code>Just</code>；否则返回<code>Nil</code>。<code>Just</code>和<code>Nil</code>是两个参数实现自Maybe容器，因此我们需要添加相应的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author Barudisshu</span></span><br><span class="line"><span class="comment"> * @tparam A 替换的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Maybe</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Just</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">&quot;Nil.get&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这部分代码中，除了类型参数部分外大部分我们都已经熟悉了。Maybe抽象类实际上就是类型A的 <strong>协变</strong> ，下小节将探索类型协变的细节。</p><h3><span id="4~2type-variance-with-covariance-and-contravariancep95">4~2〖Type variance with covariance and contravariance〗P95</span></h3><p>类型参数化(type parameterization)由类型协变性(Type variance)补充构成，类型协变性的机制则是在类型系统中通过指定诸如协变性(convariant)和逆协变性(contravariant)进行约束。子类型的关系给协变带来了问题——在类型参数化中，子类型之间是什么关系？在Scala中，你可以通过class和trait实现参数化，如前面例子。当在class和trait中使用类型参数时，你可以使用 <code>+</code> 号实现协变(如Maybe)。类型协变(Convriance)允许对其父类的协变位置中(如返回值)进行重载和使用狭义类型。如Nil对象作为类型参数是Maybe的子类和scala.Nothing的组合，你使用scala.Nothing的原因是Nil的get方法会抛出异常，因为A是Maybe的协变，你可以返回它子类的狭义类型。因为Nothing是Scala类结构中的最低层，它没有子类，所以使用Nothing实现参数化协变。</p><blockquote><h4><span id="usefulness-of-nothing-in-scala">Usefulness of Nothing in Scala</span></h4><p>在Scala中，所有方法和函数都需要有返回类型，在Scala中没有void方法。当你的方法不返回任何东西时，Scala提供<code>scala.Unit</code>类型进行代替方法的返回类型；当你的方法返回类型不确定时，则可以使用<code>scala.Nothing</code>表示，使用比较多的情况就是当抛出一个异常时:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">throwException</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Always throws exception&quot;</span>)</span><br><span class="line">throwException: <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>所以，当你看到一个方法返回Nothing时，这意味着该方法没有成功返回。如下面在运行时中调用exit(System.exit):<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">kill</span> </span>= sys.exit(<span class="number">1</span>)</span><br><span class="line">kill: <span class="type">Nothing</span></span><br></pre></td></tr></table></figure></blockquote><p>在Scala中，一个不可变的List通过它的参数实现协变，因此<code>List[String]</code>是<code>List[Any]</code>的子类，你可以通过<code>List[Any]</code>声明任意的子类型实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val everything: List[Any] = List(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)</span></span><br><span class="line">everything: List[Any] = List(one, two, three)</span><br></pre></td></tr></table></figure><p>协变有许多有用的优点，看下面这个方法:<br><code>def ++(that: GenTraversableOnce [A]): List[A]</code><br>这个方法接收一个迭代类型并返回一个级联集合。相似地，集合<code>collection.Seq</code>，<code>collection.Iterable</code>和<code>collection.Traversable</code>都提供了同样的方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">++</span></span>(that: <span class="type">GenTraversableOnce</span>[<span class="type">A</span>]): <span class="type">Traversable</span>[<span class="type">A</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">++</span></span>(that: <span class="type">GenTraversableOnce</span>[<span class="type">A</span>]): <span class="type">Iterable</span>[<span class="type">A</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">++</span></span>(that: <span class="type">GenTraversableOnce</span> [<span class="type">A</span>]: <span class="type">Seq</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure><p>Traversable是所有集合类型的父类，方法<code>++</code>在这个trait内仅仅是声明而没有实现。其它子类<code>Seq</code>，<code>Iterable</code>和<code>List</code>等继承该方法。因此，截至目前为止，你所操作的所有集合都是返回同样的类型，而Traversable正好被用作一个协变参数。在本章末尾将展示所有集合的层次结构。</p><p>协变(convariance)的相对就是逆协变(contravariance)。在协变的例子中，子类型可以下行，如List。相反地，逆协变的反向就是——子类型上行。逆协变的出现是用于处理可变数据结构的。</p><blockquote><h4><span id="mutable-objects-need-to-invariant">Mutable objects need to invariant</span></h4><p>一个类型参数应该是不变(invariant)，不论它是协变的还是逆协变的。所有Scala可变集合类都是不变的。我们用一个例子来说明为什么可变对象应该是不变的。现在，你可以舒适地使用<code>collection.immutable.List</code>以及对应的可变<code>collection.mutable.ListBuffer</code>。因为<code>ListBuffer</code>是可变的，它被声明是不变的:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListBuffer</span>[<span class="type">A</span>] ...</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注意，如果声明了一个不可变类型(invarint type)，你需要去掉<code>-</code>和<code>+</code>标记符号，因为你不能再为<code>ListBuffer</code>指定其它类型。因此下面会发生编译错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val mxs: ListBuffer[String] = ListBuffer(<span class="string">&quot;pants&quot;</span>)</span></span><br><span class="line">mxs: scala.collection.mutable.ListBuffer[String] =</span><br><span class="line">ListBuffer(pants)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val everything: ListBuffer[Any] = mxs</span></span><br><span class="line">&lt;console&gt;:6: error: type mismatch;</span><br><span class="line">found : scala.collection.mutable.ListBuffer[String]</span><br><span class="line">required: scala.collection.mutable.ListBuffer[Any]</span><br><span class="line">val everything: ListBuffer[Any] = mxs</span><br></pre></td></tr></table></figure><p>尽管String是<code>scala.Any</code>的子类型，Scala不会将mxs指向到everything，为了理解为什么，我们假设ListBuffer是可变的，并且下列代码不会发生任何编译错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val mxs: ListBuffer[String] = ListBuffer(<span class="string">&quot;pants&quot;</span>)</span><br><span class="line">mxs: scala.collection.mutable.ListBuffer[String] =</span><br><span class="line">ListBuffer(pants)</span><br><span class="line">scala&gt; val everything: ListBuffer[Any] = mxs</span><br><span class="line">scala&gt; everything += 1</span><br><span class="line">res4: everything.type = ListBuffer(1, pants)</span><br></pre></td></tr></table></figure><p>你发现到问题了没有？因为everything是Any类型的，你不能存储任何整型值到一个字符型的集合，这简直在等待灾难的发生。为了避免这类型问题的发生，把一个可变对象(mutable objects)保持不变(invariant)是最好不过的办法。如果是集合中不可变对象的话会发生什么？置于不可变对象的协变不会发生任何问题。如果你把<code>ListBuffer</code>改为<code>List</code>，你会直接获得一个指向<code>List[Any]</code>的<code>List[String]</code>实例而不发生任何问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val xs: List[String] = List(<span class="string">&quot;pants&quot;</span>)</span></span><br><span class="line">xs: List[String] = List(pants)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val everything: List[Any] = xs</span></span><br><span class="line">everything: List[Any] = List(pants)</span><br></pre></td></tr></table></figure><p>这样指向安全的原因是List是不可变的，你可以添加<code>1 </code>到 <code>xs</code>列表中，并且他会返回一个新的Any类型的List:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span> :: xs</span><br><span class="line">res5: <span class="type">List</span>[<span class="type">Any</span>] = <span class="type">List</span>(<span class="number">1</span>, pants)</span><br></pre></td></tr></table></figure><p>再说一次，上述方法是正确的，因为<code>con(::)</code>方法总是返回一个新的<code>List</code>，而它的类型取决于List元素的类型。这里唯一可以同时存储一个整形值类型和一个引用值类型的类型是<code>scala.Any</code>。请记住，这是可变/不可变对象协变一项重要属性。</p></blockquote><p>要理解逆协变的最好办法就是直接讨论现成的问题，如看看下面Java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;Hello, there!&quot;</span>;</span><br></pre></td></tr></table></figure><p>你最后将一个整形数组指向了字符型，幸运的是Java会捕获在运行时抛出的ArrayStoreException异常，Scala会在编译期阻止这类错误并强制将参数类型转为逆协变的(contravarint)或不变的(invariant)。不论是协变的还是逆协变的，类型参数都是不变的。对逆协变最好的解析就是Scala中定义的Function1特性:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">P</span>, +<span class="type">R</span>] </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Scala使用减号(<code>-</code>)表示逆协变，加号(<code>+</code>)表示协变。在Function1中，<code>P</code>是逆协变的，<code>R</code>是协变的。在Scala中，函数包含值和类型。例如，Function1表示任何接收一个参数的函数，问题是为什么Function1对参数逆协变而对返回类型协变。<br>在回答问题之前，我们用反证法进行论证——对参数协变、对返回类型逆协变会发生什么？假如有这样一个协变参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val addOne: Function1[Any, Int] = &#123; x: Int =&gt; x + 1 &#125;</span><br></pre></td></tr></table></figure><p>因为Int是scala.Any的子类，协变参数应该允许上面的代码编译。这段代码的漏洞是你可以使用任意的类型参数来调用addOne，只要参数是Any的子类。这样做会引起一系列问题，因为该函数只接收Int。Scala作为一门类型安全的(type-safe)语言，不允许你这样做。另外一个唯一可能就是你需要将参数类型声明是不可变的(invariant)，但是这样会使得Function1不易扩展。创建一个类型安全的函数的唯一可行方案就是逆协变参数类型。<br>你不能使用一个逆协变的返回类型，考虑如下代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val asString: Int =&gt; Int = &#123; x: Int =&gt; (x.toString: Any) &#125;</span><br></pre></td></tr></table></figure><p>这段代码是无效的，因为Any是Int的超类，逆协变就是允许你从狭义类型到达广义类型。那下面这个是否正确:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asString(10) + 20</span><br></pre></td></tr></table></figure><p>代码最后把20加进一个字符串值，这明显有问题。在处理参数类型和返回类型时，Scala的强类型系统会中止这类错误的发生。要实现一个灵活的、类型安全的Function1特性，唯一可能实现的的方法就是参数类型的逆协变和返回类型的协变。下一小节将介绍类型参数的另一个重要概念——类型参数边界(bounds)。</p><h3><span id="4~3lower-and-upper-type-boundsp99">4~3〖Lower and upper type bounds〗P99</span></h3><p>在Scala中，类型参数受限于类型边界。类型边界限制类型变量的具体值。下面例子更清晰说明这个概念。下列代码中，函数position在Nil对象中调用get方法时会抛出异常:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val xs = List(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)</span></span><br><span class="line">xs: List[java.lang.String] = List(one, two, three)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> position(xs, <span class="string">&quot;two&quot;</span>).get</span></span><br><span class="line">res3: Int = 1</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> position(List(), <span class="string">&quot;two&quot;</span>).get</span></span><br><span class="line">java.util.NoSuchElementException: Nil.get</span><br><span class="line">  at Nil$.get(&lt;console&gt;:7)</span><br><span class="line">  at Nil$.get(&lt;console&gt;:5)</span><br><span class="line">  at .&lt;init&gt;(&lt;console&gt;:10)</span><br></pre></td></tr></table></figure><p>这是不是说在没有找到元素的时候不应该传递默认值？这种输出结果错误的情况可以控制的。你可以在Maybe抽象类中添加默认回调方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Maybe</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">A</span></span><br><span class="line">  <span class="comment">// 添加类型参数的边界</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse</span></span>(<span class="keyword">default</span>:<span class="type">A</span>):<span class="type">A</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty) <span class="keyword">default</span> <span class="keyword">else</span> get</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，方法getOrElse会返回在遇到isEmpty为true的时候会返回默认值，若是一个Nil实例时，isEmpty总是true的，则总会有一个默认值返回，但是在编译时会有下列错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">covariant type A occurs in contravariant position in type =&gt; A of value default</span><br></pre></td></tr></table></figure><p>因为A是协变类型，Scala不允许协变类型作为输入参数。所以如果A是逆协变类型，你会在编译期获得一下错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contravariant type A occurs in covariant position in type =&gt; A of method get</span><br></pre></td></tr></table></figure><p>有两个方案解决这个问题：一是，<code>Maybe</code>是不可变的(invariant)并用释放掉所有子类型的<code>Just</code>和<code>Nil</code>；二是，使用类型边界。我不愿意放弃这么好的子类型，所以我们就在本地使用类型边界吧。<br>Scala提供两种类型参数边界：上界和下界。一个参数上界就是声明 <code>T &lt;: A</code>，那么<code>T</code>就是<code>A</code>的子类，<code>A</code>就是参数的上界。要创建一个只允许<code>Maybe</code>子类类型的函数，你可以这样写:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaultToNull</span></span>[<span class="type">A</span> &lt;: <span class="type">Maybe</span>[_]](p: <span class="type">A</span>) = &#123;</span><br><span class="line">  p.getOrElse(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数defaultToNull接收参数<code>A</code>，并且它是<code>Maybe</code>的子类型。因为<code>Maybe</code>接收一个类型参数，在定义参数上界时，你必须声明类型参数。如果你不关心类型参数，你可以使用占位符(<code>_</code>)表示。<br>下界就是指类型参数的下限，<code>T &gt;: A</code>，则限制了<code>T</code>是<code>A</code>的超类。所以你可以使用参数下界来实现<code>getOrElse</code>方法。下面列出完整的Maybe类:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Maybe</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">A</span></span><br><span class="line">  <span class="comment">// 添加类型参数的边界，类型参数下界就是A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">default</span>:<span class="type">B</span>):<span class="type">B</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty) <span class="keyword">default</span> <span class="keyword">else</span> get</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类型参数的上界就是Maybe[_]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">defaultToNull</span></span>[<span class="type">B</span> &lt;: <span class="type">Maybe</span>[_]](p: <span class="type">B</span>) = &#123;</span><br><span class="line">    p.getOrElse(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Just</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">&quot;Nil.get&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maybe类定义了协变参数A使得它的子类可以返回更多特殊类型。方法getOrElse则可返回Just的接收类型或者空值时的默认类型。由于默认值被作为一个参数，你必须设置参数下界为A来满足逆协变规则。<br>Just和Nil两个子类分别代表成功和失败的情况。sealed修改器限制了其它对象创建Maybe的子类。<br>得到下标后，你就可以调用getOrElse方法而避免任何不需要的异常:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> position(List(), <span class="string">&quot;something&quot;</span>).getOrElse(-1)</span></span><br><span class="line">res6: Int = -1</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> position(List(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>), <span class="string">&quot;three&quot;</span>).getOrElse(-1)</span></span><br><span class="line">res8: Int = 2</span><br></pre></td></tr></table></figure><p>Scala的类型系统会非常轻易地在编译期间解析到错误。你已经学习了协变和逆协变的重要规则并创建优秀的类型安全的应用程序，并掌握了Scala类型系统的一些表面知识，并以足够理解本章节的数据结构，后面章节将更多地介绍Scala类型系统并通篇全书。</p><h3><span id="4~4higher-order-functions-including-map-flatmap-and-friendsp101">4~4〖Higher-order functions, including map, flatMap, and friends〗P101</span></h3><p>函数作为参数或作为返回值的函数称为 <em><strong>高阶函数</strong></em>。在Scala的<code>immutable.List.</code>的方法中存在大量的高阶函数，我们看看其中一个map方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>] ... </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>) : <span class="type">List</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里map中的A表示List类型，B则是新List的类型。要定义一个函数参数，需要使用 <code>=&gt;</code> 表示。这里，f是一个函数接收一个<code>A</code>类型的参数并返回一个B类型的结果值。如下，你创建了一个新的List并添加1到每一个元素中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3) map &#123; (x: Int) =&gt; x + 1 &#125;</span></span><br><span class="line">res12: List[Int] = List(2, 3, 4)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3) map &#123; _ + 1 &#125;</span></span><br><span class="line">res13: List[Int] = List(2, 3, 4)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def addOne(num:Int) = num + 1</span></span><br><span class="line">addOne: (num: Int)Int</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3) map addOne</span></span><br><span class="line">res11: List[Int] = List(2, 3, 4)</span><br></pre></td></tr></table></figure><p>第一段代码传递了一个匿名函数，该函数中x作为参数并加1；第二段代码使用一个函数字面量，其中占位符表示参数；最后一段则直接传递一个定义好的addOne方法。这是点自由风格编程(pointfree-style propgramming，参考http://www.haskell.org/haskellwiki/Pointfree 中的pointwise和pointfree部分)和函数组合的一个很好的例子，像这样也称之为 <em><strong>名传递(call-by-name)</strong></em>，即函数的参数被内部另外一个函数包装(wrap)。这里的addOne将被map能到达的所有函数所访问。<br>那一个函数是如何返回另外一个函数的？下面看看对addOne进行重构的之后的返回:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def addOne(num:Int) = &#123;</span><br><span class="line">  // 包含匿名函数的方法</span><br><span class="line">  def ++ = (x:Int) =&gt; x + 1</span><br><span class="line">  ++(num)</span><br><span class="line">&#125;</span><br><span class="line">// 中置表示法(没有点号)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1,2,3) map addOne</span></span><br><span class="line">res2: List[Int] = List(2, 3, 4)</span><br></pre></td></tr></table></figure><blockquote><h4><span id="call-by-value-call-by-reference-and-call-by-name-method-invocation">Call-by-value, call-by-reference, and call-by-name method invocation</span></h4><p>Java支持两种方法调用方式: 引用传递和值传递。引用传递就是函数通过引用传递到一个对象。在Scala中，它表示AnyRef的任何子类型。值传递就是函数调用通过值传递。在Scala中值类就是Int、Float等。记住，Scala的拆箱和封箱值类型取决于它在代码中如何使用。除此之外，Scala还提供了名传递(call-by-name)和需求传递(call-by-need)。名传递，就是将函数作为参数进行传递。看下面代码，定义一个log函数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(m: <span class="type">String</span>) = <span class="keyword">if</span>(logEnabled) println(m)</span><br></pre></td></tr></table></figure>但为了检索一条日志消息，你需要从错误队列中进行查找——一个耗时操作:<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popErrorMessage</span> </span>= &#123; popMessageFromASlowQueue() &#125;</span><br><span class="line">log(<span class="string">&quot;The error message is &quot;</span> + popErrorMessage).</span><br></pre></td></tr></table></figure>不管log是否可用，这个的参数每次都会被执行，但我们实际上不需要这样做。因此你就可以通过名传递来避免这些不必要的计算操作:<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(m: =&gt; <span class="type">String</span>) = <span class="keyword">if</span>(logEnabled) println(m)</span><br></pre></td></tr></table></figure>现在，使用`=>`操作符，函数的参数就是名传递的，在函数没有真正被调用时它不会生效。Scala会将该参数作为函数并在该参数被访问时执行参数内容。所以，如果log是不可用的，参数就永远不会被执行。之后会介绍到lazy集合的名传递调用模式，如Stream。</blockquote><p>这里的嵌套函数<code>++</code>返回另外一个函数，该返回函数接收一个Int参数并返回一个Int。在REPL环境中调用<code>++</code>方法，可以看到返回类型<code>Int=&gt;Int</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def ++ = (x:Int) =&gt; x + 1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">plus<span class="variable">$plus</span>: Int =&gt; Int</span></span><br></pre></td></tr></table></figure><p>如何实现一个像map那样可以接收任意list类型的函数？有两个方法可以实现map函数——递归和for-comprehension循环。如下代码是基于递归的、模式匹配的实现方式:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>,<span class="type">B</span>](xs:<span class="type">List</span>[<span class="type">A</span>],f:<span class="type">A</span>=&gt;<span class="type">B</span>):<span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  xs <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head::tail=&gt;f(head)::map(tail,f)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果List为空，则返回Nil，如果不为空，你将使用模式匹配将List分成head和tail两部分，其中head表示List的第一个元素，tail则表示List中剩余的元素。这里使用<code>::</code>实现了f函数的递归。<br>现在我们来用map函数处理List(1,2,3)并以addOne作为参数，它们的执行步骤如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case 1 :: List(2, 3) =&gt; addOne(1) :: map(List(2, 3), addOne)</span><br><span class="line">case 2 :: List(3) =&gt; 2 :: addOne(2) :: map(List(3), addOne)</span><br><span class="line">case 3 :: List() =&gt; 2 :: 3 :: addOne(3) :: map(List(), addOne)</span><br></pre></td></tr></table></figure><p>当所有递归流程走完之后，实际上得到的结果是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 :: 3 :: 4 :: Nil</span><br></pre></td></tr></table></figure><p>现在，函数f的每一个结果将对空List进行预处理，并组装返回一个新的List:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> map(List(1, 2, 3), addOne)</span></span><br><span class="line">res0: List[Int] = List(2, 3, 4)</span><br></pre></td></tr></table></figure><blockquote><h4><span id="how-does-head-tail-work">How does head :: tail work?</span></h4><p>大家一定会觉得很奇怪，为什么<code>2 :: 3 :: 4 :: Nil</code>运行后会得到一个List。像这种<code>head::tail</code>模式称为 <em><strong>中缀操作模式</strong></em> ，实际上<code>head :: tail</code>是构造模式<code>:: (head,tail)</code>的一种速记法。不可变List在Scala中被定义为抽象的密封类(abstract sealed class)，它只有两个子类<code>Nil</code>和<code>::</code>，两个子类都是样本类(case class)。我们知道，样本类最大的好处在于参与到模式匹配中。因此，<code>::(head,tail)</code>将匹配到<code>::</code>样本类中的构造器，并将head作为第一个元素，List作为第二个元素，即tail。</p></blockquote><p><code>cons(::)</code>的结合性是右对左的。即在表达式<code>2 :: 3 :: 4 :: Nil</code>中，你最先调用的是<code>Nil</code>的<code>::</code>，并返回该操作结果，依此类推。即是<code>Nil.::(2).::(3).::(4)</code>。在Scala中，操作符的结合性取决于操作符最后一个字符。如果操作符以<code>:</code>结尾，则它是 <em>右结合的(right-associative)</em> ，反之，其它操作符则是 <em>左结合的(left-associative)</em> 。操作符的结合性会迷惑许多Scala新手。只要记住，<strong>结合性取决于操作符最后一个字符</strong> 即可。</p><p>下面介绍另一种通过for-comprehension表达式实现的map函数方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def map1[A, B](f: A =&gt; B, xs: List[A]): List[B] = for(x &lt;- xs) yield f(x)</span><br></pre></td></tr></table></figure><p>List中另一个有趣的方法是flatMap，该方法通过一个函数作用List中的所有元素并串联所有结果，最后得到一个新的集合。在List中flatMap方法定义如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>] </span>&#123; ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">GenTraversableOnce</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenTraversableOnce表示所有可以实现串行(sequentially)或并行(parallel)迭代的集合类型。在集合库中，所有以Gen开头的特性(trait)都是用于为串行、并行集合提供操作的。现在先看看串行集合。<br>flatMap方法和map方法相似，具有将集合中的一个集合平面化(flatten)为一个单集合(single collection)的能力。如下例子，你从字符串list中创建一个字符list:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;&quot;</span>) flatMap &#123; _.toList &#125;</span></span><br><span class="line">res5: List[Char] = List(o, n, e, t, w, o, t, h, r, e, e)</span><br></pre></td></tr></table></figure><p>前面提到过，String被看作是一个类序列集合(Seq-like collection)，它暴露一个toList方法用于转换为List。在上述代码中，每个元素调用了toList方法。如果你用map代替flatMap，你会得到如下结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;&quot;</span>) map &#123; _.toList &#125;</span></span><br><span class="line">res7: List[List[Char]] = List(List(o, n, e), List(t, w, o), List(t, h, r, e, e), List())</span><br></pre></td></tr></table></figure><p>可以看到，flatMap将map的结果展平成一个单list，下面是flatMap如何在List中定义:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">B</span>](xss: <span class="type">List</span>[<span class="type">List</span>[<span class="type">B</span>]]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  xss <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt; head ::: flatten(tail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]) : <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  flatten(map(xs, f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的flatMap是通过flatten组合map的List来实现单List的扁平化。这里的 <code>:::</code> 是List中定义的另外一个方法，它用于向List尾部追加另一个List的内容，下面试试这个方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> flatMap(List(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)) &#123; _.toList &#125;</span></span><br><span class="line">res9: List[Char] = List(o, n, e, t, w, o, t, h, r, e, e)</span><br></pre></td></tr></table></figure><p>这里的flatMap有点不同，它有两个参数集，一个是List，另一个是f:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def flatMap[A, B](xs: List[A])(f: A =&gt; List[B]) : List[B]</span><br></pre></td></tr></table></figure><p>像这样的函数实现叫做柯里化(currying)。柯里化允许接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。柯里化将在第五章介绍。这里实现闭包的好处是函数参数可以以闭包<code>&#123;_.toList&#125;</code>的形式进行传递。</p><blockquote><h4><span id="whats-the-difference-between-a-lambda-and-a-closure">What’s the difference between a lambda and a closure?</span></h4><p>lambda表达式是一个匿名函数——没有函数名的函数。它源于数学中的λ演算而得名，在编程语言中多以回调、lambda关键字或 <code>=&gt;</code> 操作符表示整个lambda表达式。闭包(Closure)则多数是词法闭包(Lexical Closure)的简称。词法闭包，顾名思义就是关闭它所定义的语法环境，指代某些其开放绑定（自由变量）已经由其语法环境完成闭合（或者绑定）的 lambda 表达式，从而形成了 闭合的表达式。因此，闭包有两种理解：一是，闭包是在其词法上下文中引用了自由变量的函数；二是，闭包是由函数和与其相关的引用环境组合而成的实体。让我们用一个例子来探索这个事实，提供一个求百分比的例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(100, 200, 300) map &#123; _ * 10/100 &#125;</span></span><br><span class="line">res34: List[Int] = List(10, 20, 30)</span><br></pre></td></tr></table></figure>这里你传递给map函数的是一个lambda表达式，现在假设百分比的值会随时改变，把百分值存到一个变量中。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var percentage = 10</span></span><br><span class="line">percentage: Int = 10</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val applyPercentage = (amount:Int) =&gt; amount * percentage / 100</span></span><br><span class="line">applyPercentage: (Int) =&gt; &lt;function1&gt;</span><br></pre></td></tr></table></figure>这里applyPercentage就是一个闭包，因为它时刻与它所创建的环境保持联系，如一个百分数变量:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> percentage = 20</span></span><br><span class="line">percentage: Int = 20</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(100, 200, 300) map applyPercentage</span></span><br><span class="line">res33: List[Int] = List(20, 40, 60)</span><br></pre></td></tr></table></figure>lambda表达式和闭包虽然表示不同的概念，但是他们的关系非常接近。闭包只有在被调用时才执行，即“惰性求值”，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所以，闭包不是函数，只是行为和函数相似，不是所有被传递的函数都需要转化为闭包，只有引用环境可能发生变化的函数才需要这样做。</blockquote><p>使用递归的缺点是在处理大数据集时会产生堆栈溢出，因为计算机需要记住调用函数的位置—返回位置，返回位置会存储在调用栈上。解决这个问题的方式就是实现尾递归，因为实现尾递归不需要记住调用函数的位置，Scala在实现尾调用时优化并转换递归为循环。在尾递归中首先会执行计算，然后执行递归调用传递的当前步骤到下一步的结果内容。下面重构flatten函数实现尾递归处理:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">B</span>](xss:<span class="type">List</span>[<span class="type">List</span>[<span class="type">B</span>]]):<span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_flatten</span></span>(oldList: <span class="type">List</span>[<span class="type">List</span>[<span class="type">B</span>]], newList: <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] =</span><br><span class="line">    oldList <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt; newList</span><br><span class="line">      <span class="keyword">case</span> head :: tail =&gt; _flatten(tail, newList ::: head)</span><br><span class="line">    &#125;</span><br><span class="line">  _flatten(xss, <span class="type">Nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数flatten通过尾递归模式的嵌套函数实现。结果中的<code>newList:::head</code>作为一个参数传递给函数，使得Scala编译器可以对其进行优化。关于尾递归的更多内容将在下一章介绍。下一小节介绍另外一个新的概念——折叠(fold)，折叠用于处理具有某些顺序的数据结构并建立一个返回值。</p><h3><span id="4~5using-foldleft-and-foldrightp106">4~5〖Using foldLeft and foldRight〗P106</span></h3><p>List中定义的另外两个比较有趣的方法是foldLeft和foldRight。这两个操作允许你对List中的所有元素进行二进制操作。它们在List中的定义如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(f: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法不同的地方是参数z传递给函数f的方式。在foldLeft中，z表示开始值，它作为第一个参数传递给f，在foldRight中开始值则是作为第二个参数传递。函数f是一个组合函数用于接收两个参数并生成一个单结果值。为了理解折叠如何工作，让我们再一次看看之前的flatten实现代码。它和map中的递归实现相似:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">List</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  xs <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt; f(head) :: map(tail, f)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>[<span class="type">B</span>](xss: <span class="type">List</span>[<span class="type">List</span>[<span class="type">B</span>]]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  xss <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt; head ::: flatten(tail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当List为空时执行某操作、不为空时执行另一操作。你可以使用foldRight来避免重复操作:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> startValue = <span class="type">List</span>.empty[<span class="type">B</span>]</span><br><span class="line">  xs.foldRight(startValue) &#123; f(_) :: _ &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten2</span></span>[<span class="type">B</span>](xss: <span class="type">List</span>[<span class="type">List</span>[<span class="type">B</span>]]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> startValue = <span class="type">List</span>.empty[<span class="type">B</span>]</span><br><span class="line">  xss.foldRight(startValue) &#123; _ ::: _ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startValue被设置为一个空List，然后组合函数为所有元素提供二元操作。这里使用foldRight的原因是这里使用了右结合(right-associativeness)的 <code>::</code> 和 <code>::: </code>操作符号。当两者都是接收一个空List参数时就不会调用<code>::</code>或<code>:::</code>。我确定现在你一定很熟悉下划线(<code>_</code>)作为参数占位符。这是一个很好的例子，可以在高阶函数中建立普通操作而不必使用重复代码。<br>应该尽量避免在foldRight中使用递归，因为它潜在堆栈溢出错误的可能。在某些例子中，Scala编译器会将递归函数转换为loop循环，你会在下一章学习有关方面内容。另一个可选实现是使用foldLeft，然后将得到的结果反转。例如将map修改为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> startValue = <span class="type">List</span>.empty[<span class="type">B</span>]</span><br><span class="line">  xs.foldLeft(startValue)((a, x) =&gt; f(x) :: a).reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法foldLeft提供了一个二元操作从左到右处理开始值和List的所有元素。如下面使用foldLeft计算List的长度:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3, 4).foldLeft(0) &#123; _ + _ &#125;</span></span><br><span class="line">res25: Int = 10</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3, 4).foldLeft(0) &#123; (a, b) =&gt; a + 1 &#125;</span></span><br><span class="line">res27: Int = 4</span><br></pre></td></tr></table></figure><p>第一个例子计算了所有元素的值，第二个计算了List的长度。第二个例子不能使用占位符，因为你不能用所有函数的参数来计算List的长度。<br>foldLeft和foldRight都有一个别名版本，<code>/:(foldLeft)</code>和<code>:\(foldRight)</code>，你可以用它替换。但Scala开发者更趁于用foldLeft和foldRight象征表示。<br>折叠是对处理集合数据来建立返回值是一个好方法。map方法和flatMap方法实现集合转换，折叠则实现了结构类型的转换。你可以使用折叠来处理日常遇到的编程问题。如下面一个exists方法使用了foldLeft来判断元素是否存在:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(e: <span class="type">A</span>) = xs.foldLeft(<span class="literal">false</span>) &#123; (a, x) =&gt; a || x == e&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用foldLeft和foldRight的好处是就是只需要通过二元操作而不需要添加额外的方法来处理任何数据类型。<br>由于篇幅只介绍List集合类型，但对于其他集合类型同样适用，在本章末尾将介绍Scala的其他集合类型。</p><h3><span id="4~6building-your-own-function-objectsp108">4~6〖Building your own function objects〗P108</span></h3><p>函数对象(function object)就是一个对象可以作为函数使用。如下代码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">fold1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>,<span class="type">B</span>](xs:<span class="type">Traversable</span>[<span class="type">A</span>],defaultValue:<span class="type">B</span>)(op:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>) = (defaultValue /: xs)(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以使用这个fold1函数对象，就像使用函数一样:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> foldl(List(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>), <span class="string">&quot;0&quot;</span>) &#123; _ + _ &#125;</span></span><br><span class="line">res0: java.lang.String = 0123</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> foldl(IndexedSeq(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>), <span class="string">&quot;0&quot;</span>) &#123; _ + _ &#125;</span></span><br><span class="line">res24: java.lang.String = 0123</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> foldl(Set(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>), <span class="string">&quot;0&quot;</span>) &#123; _ + _ &#125;</span></span><br><span class="line">res25: java.lang.String = 0123</span><br></pre></td></tr></table></figure><p>前面我们已经看过不少apply方法的例子，apply在函数对象的用法一样。要把一个对象看作函数对象，你只需要声明apply方法即可。在Scala中， <em><strong><code>&lt;object&gt;(&lt;arguments&gt;)</code>实际上就是<code>&lt;object&gt;.apply(&lt;arguments&gt;)</code>的语法糖</strong></em> ，当然你可以设置更多的参数。<br>因为你定义了参数Traversable，它是Scala所有集合的超类，因此你可以传递任何集合类型参数。<br>表达式<code>(defaultValue /: xs)(op)</code>看起来有些神秘，但它是由替换语法foldLeft演变而来的，<code>/:</code>是foldLeft的别名，并且是以<code>:</code>结尾，这意味着它是右结合的。<br>声明了函数对象后，现在我们来探索一下Scala库中定义的Function特质。在Scala中，Function1特性被定义如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T1</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v: <span class="type">T1</span>): <span class="type">R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的1表示带一个参数的函数</strong>，相似地，Scala中定义了两个或者多个的类型Function特质。例如，下面代码创建了一个自增的函数，该函数接收一个参数并加1返回:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">++</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(p: <span class="type">Int</span>): <span class="type">Int</span> = p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的简化和等效实现是:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ++ = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>还有另外一个方法实现这个函数对象：使用function的替换符号 <code>=&gt;</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">++</span> <span class="keyword">extends</span> (<span class="params"><span class="type">Int</span> =&gt; <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(p: <span class="type">Int</span>): <span class="type">Int</span> = p + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个例子，你使用了Function1的简写符号<code>Int =&gt;</code> Int，在定义高阶函数时，你使用了相似的语法符号。你可以在lambda或闭包的任何地方使用函数对象，例如，你在map中使用这个<code>++</code>函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> map(List(10, 20, 30), ++)</span></span><br><span class="line">res1: List[Int] = List(11, 21, 31)</span><br></pre></td></tr></table></figure><p>它实际上和匿名函数是等效的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> map(List(10, 20, 30), (x: Int) =&gt; x + 1)</span></span><br><span class="line">res2: List[Int] = List(11, 21, 31)</span><br></pre></td></tr></table></figure><p>最终结果都是调用它的Function特性原型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> map(List(10, 20, 30), new Function1[Int, Int] &#123;</span></span><br><span class="line">def apply(p: Int) = p + 1</span><br><span class="line">&#125;)</span><br><span class="line">res3: List[Int] = List(11, 21, 31)</span><br></pre></td></tr></table></figure><p>当传递一个已有函数(不是函数对象)作为一个参数时，Scala会创建一个新的匿名函数对象，该匿名函数带apply方法，并调用对应原生函数。像这种称为eta规约(eta-expansion)。</p><blockquote><p>什么是eta-expansion？什么是eta-conversion？<br>这是lambda演算中定义外延相等的公理。</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cpsi%20%5Cstackrel%7B%5Ceta%7D%7B%3D%7D%20%5Clambda%20x.%5Cpsi%20x%0A%5Cend%7Baligned%7D%0A"></p><p>即 lambda x.f x = f<br>简单来说就是：<br>把 x =&gt; func(x) 简化为 func _ 或 func 的过程称为 eta-conversion<br>把 func 或 func _ 展开为 x =&gt; func(x) 的过程为 eta-expansion<br>lambda演算中主要有alpha变换，beta规约，eta规约，你说的eta-expansion其实是eta规约规则的逆用。</p></blockquote><h4><span id="function1-is-also-defined-as-function">Function1 is also defined as Function</span></h4><p>因为Function1使用得非常频繁，Scala定义了一个类型别名Function。你不会在Scaladoc中找到其相关的文档，因为这个类型别名被定义在Predef类中:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Function</span>[-<span class="type">A</span>, +<span class="type">B</span>] </span>= <span class="type">Function1</span>[<span class="type">A</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>type为Scala中的关键字，它用于创建一个类型别名，和C中typedef相似。类型变量将在第六章介绍，并将探索如何通过类型变量来创建抽象成员。<br>类型变量的一个好处是可以用它来表示一个复杂的类型:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MILS</span> </span>= <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">String</span>]]</span><br><span class="line"><span class="keyword">val</span> mapping: <span class="type">MILS</span> = <span class="type">Map</span>(</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="type">List</span>(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;uno&quot;</span>), <span class="number">2</span> -&gt; <span class="type">List</span>(<span class="string">&quot;two&quot;</span>, <span class="string">&quot;dos&quot;</span>))</span><br></pre></td></tr></table></figure><p>函数特质允许你及nag两个函数组合成一个新函数。当你趁于通过组合函数来处理问题时，这显得尤为重要。如下我们将相同的函数组装两次，并创建出一个新的函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val addOne: Int =&gt; Int = x =&gt; x + 1</span><br><span class="line">val addTwo: Int =&gt; Int = x =&gt; x + 2</span><br><span class="line">val addThree = addOne compose addTwo</span><br></pre></td></tr></table></figure><p>它和下面的实现相似:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val addThree: Int =&gt; Int = x =&gt; addOne(addTwo(x))</span><br></pre></td></tr></table></figure><p>组合方法允许你将函数链接在一起来组装成一个新的函数。在下一章将介绍到更多关于函数组合的内容。现在我们来探索一下Scala的集合层次结构。</p><h3><span id="4~7scala-collection-hierarchyp110">4~7〖Scala collection hierarchy〗P110</span></h3><p>在Scala2.8发布以来添加的主要特性是提升的集合库。本小节将探索Scala集合的详细内容。<br>Scala集合类在<code>scala.collection</code>包以及它的子包中，在<code>scala.collection.mutable</code>包中定义了可以改变集合状态的集合类，相反，在<code>scala.collection.immutable</code>保证了不可变性。不可变集合有时被称为持久化数据结构(persistent data structures)。这里的持久化与数据库无关，是指在随着当前程序执行，一个不可变集合保持不变。在一个不可变集合的任何变化会产生一个新的集合，但不涉及到存在的集合。<br>为实现多种多样的集合，通过分包提供模块构建。一般地你不需要在同属包做任何处理，除非你要实现自定的集合类。<br>一个定义在scala.collection包中集合类可以是可变的或不可变的。例如，<code>scala.collection.Map[A,+B]</code>是<code>collection.mutable.Map[A,B]</code>和<code>collection.immutable.Map[A,+B]</code>的超类。一般地，在包scala.collection的根集合为可变集合和不可变集合定义了相同的接口，并在不可变集合的顶部添加附加的转换方法。以map为例，它提供了诸如+=和-=的方法用于添加和删除集合中的元素。尽管你可以使用根集合类型作为一个不可变集合的引用类型，但最好是显式地指明集合的类型(可变的还是不可变的)，因为在处理集合时，开发者可以更好的处理代码。下面你声明了既是可变集合，又是不可变集合的collection.Map类型值，并且不清楚mapping的类型是否可以改变:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val mapping: collection.Map[String, String] = Map(<span class="string">&quot;Ron&quot;</span> -&gt; <span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line">&quot;Sam&quot; -&gt; &quot;Analyst&quot;)</span><br><span class="line">mapping: scala.collection.Map[String,String] =</span><br><span class="line">Map(Ron -&gt; admin, Sam -&gt; Analyst)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val mapping: collection.Map[String, String] =</span></span><br><span class="line">collection.mutable.Map(&quot;Ron&quot; -&gt; &quot;admin&quot;, &quot;Sam&quot; -&gt; &quot;Analyst&quot;)</span><br><span class="line">mapping: scala.collection.Map[String,String] = Map(Sam -&gt; Analyst, Ron -&gt;</span><br><span class="line">admin)</span><br></pre></td></tr></table></figure><p>Scala会自动导入不可变集合，但你需要显式地导入可变集合类型，如这里导入了collection.mutable.Map。Scala的集合层次结构大概有三个主要的集合类型：<code>Set</code>，<code>Seq</code>，<code>Map</code><br>集合层次中的根部是Traversable特质，他实现了所有集合类型的通用功能。在Traversable特质中定义的唯一抽象方法是foreach：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">Elem</span> =&gt; <span class="type">U</span>)</span><br></pre></td></tr></table></figure><h5><span id="scala-collection-hierarchy-with-three-main-types-of-collections-set-seq-and-map">Scala collection hierarchy with three main types of collections: Set, Seq, and Map</span></h5><p><img src="/img/scala-in-action/chapter4/collection-hierarchy.png" alt="Scala collection hierarchy with three main types of collections: Set, Seq, and Map"></p><h5><span id="useful-methods-defined-in-the-traversable-trait">Useful methods defined in the Traversable trait</span></h5><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>xs.size</code></td><td style="text-align:center">集合中元素的个数</td></tr><tr><td style="text-align:center"><code>xs ++ ys</code></td><td style="text-align:center">由 xs 和 ys 组合的集合</td></tr><tr><td style="text-align:center"><code>xs map f</code></td><td style="text-align:center">为 xs 中的每个 x 作 f(x)</td></tr><tr><td style="text-align:center"><code>xs flatMap f</code></td><td style="text-align:center">为 xs 中的每个 x 作 f(x)，并串联</td></tr><tr><td style="text-align:center"><code>xs filter p</code></td><td style="text-align:center">xs 中存在 x，使得 x 满足 p(x)</td></tr><tr><td style="text-align:center"><code>xs find p</code></td><td style="text-align:center">xs 中存在 x，使得 x 满足 p(x)，不存在则 None</td></tr><tr><td style="text-align:center"><code>(z /: xs)(h)</code></td><td style="text-align:center">xs 中 foldLeft 从右到左对每个元素折叠 h(x,y)</td></tr><tr><td style="text-align:center"><code>(xs :\ z)(h)</code></td><td style="text-align:center">xs 中 foldLeft 从右到左对每个元素折叠 h(x,y)，并反转</td></tr><tr><td style="text-align:center"><code>xs.head</code></td><td style="text-align:center">集合第一个元素(或迭代中的 next)</td></tr><tr><td style="text-align:center"><code>xs.tail</code></td><td style="text-align:center">xs中除 xs.head 剩余的元素</td></tr><tr><td style="text-align:center"><code>xs mkString sep</code></td><td style="text-align:center">生成以 sep 分割的字符串</td></tr></tbody></table><p>下面看看一个例子。我们可以在Scala集合中使用Java集合，这里有一个更简单的例子，它可以在Java集合和Traversable之间任意转换:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaToTraversable</span>[<span class="type">E</span>](<span class="params">javaCollection: <span class="type">JCollection</span>[<span class="type">E</span>]</span>) <span class="keyword">extends</span> <span class="title">Traversable</span>[<span class="type">E</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f : <span class="type">E</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = javaCollection.iterator</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext) &#123;</span><br><span class="line">      f(iterator.next)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了它的唯一一个抽象方法foreach，通过这个方法，你可以使用Traversable子类中带有foreach方法实现所有方法，如<code>map</code>、<code>foldLeft</code>或<code>filter</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val jCol = new ArrayList[Int]</span></span><br><span class="line">jCol: java.util.ArrayList[Int] = []</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (1 to 5) foreach &#123; jCol.add(_) &#125;</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> jCol</span></span><br><span class="line">res3: java.util.ArrayList[Int] = [1, 2, 3, 4, 5]</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val jtoT = new JavaToTraversable(jCol)</span></span><br><span class="line">jtoT: JavaToTraversable[Int] = line3(1, 2, 3, 4, 5)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> jtoT map &#123; _ * 10 &#125; filter &#123; _ &gt; 20 &#125;</span></span><br><span class="line">res10: Traversable[Int] = List(30, 40, 50)</span><br></pre></td></tr></table></figure><p>在Scala中，你可以定义一个有限的或无限的traversable对象；<code>hasDefiniteSize</code>会决定一个集合是有限的还是无限的。你会在这章最后看到有关例子。</p><h3><span id="4~8mutable-and-immutable-collectionsp113">4~8〖Mutable and immutable collections〗P113</span></h3><p>在scala.collection包中的集合既是可变的，也是不可变的。在前面小节阅读了可变集合类和不可变集合类的区别。我们来看看Iterable特质这个特殊的集合类。它的超类是Traversable。它提供了foreach的实现并暴露了一个新的抽象方法iterator。同时它还提供了Traversable中定义的takeRight和dropRight方法实现。takeRight返回集合最后的n个元素，dropRight则刚好相反:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> Iterable(1, 2, 3, 4, 5) dropRight 2</span></span><br><span class="line">res0: Iterable[Int] = List(1, 2, 3)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> Iterable(1, 2, 3, 4, 5) takeRight 2</span></span><br><span class="line">res1: Iterable[Int] = List(4, 5)</span><br></pre></td></tr></table></figure><p>有趣的是Iterable的三个基础类:Seq，Set和Map。这些子类一个共同点是它们都实现了PartialFunction特质，这意味着它们都具有apply方法。现在我们来看看这些子类有哪些特性。</p><h3><span id="4~9working-with-list-and-listbufferp114">4~9〖Working with List and ListBuffer〗P114</span></h3><p>在一个序列中，元素被0到length - 1索引，length即为序列的元素个数。因为Seq实现了PartialFunction，因此它有一个apply方法，它是一个从Int到一个元素的局部函数。原因是索引的Int可能在集合中不存在元素。如下我们访问一个存在的元素和一个不存在:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val languages = Seq(<span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;OCaml&quot;</span>, <span class="string">&quot;ML&quot;</span>)</span></span><br><span class="line">languages: Seq[java.lang.String] = List(Scala, Haskell, OCaml, ML)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> languages(1)</span></span><br><span class="line">res11: java.lang.String = Haskell</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> languages(10)</span></span><br><span class="line">java.lang.IndexOutOfBoundsException</span><br><span class="line">at scala.collection.LinearSeqLike$class.apply(LinearSeqLike.scala:78)</span><br><span class="line">at scala.collection.immutable.List.apply(List.scala:46)</span><br></pre></td></tr></table></figure><blockquote><h4><span id="using-a-collection-as-partialfunction">Using a collection as PartialFunction</span></h4><p>在PartialFunction特质中，除了定义了apply方法之外，还定义了两个有趣的方法: andThen和orElse。例如，为了避免Seq中没有元素的情况，你可以使用orElse处理局部函数没有找到值的保障方案。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">default</span>: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;Is it a functional language?&quot;</span> &#125;</span><br><span class="line"><span class="keyword">val</span> languagesWithDefault = languages orElse <span class="keyword">default</span></span><br></pre></td></tr></table></figure>现在访问一个不存在的下标时，它返回一个默认值作为代替。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">languagesWithDefault(10) will produce &quot;Is it a functional language?&quot;</span><br></pre></td></tr></table></figure>更多函数组件的内容将在本书介绍到。</blockquote><p>如果一个序列是可变的，如ListBuffer，那么除了提供apply方法外，它还提供了一个update方法。如下代码你创建一个ListBuffer并进行update操作:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> buf = <span class="type">ListBuffer</span>(<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">5.6</span>)</span><br><span class="line">buf: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Double</span>] =</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">5.6</span>)</span><br><span class="line">scala&gt; buf(<span class="number">2</span>) = <span class="number">10</span></span><br><span class="line">scala&gt; buf</span><br><span class="line">res30: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Double</span>] =</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">10.0</span>)</span><br><span class="line">scala&gt; buf.update(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">scala&gt; buf</span><br><span class="line">res32: scala.collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Double</span>] =</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>注意这里的buf(2) = 10 和 buf.update(2,20)方法调用是完全相同的。Scala中，Seq的主要两个子类是LinearSeq和Vector。它们提供了不同的性能特征。Vector提供了高效的apply和length操作、LinearSeq提供了高效的head和tail操作。LinearSeq最常见的两个子类是List和Stream。这里介绍了List的使用例子，很快我们再探索Stream的相关内容。</p><blockquote><h4><span id="what-type-of-collection-should-i-use">What type of collection should I use?</span></h4><p>Scala集合提供了丰富多样的集合类型，每个集合类型有不同的性能特征，因此要确保你选择了一个合适的集合类型来处理你的问题。有些情况是你不确定应该使用哪个集合类型时，则应该使用Vector作为援助。总体来说，Vector相比其他集合类型拥有更好的性能特征。</p></blockquote><p>在Scala中， Sequence s的一个有趣子类范畴是Buffer s。Buffer s 总是可变的，在这里我们说得最多的内建集合类就是使用Buffer s。目前最常见的Buffer s子类包括mutable.ListBuffer 和 mutable.ArrayBuffer。</p><h3><span id="491working-with-set-and-sortedsetp115">4<sub>9</sub>1〖Working with Set and SortedSet〗P115</span></h3><p>Set是一个迭代集合类型，它不包含重复元素。Set提供了contains方法来检测给出的元素是否在Set中，并且对应的apply方法会做同样的处理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> frameworks = <span class="type">Set</span>(<span class="string">&quot;Lift&quot;</span>, <span class="string">&quot;Akka&quot;</span>, <span class="string">&quot;Playframework&quot;</span>, <span class="string">&quot;Scalaz&quot;</span>)</span><br><span class="line"><span class="comment">// Both of contains and apply method doing the same things.</span></span><br><span class="line">assertResult(<span class="literal">true</span>)&#123;frameworks contains <span class="string">&quot;Lift&quot;</span>&#125;</span><br><span class="line">assertResult(<span class="literal">true</span>)&#123;frameworks(<span class="string">&quot;Playframework&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>若要从一个不可变Set中添加或移除元素，则可以使用 <code>+</code> 和 <code>-</code> 操作符。对于一个可变的Set不推荐使用这些方法，因为它会创建一个新的Set，因为它不会更新自身。一个好的处理Set s的方法是使用 <code>+=</code> 和 <code>-=</code> 方法(如下表格内容)。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>xs contains x</code></td><td style="text-align:left">x是否为xs的一个元素</td></tr><tr><td style="text-align:left"><code>xs ++ ys</code></td><td style="text-align:left">由 xs 和 ys 组合的集合，但不从 ys 中添加重复的元素</td></tr><tr><td style="text-align:left"><code>xs &amp; ys, xs intersect ys</code></td><td style="text-align:left">xs 和 ys 的交集</td></tr><tr><td style="text-align:left"><code>xs ┃ f, xs union ys</code></td><td style="text-align:left">xs 和 ys 的并集</td></tr><tr><td style="text-align:left"><code>xs &amp;~ ys, xs diff ys</code></td><td style="text-align:left">xs 和 ys 的补集</td></tr><tr><td style="text-align:left"><code>xs ++= ys</code></td><td style="text-align:left">只作用于可变Set，从 ys 向 xs 添加元素，返回 xs 自身</td></tr><tr><td style="text-align:left"><code>xs(x) = b, xs.update(x,b)</code></td><td style="text-align:left">如果b为true，则将 x 添加 xs；反之则从 xs 移除 x</td></tr><tr><td style="text-align:left"><code>xs.clear()</code></td><td style="text-align:left">移除所有xs的元素</td></tr></tbody></table><p>下面是一些关于可变Set和不可变Set的一些添加和移除的例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val frameworks = Set() + <span class="string">&quot;Akka&quot;</span> + <span class="string">&quot;Lift&quot;</span> + <span class="string">&quot;Scalaz&quot;</span></span></span><br><span class="line">frameworks: scala.collection.immutable.Set[java.lang.String] = Set(Akka,</span><br><span class="line">Lift, Scalaz)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val frameworks = Set(<span class="string">&quot;Akka&quot;</span>, <span class="string">&quot;Lift&quot;</span>, <span class="string">&quot;Scalaz&quot;</span>) - <span class="string">&quot;Lift&quot;</span></span></span><br><span class="line">frameworks: scala.collection.immutable.Set[java.lang.String] = Set(Akka,</span><br><span class="line">Scalaz)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val mFrameworks = collection.mutable.Set[String]()</span></span><br><span class="line">mFrameworks: scala.collection.mutable.Set[String] = Set()</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> mFrameworks += <span class="string">&quot;Akka&quot;</span> += <span class="string">&quot;Lift&quot;</span></span></span><br><span class="line">res5: mFrameworks.type = Set(Lift, Akka)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> mFrameworks += <span class="string">&quot;Scalacheck&quot;</span></span></span><br><span class="line">res12: mFrameworks.type = Set(Lift, Akka, Scalacheck)</span><br></pre></td></tr></table></figure><p>除了add和remove方法之外，你可以使用Set的其他操作，如union，intersect和diff。另外，Set有个子类SortedSet。当iterator和foreach在SortedSet中调用时，它会将产生的元素放在合适的顺序上。下列代码片段你添加了两个Set，其中一个使用了Set，另外一个使用SortedSet，在SortedSet中，将维持元素的顺序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> Set(1, 2, 3) ++ Set(3, 4, 5)</span></span><br><span class="line">res15: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import collection.immutable.SortedSet</span></span><br><span class="line">import collection.immutable.SortedSet</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> SortedSet (1, 2, 3) ++ SortedSet(3, 5, 4)</span></span><br><span class="line">res18: scala.collection.immutable.SortedSet [Int] = TreeSet(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure><h3><span id="492working-with-map-and-tuplep117">4<sub>9</sub>2〖Working with Map and Tuple〗P117</span></h3><p>Maps 是键值对迭代的，键值对由<code>scala.Tuple2</code>表示，即两个元素的管道。和其他集合不一样，管道是异构的集合，因此你可以存储各种各样的元素类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val m = Map((1, <span class="string">&quot;1st&quot;</span>), (2, <span class="string">&quot;2nd&quot;</span>))</span></span><br><span class="line">m: scala.collection.immutable.Map[Int,java.lang.String] =</span><br><span class="line">Map(1 -&gt; 1st, 2 -&gt; 2nd)</span><br></pre></td></tr></table></figure><p>一个可选的写法是使用 key-&gt;value 表达式表示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val m = Map(1 -&gt; <span class="string">&quot;1st&quot;</span>, 2 -&gt; <span class="string">&quot;2nd&quot;</span>)</span></span><br><span class="line">m: scala.collection.immutable.Map[Int,java.lang.String] =</span><br><span class="line">Map(1 -&gt; 1st, 2 -&gt; 2nd)</span><br></pre></td></tr></table></figure><p>Map的大多数操作和Set相似。不同的是，在Map中，apply方法用于返回一个key的value，并且如果对应的value不存在，它将抛出一个异常。下面是使用apply方法的例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> m(1)</span></span><br><span class="line">res20: java.lang.String = 1st</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> m(3)</span></span><br><span class="line">java.util.NoSuchElementException: key not found: 3</span><br><span class="line">at scala.collection.MapLike$class.default(MapLike.scala:226)</span><br><span class="line">at scala.collection.immutable.Map$Map2.default(Map.scala:88)</span><br></pre></td></tr></table></figure><p>最好的key-value关联获取方法是使用 get 方法，它定义在Map中。为了代替返回值，它将返回的value封装在Option容器中:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(kye: <span class="type">A</span>): <span class="type">Option</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>Option和我们之前创建的Maybe结构相似，但Scala中的Option提供了比Maybe更多的特性。你可以把Option认为是只有一个元素的List。当Map中存在元素的时候，它返回Some；否则它返回None。下面例子使用get来检索key的value:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> m.get(1)</span></span><br><span class="line">res22: Option[java.lang.String] = Some(1st)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> m.get(3)</span></span><br><span class="line">res23: Option[java.lang.String] = None</span><br></pre></td></tr></table></figure><p>你可以使用get方法来提取Option中的元素，或使用getOrElse检索Option中的值。若要获得Map中的所有key和value，你可以使用m.keys和m.values来获取，两者都返回Iterator。Scala的Map也定义了filter，该方法接受一个断言，当断言为true时，返回一个Map的所有键值。下面代码片段，你要过滤掉所有rock artists。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val artists = Map(</span></span><br><span class="line">&quot;Pink Floyd&quot; -&gt; &quot;Rock&quot;, &quot;Led Zeppelin&quot; -&gt; &quot;Rock&quot;,</span><br><span class="line">&quot;Michael Jackson&quot; -&gt; &quot;Pop&quot;, &quot;Above &amp; Beyond&quot; -&gt; &quot;Trance&quot;)</span><br><span class="line">artists: scala.collection.immutable.Map[java.lang.String,java.lang.String] =</span><br><span class="line">Map(Pink Floyd -&gt; Rock, Led Zeppelin -&gt; Rock, Michael Jackson -&gt; Pop,</span><br><span class="line">Above &amp; Beyond -&gt; Trance)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> artists filter &#123; (t) =&gt; t._2 == <span class="string">&quot;Rock&quot;</span> &#125;</span></span><br><span class="line">res26: scala.collection.immutable.Map[java.lang.String,java.lang.String] =</span><br><span class="line">Map(Pink Floyd -&gt; Rock, Led Zeppelin -&gt; Rock)</span><br></pre></td></tr></table></figure><p>下面列出一些定义在可变和不可变的Map中的方法</p><pre><code>       方法              |            描述</code></pre><p>---------------------------- | :----------------------------------------------------------<br><code>ms getOrElse (k, d)</code>        | 获取 ms 中 键 k 的值，不存在则默认为 d<br><code>ms + (k -&gt; v)</code>              | 包含 ms 所有映射和 k-&gt;v 映射的Map<br><code>ms ++ kvs</code>                  | 包含 ms 所有映射和 kvs 所有键值对<br><code>ms filterKeys p</code>            | ms 中的 key 满足断言 p的映射<br><code>ms mapValues f</code>             | 对 ms 中的所有 value 作 f<br><code>ms(k) = v, ms.update(k, v)</code> | 对 ms 中的键 k 作更新操作，k 对应的 value 被覆盖<br><code>ms getOrElseUpdate(k, d)</code>   | 如果 k 在 ms 中有定义，则返回对应的 value，否则添加 k-&gt;d 并返回d<br><code>ms.clear()</code>                 | 删除ms中的所有映射</p><p>在Map中的filter方法的调用是通过将key-value键值对作为<code>scala.Tuple2</code>实例传递的。Tuple2在Scala中定义了<code>_1</code>和<code>_2</code>两个方法，它用于接收Tuple的第一个和第二个元素。如你可以使用for-comprehension过滤掉所有的rock artists:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span>(t &lt;- artists; <span class="keyword">if</span>(t._2 == <span class="string">&quot;Rock&quot;</span>)) yield t</span></span><br><span class="line">res31: scala.collection.immutable.Map[java.lang.String,java.lang.String] =</span><br><span class="line">Map(Pink Floyd -&gt; Rock, Led Zeppelin -&gt; Rock)</span><br></pre></td></tr></table></figure><p>for-comprehension和map方法、filter、foreach方法十分相似。下一小节你将看到for-comprehension在Scala中是如何转换的。</p><h3><span id="493under-the-hood-of-for-comprehensionp118">4<sub>9</sub>3〖Under the hood of for-comprehension〗P118</span></h3><p>前面我们学习了for-comprehension的使用方法，但是我们实际上不知道for-comprehension转换时发生了什么，以及如何使用模式匹配与filter、map、faltMap和foreach方法联合起来。学习这些知识后，他会帮助你理解如何联合一些简单的函数来做一些强大的事情。当然，最好的方法是看看底层到底发生了什么。<br>这里我们创建一个case class来表示艺术家并使用for-comprehension来创建一个摇滚artists的list。下面是代码片段:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span>(<span class="params">name: <span class="type">String</span>, genre: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">val</span> artists = <span class="type">List</span>(<span class="type">Artist</span>(<span class="string">&quot;Pink Floyd&quot;</span>, <span class="string">&quot;Rock&quot;</span>),</span><br><span class="line"><span class="type">Artist</span>(<span class="string">&quot;Led Zeppelin&quot;</span>, <span class="string">&quot;Rock&quot;</span>),</span><br><span class="line"><span class="type">Artist</span>(<span class="string">&quot;Michael Jackson&quot;</span>, <span class="string">&quot;Pop&quot;</span>),</span><br><span class="line"><span class="type">Artist</span>(<span class="string">&quot;Above &amp; Beyond&quot;</span>, <span class="string">&quot;trance&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Artist</span>(name, genre) &lt;- artists; <span class="keyword">if</span>(genre == <span class="string">&quot;Rock&quot;</span>))</span><br><span class="line"><span class="keyword">yield</span> name</span><br></pre></td></tr></table></figure><blockquote><h4><span id="why-use-withfilter-but-not-filter">Why use withFilter but not filter?</span></h4><p>我i什么要用withFilter而不用filter？答案在于filter的处理是否要求严格还是不严格。filter方法只有在这些元素满足断言/条件的情况下，而不严格的处理则表示计数只在需要的基础上。从Scala 2.8开始，for-comprehension是不严格的。例如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> go = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">for</span>(i &lt;- list; <span class="keyword">if</span>(go)) <span class="keyword">yield</span> &#123;</span><br><span class="line">go = <span class="literal">false</span></span><br><span class="line">i</span><br><span class="line">&#125;</span><br><span class="line">println(x)</span><br></pre></td></tr></table></figure>你期望输出List(1)，但是如果在2.7版本上执行，实际上则输出List(1,2,3)。原因是在2.8之前，for-comprehensions会被如下转换实现:<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> y = list filter &#123;</span><br><span class="line"><span class="keyword">case</span> i =&gt; go</span><br><span class="line">&#125; map &#123;</span><br><span class="line"><span class="keyword">case</span> i =&gt; &#123;</span><br><span class="line">go = <span class="literal">false</span></span><br><span class="line">i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(y)</span><br></pre></td></tr></table></figure>可以看到，go为false时根本不会对流程产生影响，因此，从Scala2.8开始使用withFilter修正这个问题，当withFilter被使用时，断言/条件将在元素每次被内部访问时执行。</blockquote><p>如果在for-comprehension中有多个计数器，事情将变得有点复杂和有趣了。我们以artist为例，假如你喜欢存储一些艺术家的照片，并且你只喜欢rock artist艺术家的照片。那我们应该如何过滤掉rock albums呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span>(<span class="params">name:<span class="type">String</span>,genre:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ArtistWithAlbums</span>(<span class="params">artist: <span class="type">Artist</span>, albums: <span class="type">List</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> artistsWithAlbums = <span class="type">List</span>(</span><br><span class="line">  <span class="type">ArtistWithAlbums</span>(<span class="type">Artist</span>(<span class="string">&quot;Pink Floyd&quot;</span>, <span class="string">&quot;Rock&quot;</span>),</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;Dark side of the moon&quot;</span>, <span class="string">&quot;Wall&quot;</span>)),</span><br><span class="line">  <span class="type">ArtistWithAlbums</span>(<span class="type">Artist</span>(<span class="string">&quot;Led Zeppelin&quot;</span>, <span class="string">&quot;Rock&quot;</span>),</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;Led Zeppelin IV&quot;</span>, <span class="string">&quot;Presence&quot;</span>)),</span><br><span class="line">  <span class="type">ArtistWithAlbums</span>(<span class="type">Artist</span>(<span class="string">&quot;Michael Jackson&quot;</span>, <span class="string">&quot;Pop&quot;</span>),</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;Bad&quot;</span>, <span class="string">&quot;Thriller&quot;</span>)),</span><br><span class="line">  <span class="type">ArtistWithAlbums</span>(<span class="type">Artist</span>(<span class="string">&quot;Above &amp; Beyond&quot;</span>, <span class="string">&quot;trance&quot;</span>),</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;Tri-State&quot;</span>, <span class="string">&quot;Sirens of the Sea&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="type">ArtistWithAlbums</span>(artist, albums) &lt;- artistsWithAlbums</span><br><span class="line">  album &lt;- albums</span><br><span class="line">  <span class="keyword">if</span> artist.genre == <span class="string">&quot;Rock&quot;</span></span><br><span class="line">&#125; <span class="keyword">yield</span> album</span><br></pre></td></tr></table></figure><p>实际上，在Scala中，当包含多个计数器的情况，Scala会使用flatMap而不是map，因此，上述代码实际上被转换为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">artistsWithAlbums flatMap &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">ArtistWithAlbums</span>(artist, albums) =&gt; albums withFilter &#123;</span><br><span class="line">album =&gt; artist.genre == <span class="string">&quot;Rock&quot;</span></span><br><span class="line">&#125; map &#123; <span class="keyword">case</span> album =&gt; album &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用flatMap的原因是你必须匹配map外层的每个计数器。使用<code>faltMap</code>获得<code>List(Dark side of the moon,Wall,Led Zeppelin IV,Presence)</code>返回，使用<code>map</code>则获得<code>List(List(Dark side of the moon,Wall),List(Led Zeppelin IV,Presence),List(),List())</code>返回。</p><h3><span id="494use-option-not-nullp121">4<sub>9</sub>4〖Use Option not Null〗P121</span></h3><p>如果你用过Java或Ruby之类的语言，你一定对使用null或nil(Ruby)的痛楚深有感触。在Ruby中还好一些，因为Nil在Ruby中是一个单例对象，这样你可以调用Nil中的方法。但是在Java中，如果一个变量引用是null，会抛出一个NullPoionterException。为了避免这个问题，许多编程开发者混杂了一些带有null checks的基础代码，使得代码难于阅读。<br>Scala使用了一个不同的方式解决这个问题，这就是Option(参考: <a href="http://mng.bz/AsUQ">http://mng.bz/AsUQ</a> 中的 Option Pattern)。Option中实现了Null Object 模式。Option同时也是一个Monad。至于什么是Monad，会在下一章介绍，现在我们可以把一个Monad认为是一个简单的容器。在Scala中，Option是一个抽象类，它定义了两个子类，Some和None。常常你会遇到一个方法需要返回一个value或什么都不返回的情况。典型地，在Java或者Ruby中你会用null或nil。但是在Scala，Option是被推荐的做法，它会在一个函数中返回一个Some或者None的一个实例。在Scala中map的get方法正是这样实现的。当给定的key存在是，它返回Some封装的值，当key不存在时，则返回None。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val artists = Map(&quot;Pink Floyd&quot; -&gt; &quot;Rock&quot;, &quot;Led Zeppelin&quot; -&gt; &quot;Rock&quot;, &quot;Michael</span><br><span class="line">Jackson&quot; -&gt; &quot;Pop&quot;, &quot;Above &amp; Beyond&quot; -&gt; &quot;Trance&quot;)</span><br><span class="line">artists: scala.collection.immutable.Map[java.lang.String,java.lang.String] =</span><br><span class="line">Map(Pink Floyd -&gt; Rock, Led Zeppelin -&gt; Rock, Michael Jackson -&gt; Pop,</span><br><span class="line">Above &amp; Beyond -&gt; Trance)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> artists.get(<span class="string">&quot;Pink Floyd&quot;</span>)</span></span><br><span class="line">res33: Option[java.lang.String] = Some(Rock)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> artists.get(<span class="string">&quot;Abba&quot;</span>)</span></span><br><span class="line">res34: Option[java.lang.String] = None</span><br></pre></td></tr></table></figure><p>你可以在Scala中使用Option来做模式匹配，Option也定义了map、filter、flatMap之类的方法，这样在一个for-comprehension中更容易使用。</p><blockquote><h4><span id="when-should-you-use-either-rather-than-option">When should you use Either rather than Option?</span></h4><p><code>scala.Either</code>表示一个两种可能意义的结果，和<code>Option</code>不同，它返回一个单独的有意义的结果或者Nothing。Either提供了两个子类：<code>Left</code> 和 <code>Right</code>。按照惯例，Left表示失败，Right类似于Some。例如，下面代码中要做一些socket连接，我们知道，服务器可以访问则返回一个连接信息否则就是连接失败。我们将这些操作封装在一个叫做throwableToLeft的函数中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throwableToLeft</span></span>[<span class="type">T</span>](block: =&gt; <span class="type">T</span>):<span class="type">Either</span>[<span class="type">Throwable</span>, <span class="type">T</span>] =</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Right</span>(block)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ex <span class="type">Throwable</span> =&gt; <span class="type">Left</span>(ex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当创建一个新的Socket连接时<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val r = throwableToLeft &#123;</span></span><br><span class="line">new java.net.Socket(&quot;localhost&quot;, 4444)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> r match &#123;</span></span><br><span class="line">case Left(e) =&gt; e.printStackTrace</span><br><span class="line">case Right(e) =&gt; println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当一个异常发生时，创建一个Left otherwise Right的实例。大多数开发者会用抛出异常处理，使用Either可能会更加适用。尤其是，在本程序中，抛出一个异常并不是一个好想法，使用Either来接收和发送，在进程和线程处理上则是一个好的方法。</blockquote><h3><span id="4~10working-with-lazy-collections-views-and-streamsp122">4~10〖Working with lazy collections: views and streams〗P122</span></h3><p>lazy collections也称为nonstrict collections，它的对立就是——strict collections。strict collections意味着元素会被立即执行。下面例子中向List中每个元素加1操作，但只返回head:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3, 4, 5).map( _ + 1).head</span></span><br><span class="line">res43: Int = 2</span><br></pre></td></tr></table></figure><p>这段代码的问题是，我们只需要map中输出结果的head，但实际上从1到5的元素都被处理了。为了更清晰说明，我们将上述代码分开说明:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val newList = List(1, 2, 3, 4, 5).map( _ + 1)</span></span><br><span class="line">newList: List[Int] = List(2, 3, 4, 5, 6)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> newList.head</span></span><br><span class="line">res44: Int = 2</span><br></pre></td></tr></table></figure><p>虽然这不是什么大的问题，但有时为了节省内存空间和时间，不希望集合中的一些不需要的元素被创建。因此，Scala中提供了两个方式:<code>View</code> 和 <code>Stream</code>。下面先从views开始。</p><h3><span id="4101convert-a-strict-collection-to-a-nonstrict-collection-with-viewsp123">4<sub>10</sub>1〖Convert a strict collection to a nonstrict collection with views〗P123</span></h3><p>请求式集合(on-demand collections)中出现最多的技术术语是 nonstrict collections。有时也被称为lazy collections，但是lazy通常指的是nonstrict 函数的缓存结果.</p><p>TIP: 在Scala 2.8之前，Views被称为Projections。因此在迁移问题上要将Projections改为Views。</p><p>几乎所有的集合都暴露了一个称为 view 的方法，该方法将返回一个非严格视图。为了处理前面的List例子问题，你可以这样做:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3, 4, 5).view.map( _ + 1).head</span></span><br><span class="line">res46: Int = 2</span><br></pre></td></tr></table></figure><p>在这里，map方法的调用会产生另外一个视图而不会对计数器进行计算，计数器会延迟直到调用head方法时才执行。另外一个有趣的方式是你可以通过惰性求值来避免一些错误问题。例如下面例子中，对List中的所有元素进行 <code>2 / _</code>操作，但是其中有一个元素会出现除数为0的错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def strictProcessing = List(-2, -1, 0, 1, 2) map &#123; 2 / _ &#125;</span></span><br><span class="line">strictProcessing: List[Int]</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> strictProcessing(0)</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at $anonfun$strictProcessing$1.apply(&lt;console&gt;:6)</span><br></pre></td></tr></table></figure><p>但是我只关心集合中的第一个元素，整个集合被处理将由第三个元素因此异常。如果是View，则可以避免这类异常问题:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def nonStrictProcessing = List(-2, -1, 0, 1, 2).view map &#123; 2 / _ &#125;</span></span><br><span class="line">nonStrictProcessing: scala.collection.SeqView[Int,Seq[_]]</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nonStrictProcessing(0)</span></span><br><span class="line">res50: Int = -1</span><br></pre></td></tr></table></figure><p>你可以忽略这类错误并处理其他元素，但是这是你如果访问这个错误元素，你会获得一个异常:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nonStrictProcessing(3)</span></span><br><span class="line">res52: Int = 2</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nonStrictProcessing(2)</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at $anonfun$nonStrictProcessing$1.apply(&lt;console&gt;:6)</span><br></pre></td></tr></table></figure><p>为了在一个视图view中强制strict处理，你可以在此调用force方法，该方法和严格版本一样，会抛出ArithmeticException异常:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nonStrictProcessing.force</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>集合元素的非严格方法处理是一个有用的和方便的提高性能的方式，特别是当一个操作是耗时的情况下。在诸如Haskell、Clean等的惰性函数语言中，几乎每个构造器都是延迟执行的。但是因为Scala不是一个惰性函数式编程语言(lazy functional programming language)，你必须通过使用 名传递函数(call-by-name functions) 或 偏函数(partial functions) 这种额外的步骤来模拟惰性的等效类型。一个例子将阐述这个编程思想。如下面代码片段有一个叫做 tweets 的耗时操作，该方法会处理从Twitter中获得的信息:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io._</span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">XML</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tweets</span></span>(handle: <span class="type">String</span>) = &#123;</span><br><span class="line">println(<span class="string">&quot;processing tweets for &quot;</span> + handle)</span><br><span class="line"><span class="keyword">val</span> source = <span class="type">Source</span>.fromURL(<span class="keyword">new</span></span><br><span class="line">java.net.<span class="type">URL</span>(<span class="string">&quot;http://search.twitter.com/search.atom?q=&quot;</span> + handle))</span><br><span class="line"><span class="keyword">val</span> iterator = source.getLines()</span><br><span class="line"><span class="keyword">val</span> builder = <span class="keyword">new</span> <span class="type">StringBuilder</span></span><br><span class="line"><span class="keyword">for</span>(line &lt;- iterator) builder.append(line)</span><br><span class="line"><span class="type">XML</span>.loadString(builder.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Source来获取Twitter的XML结果并创建一个XML节点实例。尽管它不会花费太多的时间，假设我们考虑这个操作是耗时和高消耗的。现在你需要为多个用户处理这些Twitter搜索的结果。最明显的解决办法是创建一个Map来存储:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val allTweets = Map(<span class="string">&quot;nraychaudhuri&quot;</span> -&gt; tweets(<span class="string">&quot;nraychaudhuri&quot;</span>),</span></span><br><span class="line">&quot;ManningBooks&quot; -&gt; tweets(&quot;ManningBooks&quot;),</span><br><span class="line">&quot;bubbl_scala&quot; -&gt; tweets(&quot;bubbl_scala&quot;)</span><br><span class="line">)</span><br><span class="line">processing tweets for nraychaudhuri</span><br><span class="line">processing tweets for ManningBooks</span><br><span class="line">processing tweets for bubbl_scala</span><br></pre></td></tr></table></figure><p>问题是当创建一个Map时，你实际上为所有的users调用了tweets函数。但因为tweets函数是耗时的，你只希望在一个user真正需要时才调用。所以一个可选的处理方法就是使用偏函数，如下讨论:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val allTweets = Map(</span></span><br><span class="line">&quot;nraychaudhuri&quot; -&gt; tweets _ , &quot;ManningBooks&quot; -&gt; tweets _,</span><br><span class="line">&quot;bubbl_scala&quot; -&gt; tweets _)</span><br><span class="line">allTweets: scala.collection.immutable.Map[java.lang.String,(String) =&gt;</span><br><span class="line">scala.xml.Elem] = Map(nraychaudhuri -&gt; &lt;function1&gt;, ManningBooks -&gt;</span><br><span class="line">&lt;function1&gt;, bubbl_scala -&gt; &lt;function1&gt;)</span><br></pre></td></tr></table></figure><p>这里，你使用了一个偏函数来创建一个map。偏函数(partial function)就是指一个不指定所有参数的函数。例如，当你带一个参数调用tweets时，你会获得返回信息；但是如果你省略参数，你将获得获得一个方法返回:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> tweets(<span class="string">&quot;ManningBooks&quot;</span>)</span></span><br><span class="line">processing tweets for ManningBooks</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> tweets _</span></span><br><span class="line">res73: (String) =&gt; scala.xml.Elem = &lt;function1&gt;</span><br></pre></td></tr></table></figure><p>在Scala中，省略的参数必须指定为 <code>_</code>；否则会报错:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> tweets</span></span><br><span class="line">&lt;console&gt;:19: error: missing arguments for method tweets in object $iw;</span><br><span class="line">follow this method with &#x27;_&#x27; if you want to treat it as a partially applied</span><br><span class="line">function</span><br><span class="line">tweets</span><br></pre></td></tr></table></figure><p>在这个例子中，如果你使用view，你便可以实现你所需要的惰性功能，你的tweets函数将在需要时调用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> allTweets.view.map&#123; t =&gt; t._2(t._1)&#125;.head</span></span><br><span class="line">processing tweets for nraychaudhuri</span><br></pre></td></tr></table></figure><p>在一个Map内部，values被存储为Tuple2，一个管道包含 <code>_1</code> 句柄和<code>_2</code> 值两部分，而值在这里它是一个偏函数。你通过传递name句柄调用tweets函数。如果你想执行Manning Books的信息，你可以使用一个for-comprehension:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(t &lt;- allTweets; <span class="keyword">if</span>(t._1 == <span class="string">&quot;ManningBooks&quot;</span>)) t._2(t._1)</span><br></pre></td></tr></table></figure><p>注意：从Scala2.8开始，for-comprehensions是非严格的for标准操作。</p><h3><span id="4102working-with-streamsp126">4<sub>10</sub>2〖Working with Streams〗P126</span></h3><p>Stream实现了lazy list的功能(Tuple2则实现了lazy Map)，Stream使得元素会在他们真正需要的时候被执行。Stream和list一样，他们的元素被存储为两部分，head和tail，Stream的尾(tail)不会被计算直到它被需要的时候。如果你想，你可以通过Stream建立一个无限大的list，它会消耗掉很大的内存容量。因为Stream继承自LinearSeq，你可以有List中的大部分方法实现。如下面例子使用List的下标来压缩每一个元素:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>,</span></span><br><span class="line">&quot;five&quot;).zip(Stream.from(0))</span><br><span class="line">res88: List[(java.lang.String, Int)] = List((zero,0), (one,1), (two,2),</span><br><span class="line">(three,3), (four,4), (five,5))</span><br></pre></td></tr></table></figure><p>这里定义在Stream中的from方法会创建一个从0开始，步长为1递增的无限大的Stream。在Stream中也可以使用view视图技术来提高内存损耗和性能处理的能力。我们以Fibonacci序列为例。在数学中，费波纳茨数为如下序列格式:<br><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...</code><br>定义规定，前两个数为0和1，后一个数为前两个数之和。实现Fibonacci的最一般做法是使用递归；</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = n <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> n =&gt; fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会返回n个Fibonacci的值。你要n是一个大于20的数时，才看到这个实现上有效率问题。实际上当执行到8时，它的执行过程为:<br>fib(8)<br>fib(7) + fib(6)<br>(fib(6) + fib(5)) + (fib(5) + fib(4))<br>((fib(5) + fib(4)) + (fib(4) + fib(3)) + ((fib(4) + fib(3)) + (fib(3) +<br>fib(2))<br>…<br>你可以看到，这个计数以指数增长，而又有许多步骤被重复计算。一个实现Fibonacci序列的方式就是通过它建立无穷大的(infinite) Stream。如果你将Fibonacci序列从0(0,1,2,3…)作为tail压缩，你将获得一个序列对(tuples)😦(0, 1), (1, 2), (2, 3)…)。你再用map的sum方法计算两个pair的值，你将获得一个Fibonacci序列数。为了实现这个功能，使用递归的streams。下面是代码片段:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fib: <span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>.cons(<span class="number">0</span>, <span class="type">Stream</span>.cons(<span class="number">1</span>,</span><br><span class="line">fib.zip(fib.tail).map(t =&gt; t._1 + t._2)))</span><br></pre></td></tr></table></figure><p>这里使用了Stream中的cons对象，并使用了cons对象的apply方法，它将0作为head，而另外一个Stream作为tail。现在，你比较一下这两个方法的时间，可以看到基于stream的解决方案比前一个更好。<br>这里遗留的问题是，tail在被需要时执行，而不是马上执行，那么Stream是如何管理的？答案是名调用(call-by-name)参数。近距离看一下cons对象中声明的apply方法，该方法显示第二个参数被声明为一个函数，该函数被接收参数并返回一个stream。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](hd: <span class="type">A</span>, tl: =&gt; <span class="type">Stream</span>[<span class="type">A</span>]) = <span class="keyword">new</span> <span class="type">Cons</span>(hd, tl)</span><br></pre></td></tr></table></figure><p>所以，这里的它就是一个名调用参数，它被传入的无参函数编码。注意，当模式匹配一个Stream时，常用的<code>cons(::)</code>不会生效；你必须使用<code>#::</code>。</p><h3><span id="4~11divide-and-conquer-with-parallel-collectionsp127">4~11〖Divide and conquer with parallel collections〗P127</span></h3><p>到目前为止，你已经看了集合的eager、lazy执行类型，并且集合中的元素是顺序执行的。现在来学习一下Scala的并行集合，它的元素被平行执行。<br>Scala的并行集合实现了分离(split)和组合(combine)操作的功能，即分治算法。分离操作将并行集合分割成小块的Iterable集合，直到它达到给定的临界点(threshold)。之后一系列的任务被创建来同时处理这些小块的Iterable集合。这些任务(tasks)实现了Fork/Join框架。Fork/Join框架会计算出CPU的可用核数，并用来处理这些操作以及使用线程来执行这些任务。最后，每个任务得到的结果组合(combines)成为最终结果。<br>如下图，ParVector(10,20,30,40,50,60,70,80,90)被分割成小块的Iterable，每个Iterable集合继承scala.collection.parallel.Splitter特质。为每个并行集合定义的阈值提供了集合元素最小分离个数的计算。一旦分离操作完成，每个集合被线程任务处理操作。例如，TaskA带有10，20作为输入并通过map匿名处理后输出5，10。最后，每个任务的输出再组合成为最终结果。每一个并行集合提供了一个combiner，它知道如何将小块的处理的集合进行组合并输出结果。为了得知有多少个工作被处理，你可以在REPL中尝试一下代码片段:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.parallel.immutable._</span><br><span class="line"><span class="keyword">import</span> scala.collection.parallel.immutable._</span><br><span class="line">scala&gt; <span class="type">ParVector</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>).map &#123;x =&gt;</span><br><span class="line">println(<span class="type">Thread</span>.currentThread.getName); x / <span class="number">2</span> &#125;</span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-2</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-2</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-3</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-3</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-3</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-3</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-1</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-0</span></span><br><span class="line"><span class="type">ForkJoinPool</span><span class="number">-1</span>-worker<span class="number">-0</span></span><br><span class="line">res2: scala.collection.parallel.immutable.<span class="type">ParVector</span>[<span class="type">Int</span>] = <span class="type">ParVector</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line"><span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/scala-in-action/chapter4/Fork&amp;Join.png" alt="Fork/Join Framework"></p><blockquote><h4><span id="configuring-parallel-collections">Configuring parallel collections</span></h4><p>负责调度并行集合的引擎称为 TaskSupport。每个并行集合配置了一个任务支持对象，负责跟踪线程池、负载平衡和任务调度。<br>Scala提供了下面几个任务支持的实现:<br>&quot;ForkJoinTaskSupport——JVM1.6中使用的fork-join线程池。<br>&quot;ThreadPoolTaskSupport——稍微比ForkJoinTaskSupport高效；使用常规线程池执行。<br>&quot;ExecutionContextTaskSupport——Scala所有并行集合中的默认任务支持。它在scala.concurrent包中，后台使用fork-join线程池实现。<br>若要改变给定集合的TaskSupport，可以如下简单处理:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.parallel._</span><br><span class="line"><span class="keyword">val</span> pv = immutable.<span class="type">ParVector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">pv.tasksupport = <span class="keyword">new</span> <span class="type">ForkJoinTaskSupport</span>(<span class="keyword">new</span></span><br><span class="line">scala.concurrent.forkjoin.<span class="type">ForkJoinPool</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>这里tasksupport变为了一个4线程的ForkJoinTask任务。</blockquote><p>并行集合适用于处理数据并行问题，提高负载操作的性能而不用担心并发性。map 操作就是一个最好的例子，因为它不依赖于集合元素的顺序处理。Scala中并行集合不确保任何顺序执行。另外，foldLeft不适用于并行集合，因为集合中的元素要求在一个正确的顺序上被处理。下面例子演示foldLeft被执行时是单线程的，即使在ParVector上执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> ParVector(10, 20, 30, 40, 50, 60, 70, 80, 90).foldLeft(0) &#123;(a,x) =&gt;</span></span><br><span class="line">println(Thread.currentThread.getName); a + x &#125;</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">Thread-14</span><br><span class="line">res3: Int = 450</span><br></pre></td></tr></table></figure><h3><span id="4111parallel-collection-hierarchyp129">4<sub>11</sub>1〖Parallel collection hierarchy〗P129</span></h3><p>Scala2.9后，并行集合被添加到了集合库中。所有并行集合类实现了如下单独的层次结构。在最顶部的并行集合库是ParIterable。它实现了所有并行集合的通用行为。</p><p><img src="/img/scala-in-action/chapter4/parallel-collection.png" alt="Scala parallel collection hierarchy"></p><p>Scala并行集合库实现的集合类型大部分在scala.collection包，包括mutable和immutable类型。之所以说大部分是因为你找不到LinearSeq类型集合对应的List实现，因为它们不适用于并行处理。<br>要使用这些集合类型，你需要导入scala.collection.parallel.immutable或scala.collection.parallel.mutable包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import scala.collection.parallel.mutable._</span></span><br><span class="line">import scala.collection.parallel.mutable._</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> ParArray(1, 2, 3, 4).sum</span></span><br><span class="line">res4: Int = 10</span><br></pre></td></tr></table></figure><p>你不总是要以并行集合来实现并行处理；如有需要，你可以非常容易地在顺序集合和并行集合之间进行转换。</p><blockquote><h5><span id="why-there-are-gen-classes-in-the-scalacollection-package">Why there are Gen* classes in the scala.collection package</span></h5><p>顺序集合和并行集合库中都实现了Gen*类中的操作。因此，如果你不关心接收的是并行集合还是有序集合，你应该使用带前缀的Gen: Gentraversable，GenIterable，GenSeq，这样，它既是并行的，又是顺序的。</p></blockquote><h3><span id="4112switching-between-sequential-and-parallel-collectionsp130">4<sub>11</sub>2〖Switching between sequential and parallel collections〗P130</span></h3><p>Scala集合为所有有序集合类型提供了par方法来创建一个并行版本的集合。另一方面，所有并行集合类型实现了seq方法来创建有序版本的集合。下面例子通过转换顺序Vector为并行ParVector来过滤所有偶数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vs = <span class="type">Vector</span>.range(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">vs.par.filter(_ % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里将输出一个ParVector实例的偶数。若要回到Vector，需要调用seq方法。如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vector</span>.range(<span class="number">1</span>, <span class="number">100000</span>).par.filter(_ % <span class="number">2</span> == <span class="number">0</span>).seq</span><br></pre></td></tr></table></figure><p>这种转换的一个附加好处是，你可以使用并行集合优化剩余基础代码而不用改变原来代码中的集合类型。</p><p>但是，并行集合并不是一个最好的药方。你不希望所有操作都要通过并行集合的转换来进行处理。实际上，在有些情况它可能表现得比有序集合更差。因此，在转换为并行集合前要考虑两点：</p><ol><li>类型的操作</li><li>转换的开销<br>首先，不是所有操作是可并行的，因此这些操作转换为并行集合并不会提高性能。一个理想候选是不产生任何顺序执行、没有任何副作用。诸如map、flatMap、filter和forall这些易于并行化的操作就是一个好的方法例子。<br>第二，使用Fork/Join框架来创建并行到顺序集合的转换会有一定的开销。如果处理一个操作比创建一个并行集合花费更小的时间，那么使用并行版本会减少你的性能。另外它也可能由你所使用的集合类型有关。转换Seq为ParSeq比转换List为Vector要快很多，因为没有对List的并行实现，正因为如此，你在List调用par方法时会返回ParVector。</li></ol><h3><span id="4~12summaryp131">4~12〖Summary〗P131</span></h3><p>在本章你已经学习了一些重要的概念。类型参数化帮助我们探索类型协变性概念以及Scala类型安全机制。理解了这些概念对创建泛型、类型暗转、可重用组建是重要的。这章还探索了高级函数的使用，例如map和filter，以及他们是如何在Scala库中使用——另外也给集合库提供了丰富的、有用的API。使用这些告诫函数，你可以很容易地封装常用的编程惯用代码。<br>这章还介绍了Scala集合库以及Scala2.8新创建的API。Scala集合库是一个大的API，目前我们值看到了最重要和最常用的几个。你需要从scala文档中探索更多集合类型类型和API的使用，因为几乎所有的通用的、有用的函数都已经写入到库中。<br>在使用集合的同时，对于理解一个集合类型的性能和内存要求是非常重要的。知道严格(strict)和非严格(nonstrict)的区别会帮助我们决定哪种集合类型更适用、什么时候更适用。<br>下一章开始探索函数式编程。你会学习什么是函数式编程，函数式编程在Scala中如何操作。理解函数式编程有助于我们创建函数式的、不可变的以及简单的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：Scala OOP</title>
      <link href="/2016/10/27/scala/03-scala-oop/"/>
      <url>/2016/10/27/scala/03-scala-oop/</url>
      
        <content type="html"><![CDATA[<h4><span id="主要内容">主要内容：</span></h4><ol><li>构建MongoDB驱动</li><li>case模式匹配</li><li>命名和默认参数</li></ol><p>上一章讲了Scala的基础部分，这章介绍Scala面向对象的特性。面向对象编程不是新鲜事物，但是Scala在面向对象基础上添加了一些新的特性。<br>本章将使用Scala构建MongoDB的驱动。MongoDB也是可伸缩的(scalable)，基于文档的数据库。你将使用Scala面向对象构造器快速构建MongoDB驱动程序，并在此讲述每一步的概念。Scala使得面向对象得到革新，其中包括特征(trait)。特征相似与Java的半实现的抽象类(abstract classes)。本章将介绍特征在Scala程序中是如何工作的。同时，本章也将介绍容器类(case classes)，容器类对于构建不可变类是非常有用的，另外也会介绍并发和数据-对象转换。容器类是函数式编程和面向对象编程的桥梁。</p><span id="more"></span><h2><span id="building-a-scala-mongodb-driver-user-stories">Building a Scala MongoDB driver: user stories</span></h2><blockquote><p>首先解析一下这个概念，顾名思义就是用户故事。这是敏捷开发中的一种模式，也叫用户案例(user case)，就是站在用户价值立场实时分析情景，只对需求作描述，不对需求作规范。</p></blockquote><p>我们思考一下，为什么要构建MongoDB的驱动?MongoDB不是已有现成的MongoDB驱动了吗?但考虑下面的user stories: As a developer, I want an easier way to connect to my MongoDB server and access document databases. As a developer, I want to query and manage documents.</p><p>MongoDB是一个用C++开发的数据库，具有可伸缩性、高并发、开源、模式自由的、面向文档的特性。MongoDB是一种用JSON(JavaScript Object Notation)数据格式存储的基于文档的数据库。这种模式自由的特性使得MongoDB可以存储任何类型的数据结构，因此你不需要定义你的数据库表和属性。你可以按需求任意删除属性。这种自由度是通过基于文档模式实现的。和关系型数据库不同，一个基于文档模式的记录(records)被作为一个文档存储，因此该记录可以存储任何长度、任何数量的字段。例如，一个集合(collection)中可以存储如下形式(集合在MongoDB中相当于传统RDBMS(Relational Database Management System)数据库中的表)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; name : <span class="string">&quot;Joe&quot;</span>, x : <span class="number">3.3</span>, y : [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &#125;</span><br><span class="line">&#123; name : <span class="string">&quot;Kate&quot;</span>, x : <span class="string">&quot;abc&quot;</span> &#125;</span><br><span class="line">&#123; q : <span class="number">456</span> &#125;</span><br></pre></td></tr></table></figure><p>在模式自由的环境中，这里的模式(schema)更多是指应用程序，而不是数据库。和其他工具一样，模式自由的数据库有利也有弊，关键取决于你选择的解决方案。</p><p>在MongoDB中文档的存储格式是BSON(Binary JSON)，其他基于文档的数据库，如IBM的Lotus Notes和Amazon的SimpleDB则是使用XML结构存储。在基于Web应用程序中，JSON有一个突出的优势就是JSON文档可以非常容易地进行转换并使用。更多内容，参考<a href="http://try.mongodb.org">http://try.mongodb.org</a>.并下载安装到本地。开启MongoDB服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/mongod</span></span><br></pre></td></tr></table></figure><p>开启服务之后，我们打开Shell进行数据库连接:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/mongo</span></span><br><span class="line">MongoDB shell version: 1.2.4</span><br><span class="line">url: test</span><br><span class="line">connecting to: test</span><br><span class="line">type &quot;help&quot; for help</span><br></pre></td></tr></table></figure><p>搭建好数据库后，我们将进入MongoDB驱动开发阶段。</p><h2><span id="classes-and-constructors">Classes and constructors</span></h2><p>创建一个Mongo客户端连接到服务上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scala&gt; class MongoClient(val host:String, val port:Int)</span><br></pre></td></tr></table></figure><p>这看起来和Java、C#不同，不但声明了类，还声明了主构造器(primary constructor)。</p><p>当创建一个MongoClient类的实例时，主构造函数以重载的形式直接或间接地被调用。在Scala中，主构造器(primary constructor)是在类声明时行内出现。如本例中，构造器带有两个参数，host和port，即指定MongoDB的主机IP和端口。</p><p>因为所有构造器参数都是以val为前导，Scala会为每个参数创建不可变的实例。如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val client = new MongoClient(<span class="string">&quot;127.0.0.1&quot;</span>, 123)</span></span><br><span class="line">client: MongoClient = MongoClient@561279c8</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> client.port</span></span><br><span class="line">res0: Int = 123</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> client.host</span></span><br><span class="line">res1: String = 127.0.0.1</span><br></pre></td></tr></table></figure><p>和Java、C#一样，Scala通过new关键字创建类的实例。不同的是，在Scala中，类的语句体是可选的，因此可以在声明类的不带语句体。如，要创建一个包含setter和getter的JavaBean，在Scala中就变得很简单了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class AddressBean(</span></span><br><span class="line">var address1:String,</span><br><span class="line">var address2:String,</span><br><span class="line">var city:String,</span><br><span class="line">var zipCode:Int)</span><br><span class="line">defined class AddressBean</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var localAddress = new AddressBean(<span class="string">&quot;230 43rd street&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Columbus&quot;</span>,</span></span><br><span class="line">43233)</span><br><span class="line">localAddress: (java.lang.String, java.lang.String, java.lang.String, Int) =</span><br><span class="line">(230 43rd street,,Columbus,43233)</span><br></pre></td></tr></table></figure><p>如果参数是以var为前导，Scala将创建可变的变量。val和var前导都是可选的。如果两个都不填，则参数将作为私有的实例值，不能在类外部进行访问:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class MongoClient(host:String, port:Int)</span></span><br><span class="line">defined class MongoClient</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val client = new MongoClient(<span class="string">&quot;localhost&quot;</span>, 123)</span></span><br><span class="line">client: MongoClient = MongoClient@4089f3e5</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> client.host</span></span><br><span class="line">&lt;console&gt;:7: error: value host is not a member of MongoClient client.host</span><br></pre></td></tr></table></figure><p>注意，当Scala创建值或者变量时，同时也将为他们创建相应的访问者，在某种程度上直接访问值。下面定义的MongoClient和之前的是等价的:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">private val _host:<span class="type">String</span>, private val _port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">host</span> </span>= _host</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">port</span> </span>= _port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用private的原因是Scala编译器默认不会创建访问者。val和var做的是定义一个字段和getter，var则带setter。</p><blockquote><p><strong>如何为类添加setter方法</strong><br>当被定义为private类型时，如果需要添加setter方法，需要在其后添加_=.方法，如下面例子包含了getter和setter:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var firstName:<span class="type">String</span>, var lastName:<span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">private var _age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= _age</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age_=</span></span>(newAge: <span class="type">Int</span>) = _age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以创建实例并进行操作:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Nima&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>, <span class="number">2</span>)</span><br><span class="line">p.age = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>赋值p.age = 3实际上相当于p.age_= (3)。当计数器遇到诸如x = e的赋值语句，它会检测是否有对应的x_=方法并进行调用。这种赋值推断(assignment interpretation)在Scala中显得很有趣，在不同的上下文中表示不同的操作。如对一个函数进行赋值f(args) = e则表示是f.update(args)。关于函数赋值，将在之后介绍。</p></blockquote><p>大多数情况下，MongoDB的默认端口是27017，那在Scala中如何定义默认IP和端口呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了重载构造函数，通过<code>this</code>关键字来表示当前定义方法。你不能为其构造函数指定返回类型，因为重载函数中的第一个表达式必须调用其他重载构造函数或主构造函数，因此如下声明是错误的:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = &#123;</span><br><span class="line"><span class="keyword">val</span> defaultHost = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="keyword">val</span> defaultPort = <span class="number">27017</span></span><br><span class="line"><span class="keyword">this</span>(defaultHost, defaultPort)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时将报如下错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MongoClient.scala:3: error: &#x27;this&#x27; expected but &#x27;val&#x27; found.</span><br><span class="line">val defaultHost = &quot;127.0.0.1&quot;</span><br><span class="line">^</span><br><span class="line">MongoClient.scala:4: error: &#x27;(&#x27; expected but &#x27;;&#x27; found.</span><br><span class="line">val defaultPort = 27017</span><br><span class="line">^</span><br><span class="line">two errors found</span><br></pre></td></tr></table></figure><p>如果要在调用其他构造函数前做出一些操作将会是一个挑战，后面会通过companion object来突破这种限制。</p><p>连接MongoDB，你需要使用MongoDB为Java提供的驱动类<code>com.mongodb.Mongo</code>，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 本书使用的MongoDB驱动版本是1.10.1，更多版本信息请参考<a href="http://www.mongodb.org/display/DOCS/Java+Language+Center">http://www.mongodb.org/display/DOCS/Java+Language+Center</a></p><p>因为Scala具有脚本的特性，因此你可以在类内编写像脚本一样的代码，并且会在实例创建时执行。如下面是一个打印类:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScript</span>(<span class="params">host:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;Have to provide host name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(host == <span class="string">&quot;127.0.0.1&quot;</span>) println(<span class="string">&quot;host = localhost&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> println(<span class="string">&quot;host = &quot;</span> + host)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们像检验构造器的参数，我们可以在类内部这样做(通常在最前面):</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Java一样，Scala使用extends实现继承，如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClientV2</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Mongo</span>(host, port)&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你同样可以在超类(super class)中定义主构造器。一个不好的地方就是，你不能向父类传递参数验证。</p><p><strong>注意</strong> 你不用显式继承任何类，但类默认继承了scala.AnyRef，并且scala.AnyRef是所有类型推断的基础类。</p><h2><span id="packaging">Packaging</span></h2><p>包(package)在Scala中兼具有Java和C#两者的用法，因此，你可以这样定义:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line">    <span class="keyword">package</span> scalainaction &#123;</span><br><span class="line">        <span class="keyword">package</span> mongo &#123;</span><br><span class="line">            <span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">            require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法和一下写法是等价的:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以使用大括号:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo &#123;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的而且确会造成语法上的混乱，因此，一般都推荐使用顶部包名的方法。另外Scala的包不需要匹配目录结构，你可以任意声明多个包在同一个文件:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.persistence &#123;</span><br><span class="line"><span class="keyword">package</span> mongo &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> riak &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiakClient</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> hadoop &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HadoopClient</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Scala对此进行编译时，会自动将其匹配到相应的目录中，前提是你的类是使用JVM进行编译的。</p><h3><span id="scala-imports">Scala imports</span></h3><p>Scala的import和Java的相似，但是用法更加简洁，如导入com.mongodb包中的所有类，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mongodb._</span><br></pre></td></tr></table></figure><p>在Scala中，你不仅可以在开头使用import，你可以在任何地方使用import导入，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val randomValue = &#123; import scala.util.Random</span></span><br><span class="line">new Random().nextInt</span><br><span class="line">&#125;</span><br><span class="line">randomValue: Int = 1453407425</span><br></pre></td></tr></table></figure><p>因为import是在<code>&#123;&#125;</code>语句块内，所以<code>Random()</code>类只能在该语句块内使用。另外，由于Scala默认会自动导入scala包，所以，上述代码可以改为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val randomValue = &#123; import util.Random</span></span><br><span class="line">new Random().nextInt</span><br><span class="line">&#125;</span><br><span class="line">randomValue: Int = 619602925</span><br></pre></td></tr></table></figure><p>若要引入类的成员，也可以通过<code>._</code>引入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import java.lang.System._</span></span><br><span class="line">import java.lang.System._</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nanoTime</span></span><br><span class="line">res0: Long = 1268518636387441000</span><br></pre></td></tr></table></figure><p>其中nanoTime是System的一个方法，因此可以直接使用，这和Java的static import相似(scala没有static关键字)。因为引入是相关联的，因此也可以这样:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import java.lang._</span></span><br><span class="line">import java.lang._</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> import System._</span></span><br><span class="line">import System._</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> nanoTime</span></span><br><span class="line">res0: Long = 1268519178151003000</span><br></pre></td></tr></table></figure><blockquote><p><strong>The <code>_root_</code> package in Scala</strong><br>考虑如下两个包:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> monads &#123; <span class="class"><span class="keyword">class</span> <span class="title">IOMonad</span> &#125;</span></span><br><span class="line">    <span class="keyword">package</span> io &#123;</span><br><span class="line">    <span class="keyword">package</span> monads &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Console</span> </span>&#123; <span class="keyword">val</span> m = <span class="keyword">new</span> monads.<span class="type">IOMonad</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，会发现编译报错，因为Console是在monads下，会报错没找到IOMonad类。为了声明一个顶层包，你可以使用<code>_root_</code>表示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="keyword">new</span> _root_.monads.<span class="type">IOMonad</span></span><br></pre></td></tr></table></figure><p>另外需要说明的是，当你创建一个不带任何包的类或对象，他们属于一个空包。你不能导入空包，但是空包的成员是相互可见的。</p></blockquote><p>import另外一个非常有用的特性是：你可以为你引入的类创建新的名称空间，即别名。这在某些情况下可以提高可读性。如在Java中，<code>java.util.Date</code>和<code>java.sql.Date</code>具有同样的名字，这容易造成混淆，但在Scala，可以通过映射解决这个问题:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Date</span> =&gt; <span class="type">SqlDate</span>&#125;</span><br><span class="line"><span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line"><span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">p(now)</span><br><span class="line"><span class="keyword">val</span> sqlDate = <span class="keyword">new</span> <span class="type">SqlDate</span>(now.getTime)</span><br><span class="line">p(sqlDate)</span><br></pre></td></tr></table></figure><p>你甚至可以将导入的类通过占位符将其隐藏:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Date</span> =&gt; _ &#125;</span><br></pre></td></tr></table></figure><p>这样Date类将不可见。</p><p>回到用户故事(user story)中，我们需要构建完整的类并添加方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">version</span> </span>= underlying.getVersion</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropDB</span></span>(name:<span class="type">String</span>) = underlying.dropDatabase(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDB</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="objects-and-companion-objects">Objects and companion objects</span></h2><p>在给出DB类之前，让我们探索一下Scala的对象(objects)。Scala没有提供任何静态修改器，这样做是为了成为一门纯面向对象的编程语言的设计目标，即所有值都是对象，所有操作都是方法调用，所有变量都是对象的一个成员。如果包含static就无法成为一门纯粹的面向对象的语言，在代码中使用static会带来非常多的缺点。相反，Scala支持单例对象(singleton object)。一个单例对象限制你一个类只能有一个对象。简单实现一个单例模式可以通过如下表示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichConsole</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span></span>(x: <span class="type">Any</span>) = println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里RichConsole是一个单例对象。对象的声明和Java的class一样，只不过是使用关键字object。若要调用方法p，你需要加类名前缀，这个你在Java或C#中调用静态方法一样:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :l <span class="type">RichConsole</span>.scala</span><br><span class="line"><span class="type">Loading</span> <span class="type">RichConsole</span>.scala...</span><br><span class="line">defined module <span class="type">RichConsole</span></span><br><span class="line">scala&gt; <span class="type">RichConsole</span>.p(<span class="string">&quot;rich console&quot;</span>)</span><br><span class="line">rich console</span><br></pre></td></tr></table></figure><p>你可以导入并使用Object中的所有方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line">scala&gt; p(<span class="string">&quot;this is cool&quot;</span>)</span><br><span class="line"><span class="keyword">this</span> is cool</span><br></pre></td></tr></table></figure><p>在这里说到的DB实际上是一个对象(object)，它是一个工厂用于创建MongoDB数据库实例:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是，当使用DB作为一个工厂对象使用时，你实际上是调用了他的一个方法，<code>DB(underlying.getDB(name))</code>，他实际上就是调用了<code>DB.apply(underlying.getDB(name))</code>。Scala提供了语法糖(syntactic sugar)，它允许你将一个对象看作是一个方法进行调用。Scala中是通过转换调用apply方法实现的，apply将匹配类或者对象中的参数。如果没有任何参数匹配apply方法，则会发生编译报错。我们注意到，一个对象总是被延迟执行的，这意味着对象是在它的第一个成员被访问时才创建。在这个例子中，这个成员就是apply。所以，即使apply方法是正确的，也要看它所使用的场景。</p><blockquote><p><strong>Scala的工厂模式</strong><br>当我们讨论构造函数的时候，会发现会有诸如进程或参数校验的限制，因为Scala的构造器的第一行必须是调用其他构造函数或者是主构造器。使用Scala的object则可以很简单地解决了这个问题，因为方法apply没有这样的限制。我们以在Scala中实现工厂模式为例:<br>你要创建多个Role类，基于这个类名你会常见合适的role实例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(continued)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page: <span class="type">String</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperAnalyst</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = page != <span class="string">&quot;Admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyst</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = <span class="literal">false</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(roleName:<span class="type">String</span>) = roleName <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;root&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">Root</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;superAnalyst&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">SuperAnalyst</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;analyst&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">Analyst</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，object Role就相当于一个工厂一样，并创建每个实例的变量角色:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> root = <span class="type">Role</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> analyst = <span class="type">Role</span>(<span class="string">&quot;analyst&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>在apply方法内创建了DB类的一个实例。在Scala中，class和object是可以同名的(share name)，这种共享名字的类(class)称为伴生类(companion class)，共享名字的对象(object)称为伴生对象(companion object)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongoDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，类DB的构造器被private修饰，表示不被其他伴生对象所访问。在Scala中，伴生对象(conpanion object)可以访问伴生类(companion class)的私有成员，该私有成员不能在类外部被访问。在这个例子中，通过伴生对象创建一个实例显得有点多余，但有时却非常有用，如上面提到的工厂模式。其次就是在导入MongoDB驱动类的时候，由于命名冲突的作用将MongoDB映射为DB类。提示: 伴生对象(companoin object)和伴生类(companion class)在使用时区别就是伴生对象是直接调用的，而伴生类是通过new关键字创建的。</p><blockquote><p><strong>Package object</strong></p><p>在包中，只有类、特性和对象。但通过使用包对象，你可以在包中放置任何你定义的内容。例如，你在包对象中添加一个方法，该方法将能被包中的所有成员访问。一般地，包对象的创建为同级目录的对应包文件，即package.scala。你也可以使用在包嵌套语法中，但一般不推荐:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> minimumAge = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyAge</span> </span>= &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，变量minimumAge和方法verifyAge将允许包bar下的所有成员访问。如下面为包内的类使用包对象的方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bar</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BarTender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serveDrinks</span> </span>= &#123; verifyAge; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种包对象的适用情景是，你需要定义包内的成员变量，而包外则通过包的接口定义。</p></blockquote><p>在MongoDB中，一个数据库是被分为多个集合(collection)和文档(document)。现在我们向DB类添加一个检索所有collection的方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.convert.<span class="type">Wrappers</span>._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectionNames</span> </span>= <span class="keyword">for</span>(name &lt;- <span class="keyword">new</span></span><br><span class="line"><span class="type">JSetWrapper</span>(underlying.getCollectionNames)) <span class="keyword">yield</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到JSetWrapper对象，它是一个工具类，用于将<code>java.util.Set</code>转换为Scala的set，因此这里使用了for-comprehension。Wrappers提供了Java集合到Scala集合之间的转换。下面尝试调用一下该方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.scalainaction.mongo._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span> </span>= client.createDB(<span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(name &lt;- db.collectionNames) println(name)</span><br></pre></td></tr></table></figure><p>默认地，MongoDB会提供test和system.indexes这两个集合，因此上面mydb打印出这两个集合。</p><p>下面开始探讨一下MongoDB的CRUD(Create,Read,Update,Delete)操作。下面为完整的MongoClient.scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">version</span> </span>= underlying.getVersion</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropDB</span></span>(name:<span class="type">String</span>) = underlying.dropDatabase(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDB</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你可以通过MongoClient类连接数据库了，我们还要为DB类添加相应的dropDB、createDB等方法。下面定义DB类的伴生对象:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.convert.<span class="type">Wrappers</span>._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectionNames</span> </span>= <span class="keyword">for</span>(name &lt;- <span class="keyword">new</span></span><br><span class="line"><span class="type">JSetWrapper</span>(underlying.getCollectionNames)) <span class="keyword">yield</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongoDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们将为其添加更多的函数和方法。</p><h2><span id="mixin-with-scala-traits">Mixin with Scala traits</span></h2><p>在面向对象编程里面，一个mixin组合表示一个类可以被其他类使用并提供确定的函数。因此，在Scala中特性(traits)相当于一个添加到其他类中的抽象类，或者看作是实现了方法的接口。</p><p><strong>注意</strong> 在Scala中，特性(traits)和抽象类不同的是，抽象类(abstract class)可以带构造参数，但是特性(traits)不可以带任何参数。但两者都可以带类型参数。</p><p>第二个用户故事的需求是，你需要为你的MongoDB添加创建、删除和查询的功能。MongoDB将文档存储在集合(collection)里面，一个数据库又可以包含多个集合。因此，你需要创建一个组件用来表示集合。这个组件应该包括:从集合中检索文档，具有创建和删除文档的功能。Java的MongoDB驱动提供了DBCollection类用于操作集合，但你需要将其分为多个视图。在Scala，你可以使用特性(traits)实现。你将使用不同的特性(traits)处理不同的任务。</p><p>在这里，将扩展DBCollection实现三个特性: ReadOnly、Administrable和Updatable。如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DBCollection</span> =&gt; <span class="type">MongoDBCollection</span> &#125;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">DBObject</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> underlying: <span class="type">MongoDBCollection</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= underlying getName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>= underlying getFullName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = underlying find doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = underlying findOne doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= underlying findOne</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>(doc: <span class="type">DBObject</span>) = underlying getCount doc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的三个特性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DBCollection</span> =&gt; <span class="type">MongoDBCollection</span> &#125;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">DBObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBCollection</span>(<span class="params">override val underlying: <span class="type">MongoDBCollection</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">ReadOnly</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> underlying: <span class="type">MongoDBCollection</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= underlying getName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>= underlying getFullName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = underlying find doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = underlying findOne doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= underlying findOne</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>(doc: <span class="type">DBObject</span>) = underlying getCount doc</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Administrable</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop</span></span>: <span class="type">Unit</span> = underlying drop</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropIndexes</span></span>: <span class="type">Unit</span> = underlying dropIndexes</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Updatable</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">-=</span></span>(doc: <span class="type">DBObject</span>): <span class="type">Unit</span> = underlying remove doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+=</span></span>(doc: <span class="type">DBObject</span>): <span class="type">Unit</span> = underlying save doc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用过Ruby，你会发现它和Ruby的模组十分相似。和模组相比，特性的优点是模块化的mixin组合方式只在编译时进行校验，堆栈中发生错误将在编译是抛出。</p><p>下面尝试测试一下这个驱动:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.scalainaction.mongo._</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">BasicDBObject</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span> </span>= client.db(<span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(name &lt;- db.collectionNames) println(name)</span><br><span class="line"><span class="keyword">val</span> col = db.readOnlyCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">println(col.name)</span><br><span class="line"><span class="keyword">val</span> adminCol = db.administrableCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">adminCol.drop</span><br><span class="line"><span class="keyword">val</span> updatableCol = db.updatableCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> doc = <span class="keyword">new</span> <span class="type">BasicDBObject</span>()</span><br><span class="line">doc.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;MongoDB&quot;</span>)</span><br><span class="line">doc.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;database&quot;</span>)</span><br><span class="line">doc.put(<span class="string">&quot;count&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> info = <span class="keyword">new</span> <span class="type">BasicDBObject</span>()</span><br><span class="line">info.put(<span class="string">&quot;x&quot;</span>, <span class="number">203</span>)</span><br><span class="line">info.put(<span class="string">&quot;y&quot;</span>, <span class="number">102</span>)</span><br><span class="line">doc.put(<span class="string">&quot;info&quot;</span>, info)</span><br><span class="line">updatableCol += doc</span><br><span class="line">println(updatableCol.findOne)</span><br><span class="line">updatableCol -= doc</span><br><span class="line">println(updatableCol.findOne)</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">100</span>) updatableCol += <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line"><span class="keyword">val</span> query = <span class="keyword">new</span> <span class="type">BasicDBObject</span></span><br><span class="line">query.put(<span class="string">&quot;i&quot;</span>, <span class="number">71</span>);</span><br><span class="line"><span class="keyword">val</span> cursor = col.find(query)</span><br><span class="line"><span class="keyword">while</span>(cursor.hasNext()) &#123;</span><br><span class="line">println(cursor.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BasicDBObject对象是一个MongoDB的map转换器，由于MongoDB是模式自由的，因此，你可以通过BasicDBObject类插入任何键值对。基本的增删改查操作是满足不了业务的需求，例如我们要提高每次访问的性能，这里使用一种称为记忆(Memoization)的技术。这里，他会记住之前的find方法，并避免重复去数据库执行。实现的方式是通过mixin组合traits。因为在Scala中traits是堆栈的，这意味着可以被其继承的traits修改或装饰。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Memoizer</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> history = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">DBObject</span>]()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= &#123;</span><br><span class="line">history.getOrElseUpdate(<span class="number">-1</span>, &#123; <span class="keyword">super</span>.findOne &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">history.getOrElseUpdate(doc.hashCode, &#123; <span class="keyword">super</span>.findOne(doc) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法getOrElseUpdate将返回对应键的值，如果对应键不存在，它将调用第二个参数提供的方法。在这个例子中，由于不带参数，使用-1作为key。</p><h2><span id="class-linearization">Class Linearization</span></h2><p>如果你学习过C++或Common Lisp，你就会发现特性混入类(mixin of traits)看起来和多继承一样。但问题是Scala应该如何处理多重继承的钻石问题(或称菱形缺陷，diamond problem)。</p><ul><li><p>什么是混入(mixin)<br>混入是一种组合的抽象类，主要用于多继承上下文中为一个类添加多个服务，多重继承将多个 mixin 组合成你的类。例如，如果你有一个类表示“马”，你可以实例化这个类来创建一个“马”的实例，然后通过继承像“车库”和“花园”来扩展它，使用 Scala 的写法就是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myHouse = <span class="keyword">new</span> <span class="type">House</span> <span class="keyword">with</span> <span class="type">Garage</span> <span class="keyword">with</span> <span class="type">Garden</span></span><br></pre></td></tr></table></figure><p>从 mixin 继承并不是一个特定的规范，这只是用来将各种功能添加到已有类的方法。在 OOP 中，有了mixin，你就有通过它来提升类的可读性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): unit = &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">extends</span> <span class="title">StringIterator</span>(<span class="params">args(0</span>))</span></span><br><span class="line"><span class="keyword">with</span> <span class="type">RichIterator</span>[char]</span><br><span class="line"><span class="keyword">val</span> iter = <span class="keyword">new</span> <span class="type">Iter</span></span><br><span class="line">iter foreach <span class="type">System</span>.out.println</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如Iter类通过RichIterator和StringIterator这两个父类混入构成，第一个父类仍然称为超类(superclass)，第二个父类则称为混入类(mixin)。</p></li><li><p>多重继承的钻石问题<br>又叫菱形问题(有时叫做“致命的死钻石”deadly diamond of death)，描述的是B和C继承自A，D继承自B和C，如果A有一个方法被B和C重载，而D不对其重载，那么D应该实现谁的方法，B还是C？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> ↗ ↖</span><br><span class="line">B     C</span><br><span class="line"> ↖ ↗</span><br><span class="line">   D</span><br></pre></td></tr></table></figure></li></ul><p>Scala是通过类的全序化(Class Linearization)，或称作类的线性化。线性化指出一个类的祖先类是一条线性路径的，包括超类(superclass)和特性(traits)。它通过两步来处理方法调用的问题:<br>- 使用右孩子优先的深度优先遍历搜索(right-first,depth-first search)算法进行搜索。<br>- 遍历得到的结构层次中，保留最后一个元素，其余删除。</p><ul><li><p>JVM上的trait类<br>Scala编译器上生成的class文件取决于你如何定义。当你定义一个只包含方法声明而不包含方法体的trait类，他会编译成一个Java接口。你可以使用<code>javap –c &lt;class file name&gt;</code>查看。例如，trait Empty{def e:Int}会产生如下的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Empty</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">e</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果trait声明了具体的方法或代码，Scala会生成两个类:一个接口类和一个包含代码的新类。当一个类继承这个trait时，trait中声明的变量将被复制到这个类文件中，而定义在trait中的方法作为这个继承类的外观模式的方法。这个类调用这个方法时，将调用新类中的对应方法。</p></li></ul><h2><span id="stackable-traits">Stackable traits</span></h2><p>现在回顾一下，通过ReadOnly特性作为接口实现，通过Updatable和Administrable实现扩展，通过Memoizer实现方法重载，trait这种可堆叠的特征使得在组件重构和行为修改上显得非常方便。现在来看看另外一个特征。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LocaleAware</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">doc.put(<span class="string">&quot;locale&quot;</span>, java.util.<span class="type">Locale</span>.getDefault.getLanguage)</span><br><span class="line"><span class="keyword">super</span>.findOne(doc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">doc.put(<span class="string">&quot;locale&quot;</span>, java.util.<span class="type">Locale</span>.getDefault.getLanguage)</span><br><span class="line"><span class="keyword">super</span>.find(doc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocaleAware重载中实现了super的findOne方法，这意味着下面两个表达式是等价的:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">DBCollection</span>(collection(name)) <span class="keyword">with</span> <span class="type">Memoizer</span> <span class="keyword">with</span> <span class="type">LocaleAware</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">DBCollection</span>(collection(name)) <span class="keyword">with</span> <span class="type">LocaleAware</span> <span class="keyword">with</span> <span class="type">Memoizer</span></span><br></pre></td></tr></table></figure><p>因为Memoizer和LocaleAware的findOne都实现了super方法，由于super是动态调用的，这意味着，Memoizer和LocaleAware中的super.findOne方法并没有马上执行，而是先根据有孩子优先的深度遍历顺序先执行findOne里面的方法，最后才执行ReadOnly里面的方法。</p><ul><li>ScalaObject trait<br>在讨论类的全序列化时，并没有给出完整的图例。实际上，Scala会在最后一个混入类中插入scala.ScalaObject。UpdatableCollection的完整序列化顺序是:<br><code>UpdatableCollection -&gt; Memoizer -&gt; Updatable -&gt; DBCollection -&gt; ReadOnly -&gt; ScalaObject -&gt; AnyRef -&gt; Any</code><br>在Scala2.8之前，ScalaObject用于向$tag的正则匹配提供方法，但从Scala2.8开始ScalaObject将作为一个空的标记trait。</li></ul><h2><span id="case-class">Case class</span></h2><p>case class 是一种使用case关键创建的特殊类。当Scala编译器看到一个case class时，它会自动生成样板代码而不用自己手动编写。如我们要创建一个Person类:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">case</span> class Person(firstName:String, lastName:String)</span></span><br><span class="line">defined class Person</span><br></pre></td></tr></table></figure><p>在这个例子中，你创建了一个Person 样本类并包含参数。如果一个类的前缀是case关键字，则它会自动完成下面的工作:</p><ul><li>所有参数前缀用val修饰，使它们作为public成员。但仍然不能对其进行直接方法，若要访问，需要通过访问器(accessors)。</li><li>根据参数自动实现equals和hashCode方法。</li><li>编译器会自动实现toString方法，并返回类名和参数。</li><li>所有case class都有一个copy方法用于该类实例的复制。</li><li>伴生对象(companion object)被创建并提供apply方法，并且该方法参数和该case class参数一致。</li><li>编译器会添加一个unapply方法，该方法将用于正则匹配中的类名提取器中。</li><li>默认的实现将提供了序列化。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val me = Person(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>)</span></span><br><span class="line">me: Person = Person(Nilanjan,Raychaudhuri)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val myself = Person(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>)</span></span><br><span class="line">myself: Person = Person(Nilanjan,Raychaudhuri)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> me.equals(myself)</span></span><br><span class="line">res1: Boolean = true</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> me.hashCode</span></span><br><span class="line">res2: Int = 1688656232</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> myself.hashCode</span></span><br><span class="line">res4: Int = 1688656232</span><br></pre></td></tr></table></figure><p>在Java中，想想我们创建了多少个DTO(Data transfer object)，而这些对象仅仅是数据转换的访问器！Scala中的样本类使得对象的访问变得容易了，并且自动为我们提供了equals和hasCode方法，这样再也不用写包含setter和getter的JavaBean了。<br><strong>注意</strong> 如果你想要同时实现访问器和修改器，你可以在样本类参数前面使用var关键字修饰。Scala中默认是通过val修饰参数的，并且推荐这样做。</p><p>和其他类一样，样本类(case class)可以继承其他类，包括trait和case class自身。当你声明一个abstract case class时，Scala不会在伴生对象(companion object)中生成apply方法。这意味着你不能创建一个抽象类的实例，但你可以创建单例的、序列化的case object，如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Yes</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">No</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span></span><br></pre></td></tr></table></figure><p>在网络传输中，Scala的case class和case object是非常容易进行消息传送的。这将在Scala actors中介绍讲到。<br><strong>注意</strong> 从Scala2.8开始，不带参数列表的case class是不赞成的(deprecated)。如果需要，你可以声明你的case class不带任何参数，但要使用()代替。</p><p>下面讲述case class在MongoDB中如何使用。前面主要实现了find方法，MongoDB支持多条件查询选项如Sort、Skip和Limt下面通过case class和模式匹配实现。首先定义选项查询支持:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryOption</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NoOption</span> <span class="keyword">extends</span> <span class="title">QueryOption</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span>(<span class="params">sorting: <span class="type">DBObject</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Skip</span>(<span class="params">number: <span class="type">Int</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Limit</span>(<span class="params">limit: <span class="type">Int</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br></pre></td></tr></table></figure><p>这里你创建了四个选项: Sort、Skip、Limit和NoOption，每个查询选项可以包含其他查询选项。注意到，所有查询选项都继承了QueryOption并使用sealed修饰。关于修改器的内容将在后面阐述。sealed修改器会阻止除在同一文件内的其他所有对象的继承。<br>下面实现Query查询类:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>(<span class="params">q: <span class="type">DBObject</span>, option: <span class="type">QueryOption</span> = <span class="type">NoOption</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(sorting: <span class="type">DBObject</span>) = <span class="type">Query</span>(q, <span class="type">Sort</span>(sorting, option))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip</span></span>(skip: <span class="type">Int</span>) = <span class="type">Query</span>(q, <span class="type">Skip</span>(skip, option))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span></span>(limit: <span class="type">Int</span>) = <span class="type">Query</span>(q, <span class="type">Limit</span>(limit, option))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，QueryOption默认是NoOption，则可以通过以下形式调用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rangeQuery = <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;i&quot;</span>, <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;$gt&quot;</span>, <span class="number">20</span>))</span><br><span class="line"><span class="keyword">var</span> richQuery = <span class="type">Query</span>(rangeQuery).skip(<span class="number">20</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>这里当第二个参数未指定时，它将使用一个默认的参数值。当我们创建一个case class对象实例时，我们不需要通过new关键字创建，因为他会自动创建伴生对象。现在可以通过下面的形式调用Query对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span> </span>(query: <span class="type">Query</span>) = &#123; <span class="string">&quot;...&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>下面讲解case class如何实现模式匹配功能:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">case</span> class Person(firstName:String, lastName: String)</span></span><br><span class="line">defined class Person</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val p = Person(<span class="string">&quot;Matt&quot;</span>, <span class="string">&quot;vanvleet&quot;</span>)</span></span><br><span class="line">p: Person = Person(Matt,vanvleet)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> p match &#123;</span></span><br><span class="line">case Person(first, last) =&gt; println(&quot;&gt;&gt;&gt;&gt; &quot; + first + &quot;, &quot; + last)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt; Matt, vanvleet</span></span><br></pre></td></tr></table></figure><p>看看模式匹配是如何提取Person中的first和last的。这里通过变量值的匹配来获取first和last的值。在后台，Scala处理这种匹配模式是通过调用一个unapply方法。如果你手动输入伴生对象的代码，它实际上是如下形式:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(firstName:<span class="type">String</span>, lastName:<span class="type">String</span>) = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(p:<span class="type">Person</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">String</span>)] =</span><br><span class="line"><span class="type">Some</span>((p.firstName, p.lastName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,apply方法用于case class创建一个实例时进行调用。方法unapply只有在使用模式匹配中被调用。典型地，方法unapply用于解封case实例并返回case class的元素。Option类型将在下一章详细阐述。<br><strong>注意</strong> 取代unapply方法的另一个方法unapplySeq用于生成case class中参数重复的情况，这将在下一章讨论。</p><p>在第二章中没有提及到for-comprehensions如何使用模式匹配，下面讨论一下如何在for表达式中使用模式匹配:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val people = List(</span></span><br><span class="line">| Person(&quot;Simon&quot;, &quot;kish&quot;),</span><br><span class="line">| Person(&quot;Phil&quot;, &quot;Marzullo&quot;),</span><br><span class="line">| Person(&quot;Eric&quot;, &quot;Weimer&quot;)</span><br><span class="line">| )</span><br><span class="line">people: List[Person] = List(Person(Simon,kish), Person(Phil,Marzullo),</span><br><span class="line">Person(Eric,Weimer))</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span>(Person(first, last) &lt;- people) yield first + <span class="string">&quot;,&quot;</span> + last</span></span><br><span class="line">res12: List[java.lang.String] =</span><br><span class="line">List(Simon,kish, Phil,Marzullo, Eric,Weimer)</span><br></pre></td></tr></table></figure><p>你将在本书多处看到模式匹配和提取器的例子。</p><ul><li>公共参数和模式匹配<br>模式匹配存在于函数式编程语言中，但不在OOP编程中。从面向对象的角度看模式匹配相当于观察者模式，模式匹配不能扩展，并打破了封装。<br>首先，相比观察者模式，模式匹配减少了大量的样板代码，其次模式匹配不仅可以匹配基本数据类型，还可以匹配到更多复杂的类型。另外，case class的匹配仅仅是通过构造器的参数提供匹配，这样，你就不需要暴露隐藏的字段，并确保封装。</li></ul><h2><span id="named-and-default-arguments-and-copy-constructors">Named and default arguments and copy constructors</span></h2><p>主要是三部分：命名参数，默认参数和构造器复制</p><ul><li>命名参数<br>首先观看一下代码:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">case</span> class Person(firstName:String, lastName:String)</span></span><br><span class="line">defined class Person</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val p = Person(<span class="string">&quot;lastname&quot;</span>, <span class="string">&quot;firstname&quot;</span>)</span></span><br><span class="line">p: Person = Person(lastname,firstname)</span><br></pre></td></tr></table></figure><p>不幸的是，两个参数都有相同的参数类型，即都是String类型，并且Scala编译器在编译期间不会检测错误。不过，你可以通过指定命名类型来避免这个问题:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val p = Person(lastName = <span class="string">&quot;lastname&quot;</span>, firstName = <span class="string">&quot;firstname&quot;</span>)</span></span><br><span class="line">p: Person = Person(firstname,lastname)</span><br></pre></td></tr></table></figure><p>这样，使用名称参数后就不用顾虑参数的顺序问题，这有利不避免不定参数和trait重构的情况，因此，如下写法等价:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val p = Person(firstName = <span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;lastname&quot;</span>)</span></span><br><span class="line">p: Person = Person(firstname,lastname)</span><br></pre></td></tr></table></figure><p>下面看看如下代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> trait Person &#123; def grade(years: Int): String &#125;</span></span><br><span class="line">defined trait Person</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class SalesPerson extends Person &#123; def grade(yrs: Int) = <span class="string">&quot;Senior&quot;</span> &#125;</span></span><br><span class="line">defined class SalesPerson</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s = new SalesPerson</span></span><br><span class="line">s: SalesPerson = SalesPerson@42a6cdf5</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.grade(yrs=1)</span></span><br><span class="line">res17: java.lang.String = Senior</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.grade(years=1)</span></span><br><span class="line">&lt;console&gt;:12: error: not found: value years</span><br><span class="line">s.grade(years=1)</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>编译不通过，因为years不是SalesPerson的实例，如果你强制转换为Person，你可以使用命名参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val s: Person = new SalesPerson</span></span><br><span class="line">s: Person = SalesPerson@5418f143</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.grade(years=1)</span></span><br><span class="line">res19: String = Senior</span><br></pre></td></tr></table></figure><p>这里的命名参数实际上相当于一个表达式或者是一个方法或代码块，每次该方法被调用时，这个表达式就被执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s.grade(years=&#123;val x = 10; x + 1&#125;)</span></span><br><span class="line">res20: String = Senior</span><br></pre></td></tr></table></figure><ul><li><p>默认参数<br>默认参数使用<code>arg:Type=expression</code>形式表示，当使用默认参数时，expression将被调用执行。</p></li><li><p>copy方法<br>从Scala2.8开始，所有case class将附加提供一个copy方法用于修改类的实例。在对象成员同名或者父级对象同名的情况下不会生成copy方法，它用于覆盖指定构造器参数的情况。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val skipOption = Skip(10, NoOption)</span></span><br><span class="line">skipOption: Skip = Skip(10,NoOption())</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val skipWithLimit = skipOption.copy(anotherOption = Limit(10,</span></span><br><span class="line">NoOption))</span><br><span class="line">skipWithLimit: Skip = Skip(10,Limit(10,NoOption))</span><br><span class="line">实际上，方法copy自动生成代码为如下形式:</span><br><span class="line">case class Skip(number: Int, anotherOption: QueryOption)</span><br><span class="line">extends QueryOption &#123;</span><br><span class="line">def copy(number: Int = number,</span><br><span class="line">anotherOption: QueryOption = anotherOption) = &#123;</span><br><span class="line">Skip(number, anotherOption)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当copy方法不指定参数时，它将等同于自身:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> Skip(10, NoOption) == Skip(10, NoOption).copy()</span></span><br><span class="line">res22: Boolean = true</span><br></pre></td></tr></table></figure><p>在Scala中，==和equals方法是等价的。</p><h2><span id="modifiers">Modifiers</span></h2><p>修饰器，常见的就是private和protected，和Java一样，用于修饰访问范围，Scala不限于这些修饰器，并带来新的特性。<br>private修改器可以用于任何定义中，使用private意味着访问只能在闭包、伴生类或伴生对象中。在Scala中，你可以通过包名或者一个类进行限定。如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> outerpkg.innerpkg</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>[<span class="type">Outer</span>] <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() = <span class="string">&quot;This is f&quot;</span></span><br><span class="line"><span class="keyword">private</span>[innerpkg] <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>() = <span class="string">&quot;This is g&quot;</span></span><br><span class="line"><span class="keyword">private</span>[outerpkg] <span class="function"><span class="keyword">def</span> <span class="title">h</span></span>() = <span class="string">&quot;This is h&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里方法f可以出现在Outer类的任何地方；方法g可以在outerpkg.innerpkg任何地方访问；方法h可以出现在outerpkg以及它的子包的任何地方。<br>在Scala中可以通过this:private[this]进行限制，在这里表示object private。对象私有表示它只能在对象内部进行访问。当成员用private修饰时，这称为类私有化(class-private)。</p><p>类似地，protected表示伴生类和子类访问权限，也可以修饰package、class和this。默认地，如果你不是使用任何修改器，则表示它是public的。但Scala没有public这个修改器。<br>和Java一样，Scala中提供了override重构修改器，不同的是Scala中的override是强制性的，这意味着，被重构的父类对象的方法应该是具体的方法，如下面写法会发生编译错误:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DogMood</span></span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>()&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AngryMood</span> <span class="keyword">extends</span> <span class="title">DogMood</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;bark&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为DogMood中的greet是抽象的，在AngryMood中通过<code>super.greet()</code>调用了抽象的父类方法，但是override中的greet()方法是具体的，因此会发生编译错误。因此，这里的override需要和abstract组合使用:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AngryMood</span> <span class="keyword">extends</span> <span class="title">DogMood</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;bark&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala中还提供了一个新的仅用于类定义的修改器sealed(密封的)，它和final有点不同；final中定义的类不能被子类重载，但是sealed定义的类，只要是在同一个文件就可以实现重构，因此可以这样定义:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryOption</span></span></span><br></pre></td></tr></table></figure><p>可以可以达到QueryOption只能被其子类继承而不能被其他对象继承。</p><h2><span id="value-classes-objects-on-a-diet">Value classes: objects on a diet</span></h2><p>从Scala2.10版本开始，Scala允许一种继承于AnyVal的值类(value class)，当然也可以是case class类，它是一个新的机制用于避免运行时分配对象。创建一个值类，你需要遵循某些规则:</p><ul><li>这个类至少要有一个val参数（vars不允许）。</li><li>参数类型不应该是值类。</li><li>不能有任何附加的构造器。</li><li>只能用def定义对象的成员，不能有val或var。</li><li>该类不能继承任何trait，只能是全局的trait（如AnyVal）。<br>Scala对于该类有如此多的限制，为什么还需要值类(value class)？它允许你在运行时添加方法但又不创建实例，如:</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">up</span> </span>= name.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类Wrapper有一个自定义参数name，并暴露了up()方法，下面创建一个Wrapper实例并调用这个方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> w = <span class="keyword">new</span> <span class="type">Wrapper</span>(<span class="string">&quot;hey&quot;</span>)</span><br><span class="line">w.up</span><br></pre></td></tr></table></figure><p>上述调用只有在编译时才生效。而在运行时这个表达式实际上等效于调用了一个对象的静态方法:Wrapper.up<img src="https://math.now.sh?inline=extendsion%28%22hey%22%29%E3%80%82%E9%82%A3%E4%B9%88%E5%9C%A8%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%0A%E5%9C%A8Scala%E5%90%8E%E5%8F%B0%E7%BC%96%E8%AF%91%E6%97%B6%E4%BC%9A%E4%B8%BA%E5%80%BC%E7%B1%BB%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%86%85%E6%94%B9%E7%BA%BF(rerouted)%E5%80%BC%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95w.up()%E4%B8%BAup" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;">extension方法。方法&quot;<img src="https://math.now.sh?inline=extension%22%E4%B8%BA%E5%AF%B9%E5%BA%94%E4%BC%B4%E7%94%9F%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E7%9A%84%E5%90%8E%E7%BC%80%E3%80%82%E4%BD%86%E6%98%AF%E6%96%B9%E6%B3%95%E4%BD%93up" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;">extension中的内容和up()方法体完全一模一样，因此，Wrapper值类的等效伴生对象为:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up$extension</span></span>(_name: <span class="type">String</span>) = _name.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规定！一个值类只能继承一个通用特质(universal trait)，并且该特质是继承自Any的（特质默认是继承自AnyDef的）。通用特质只能有方法定义不能包含初始代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Printable</span> <span class="keyword">extends</span> <span class="title">Any</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span></span>() = println(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> <span class="keyword">with</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span></span>() = name.toUpperCase</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> w = <span class="type">Wrapper</span>(<span class="string">&quot;Hey&quot;</span>)</span><br><span class="line">w.p()</span><br></pre></td></tr></table></figure><p>无论如何，通过值类为存在的类型添加附加的方法是一个非常好的方法。我们会在本书后面看到关于这方面更多的例子。</p><h2><span id="implicit-conversion-with-implicit-classes">Implicit conversion with implicit classes</span></h2><p>隐式转换是一种传入一个类型的参数返回另外一种类型参数的方法。例如下面例子将Double类转换为Int:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val someInt: Int = 2.3</span></span><br><span class="line">&lt;console&gt;:7: error: type mismatch;</span><br><span class="line">found : Double(2.3)</span><br><span class="line">required: Int</span><br><span class="line">val someInt: Int = 2.3</span><br><span class="line">^</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def double2Int(d: Double): Int = d.toInt</span></span><br><span class="line">double2Int: (d: Double)Int</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val someInt: Int = double2Int(2.3)</span></span><br><span class="line">someInt: Int = 2</span><br></pre></td></tr></table></figure><p>通常你不能显式地将Double类转换为Int类型，但这里我们可以使用double2Int方法明确地将Double转换为Int类型。我们可以使用implicit关键字进行隐式转换:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> double2Int(d: <span class="type">Double</span>): <span class="type">Int</span> = d.toInt</span><br></pre></td></tr></table></figure><p>隐式转换的特点是编译器会找到合适的转换器并进行调用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val someInt: Int = 2.3</span></span><br><span class="line">&lt;console&gt;:7: error: type mismatch;</span><br><span class="line">found : Double(2.3)</span><br><span class="line">required: Int</span><br><span class="line">val someInt: Int = 2.3</span><br><span class="line">^</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> implicit def double2Int(d: Double): Int = d.toInt</span></span><br><span class="line">warning: there were 1 feature warnings; re-run with -feature for details</span><br><span class="line">double2Int: (d: Double)Int</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val someInt: Int = 2.3</span></span><br><span class="line">someInt: Int = 2</span><br></pre></td></tr></table></figure><p>在Scala中，当编译器解析到一个类型错误的时候，它并没有马上退出；实际上，它会查找任何满足这个错误的隐式转换。因此，在这个例子中，double2Int是用于将Double转换为Int的，表达式会被编译器重写:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> someInt: <span class="type">Int</span> = double2Int(<span class="number">2.3</span>)</span><br></pre></td></tr></table></figure><p>这个转换发生在编译期间，如果没有找到合适的转换方法，编译器则会抛出一个编译异常。另外，如果转换方法冲突也会抛出一个异常。例如，有多于一个隐式转换器被匹配到，相比其他动态语言Scala的隐式转换只在编译期抛出错误信息，因此它是安全的。下面讨论一下隐式转换器的用法:<br>隐式转换器一个普遍的用法就是对存在的数据类型添加扩展方法，如，我们知道可以用如下方法创建一个范围:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneTo10 = <span class="number">1</span> to <span class="number">10</span></span><br></pre></td></tr></table></figure><p>但是，如果我们要创建一个<code>--&gt;</code>方法来表示1到10的范围怎么实现？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneTo10 = <span class="number">1</span> --&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>我们可以通过两步进行</p><p>①创建一个类型实现了Int类型的<code>--&gt;</code>方法<br>②提供一个隐式转换器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class RangeMaker(left: Int) &#123;</span></span><br><span class="line">| def --&gt;(right: Int) = left to right</span><br><span class="line">| &#125;</span><br><span class="line">defined class RangeMaker</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val range: Range = new RangeMaker(1).--&gt;(10)</span></span><br><span class="line">range: Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure><p>现在只需要再定义一个隐式转换器即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> implicit def int2RangeMaker(left: Int) = new RangeMaker(left)</span></span><br></pre></td></tr></table></figure><p>当我们使用<code>val oneTo10 = 1 --&gt; 10</code>时，它实际上隐式调用了<code>new RangeMaker(1).--&gt;(10)</code>方法进行操作<br>另外一种比较便捷的方法是使用implicit class修改器（或称作修饰符）实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implicit class RangeMaker(left: Int) &#123;</span><br><span class="line">def --&gt;(right: Int): Range = left to right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，它和上面的实现形式是一样的，Scala编译器会将implicit class进行“拖糖”，即将其分解为一般类和隐式转换方法。注意隐式类必须要有一个带一个参数的主构造器（那是当然的，不然如何实现转换）。<br>我们注意到，上面的例子中，隐式转换是在编译期发生的，这意味着在运行期每实现一个隐式转换就会创建一个隐式转换类的一个实例，这是我们不希望看到的，幸运的是，前面介绍到，我们可以创建值类:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeMaker</span>(<span class="params">val left: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">--&gt;</span></span>(right: <span class="type">Int</span>): <span class="type">Range</span> = left to right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，隐式转换就变得非常强大，但过度使用会减少代码的可读性和基础代码的维护性。</p><h2><span id="scala-class-hierarchy">Scala class hierarchy</span></h2><p>在3.3小节介绍过Scala的类层次结构。层次结构中的根类为scala.Any，其他所有类直接或间接继承该类。该类定义了两个子类，分别是AnyVal和AnyDef，在主系统(JVM或CLR)中，一个对象的所有值都是AnyDef的子类。其中，所有用户定义的Scala类继承自特质scala.ScalaObject，AnyDef是java.lang.Object（Java）和system.Object（C#）的映射。<br>子类AnyVal在主系统中不作为一个对象表示。但是在Scala中，Everything is Object，这不是矛盾？的确在Scala中所有事物都是对象，但不在主系统范围(JVM或CLR)。当Scala编译成Java字节码时，它会使用Java的基础类行，而不是封装类型，因为这样更加高效，而当需要被Scala使用时则转换为对象。<br>实际上Scala有个views隐式类型，它是一个转换器用于将Char，Int，Long进行相互转换。在之后将会介绍到隐式函数。<br>Scala.Null是所有参考类型的子类，也是null唯一的实例参考。所以创建一个null实例的唯一方法就是指定它的类型:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val x: Null = null</span></span><br><span class="line">x: Null = null</span><br></pre></td></tr></table></figure><p>因为Null对象是AnyRef的子类，所以不能将其标识为值类型，否则将抛出异常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val x: Int = null</span></span><br><span class="line">&lt;console&gt;:8: error: type mismatch;</span><br><span class="line">found : Null(null)</span><br><span class="line">required: Int</span><br><span class="line">val x: Int = null</span><br></pre></td></tr></table></figure><p>另外，scala.Nothing是Scala层次结构的最后一个子类，它是所有类的子类，但是你不能创建scala.Nothing的实例，在Scala中没有该类型的实例。在第四章将介绍到更多关于Nothing的解决复杂的问题。<br><img src="/img/scala-in-action/chapter3/scala-class-hierarchy.png" alt="Class hierarchy of Scala with subtypes and views"></p><h2><span id="summary">Summary</span></h2><p>本章介绍了比较多的内容，包括Scala增强的OOP技术，并介绍了命名和默认参数；介绍了混入和类组合结构；介绍了case class和value class，以及如何通过case class实现可变参数，你将在后面章节的Actors和concurrency使用到更多case class，同时，你也学习了单例对象和伴生对象如何在Scala中使用。<br>在本章最后，我们探索了Scala的类层次结构和一些重要的类，这部分内容将有助你更容易入手Scala文档并库。<br>本章只介绍了一些基础，你会在第7章重新开始面向对象的概念，并接触到更多抽象的技术。<br>记住，一个是你熟悉的好方法就是进入到REPL环境并尝试所有的特性和功能。行动才是学习Scala最快捷的方法。下一章将开始介绍Scala多样的函数式接口。</p>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：开始学习Scala</title>
      <link href="/2016/10/27/scala/02-getting-started/"/>
      <url>/2016/10/27/scala/02-getting-started/</url>
      
        <content type="html"><![CDATA[<p>本章内容将学习Scala的类型，函数，for-comprehensions，模式匹配，以及其它方面内容。</p><p>注意模式匹配和for-comprehensions，是函数式编程概念。本章主要目的是先熟悉Scala语言的环境和一些基本的语法。一开始，会先从REPL简单环境入手。</p><p>在作进一步学习之前，先确保已经安装好Scala。现在，让我们先了了解Scala的解析器REPL。</p><span id="more"></span><h2><span id="scala解析器repl">Scala解析器REPL</span></h2><p>Scala 解析器，指的是一个可以编写Scala表达式和程序的交互shell。要进入到Scala的交互模式，在命令提示符中输入<code>scala</code>即可。你将进入到Scala的命令提示符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Scala version 2.10.0.final (Java ...).</span><br><span class="line">Type in expressions to have them evaluated.</span><br><span class="line">Type :help for more information.</span><br><span class="line"><span class="meta">scala&gt;</span></span><br></pre></td></tr></table></figure><p>这表明Scala安装成功。在Scala提示符输入42，按回车，将看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> 42</span></span><br><span class="line">res0: Int = 42</span><br></pre></td></tr></table></figure><p><code>res0</code>为Scala解析器创建的变量名，持有值42。如果再输入变量名，将再次得到相似的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> res0</span></span><br><span class="line">res1: Int = 42</span><br></pre></td></tr></table></figure><p>带有这些步骤的，称之为 REPL(read-evaluate-print loop)。即你可以在Scala解析器内部重复的循环 读-执行-打印 步骤。现在再看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> println(<span class="string">&quot;Hello world&quot;</span>)</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这里调用了<code>println</code>函数，以及传递参数<code>&quot;Hello World&quot;</code>，并输出结果。</p><p><code>println</code>是<code>scala.Console</code>中的一个函数，该函数使用<code>System.out.println()</code>将消息输出在控制台上，Scala库中的Predef会将<br><code>Console.println</code>映射为<code>println</code>，因此你可以不使用包名调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; val myList = new java.util.ArrayList[String]()</span><br><span class="line">myList: java.util.ArrayList[String] = []</span><br></pre></td></tr></table></figure><p>在Scala中可以直接调用Java对象和方法。</p><p>下面列出REPL的一些比较有用的选项：</p><table><thead><tr><th>Command</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td><code>:help</code></td><td style="text-align:left">This command prints the help message with all the commands available in the Scala interpreter.</td></tr><tr><td><code>:cp</code></td><td style="text-align:left">Use this command to add a JAR file to the classpath for the Scala interpreter. For example, <code>:cp tools/junit.jar</code> will try to find a JUnit JAR file relative to your current location and, if found, it will add the JAR file to your classpath so that you can refer to the classes inside the JAR file.</td></tr><tr><td><code>:load</code> or <code>:l</code></td><td style="text-align:left">Allows you to load Scala files into the interpreter. If you want to investigate existing Scala code, you could load the file into the Scala interpreter, and all the definitions will be accessible to you.</td></tr><tr><td><code>:replay</code> or <code>:r</code></td><td style="text-align:left">Resets the interpreter and replays all the previous commands.</td></tr><tr><td><code>:quit</code> or <code>:q</code></td><td style="text-align:left">Exits the interpreter.</td></tr><tr><td><code>:type</code></td><td style="text-align:left">Displays the type of an expression without evaluating it. For example, <code>:type 1 + 2</code> will determine the type of the expression to <code>Int</code> without performing the add operation.</td></tr></tbody></table><h2><span id="scala基础">Scala基础</span></h2><p>接下来将介绍Scala的基础类型，包括<code>String</code>和值类型<code>Byte</code>，<code>Short</code>，<code>Int</code>，<code>Long</code>，<code>Float</code>，<code>Double</code>，<code>Boolean</code>以及<code>Char</code>。同时将介绍Scala的两种变量类型<code>var</code>和<code>val</code>。你将学习Scala函数，如何定义，如何调用。</p><h3><span id="基础类型">基础类型</span></h3><p>Scala的所有基础类型都是对象，它们定义在<code>scala</code>包下。</p><p>2种变量类型，9种基本数据类型</p><table><thead><tr><th>Value type</th><th style="text-align:left">Description and range</th></tr></thead><tbody><tr><td><code>Byte</code></td><td style="text-align:left">8位二进制，-128~127</td></tr><tr><td><code>Short</code></td><td style="text-align:left">16位二进制，-32768~32767</td></tr><tr><td><code>Int</code></td><td style="text-align:left">32位二进制，–2,147,483,648~2,147,483,647</td></tr><tr><td><code>Long</code></td><td style="text-align:left">64位二进制，-9,223,372,036,854,775,808~,223,372,036,854,775,807</td></tr><tr><td><code>Float</code></td><td style="text-align:left">A single-precision 32-bit IEEE 754 floating point.</td></tr><tr><td><code>Double</code></td><td style="text-align:left">A double-precision 64-bit IEEE 754 floating point.</td></tr><tr><td><code>Boolean</code></td><td style="text-align:left">True False</td></tr><tr><td><code>Char</code></td><td style="text-align:left">16位的Unicode字符，‘、u0000’~‘\uffff’</td></tr></tbody></table><p>在Scala中，所有的基本数据类型的第一个字母都是大写的。在Scala的早期版本中既可以使用小写也可以使用首字母大写，<br>但从2.8版本开始，将不再支持小写。</p><p><strong>注意</strong> 在Scala中是默认导入了<code>java.lang</code>和<code>Scala.Predef</code>，在.Net环境中对应是system包。对象Predef定义了函数和类型<br>别名，由于Predef是自动导入的，你可以使用Predef中的所有成员和方法。</p><p><strong>说明</strong> 你可以在REPL编译环境中通过命令<code>:import</code>查看所有被自动导入的包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> :imports</span></span><br><span class="line">1) import java.lang._ (153 types, 158 terms)</span><br><span class="line">2) import scala._ (798 types, 806 terms)</span><br><span class="line">3) import scala.Predef._ (16 types, 167 terms, 96 are implicit)</span><br></pre></td></tr></table></figure><h4><span id="字面常量">字面常量</span></h4><h5><span id="整形">整形</span></h5><p>Byte，Short，Int，Long和Char这些基本类型被称为 整形。字面常量可以表示十进制、十六进制和八进制的数，这取决于<br>这些字面常量的定义方式。如果是0或非零的数字，则它是十进制的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scala &gt; val decimal = 11235</span><br><span class="line">decimal: Int = 11235</span><br></pre></td></tr></table></figure><p>和Java一样，如果要声明为Long长整型，只需要在后面加上L或l，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val decimal = 11235L</span></span><br><span class="line">decimal: Long = 11235</span><br></pre></td></tr></table></figure><p>类似地，如果要声明为十六进制和八进制则在数据前面加上前缀0x(十六进制)和0(八进制)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val hexa = 0x23</span></span><br><span class="line">hexa: Int = 35</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val octa = 023</span></span><br><span class="line">hexa: Int = 19</span><br></pre></td></tr></table></figure><p>值得注意的是，不管是十六进制还是八进制，Scala总是返回一个十进制，如果你可以通过类型声明的方式指定，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val i = 1</span></span><br><span class="line">i: Int = 1</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val i2: Byte = 1</span></span><br><span class="line">i2: Byte = 1</span><br></pre></td></tr></table></figure><h5><span id="浮点型">浮点型</span></h5><p>浮点型字面量一般包含整数部分和小数部分，小数点和小数部分通常是可选的，浮点型(Float)以F或f作后缀标记，否则就是<br>Double型的，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val d = 0.0</span></span><br><span class="line">d: Double = 0.0</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val f = 0.0f</span></span><br><span class="line">f: Float = 0.0</span><br></pre></td></tr></table></figure><p>Double型可以通过科学记数法表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash">val exponent = 1e30</span></span><br><span class="line">exponent: Double = 1.0E30</span><br></pre></td></tr></table></figure><p>特列：由于浮点型数据可以以 <code>1.</code> 表示，在使用<code>toString</code>方法时，需要用空格分开，即<code>1. toString</code>。对于非字母开头的方法<br>则可以自动识别，如<code>1.+1</code>将返回<code>2.0</code>，这是一种不规范的写法，应该尽量避免使用。</p><h5><span id="字符字面量">字符字面量</span></h5><p>字符字面量有两种表示形式，一种是使用Unicode编号，一种是直接显示，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val capB = <span class="string">&#x27;\102&#x27;</span></span></span><br><span class="line">capB: Char = B</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val capB = <span class="string">&#x27;B&#x27;</span></span></span><br><span class="line">capB: Char = B</span><br></pre></td></tr></table></figure><p>因此，一些比较特殊的字符，比如换行和回车也可以表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val new_line = <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">new_line: Char = </span><br></pre></td></tr></table></figure><h5><span id="字符串字面量">字符串字面量</span></h5><p>字符串字面量表示方式和字符字面量一样，表示形式和Java语言一样，基本类型也是String。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val bookName = <span class="string">&quot;Scala in \&quot;Action\&quot;&quot;</span></span></span><br><span class="line">bookName: java.lang.String = Scala in &quot;Action&quot;</span><br></pre></td></tr></table></figure><p>同时也具有如python的换行等特性，如用连续三个引号来表示换行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val multiLine = <span class="string">&quot;&quot;</span><span class="string">&quot;This is a</span></span></span><br><span class="line">| multi line</span><br><span class="line">| string&quot;&quot;&quot;</span><br><span class="line">multiLine: java.lang.String =</span><br><span class="line">This is a</span><br><span class="line">multi line</span><br></pre></td></tr></table></figure><blockquote><p><strong>新特性</strong><br>从Scala 2.10开始支持字符串内插(String interpolation)写法，因此你可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val name = <span class="string">&quot;Nilanjan&quot;</span></span></span><br><span class="line">name: String = Nilanjan</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> s<span class="string">&quot;My name <span class="variable">$name</span>&quot;</span></span></span><br><span class="line">res0: String = My name Nilanjan</span><br></pre></td></tr></table></figure><p>在Scala内部将调用一个类StringContext来对字符串进行处理，以<code>$</code>或<code>${...}</code>开头的字符token将被替换，头处理f会将匹配的字符进行格式化操作，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val height = 1.9d</span></span><br><span class="line">height: Double = 1.9</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val name = <span class="string">&quot;James&quot;</span></span></span><br><span class="line">name: String = James</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> println(f<span class="string">&quot;<span class="variable">$name</span>%s is <span class="variable">$height</span>%2.2f meters tall&quot;</span>)</span></span><br><span class="line">James is 1.90 meters tall</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><em><strong>RichString vs. StringLike</strong></em><br>如果你使用之前的版本，你将使用<code>scala.RichString</code>来为字符串对象提供额外的方法，但从Scala2.8开始被叫做<code>scala.collection.immutable.StringLike</code>，因为字符串是一个字符集合，它将把字符串视作一个不可变的容器(immutable collection)。相对地，Rich的封装基本类还有<code>RichInt</code>，<code>RichBoolean</code>，<code>RichDouble</code>等等。</p></blockquote><h5><span id="xml字面量">XML字面量</span></h5><p>传统地，使用XML意味着需要第三方解析器或者库，但在Scala中属于语言的一部分，Scala支持XML字面量，因此，可以直接输入：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> book = &lt;book&gt;</span><br><span class="line">&lt;title&gt;<span class="type">Scala</span> in <span class="type">Action</span>&lt;/title&gt;</span><br><span class="line">&lt;author&gt;<span class="type">Nilanjan</span> <span class="type">Raychaudhuri</span>&lt;/author&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">book: scala.xml.<span class="type">Elem</span> =</span><br><span class="line">&lt;book&gt;</span><br><span class="line">&lt;title&gt;<span class="type">Scala</span> in <span class="type">Action</span>&lt;/title&gt;</span><br><span class="line">&lt;author&gt;<span class="type">Nilanjan</span> <span class="type">Raychaudhuri</span>&lt;/author&gt;</span><br><span class="line">&lt;/book&gt;</span><br></pre></td></tr></table></figure><p>Scala将XML字面量转换为<code>scala.xml.Elem</code>类型对象，不仅仅如此，你可以使用<code>&#123;&#125;</code>在XML中传递参数和变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val message = <span class="string">&quot;I didn&#x27;t know xml could be so much fun&quot;</span></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val code = “1”</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val alert = &lt;alert&gt;</span></span><br><span class="line">&lt;message priority=&#123;code&#125;&gt;&#123;message&#125;&lt;/message&gt;</span><br><span class="line">&lt;date&gt;&#123;new java.util.Date()&#125;&lt;/date&gt;</span><br><span class="line">&lt;/alert&gt;</span><br><span class="line">alert: scala.xml.Elem =</span><br><span class="line">&lt;alert&gt;</span><br><span class="line">&lt;message priority=”1”&gt;</span><br><span class="line">I didn&#x27;t know xml could be so much fun</span><br><span class="line">&lt;/message&gt;</span><br><span class="line">&lt;date&gt;Fri Feb 19 19:18:08 EST 2010&lt;/date&gt;</span><br><span class="line">&lt;/alert&gt;</span><br></pre></td></tr></table></figure><p>像这样代码定义在<code>&#123;&#125;</code>里面的，在Scala中称之为 Scala代码块(Scala code blocks)。顾名思义，我们可以在<code>&#123;&#125;</code>内写入程序代<br>码。值得注意的是，在<code>&#123;&#125;</code>外不要使用<code>“”</code>双引号，否则将解析成字符串。</p><h4><span id="变量">变量</span></h4><p>Scala中变量的声明有两种方式：<code>val</code>和<code>var</code>。<br><code>val</code> 是一个赋值变量，有时又叫 值(value)，表示一旦初始化就不能被修改和指定到其他值(类似于Java的final)。<br><code>var</code> 是可再分配的(reassignable)，你可以在其初始化后任意更改变量的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val constant = 87</span></span><br><span class="line">constant: Int = 87</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> constant = 88</span></span><br><span class="line">&lt;console&gt;:5: error: reassignment to val</span><br><span class="line">constant = 88</span><br><span class="line">^</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var variable = 87</span></span><br><span class="line">variable: Int = 87</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> variable = 88</span></span><br><span class="line">variable: Int = 88</span><br></pre></td></tr></table></figure><p>尽管Scala解析器在变量类型上实现和很好的机制，但有时需要对变量声明指定的类型，我们可以通过 变量:【类型】的形式进行指定。当你声明一个变量而又不明确该变量的值时，你可以使用占位符(_)表示默认类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var willKnowLater:String = _</span></span><br><span class="line">willKnowLater: String = null</span><br></pre></td></tr></table></figure><p>因为String的默认类型为null，在该例子中willKnowLater的值就是null。特别声明，不管是var还是val都要为其指定值或<code>_</code>占位符(val不能通过占位符<code>_</code>表示值，因为val声明的是一个确切的不能被改变的值，本地方法或语句块内的var变量不能<br>使用占位符<code>_</code>)，只有变量声明在类内部时才不用指定值。</p><h5><span id="lazy-变量">Lazy 变量</span></h5><p>由于变量在var或val声明时便被赋值，但你又不想在一些耗时的操作中声明该变量的值，为了改变这种行为，可以使用<code>lazy val</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> lazy val forLater = someTimeConsumingOperation()</span></span><br><span class="line">forLater: Unit = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">表示forLater不在绑定变量后立即求值，</span><br><span class="line">而是在someTimeConsumingOperation()被调用时，才进行求值，如</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var a = 1</span></span><br><span class="line">a: Int = 1</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> lazy val b = a + 1</span></span><br><span class="line">b: Int = &lt;lazy&gt;</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> a = 5</span></span><br><span class="line">a: Int = 5</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> b</span></span><br><span class="line">res1: Int = 6</span><br></pre></td></tr></table></figure><p>变量<code>b</code>在最后一步被调用，但是原来的<code>a</code>已经由<code>1</code>变成了<code>5</code>，所有<code>b</code>最后计算的<code>6</code>。</p><p><strong>注意</strong> <code>lazy</code>关键字只能跟随<code>val</code>，不能声明<code>lazy var</code>，因为只有<code>val</code>是不可变的，这意味着通过<code>lazy val</code>声明的变量将在第<br>一次被调用时产生一个确切的不可变的值。</p><h5><span id="模式匹配">模式匹配</span></h5><p>我们还可以通过模式匹配来进行声明变量，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val first :: rest = List(1, 2, 3)</span></span><br><span class="line">first: Int = 1</span><br><span class="line">rest: List[Int] = List(2, 3)</span><br></pre></td></tr></table></figure><p>List在Scala中是一个队列容器，模式匹配中左边的<code>first</code>将匹配到List中的第一个元素，最后一个rest匹配剩余的元素，符号<code>::</code>是一个定义在List中的方法，模式匹配将在本章着重讨论。</p><p>记住，声明变量时习惯上将其用<code>val</code>声明，而在实际需要是再将其更改为<code>var</code>，以避免出错。</p><h4><span id="函数">函数</span></h4><h5><span id="函数结构定义">函数结构定义</span></h5><p>函数在Scala中以语句块形式表示，在本小节我们将着重探讨。<br>在Scala中，函数的定义形式为：</p><p>def 方法名（方法参数） 可选返回类型 = 方法主体</p><p>在函数中，使用<code>:</code>从返回类型中分割参数列表；多个参数使用<code>,</code>隔开；使用<code>=</code>将方法声明部分和方法主体部分隔开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def myFirstMethod():String = &#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()String</span><br></pre></td></tr></table></figure><p>在该部分，方法返回类型是可选的，因此上面也可以这样声明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def myFirstMethod() = &#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()java.lang.String</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> myFirstMethod()</span></span><br><span class="line">res6: java.lang.String = exciting times ahead</span><br></pre></td></tr></table></figure><p>在方法中<code>=</code>的作用不仅仅用于区分方法声明和方法主体，另一个作用是告诉Scala编译器，应该返回什么类型的数据。如果<br>省略了<code>=</code>号，Scala将不返回任何东西，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def <span class="function"><span class="title">myFirstMethod</span></span>()&#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()Unit</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> myFirstMethod()</span></span><br></pre></td></tr></table></figure><p>以上面为例，在REPL环境中，返回类型不再是<code>java.lang.String</code>，而已<code>Unit</code>。<code>Unit</code>即相当于Java中的void，就是表示一个<br>方法不返回任何东西。</p><p>对于一般比较简单的方法，你可以直接去掉大括号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def myFirstMethod() = <span class="string">&quot;exciting times ahead&quot;</span></span></span><br><span class="line">myFirstMethod: ()java.lang.String</span><br></pre></td></tr></table></figure><p>像这些不包含复杂结构的，或不进行参数传递的，可以直接省略掉<code>&#123;&#125;</code>大括号。甚至，如果不包含参数，可以直接将小括号去掉<code>()</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def myFirstMethod = <span class="string">&quot;exciting times ahead&quot;</span></span></span><br><span class="line">myFirstMethod: java.lang.String</span><br></pre></td></tr></table></figure><p>输出结果形式更像是一个声明，因此这也意味着你可以用这种<code>def</code>的方法声明形式代替<code>val</code>或<code>var</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> myFirstMethod</span></span><br><span class="line">res17: java.lang.String = exciting times ahead</span><br></pre></td></tr></table></figure><p>明显，调用这种形式的方法和调用var和val是一样的。</p><h5><span id="函数类型">函数类型</span></h5><p>回到函数参数，下面提供一个函数<code>max</code>传递了两个参数，并返回一个最大的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def max(a: Int, b: Int) = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span></span><br><span class="line">max: (a: Int,b: Int)Int</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> max(5, 4)</span></span><br><span class="line">res8: Int = 5</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> max(5, 7)</span></span><br><span class="line">res9: Int = 7</span><br></pre></td></tr></table></figure><p>在Scala中，<code>return</code>是可选的，在函数中你可以不用使用<code>return</code>关键，它将返回的是最后一个表达式的值。在上面的例子中，if<br>else语句中的表达式部分为<code>a</code>和<code>b</code>，又因为<code>a</code>和<code>b</code>都是最后一个表达式，因此，当if条件为<code>true</code>时返回<code>a</code>，否则返回<code>b</code>。</p><p>尽管<code>return</code>是可选的，你也不用在函数定义的时候声明函数的参数类型。Scala是在函数调用时推断出函数的返回类型，而不是在函数声明的时候<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><blockquote><p><strong>类型推断</strong></p><p>如果你有诸如Haskell，OCaml等类型推断编程语言的使用背景，你会对Scala参数定义的方式感到怪异。原因是，Scala不使用Hindley-Milner算法进行类型推断；实际上Scala的类型推断是基于本地声明的信息，也就是本地类类型推断。类型推断超出本书的范围，你可以阅读更多有关于Hindley-Milner类型推断算法的资料以及为什么它是有用的。</p></blockquote><h5><span id="参数化类型-parameterized-type">参数化类型 (parameterized type)</span></h5><p>有时我们要通过List作为参数传入一个函数中，但是不能确定List参数传入的是Int还是String，面对这种情况，Scala中提供了一个参数化类型，可以使得在函数调用的时候在决定函数参数的类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def toList[A](value:A) = List(value)</span></span><br><span class="line">toList: [A](value: A)List[A]</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> toList(1)</span></span><br><span class="line">res16: List[Int] = List(1)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> toList(<span class="string">&quot;Scala rocks&quot;</span>)</span></span><br><span class="line">res15: List[java.lang.String] = List(Scala rocks)</span><br></pre></td></tr></table></figure><p>在声明函数时，标识未知的参数类型为A。当toList方法被调用时，A将被传入的参数的类型代替，由于List在Scala中也使用了参数化类型，所以将返回实际参数的类型。</p><p>注意：如果你是一个Java编程员，你会发现Java的泛型和Scala的参数化类型十分相似。不同的是，Java是使用(<code>&lt;&gt;</code>)而Scala则是使用(<code>[]</code>)。另外稍微不同的是Scala通常是使用A，B，C… Z标识，而Java通常是T，K，V和E。</p><h5><span id="函数字面量">函数字面量</span></h5><p>在Scala中，你把函数作为参数传递给另一个函数，这种把函数作为参数传递的宽松机制被称为闭包(closure)（函数作参数传递不总是闭包，这会在第四节介绍）。Scala提供了一个简便的机制创建函数，就是你只需要写函数主体，这种形式叫做函数字面量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val evenNumbers = List(2, 4, 6, 8, 10)</span></span><br><span class="line">evenNumbers: List[Int] = List(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure><p>我们可以使用List中的foldLeft方法计算list中的和。foldLeft方法传递两个参数，一个初始化值和一个二元运算。二元运算提供了初始化值和list中的所有元素。二元运算将作为一个函数，这个函数包含了两个参数用于自身操作，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> evenNumbers.foldLeft(0) &#123; (a: Int, b:Int) =&gt; a + b &#125;</span></span><br><span class="line">res19: Int = 30</span><br></pre></td></tr></table></figure><p>如上例子，第一个参数为<code>(0)</code>表示初始化值，第二个参数为<code>&#123; (a: Int, b:Int) =&gt; a + b &#125;</code>，它是一个二元运算，在本例中，它也是一个匿名函数，或称为一个没有预定义函数名的函数。由于在Scala中可以使用类型推断，因此下面形式是等价的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> evenNumbers.foldLeft(0) &#123; (a, b) =&gt; a + b &#125;</span></span><br><span class="line">res20: Int = 30</span><br></pre></td></tr></table></figure><p>分析：在Scala中，foldLeft方法定义方式为<code>def foldLeft[B](z: B)(f: (B, A) =&gt; B): B</code>，其中<code>[B]</code>为参数化，<code>(z: B)</code>为第一个参数，B是要返回的对象，<code>(f: (B, A) =&gt; B)</code>为第二个参数，它是一个二元运算，他表示将(B,A)得到的结果赋予给B，用数学公式表示就是 y = f(x,y)。在本例中就是b = a + b，实际上就是个累加器。</p><p>Scala允许你对匿名函数做更进一步的操作：你可以去掉匿名函数的参数部分，仅仅保留方法主体，这种情况下，匿名函数的参数要用占位符<code>_</code>代替。下划线在Scala中有特殊意义，在本例中下划线就相当于占位符，因此，下面写法也是等价的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> evenNumbers.foldLeft(0) &#123; _ + _ &#125;</span></span><br><span class="line">res21: Int = 30</span><br></pre></td></tr></table></figure><p>下划线在Scala中用得比较多，占位符<code>_</code>可以用在任何地方，具体表示什么值取决于所在的上下文，并且是在其被真正调用的时候才决定其值。函数字面量是Scala中的习惯用法，在Scala基础代码和库中会频繁出现。<br>回到第一章的例子我们就可以明白，占位符代表了exists方法中的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val hasUpperCase = name.exists(_.isUpper)</span><br></pre></td></tr></table></figure><h4><span id="使用scala闭包和第一类函数">使用Scala闭包和第一类函数</span></h4><p>闭包就是在它被定义的环境中封装起来的方法。例如，闭包会跟踪函数内部指向函数外部的变量的变化。<br>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。<br>注意：闭包一词经常和匿名函数混淆。这可能是因为两者经常同时使用，但是它们是不同的概念。<br>这里要说明，Scala中没有break或continue，也不是保留字。Scala是一门可扩展的语言，因此，你可以扩展来达到break的作用。我们可以通过Scala的异常处理机制来实现break。因为，抛出一个异常会是执行队列停止，使得catch语句块只执行到这之前，因为return在Scala中是多余的，Scala总是返回最后一个语句。我们通过声明异常，就可以达到模拟break的实现，如我们定义一个抛出异常的break方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def break = new RuntimeException(&quot;break exception&quot;)</span><br></pre></td></tr></table></figure><p>下面我们以此创建一个闭包函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def breakable(op: =&gt; Unit) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>op: =&gt; Unit</code>是什么？右箭头<code>=&gt;</code>表示函数<code>breakable</code>中要求一个函数作为参数；箭头右边的为breakable函数的返回类型（——本例中Unit相当于Java中的void）；<code>op</code>为参数名。因为在右箭头(<code>=&gt;</code>)左边没有定义任何东西，这意味着作为参数的函数自身不具有参数，若其要传递参数，以foldLeft为例，需要如下定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def foldLeft(initialValue: Int, operator: (Int, Int) =&gt; Int)= &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们以Scala实现搜索SCALA_HOME环境变量为例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> breakException = <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;break exception&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">op</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> _ =&gt; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">break</span> </span>= <span class="keyword">throw</span> breakException</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span> </span>= &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">System</span>.getenv(<span class="string">&quot;SCALA_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(env == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">println(<span class="string">&quot;found scala home lets do the real work&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该闭包:breakable(install)，因为breakable中的实际参数为install，而install的参数为空，所以另外一种方式就是通过行内调用，如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breakable &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">System</span>.getenv(<span class="string">&quot;SCALA_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(env == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">println(<span class="string">&quot;found scala home lets do the real work&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong> 在Scala中，如果函数的最后一个参数为function类型，你就可以把该函数作为闭包传递。这个语法糖对创建DSL非常有用。下一章开始将介绍闭包如何转换为对象，记住，在Scala中，一切都是对象。</p><p><strong>注意</strong> 在Scala的库中早就已经提供了breakable，参考<code>scala.util.control.Breaks</code>。Scala中没有break关键字，如果你需要使用break你需要使用Breaks即可。</p><h3><span id="working-with-array-and-list">Working with Array and List</span></h3><p>在第四章为数据结构部分，在此之前，先来了解一下List和Array，这样我们就可以写一些比较有用的Scala脚本。<br>下面例子中，array是scala.Array中的一个实例，scala.Array类似Java中的Array类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val array = new Array[String](3)</span></span><br><span class="line">array: Array[String] = Array(null, null, null)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> array(0) = <span class="string">&quot;This&quot;</span></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> array(1) = <span class="string">&quot;is&quot;</span></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> array(2) = <span class="string">&quot;mutable&quot;</span></span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> array</span></span><br><span class="line">res37: Array[String] = Array(This, is, mutable)</span><br></pre></td></tr></table></figure><p>记住，在Scala中，类型信息和参数化使用方括号，他们的作用是等同的。参数化是用于在创建实例的时候计算出该实例的数据类型。<br>下面打印出每个Array的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> array.foreach(println)</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line">mutable</span><br></pre></td></tr></table></figure><p>由于Scala中默认引入了Predef，所以，在使用Array对象的同时，请查看<code>scala.collection.mutable.ArrayLike</code>类，它被声明为<code>trait</code>（特质）。因此在使用Array实例的时候，可以动态地使用ArrayLike提供的功能。</p><p><strong>注意</strong> Predef默认将Array转换为<code>scala.collection.mutable.ArrayOps.ArrayOps</code>，该类是ArrayLike的子类。因此，ArrayLike就相当于一个接口为其子类提供了大量的方法，不同的是，在Scala中是通过trait声明，而在Java中是通过interface声明。</p><h5><span id="命令行参数">命令行参数</span></h5><p>你可以使用一个隐式的val变量args来获取命令行输入的参数，如输出在控制台输入的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args.foreach(println)</span><br></pre></td></tr></table></figure><p>我们把该表达式存储为一个myfirstScript.scala文件，在控制台输入如下命令 <code>scala myfirstScript.scala my first script</code>将输出如下结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my </span><br><span class="line">first </span><br><span class="line">script</span><br></pre></td></tr></table></figure><p>Array是一个可变数据结构。通过向array中添加元素会改变array实例并产生副作用。在函数式编程中，方法不应该有副作用。方法的唯一作用就是计算值并返回值而不改变实例。因此，你可以使用List代替，在Scala中，List是不可变的并使得函数式编程变得容易。创建一个List可以如下创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val myList = List(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;immutable&quot;</span>)</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure><p>也可以如下创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val myList = scala.collection.immutable.List(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>,<span class="string">&quot;immutable&quot;</span>)</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure><blockquote><p><strong>什么是scala.collection.immutable.<img src="https://math.now.sh?inline=colon" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;">colon？</strong></p><p>在上面例子中，你调用getClass方法查看对象的类型，你会对其输出觉得奇怪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> myList.getClass</span></span><br><span class="line">res42: java.lang.Class[_] = class</span><br><span class="line">scala.collection.immutable.$colon$colon</span><br></pre></td></tr></table></figure><p>这是因为<code>scala.collection.immutable.List</code>是一个抽象类，它包含两个实现类，<code>scala.Nil</code>和<code>scala.::.</code>。在Scala中，<code>::</code>是个有效标识符，你可以用它来命名一个类。<code>Nil</code>代表一个空的list，<code>scala.::</code>则代表非空的list。</p></blockquote><p>可变集合大多数情况用于添加和删除元素，但不可变集合是不会被改变的，但可以通过创建新的实例实现，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val oldList = List(1, 2)</span></span><br><span class="line">oldList: List[Int] = List(1, 2)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val newList = 3 :: oldList</span></span><br><span class="line">newList: List[Int] = List(3, 1, 2)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> oldList</span></span><br><span class="line">res45: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure><p>上述例子中，<code>::</code>用于创建一个新的实例并将元素添加的list的前面，如果要放到最后，可以使用<code>:+</code>方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val newList = oldList :+ 3</span></span><br><span class="line">newList: List[Int] = List(1, 2, 3)</span><br></pre></td></tr></table></figure><p>Scala中提供了一个特殊的对象<code>Nil</code>用于表示空List，因此，你可以用它创建一个空列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val myList = <span class="string">&quot;This&quot;</span> :: <span class="string">&quot;is&quot;</span> :: <span class="string">&quot;immutable&quot;</span> :: Nil</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure><p>在Scala中，若要删除一个元素，可以使用<code>-</code>方法，但是它是过时的。取而代之的是使用<code>filterNot</code>方法，该方法提供一个断言(predicate)，然后根据断言选择出所有不符合的元素并放置到新的实例里面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val afterDelete = newList.filterNot(_ == 3)</span></span><br><span class="line">afterDelete: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure><p>关于集合更多内容，将在本书第四章4.3节作着重介绍。</p><h2><span id="controlling-flow-with-loops-and-ifs">Controlling flow with loops and ifs</span></h2><p>if~else流程控制语句和其他编程语言一样，if为true则执行if语句块，否则执行else语句块。不同的是，在Scala中所有语句都是表达式，而它的值取决于最后一个表达式的值。因此，声明一个值取决于某些条件，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val someValue = if(some condition) value1 else value2</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val useDefault = <span class="literal">false</span></span></span><br><span class="line">useDefault: Boolean = false</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val configFile = <span class="keyword">if</span>(useDefault) <span class="string">&quot;custom.txt&quot;</span> <span class="keyword">else</span> <span class="string">&quot;default.txt&quot;</span></span></span><br><span class="line">configFile: java.lang.String = default.txt</span><br></pre></td></tr></table></figure><p>在Java中可以使用<code>？</code>三元表达式，但在Scala中不支持，因为<code>？</code>表达式是多余的，你甚至可以用if~else组合更加复杂的表达式语句。<br>循环语句在Scala中全面支持，比如<code>while</code>循环、<code>do-while</code>循环，但这两个都比较独立，和Java以及C#的使用没有异样。在<br>Scala中真正比较有趣的是for循环。</p><h2><span id="for-comprehensions">For-comprehensions</span></h2><p>For-comprehensions 就像一把瑞士军刀一样，你可以用它做许多事情。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = <span class="keyword">new</span> java.io.<span class="type">File</span>(<span class="string">&quot;.&quot;</span>).listFiles</span><br><span class="line"><span class="keyword">for</span>(file &lt;- files) &#123;</span><br><span class="line"><span class="keyword">val</span> filename = file.getName</span><br><span class="line"><span class="keyword">if</span>(fileName.endsWith(<span class="string">&quot;.scala&quot;</span>)) println(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Java和C#不同是地方是<code>file &lt;- files</code>，在Scala中叫做生成器(generator)，生成器的工作就是用于迭代，箭头右边的表示集合。用Java写则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(File file: files) &#123;</span><br><span class="line">String filename = file.getName();</span><br><span class="line"><span class="keyword">if</span>(filename.endsWith(<span class="string">&quot;.scala&quot;</span>)) System.out.println(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，你可以不用声明迭代对象的类型。另外一种写法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(</span><br><span class="line">  file &lt;- files;</span><br><span class="line">  fileName = file.getName</span><br><span class="line">  <span class="keyword">if</span> fileName.endsWith(<span class="string">&quot;.iml&quot;</span>)</span><br><span class="line">) println(file)</span><br></pre></td></tr></table></figure><p>不同的是，在括号内的所有变量都是val类型的，因此它们不能被修改并减少代码的副作用。<br>你也可以声明多个生成器(generator)，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val aList = List(1, 2, 3)</span></span><br><span class="line">aList: List[Int] = List(1, 2, 3)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val bList = List(4, 5, 6)</span></span><br><span class="line">bList: List[Int] = List(4, 5, 6)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; println(a + b)</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>实际上这是两层循环，即当a=1时，对b=4，5，6进行迭代，依此类推。你也可以用小括号()代替中括号。</p><p>从for-comprehension中可以看出了Scala的两种特性。即命令式和函数式。上面例子即为命令式，这种模式中容许语句反复运行数次而不返回值，直到某些条件改变。另一种命令式(functional form)也就序列解析(sequence comprehension)，在这种模式中，更偏向于使用值而不是执行表达式语句，并且不返回值。如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield a + b</span></span><br><span class="line">res27: List[Int] = List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span><br><span class="line">为了取代输出一个值，Scala中使用yield关键字代替返回的值，因此当你实际需要输出时，替换yield操作</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val result = <span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield a + b</span></span><br><span class="line">result: List[Int] = List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span>(r &lt;- result) println(r)</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>看起来函数式比命令式要累赘，但是想想。你已经将计算（本例为两个数相加）和使用（输出结果）进行了分离，这提高了代码复用和函数的组合能力，这就是函数式编程的一个好处。例如下面是for-yield复用的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val xmlNode = &lt;result&gt;&#123;result.mkString(<span class="string">&quot;,&quot;</span>)&#125;&lt;/result&gt;</span></span><br><span class="line">xmlNode: scala.xml.Elem = &lt;result&gt;5,6,7,6,7,8,7,8,9&lt;/result&gt;</span><br></pre></td></tr></table></figure><p>mkString是定义在<code>scala.collection.immutable.List</code>中的一个方法，但是如果在表达中直接输出结果会怎样？显然这不好实现。记住，所有东西在Scala中都是表达式，并且都有一个返回值。例如将代码改为如下仍然可以获得一个返回值，但是返回的是一个空的集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield &#123; println(a+b)&#125;</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">res32: List[Unit] = List((), (), (), (), (), (), (), (), ())</span><br></pre></td></tr></table></figure><p>因为yield 后面跟着的是println，println返回值类型是unit，即相当于Java中的void。</p><h2><span id="pattern-matching">Pattern Matching</span></h2><p>模式匹配属于Scala函数式编程中的一个概念部分。模式匹配跟Java中的switch case类似。如下列出模式匹配在Scala和Java中的实现<br>-一般匹配模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordinal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ordinal(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ordinal</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;1st&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;2nd&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;3rd&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;4th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;5th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: System.out.println(<span class="string">&quot;6th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: System.out.println(<span class="string">&quot;7th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: System.out.println(<span class="string">&quot;8th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: System.out.println(<span class="string">&quot;9th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: System.out.println(<span class="string">&quot;10th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : System.out.println(<span class="string">&quot;Cannot do beyond 10&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala中实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ordinal(args(<span class="number">0</span>).toInt)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ordinal</span></span>(number:<span class="type">Int</span>) = number <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">&quot;1st&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> =&gt; println(<span class="string">&quot;2nd&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; println(<span class="string">&quot;3rd&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span> =&gt; println(<span class="string">&quot;4th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span> =&gt; println(<span class="string">&quot;5th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> =&gt; println(<span class="string">&quot;6th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span> =&gt; println(<span class="string">&quot;7th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span> =&gt; println(<span class="string">&quot;8th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span> =&gt; println(<span class="string">&quot;9th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span> =&gt; println(<span class="string">&quot;10th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;Cannot do beyond 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Java不同的是，你不用声明main方法入口，不用使用break语句，因为在Scala的case中不会跳转到其它语句上，default值则使用_占位符匹配所有。因为Scala支持脚本，因此在终端输入运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala Ordinal.scala &lt;your input&gt;</span><br></pre></td></tr></table></figure><p>在Scala中，<code>case _</code>是可选的，移除后如果不匹配，则Scala会提示错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> 2 match &#123; <span class="keyword">case</span> 1 =&gt; <span class="string">&quot;One&quot;</span> &#125;</span></span><br><span class="line">scala.MatchError: 2</span><br><span class="line">at .&lt;init&gt;(&lt;console&gt;:5)</span><br><span class="line">at .&lt;clinit&gt;(&lt;console&gt;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这点和Java的default不同，Java中去掉default后，如果不匹配，不会抛出任何信息，因为Java中这不算是异常。</p><h5><span id="类型匹配">类型匹配</span></h5><p>Java中的switch case只能用于断言或枚举，而在Scala中，你可以匹配字符串，值，类型，变量，常量和构造器。更多模式匹配的概念会在下一章介绍，特别是构造器的匹配。下面是Scala模式匹配的一个例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printType</span></span>(obj: <span class="type">AnyRef</span>) = obj <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt; println(<span class="string">&quot;This is string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> l: <span class="type">List</span>[_] =&gt; println(<span class="string">&quot;This is List&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> a: <span class="type">Array</span>[_] =&gt; println(<span class="string">&quot;This is an array&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> d: java.util.<span class="type">Date</span> =&gt; println(<span class="string">&quot;This is a date&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中用于匹配类型，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> printType(<span class="string">&quot;Hello&quot;</span>)</span></span><br><span class="line">This is string</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> printType(List(1, 2, 3))</span></span><br><span class="line">This is List</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> printType(new Array[String](2))</span></span><br><span class="line">This is an array</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> printType(new java.util.Date())</span></span><br><span class="line">This is a date</span><br></pre></td></tr></table></figure><h5><span id="中辍操作匹配插入操作匹配">中辍操作匹配（插入操作匹配）</span></h5><p>更为强大的是Scala中支持中辍操作匹配，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> List(1, 2, 3, 4) match &#123;</span></span><br><span class="line">case f :: s :: rest =&gt; List(f, s)</span><br><span class="line">case _ =&gt; Nil</span><br><span class="line">&#125;</span><br><span class="line">res7: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure><p>上面例子中表示要求list元素匹配<code>f::ss::rest</code>并输出<code>f::ss</code>，满足这种匹配的结果有<code>1::2::3，4</code>，则输出<code>f::ss</code>结果就是<code>1，2</code>。</p><h5><span id="case增强">case增强</span></h5><p>Scala允许你在case语句中使用扩展</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeMatcher</span></span>(num:<span class="type">Int</span>) = num <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> within10 <span class="keyword">if</span> within10 &lt;= <span class="number">10</span> =&gt; println(<span class="string">&quot;with in 0 to 10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> within100 <span class="keyword">if</span> within100 &lt;= <span class="number">100</span> =&gt; println(<span class="string">&quot;with in 11 to 100&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> beyond100 <span class="keyword">if</span> beyond100 &lt; <span class="type">Integer</span>.<span class="type">MAX_VALUE</span> =&gt; println(<span class="string">&quot;beyond 100&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面这些功能后，我们对原来的例子进行改进</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> suffixes = <span class="type">List</span>(<span class="string">&quot;th&quot;</span>, <span class="string">&quot;st&quot;</span>, <span class="string">&quot;nd&quot;</span>, <span class="string">&quot;rd&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>,<span class="string">&quot;th&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordinal</span></span>(number:<span class="type">Int</span>) = number <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tenTo20 <span class="keyword">if</span> <span class="number">10</span> to <span class="number">20</span> contains tenTo20 =&gt; number + <span class="string">&quot;th&quot;</span></span><br><span class="line"><span class="keyword">case</span> rest =&gt; rest + suffixes(number % <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处调用了RichInt的to方法，该方法创建了一个范围对象(scala.collection.immutable<br>.Inclusive)，该对象包含一个contains方法用于判断返回。最后一个表达式将不在10到20的变量映射到rest上。这叫做 可变模式匹配。你可以通过下标访问list中的特定元素。</p><h2><span id="exception-handling">Exception handling</span></h2><p>前面的breakable例子初步接触了异常处理。Scala中的异常处理和Java有些许的不同。Scala支持单一的try/catch语句块，在这个单一catch语句块里面你可以使用模式匹配来捕获异常。实际上catch语句块就是匹配语句块，因此前面你所学到的模式匹配技术都可以用到catch语句块中。如修改rangeMatcher为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeMatcher</span></span>(num:<span class="type">Int</span>) = num <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> within10 <span class="keyword">if</span> within10 &lt;= <span class="number">10</span> =&gt; println(<span class="string">&quot;with in 0 to 10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> within100 <span class="keyword">if</span> within100 &lt;= <span class="number">100</span> =&gt; println(<span class="string">&quot;with in 11 to 100&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;Only values between 0 and 100 are allowed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，将其包含到try/catch语句中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> try &#123;</span></span><br><span class="line">rangeMatcher1(1000)</span><br><span class="line">&#125; catch &#123; case e: IllegalArgumentException =&gt; e.getMessage &#125;</span><br><span class="line">res19: Any = Only values between 0 and 100 are allowed</span><br></pre></td></tr></table></figure><p>Scala中没有类型检测的概念，所有异常都是未检测的。这是非常强大和灵活的，因为对于编程人员，你可以决定是否需要抛出异常，尽管Scala异常处理被实现得非常不一样，但行为机制和Java是一模一样的，通过不进行异常检测，是的Scala可以更容易地和Java现有的框架进行相互操作。你会在本书各处看到Scala异常处理的例子。</p><h2><span id="command-line-rest-client-building-a-working-example">Command-line REST client: building a working example</span></h2><h4><span id="什么是rest">什么是REST?</span></h4><p>REST是(REpresentational State Transfer)的缩写，意即表述性状态转移。它是分布式超媒体系统(如WWW)的软件架构风格。<br>系统遵循如下REST原则的称为RESTful：</p><p>①Application state and functionality are divided into resources.<br>应用的状态和功能被分成资源。</p><p>②Every resource is uniquely addressable using a universal syntax.<br>任何一个资源都有唯一一个访问入口，可使用一般语法访问。</p><p>③All resources share a uniform interface for transfer of state between client and resource, consisting of well-defined operations (GET, POST, PUT, DELETE, OPTIONS, and so on, for RESTful web services) and content types.<br>所有资源共享标准接口用于在客户~资源之间进行状态转换，持有良好的操作和上下文类型。</p><p>④A protocol that’s client/server, stateless cacheable, and layered.<br>协议是C/S，无状态的，缓存的，分层的。</p><h3><span id="introducing-httpclient-library">Introducing HttpClient library</span></h3><p>HttpClient<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>是Apache的一个框架，它是一个客户端HTTP传输库。作用是用于发送和接口HTTP消息。它不是浏览器，也不执行与HTTP传输无关的事情，诸如JavaScript解析或猜测客户content-type内容等。HttpClient的主要工作就是执行HTTP方法。HttpClient会接受用户的请求对象(如HttpPost或HttpGet)，然后将请求发送到目标服务器并返回响应对象或者抛出异常。<br>HttpClient封装了每个HTTP方法类型在一个对象中，这些方法在org.apache.http.client.methods中提供。本例将使用4中请求类型 GET, POST, DELETE, 和 OPTIONS。HttpClient默认提供的client已经足够我们使用了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> httpDelete = <span class="keyword">new</span> <span class="type">HttpDelete</span>(url)</span><br><span class="line"><span class="keyword">val</span> httpResponse = <span class="keyword">new</span> <span class="type">DefaultHttpClient</span>().execute(httpDelete)</span><br></pre></td></tr></table></figure><p>根据HTTP规范，HTTP的POST方法有点不同，POST方法和PUT方法是实体封装的。<br>如果要在脚本中使用HttpClient，需要导入相应的包，Scala和Java一样，使用import关键字导入，不同的是Scala是使用_表示包中的所有类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.utils._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.params._</span><br></pre></td></tr></table></figure><p>关于import的更多用法，将在下一章介绍</p><h2><span id="building-the-client-step-by-step">Building the client, step by step</span></h2><p>这部分为本章所有知识点用例，请参考项目代码RestClient.scala，并尝试动手调试。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.scala.chapter2.o</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile in sbt</span></span><br><span class="line"><span class="comment">// Run in sbt&gt;run get https://raw.githubusercontent.com/nraychaudhuri/scalainaction/master/chap02/breakable.scala</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The command line in sbt is </span></span><br><span class="line"><span class="comment">// &gt;run (post | get | delete | options) -d &lt;request parameters comma separated -h &lt;headers comma separated&gt; &lt;url&gt;</span></span><br><span class="line"><span class="comment">// at minimum you should specify action(post, get, delete, options) and url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.cert.<span class="type">X509Certificate</span></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.<span class="type">UrlEncodedFormEntity</span></span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.scheme.<span class="type">Scheme</span></span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.&#123;<span class="type">SSLSocketFactory</span>, <span class="type">X509HostnameVerifier</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RestClient</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*解析参数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parseArgs</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nameValuePair</span></span>(paramName: <span class="type">String</span>) = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">values</span></span>(commaSeperatedValues: <span class="type">String</span>) = commaSeperatedValues.split(<span class="string">&quot;,&quot;</span>).toList</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> index = args.indexWhere(_ == paramName)</span><br><span class="line">      (paramName, <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="type">Nil</span> <span class="keyword">else</span> values(args(index + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Map</span>(nameValuePair(<span class="string">&quot;-d&quot;</span>), nameValuePair(<span class="string">&quot;-h&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">splitByEqual</span></span>(nameValue: <span class="type">String</span>): <span class="type">Array</span>[<span class="type">String</span>] = nameValue.split(&#x27;=&#x27;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">headers</span> </span>= <span class="keyword">for</span> (nameValue &lt;- params(<span class="string">&quot;-h&quot;</span>)) <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokens</span> </span>= splitByEqual(nameValue)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BasicHeader</span>(tokens(<span class="number">0</span>), tokens(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">formEntity</span> </span>= &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toJavaList</span></span>(scalaList: <span class="type">List</span>[<span class="type">BasicNameValuePair</span>]) = &#123;</span><br><span class="line">      java.util.<span class="type">Arrays</span>.asList(scalaList.toArray: _*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">formParams</span> </span>= <span class="keyword">for</span> (nameValue &lt;- params(<span class="string">&quot;-d&quot;</span>)) <span class="keyword">yield</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">tokens</span> </span>= splitByEqual(nameValue)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">BasicNameValuePair</span>(tokens(<span class="number">0</span>), tokens(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">formEntity</span> </span>= <span class="keyword">new</span> <span class="type">UrlEncodedFormEntity</span>(toJavaList(formParams), <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    formEntity</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handlePostRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httppost = <span class="keyword">new</span> <span class="type">HttpPost</span>(url)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httppost.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    httppost.setEntity(formEntity)</span><br><span class="line">    <span class="keyword">val</span> responseBody = httpClient.execute(httppost, <span class="keyword">new</span> <span class="type">BasicResponseHandler</span>())</span><br><span class="line">    println(responseBody)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleGetRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> query = params(<span class="string">&quot;-d&quot;</span>).mkString(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> httpget = <span class="keyword">new</span> <span class="type">HttpGet</span>(<span class="string">s&quot;<span class="subst">$url</span>?<span class="subst">$query</span>&quot;</span>)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httpget.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> responseBody = httpClient.execute(httpget, <span class="keyword">new</span> <span class="type">BasicResponseHandler</span>())</span><br><span class="line">    println(responseBody)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleDeleteRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httpDelete = <span class="keyword">new</span> <span class="type">HttpDelete</span>(url)</span><br><span class="line">    <span class="keyword">val</span> httpResponse = httpClient.execute(httpDelete)</span><br><span class="line">    println(httpResponse.getStatusLine)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleOptionsRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httpOptions = <span class="keyword">new</span> <span class="type">HttpOptions</span>(url)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httpOptions.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> httpResponse = httpClient.execute(httpOptions)</span><br><span class="line">    println(httpOptions.getAllowedMethods(httpResponse))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*require 函数用于抛出异常*/</span></span><br><span class="line">  require(args.size &gt;= <span class="number">2</span>, <span class="string">&quot;at minimum you should specify action(post, get, delete, options) and url&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> command = args.head</span><br><span class="line">  <span class="keyword">val</span> params = parseArgs(args)</span><br><span class="line">  <span class="keyword">val</span> url = args.last</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** SNI(Server Name Indication) 问题</span></span><br><span class="line"><span class="comment">    * 针对https服务器会使用SNI选择证书进行发送，但是本例不支持SNI(如一些Android系统)，在SSL/TLS握手期间，</span></span><br><span class="line"><span class="comment">    * 服务器无法根据客户端选择哪种SNI证书发送，因此需要让其验证时为True</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">val</span> xtm = <span class="keyword">new</span> <span class="type">X509TrustManager</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getAcceptedIssuers</span></span>: <span class="type">Array</span>[<span class="type">X509Certificate</span>] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkClientTrusted</span></span>(p1: <span class="type">Array</span>[<span class="type">X509Certificate</span>], p2: <span class="type">String</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkServerTrusted</span></span>(p1: <span class="type">Array</span>[<span class="type">X509Certificate</span>], p2: <span class="type">String</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> hostnameVerifier = <span class="keyword">new</span> <span class="type">X509HostnameVerifier</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">SSLSocket</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">X509Certificate</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">Array</span>[<span class="type">String</span>], p3: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">SSLSession</span>): <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//TLS1.0与SSL3.0基本上没有太大的差别，可粗略理解为TLS是SSL的继承者，但它们使用的是相同的SSLContext</span></span><br><span class="line">  <span class="keyword">val</span> ctx = <span class="type">SSLContext</span>.getInstance(<span class="string">&quot;TLS&quot;</span>)</span><br><span class="line">  <span class="comment">//使用TrustManager来初始化该上下文，TrustManager只是被SSL的Socket所使用</span></span><br><span class="line">  ctx.init(<span class="literal">null</span>, <span class="type">Array</span>(xtm), <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">//创建SSLSocketFactory</span></span><br><span class="line">  <span class="keyword">var</span> socketFactory = <span class="keyword">new</span> <span class="type">SSLSocketFactory</span>(ctx)</span><br><span class="line">  socketFactory.setHostnameVerifier(hostnameVerifier)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> httpClient = <span class="keyword">new</span> <span class="type">DefaultHttpClient</span>()</span><br><span class="line">  httpClient.getConnectionManager.getSchemeRegistry</span><br><span class="line">    .register(<span class="keyword">new</span> <span class="type">Scheme</span>(<span class="string">&quot;https&quot;</span>, socketFactory, <span class="number">443</span>))</span><br><span class="line"></span><br><span class="line">  command <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;post&quot;</span> =&gt; handlePostRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;get&quot;</span> =&gt; handleGetRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span> =&gt; handleDeleteRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;options&quot;</span> =&gt; handleOptionsRequest()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="summary">Summary</span></h2><p>本章涵盖了Scala的大部分基础概念，如数据类型、变量和函数，以及如何安装和配置Scala。更重要的是，你学会了如何定义函数，Scala语句块，函数式语言的概念，模式匹配和for-comprehension。你更学习了如何通过模式匹配技术来定义异常。同时本章也介绍了List和Array集合的使用以及如何编写Scala脚本。本章还介绍了REPL编程环境，并且REPL将通篇出现。本章最后还介绍了运用所学知识点编写REST程序代码。下一章开始，我们将着重介绍Scala类和对象。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/32jw">Type inference</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/H4ip">Daniel Spiewak, posted at Code Commit, “What is Hindley-Milner? (and why is it cool?)”</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="http://mng.bz/Q4Bf">HttpClient Overview</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：Scala基础</title>
      <link href="/2016/10/27/scala/01-scala-conception/"/>
      <url>/2016/10/27/scala/01-scala-conception/</url>
      
        <content type="html"><![CDATA[<p>Scala是一门多用途的(general-purpose)编程语言，运行在Java虚拟机(JVM)和.NET平台。基于这种平台的编程语言，每个开发者今天面临的问题是：下一代要学习的编程语言是什么？哪种语言适用主流开发？其中的编程语言包括<code>Groovy</code>，<code>Ruby</code>，<code>Clojure</code>，<code>Erlang</code>和<code>F#</code>，为什么应该学习Scala？</p><p>学习一门新语言仅仅是一个开始。要成为一个卓越和富有成效的开发者，你应该熟悉系统基础结构的所有开关(toggles)和线框(gizmos)。</p><p>在阐述为什么应该学习Scala之前，先来理解下什么是Scala。它是一门富特性(feature-rich)语言，被广泛用于多类型应用中，构建社交网络大型消息层应用，如Twitter<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 。以及应用构建工具如SBT<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (Simple Build Tool)。基于它的伸缩性(scala-bility)，这门语言名字取名<code>scala</code>。</p><span id="more"></span><p>本章将探索该语言的高级特性，并和你熟悉的编程语言进行对比。这将帮助你选择Scala作为下一门编程语言。</p><p>Scala是为数不多的同时支持面向对象(object-oriented)和函数式(functional)语言特性的一门编程语言。这种强大之处，使得你在解决编程问题时有更多的方案。假设你的应用正在寻找一门语言，用来提高生产效率，同时对已有的Java代码进行重用(reuse)，Scala的Java集成会是很好的选择，因为Scala能够运行在JVM平台上。</p><p>下面探索Scala的更多内容。</p><h2><span id="什么是scala">什么是Scala</span></h2><p>Scala是一门多用途的编程语言，以简明的、优雅的和类型安全的(type-safe)方式设计，以表述通用的编程模式。它平稳地集成了面向对象和函数式编程语言的特性，能被编程者高效地使用。Martin Odersky(Scala创建者)和他的团队，从2001年开始，在EPFL大学的编程方法实验室，从事Scala的开发。至2004年1月在JVM平台首次发布，继而数月后公布了其.NET平台版本。</p><p>尽管Scala在语言领域比较新颖，它正获得编程社区的支持，并日渐成长。Scala是一门特性丰富的语言，下面让我们作进一步的深入了解。</p><p><strong>SCALA ON .NET</strong> 目前为止，Scala对.NET的支持并不稳定。根据Scala语言网站<a href="https://www.scala-lang.org">(www.scala-lang.org)</a>，当前的Scala发行版可以为.NET平台编译部分程序，但一些库却不支持。主要困难是Scala程序重度使用Java JDK，JDK不能在.NET平台适用。要克服这个问题，当前的策略是使用<a href="https://www.ikvm.net">IKVM</a>，它可以让Java程序转换为MSIL和.NET库<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 。本章主要介绍JVM上的Scala，示例代码仅在JVM上测试。</p><h3><span id="scala作为一门面向对象语言">Scala作为一门面向对象语言</span></h3><p>诸如<code>Java</code>、<code>C#</code>、和<code>Ruby</code>这些流行的编程语言，都包含有令大多数编程者接受的面向对象(OOP)特性。OOP，顾名思义，是一个对象编程的范式。把对象看作是包含了字段和方法的数据结构。使用类和对象给应用提供了结构。它易于组合，因此你可以从小的构建块，创建成大型应用。目前有许多OOP语言，但仅仅一小部分适合定义为纯面向对象语言。</p><p>怎样才算纯的面向对象语言？尽管确切定义不尽相同，大部分纯面向对象语言应该有以下这些特点：</p><ul><li>封装/信息隐藏。</li><li>继承。</li><li>多态性/动态绑定。</li><li>所有预定义类型都是对象。</li><li>所有操作通过向对象发送消息执行。</li><li>所有用户定义类型都是对象。</li></ul><p>Scala支持所有这些特性，并使用了一个和Smalltalk<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> (一门纯面向对象语言，由Alan Kay在1980创建)类似的纯面向对象模型——每个值都是对象，每个操作都是消息发送。如下是一个简单表达式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在Scala的编译器中，这个表达式被解析为<code>1.+(2)</code>。意味着你调用了整型对象(这里是 <code>1</code>)的一个 <code>+</code> 操作，并将 <code>2</code>作为参数传递给该操作。Scala把操作符看作常规标识符。在Scala中，一个标识符既可以是由字母和数字开头的一系列字符组成，也可以是操作符。除了 <code>+</code>，也可能定义如 <code>&lt;=</code>，<code>-</code>，或<code>*</code>之类的方法。</p><p>在纯面向对象特性的基础上，Scala在OOP领域作了一些创新：</p><ul><li>模块化混入组成(Modular mixin composition)：和Java接口和抽象类一样，你可以定义约定使用一个或多个特质(traits)，以实现它的某些或者全部方法。</li><li>自类型(Self-type)：不取决于它所混入(minxed into)类的任何方法或字段，该Scala特性称为 <code>self-type</code>。</li><li>类型抽象(Type abstraction)：编程语言中有两种主要的抽象形式，参数化和抽象成员。Scala的类型和值，统一支持这两种抽象形式。</li></ul><p><strong>DEFINITION</strong> 混入类指一个类提供某些功能，并由子类继承，该类不能实例化自身。一个混入类可以看作是一个带有实现方法的接口。</p><h3><span id="scala作为一门函数式语言">Scala作为一门函数式语言</span></h3><p>函数式编程，是一个将计算看作是规避了状态和可变数据的数学函数求值的编程范式。</p><blockquote><p><strong>可变、不可变数据</strong></p><p>一个对象称为可变，指当你有该对象的一个引用，以及改变该对象的内容。而不可变对象，指对象的内容不能被修改。</p><p>可以简单地创建一个可变对象；你需要做的仅仅是提供对象的可变状态访问。可变对象的缺陷是随改变而改变。在一个多线程环境中，你需要lock/synchronization机制来避免并发访问。对于不可变对象，则不需要担心这里问题的发生。</p></blockquote><p>函数式编程，更多的是一个数学的世界观，程序由函数组成，接收某些输入，产生值或其它函数。函数式编程的构建块，既不是对象，也不是过程，而是函数。函数式编程的最简单定义，就是用函数编程。</p><p>这里着重理解什么是 <strong>函数</strong> 。一个函数指定义域(domain)的每个值，都能有相应上域(codomain)与之映射。输入集合的每一个元素，都有唯一一个输出集合元素与之对应。</p><p><img src="/img/scala-in-action/chapter1/Figure_01_01.png" alt="Figure 1.1"></p><blockquote><p><strong>数学函数是如何关联到编程中的函数</strong><br>在数学，一个函数，是指一个定义域集合元素，到上域集合元素的映射。根据定义，每一个定义域的元素，都有唯一一个上域元素与之对应。例如，<code>f(x) = y</code> 可以被解析为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x has a relationship f <span class="keyword">with</span> y or x maps to y via f</span><br></pre></td></tr></table></figure><p>如果你编写你函数，心里定义的是数学函数，那么对于一个给定的输入，不论输入多少次，同一个函数总是得到相同的结果。</p><p>让我们看看下面一个程序。你有下面的一个函数，它接收两个输入参数，生成它们的总和：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addFunction</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = a + b</span><br></pre></td></tr></table></figure><p>对于一个给定的输入集合 <code>(2, 3)</code>，该函数总是返回 <code>5</code>，但下面函数currentTime却不适用该定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">currentTime</span></span>(timezone: <span class="type">TimeZone</span>) = </span><br><span class="line"><span class="type">Calendar</span>.getInstance(timezone).getTime</span><br></pre></td></tr></table></figure><p>对于给定的timezone GMT，它总是返回不同的结果。</p><p>一个数学函数的一个有趣的特点是 <strong>引用透明(referential transparency)</strong>，意识是，一个表达式可以由它的结果所代替。在这里的<code>addFunction</code>，我们可以以输出值代替它的所有调用，并且程序的行为不会发生任何改变。</p></blockquote><p>函数式编程的另一方面是，他不会有副作用或可变性。不带有可变性和副作用的好处是，程序更易于理解，测试更接近本地，因为它不带外部作用。另一个更大的好处在于，更容易进行函数式的并发编程。并发编程不再是问题，因为不会有进程或线程间的相互协调的改变。</p><blockquote><p><strong>副作用</strong></p><p>如果一个函数或表达式被认为有副作用，除了产生一个值，它还修改某些状态，或有一个显而易见的外部交互的方法调用，或在方法之外。一个函数可能修改一个全局或一个静态的变量，修改它的参数，抛出一个异常，编写数据到磁盘或文件，读取数据，调用其它函数，都会有副作用。在已有的副作用中，一个程序的行为，取决于它的执行历史。</p></blockquote><blockquote><p><strong>Scala是一门纯函数式语言吗？</strong></p><p>简单来说，Scala不是一门纯函数式语言。在纯函数式语言中，修改被执行时，变量以数学角度被使用，并标识为对不可变的和持久化对象的引用。纯函数的一个明显例子就是Haskell。</p><p>Scala支持两种变量类型：单赋值变量(通常叫值)，在它们的生命周期不改变它们的值，直到指向一个可变状态或重新分配到其它对象。尽管你应该尽可能地使用不可变对象，Scala对此并没有提供任何约束。最好的做法是，默认在不需要的情况下使用val来声明变量。</p></blockquote><p>函数式编程语言，至少支持下面这些特性：</p><ul><li>高阶函数(Higher-order functions)</li><li>词法闭包(Lexical closures)</li><li>模式匹配(Pattern matching)</li><li>单赋值(Single assignment)</li><li>惰性执行(Lazy evaluation)</li><li>类型接口(Type inference)</li><li>尾递归/尾调用(Tail call optimization)</li><li>链推导(List comprehensions)</li><li>单体效应(Monadic effects)</li></ul><p>Scala支持大部分函数式语言特性，Scala作为一门函数式语言，Scala的函数是 <strong>第一类值(first-class values)</strong>。这意味着，Scala的所有函数都是一个值，你可以将它们作为参数进行传递，并从其它函数得到返回。在Scala你可以声明一个函数 <code>(x: Int) =&gt; x + 1</code> 到一个 <code>val inc</code> 并进行调用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> inc = (x : <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line">inc(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里的val表示一个单赋值变量(single assignment variable)，类似Java的<code>final variables</code>，该值 <code>inc</code>指派后不能被修改，输出结果为 <code>2</code>。</p><p>下面例子将看到，它是如何作为函数的参数进行传递，并得到结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map((x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里你传递一个递增函数到另外一个函数<code>map</code>，输出通过调用<code>map</code>函数得到结果 <code>List(2,3,4)</code>。从结果可以看出，<code>map</code> 调用作用于集合中的每一个元素。这将在后续高阶函数中作介绍。</p><h3><span id="scala作为一门多范式语言">Scala作为一门多范式语言</span></h3><p>Scala是一门多范式语言，它同时支持函数式和OOP编程。Scala是JVM上第一个统一了函数式编程和OOP静态类型的编程语言。但问题是，为什么需要多于一个的编程风格？</p><p>多范式编程的主要目的，是希望给编程者提供更多的解决选项，以及选择最佳的方案处理问题。函数式编程使得能够从简单部分构建，OOP适合继承复杂系统，以及对其进行扩展。</p><p>根据研究员Timothy Budd<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> 报告显示：“研究表明，个人的编程技能，更多的取决于其掌握了多少种编程风格，而不是其工作经验”。</p><p>Scala是如何结合这两种不同的，甚至相反的编程范式到编程语言中的？例如OOP，构建块是对象，而在函数式编程中，构建块则是函数。在Scala中，函数被看作是对象。</p><p><strong>函数作为对象</strong><br>在Scala中组合函数式编程和面向对象编程，并把函数看作是对象。</p><p>Scala作为一门函数式语言，把函数看作是值，上面看到，我们可以将函数赋值到变量中。因为Scala中所有值(value)都是对象，因此函数都是对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map((x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>你将函数 <code>(x:Int) =&gt; x + 1</code> 作为参数传递给方法 <code>map</code>。当编译器遇到该调用时，它将该函数的参数替换为一个对象，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]&#123; <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x:<span class="type">Int</span>): <span class="type">Int</span> = x + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>这里发生了什么？暂时不对此深入，当Scala编译器遇到函数带一个参数的函数时，它会将其替换为一个<code>scala.Function1</code>的一个实例，改实例实现了一个<code>apply</code>方法。如果你仔细观察，会发现函数的主体会转换到 <code>apply</code>方法。同样地，Scala包含有多于一个参数的<code>Function</code>对象。</p><p>随着多范式(multi-paradigm)编程的逐渐普及，函数式和面向对象编程的界线渐渐淡去。我们将继续探索Scala，你将看到如何掺合函数式编程和OOP来解决问题。</p><h3><span id="scala作为一门可伸缩的-可扩展的语言">Scala作为一门可伸缩的、可扩展的语言</span></h3><p>Scala是 <code>scalable language</code><sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> 的代表。Scala的一个设计目的是带需求地增量。Scala也适用于脚本化，对于大型应用也一样。Scala的组件抽象，语法简洁，以及支持面向对象和函数式编程，使得该语言可伸缩。</p><p>Scala提供了独特的结合机制，以库的形式添加新的语言结构。你可以使用任何方法作为一个中缀或后缀操作，并且Scala的闭包可以作为“名传递”参数，传递给其它函数。这种特性使得开发者更容易定义新的结构。</p><p>让我们创建一个新的循环结构<code>loopTill</code>，它和<code>while</code>循环类似。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loopTill</span></span>(cond: =&gt; <span class="type">Boolean</span>)(body: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (cond) &#123;</span><br><span class="line">    body</span><br><span class="line">    loopTill(cond)(body)    <span class="comment">// 尾递归</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">loopTill(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  print(<span class="string">f&quot;<span class="subst">$i</span> &quot;</span>)</span><br><span class="line">  i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个新 <code>loopTill</code> 结构，它由接收两个参数的 <code>loopTill</code> 方法声明。第一个参数是条件 <code>(i &gt; 0)</code> ，第二个参数是一个闭包。只要条件是 <code>true</code>，函数<code>loopTill</code> 将执行闭包内容。</p><blockquote><p><strong>定义</strong><br>在计算机科学中，闭包(Closure)是词法闭包(Lexical Closure)的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。<br>因为闭包只有在被调用的时候才执行，即“惰性求值”，所以它可以被用来定义控制结构。典型实现方式是定义一个特殊的数据结构，保存了函数地址指针与闭包创建时的函数的词法环境表示。使用函数调用栈的语言实现闭包比较困难，因而这也说明了为什么大多数实现闭包的语言是基于垃圾收集机制。</p></blockquote><p>在loopTill例子中，自由变量为<code>i</code>，尽管它定义在闭包的外面，你仍然可以将其在闭包内部使用。在loopTill中，第二个参数是一个闭包，在Scala中表示一个Scala.Function0的对象类型。</p><p>使用库来扩展一门语言，比起扩展语言自身要简单。因为你不需要考虑后台兼容性问题。例如，Scala actor提供一个库作为实现，该库不属于Scala语言。当第一个actor不能很好容纳，可以选择另外一个版本，而不用改变Scala语言本身。</p><h3><span id="scala运行在jvm">Scala运行在JVM</span></h3><p>Java最好的不是语言本身，而是JVM。一个JVM是一块装置，HotSpot团队在几年间对此做了非常好的性能提升。成为一门JVM语言，Scala很好地集成到Java和它的系统中，包括工具、库、IDE。现在大部分IDE带有Scala插件，因此你可以在IDE内构建、运行和测试Scala引用。要学习Scala，你不必丢掉你在Java上的投资。相反，你可以重用以获得回利。</p><p>Scala编程成Java字节码，在字节码层面不能分出Java代码和Scala代码，因为它们是一样的。你可以使用Java类文件反汇编器<code>javap</code>，将Scala字节码反汇编成Java类。</p><p>在JVM上运行Scala的另一个优势是，它能驾驭所有类JVM的性能、开箱即用的稳定性。作为一门强静态类型语言，Scala程序运行和Java程序一样快。</p><p>所有这些特性将在后面陆续介绍，但问题仍然是——为什么选择Scala？</p><h2><span id="面临危机">面临危机</span></h2><p>一个著名的“Andy giveth, and Bill taketh away”现象，表明了无论处理器变得有多快，我们软件人员都能找到方法跟上它的速度。伴随着软件解决越来越复杂的问题，这种趁势将持续增长。关键问题是，处理器制造商将持续提升速度和处理能力，这种循环何时了结？</p><h3><span id="摩尔定律终结">摩尔定律终结</span></h3><p>根据摩尔定律，芯片上每平方英寸的晶体管(transistors)数量，每18个月翻1倍。但最终英特尔和其它CPU制造商对摩尔定律产生撞墙效应<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> ，取而代之的是多核处理器路线。好消息当然是处理器能够持续增长，并日渐强悍；不好的则是我们当前应用和编程环境需要面临多核处理器的挑战。</p><h3><span id="多核编程">多核编程</span></h3><p>我们应如何克服多核处理器这场革新？</p><p>并发。有了并发，我们可以编写软件来解决我们的大型的、分布式的、复杂的企业问题，使用CPU的吞吐量。谁不想使它们的应用有高效良好的性能？我们都需要。</p><p>少部分人曾做过并行和并发编程，但它仍不足以成为企业开发者的主流，或不常见。一个原因是并发编程自身有一系列的挑战性。在传统的基于线程的并发模型，程序的执行被分开到多个并行的运行任务(线程)中，每个任务的操作共享内存。这导致很难找到竞态条件(race conditions)，以及死锁(deadlock)问题会花费数周甚至数月时间来进行隔离、重现、修复。所有这些并发问题，不是线程方面的，根本原因是共享内存导致的。这种并发模型太难让开发者心领神会，我们需要一个更好的并发编程模型，以帮助开发者更容易地编写和维护并发问题。</p><p>对于并发，Scala采用了完全不同的方式：Actor 模型。一个actor是一个并行计算的数学模型，它封装了数据、代码、和它自己的线程控制，以及使用不可变(无副作用)的异步的消息传送技术。基础Actor架构依赖于一个非共享的策略，事实上它是轻量级的。它是Java线程所不能比拟的；它更像一个事件对象，获取调度计划，再由线程执行。Scala的Actor模型很好地处理了并发性问题。它的非共享架构，以及异步消息传送技术，使得它成为现有线程的一个很好的解决方案。</p><blockquote><p><strong>Actor模型的历史</strong></p><p>Actor模型最先由Carl Hewitt在1973年在他的文章“A Universal Modular ACTOR Formalism for Artificial Intelligen”提出，以及后来由Gul Agha增进 (“ACTORS: A Model of Concurrent Computation in Distributed Systems”)。</p><p>Erlang 是第一个实现了Actor模型的编程语言。Erlang是一门多用途的并发编程的动态类型语言。Erlang Actor模型在Ericsson、Facebook和Yahoo上获得成功后，它成为了处理并发问题的不二选择，以及后来Scala实现了它。在Scala，Actor在一个库实现，并让开发者继承。后面的章节内容将陆续介绍Scala actor的多种实现。</p></blockquote><p>传统地，多核编程比单核编程更复杂，它要求有平台特定的知识。同时也很难维护和管理这些基础代码。为了使并行编程变得容易，Scala提供了并行集合库实现了高级抽象，并隐藏了并行算法。例如，要并行地清算一个<code>List</code>中的每一个元素，你使用并行集合作如下处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).par.map(x =&gt; x * x)</span><br></pre></td></tr></table></figure><p>这里<code>.par</code>将<code>List</code>转换为一个并行集合，并使用并行集合的map方法。在幕后一个并行集合库将使用所有可用核，分叉线程(fork thread)执行map方法。并行集合库是Scala新增的库，它提供了大多数集合类型的并行版本。</p><h2><span id="从java过渡到scala">从Java过渡到Scala</span></h2><p>当时Java在1995年5月发布，并带来一些好的思想，例如平台独立(write once,run anywhere)，自动垃圾回收，以及OOP。Java使得开发者更容易实现面向对象编程，和C/C++相比，它更迅速进入了工业。</p><p>过去几年Java变得有些浮躁。每每引进新特性，都给编程者带来更多的引用代码。甚至小的程序由于注解，模版，和类型信息变得臃肿。Java开发者又总是寻找第三方库和工具来提高生产效率。但这是问题的解决方案吗？为什么不采用一种更高效的编程语言？</p><h3><span id="scala提高生产效率">Scala提高生产效率</span></h3><p>添加库和工具来解决生产效率问题，有时往往事与愿违，给应用添加了复杂性、降低了生产效率。这里不是说不要依赖库；你应当它是有意义的。但如果你构建的语言是一个从灵活性、可扩展性、可伸缩性逐渐成长过来的，你会选择它吗？</p><p>如今的开发者需求和以往不一样。在Web 2.0中，敏捷开发，灵活性和可扩展性的编程环境是重要的。开发者需要一门语言来衡量这类需求。如果你来自Java，那么Scala就是这么一门语言。它能使你高效，以及以最小的代码，做更多的事情，而不会有样板代码(boilerplate code)。</p><blockquote><p>在计算编程中，<em>样板代码</em>，指那些部分代码包含在很多地方，却仅带有很少的变动，甚至不变动。它是编程者间一个口语，通常表示编程者编写了大量的代码，却仅做了很少的工作。</p></blockquote><h3><span id="scala-doese-more-with-less-code">Scala doese more with less code</span></h3><p>要看Scala的简洁性，你需要深入到代码中。接下来两个例子，为查找给定字符串的大写字母，比较Java和Scala的不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasUpperCase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasUpperCase = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isUpperCase(s.charAt(i))) &#123;</span><br><span class="line">            hasUpperCase = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasUpperCase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码遍历每个字符串字符。当找到大写字母时，设置<code>hasUpperCase</code>为<code>true</code>并跳出循环。下面看看Scala怎样写这个。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hasUpperCase = name.exists(_.isUpper)</span><br></pre></td></tr></table></figure><p>在Scala中，你用一行代码就解决了该问题。尽管做了相同的工作，编程者不会再有编写样板代码。该函数中调用了<code>name</code>上的<code>exists</code>函数，并由一个谓语检验是否正确，该字符由 <code>_</code>表示。这证明了Scala语言的简洁性和可读性。现在再看看下面的清单，你创建了一个Java类Programmer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String language;</span><br><span class="line">    <span class="keyword">private</span> String favDrink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">(String name, String language)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.language = language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">getter/setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个带3个属性的POJO(plain old Java object)。Scala同样可以创建该类，只用一行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>(<span class="params">var name:<span class="type">String</span>,var language:<span class="type">String</span>,var favDrink:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>这里你创建了Scala的一个简单的类<code>Programmer</code>，有时也叫 <code>primary constructor</code>。是的，你可以在类声明内定义一个构造器。带<code>var</code>前缀的每个参数，Scala编译器遇到时，会为每个field生成一个getter和setter。这是隐式的吗？后续将作详细介绍。现在，很明显Scala可以以更少的代码，做更多的事情。你可能会争执说IDE可以自动生成这些样板代码，当然没问题。但即使这样，你也需要维护这些样板代码。</p><h2><span id="来自动态语言">来自动态语言</span></h2><p>很难发现时至今日，没有哪个开发者没有听说过Runby、Groovy或Python的。来自动态语言对静态语言的诉苦，最大的是，它们不帮助编程者提高生产效率，并强制开发者编写样板代码。动态类型语言和Java相比，最明显的是闭包和语言扩展随处可见。Scala对这个问题显然不同。</p><p>在比较静态类型语言和动态类型语言之前，先来看看Scala支持的闭包和混入(mixin)。下面列出了Ruby中如何统计给定文件的行数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">File.open <span class="string">&quot;someFile.txt&quot;</span> <span class="keyword">do</span> <span class="params">|file|</span></span><br><span class="line">file.each &#123; <span class="params">|line|</span> count += <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>你打开文件 someFile.txt，每行计数加1。很简单吧！下面列出了Scala的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> src = scala.io.<span class="type">Source</span>.fromFile(“someFile.txt”)</span><br><span class="line"><span class="keyword">val</span> count = src.getLines().map(x =&gt; <span class="number">1</span>).sum</span><br></pre></td></tr></table></figure><p>这看起来和Ruby很相像。你可以在Scala中有很多实现方式；这里使用 <code>map</code>方法来返回每行文件，使用<code>sum</code>方法来计算总数。</p><p>Scala支持组合某些 <code>traits</code>，它和部分实现的抽象类相似。例如，你可以创建集合的一个新类型，通过混入 <code>Iterable</code> 特质，以允许用户访问迭代地文本。约束仅需要实现一个迭代方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileAsIterable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iterator</span> </span>= scala.io.<span class="type">Source</span>.fromFile(<span class="string">&quot;someFile.txt&quot;</span>).getLines()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在混入了Scala的<code>Iterable</code>，你的新的<code>FileAsIterable</code>会成为一个Scala<code>Iterable</code>并支持<code>Iterable</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newIterator = <span class="keyword">new</span> <span class="type">FileAsIterable</span> <span class="keyword">with</span> <span class="type">Iterable</span>[<span class="type">String</span>]</span><br><span class="line">newIterator.foreach &#123; line =&gt; println(line) &#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>foreach</code>方法来迭代文件的每一行。</p><p>Scala版本2.10开始支持一个 <code>Dynamic</code><sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> 类型。使用这个特性，你可以在运行时中，动态地添加方法和字段到一个类型中。这和Ruby的<code>method_missing</code>特性很相似，它对于构建一个DSL(domain-specific language)语言很有帮助。例如，Scala map是一个key-value集合，如果你想要通过key访问关联的value，你可以这个：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> someMap = <span class="type">Map</span>(<span class="string">&quot;foo&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;bar&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line">someMap.get(<span class="string">&quot;foo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>someMap</code>是一个键值对集合，<code>someMap.get(&quot;foo&quot;)</code>将返回 1。使用<code>Dynamic</code>，我们可以轻松地通过key访问。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span> <span class="keyword">extends</span> <span class="title">Dynamic</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">selectDynamic</span></span>(fieldName: <span class="type">String</span>) = map.get(fieldName)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;foo&quot;</span> -&gt; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;bar&quot;</span> -&gt; <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> someMap = <span class="keyword">new</span> <span class="type">MyMap</span></span><br><span class="line">someMap.foo</span><br><span class="line">someMap.bar</span><br></pre></td></tr></table></figure><p>这里的神奇所在是<code>selectDynamic</code>方法。当Scala编译器检测到<code>foo</code>不是类型的一部分是，它不会马上放弃。如果类型是<code>Dynamic</code>的一个子类，并在<code>selectDynamic</code>方法找到并调用。如果不提供该方法，你将得到一个编译错误。</p><p>Scala也支持隐式转换(implicit conversion)，和Ruby的打开类，但返回和编译时检查类似。隐式转换将在后续介绍。</p><h2><span id="case-for-static-typing-the-right-way">Case for static typing, the right way</span></h2><p>说了这么多，Scala仍然是一个静态类型语言。但如果你前面部分，会令你感觉它是一门动态类型语言。至少，我们为什么要关心静态类型？</p><p><strong>定义</strong> <em>Static typing</em>指值和变量包含类型的一个类型系统。如一个数字 变量，不能赋值为其它，仅指派为数字。类型在编译时或声明时就已经强制确定的。</p><p><strong>定义</strong> <em>Dynamic typing</em>指值有类型，但变量没有类型的一个类型系统。如一个变量，既可以是字符，也可以是数字。</p><p>你构建的应用日渐复杂，有一个编译器给你做类型检查是件好事。它减少了你在类型错误上的修复和调试时间。在一个静态类型语言中，在一个数字字段调用一个length方法，编译器将给出一个编译错误。而在动态类型语言中，将得到运行时错误。</p><p>静态类型语言的另外一个好处是，允许你有一个如重构或IDE这样的强大工具。IDE可能不会引起你的兴趣，因为编辑器比比皆是，但重构的支持对于你的代码来说是一个巨大的帮助。</p><p>所有这些优势都伴随这付出。静态类型语言比动态类型语言有更多的约束，当你声明或调用一个函数时，有时会强制要求你提供额外的类型信息。对于构建大型应用来说，有约束也是好事，因为它强制了你以正确的规则实现。Scala作为一门类型推导(type-inferred)语言，为编程者照料的大部分的样板代码，使你更接近动态类型语言，但它终究还是静态类型语言。</p><p><strong>定义</strong> <em>Type inference</em>是一门技术，指，不需要编程者，由编译器来决定变量或函数的类型。编译器会推断出变量<code>s</code>在 <code>s=Hello</code>上是字符串类型，因为 <code>&quot;hello&quot;</code>是一个字符串。类型推断确保了在运行时，类型缺失时减少编程者的负担。</p><p>要证明类型推断是如何工作的，创建map的Array：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> computers = <span class="type">Array</span>(</span><br><span class="line"><span class="type">Map</span>(<span class="string">&quot;name&quot;</span> -&gt; <span class="string">&quot;Macbook&quot;</span>, <span class="string">&quot;color&quot;</span> -&gt; <span class="string">&quot;white&quot;</span>),</span><br><span class="line"><span class="type">Map</span>(<span class="string">&quot;name&quot;</span> -&gt; <span class="string">&quot;HP Pavillion&quot;</span>, <span class="string">&quot;color&quot;</span> -&gt; <span class="string">&quot;black&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果你在Scala的REPL中运行该代码，将看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computers:</span><br><span class="line">Array[scala.collection.immutable.Map[java.lang.String,java.lang.String]]</span><br><span class="line">= Array(Map(name -&gt; Macbook, color -&gt; white), Map(name -&gt; HP Pavillion,</span><br><span class="line">color -&gt; black))</span><br></pre></td></tr></table></figure><p>尽管为该map数组指定了key-value，Scala编译器能够推断出array和map的类型。并且，如果你尝试给<code>name</code>指定为整型类型，编译器会告诉你类型不匹配，你不能给一个整型变量指派为<code>String</code>类型。</p><h2><span id="来自编程爱好者">来自编程爱好者</span></h2><p>Scala语言设计的一个主要目的，是集成函数式和OOP。Scala是第一个静态类型语言，基于JVM融合了函数式和OOP。以及在OOP方面作了某些革新，以此使你能够创建更好的组件抽象(component abstractions)。</p><p>Scala沿袭了过去到现在各种编程语言的思想。首先，Scala吸收了来自<code>Java/C#</code>的语法，支持JVM和CLR(Common Language Runtime)。Scala中，每个值都是一个对象，每个操作都是一个方法调用。Smalltalk影响了这种纯面向对象模型。Scala也支持通用的嵌套和统一访问原则，这点分别借用了来自<code>Algol/Simula</code>和<code>Eiffel</code>。在Scala中变量和不带参数的函数，访问方式是一样的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UAPExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> someField = <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">someMethod</span> </span>= <span class="string">&quot;there&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> o = <span class="keyword">new</span> <span class="type">UAPExample</span></span><br><span class="line">o.someField</span><br><span class="line">o.someMethod</span><br></pre></td></tr></table></figure><p>这里你正访问<code>UAPExample</code>类实例的一个字段和一个方法，对于调用者，该类是透明的。</p><p>Scala的函数式编程构念和ML家族语言相似，以及Scala的Actor库正是受Erlang的Actor模型的影响。</p><blockquote><p><strong>编译宏(COMPILE MACROS)</strong> Scala 2.10版本发布添加了试验性的编译宏<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> 支持。它允许编程者编写宏定义：函数由编译器透明地加载，并在编译期间执行。这就是Scala的元编程(metaprogramming)理念。</p></blockquote><p>以上种种表明，Scala是一门特性和功能丰富的语言。</p><h2><span id="总结">总结</span></h2><p>本章迅速覆盖了许多的概念，在后续部分，将以大量的例子反复阐述、证明、理解这些概念，并解决真实的问题。</p><p>Scala的可扩展性和可伸缩特性，使得它可以帮助你解决各类编程问题。它的多范式模型，带给编程者函数式和OOP的强大抽象。函数式编程和actor使得你的并发编程更简单以及可维护。Scala的类型接口，使得可以远离样板代码，并专注于解决实际问题。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">“Twitter on Scala: A Conversation with Steve Jenson, Alex Payne, and Robey Pointer,” Scalazine, April 3,2009, <a href="https://www.artima.com/scalazine/articles/twitter_on_scala.html">www.artima.com/scalazine/articles/twitter_on_scala.html</a>.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Mark Harrah, “SBT, a Build Tool for Scala,” 2012, <a href="https://github.com/harrah/xsbt/">https://github.com/harrah/xsbt/</a>.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">“Scala comes to .Net,” July 22, 2011, www.scala-lang.org/node/10299.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">“Smalltalk,” Wikipedia, click <a href="http://en.wikipedia.org/wiki/Smalltalk">here</a>.</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">Timothy A. Budd’s personal web page, <a href="http://web.engr.oregonstate.edu/~budd/">http://web.engr.oregonstate.edu/~budd/</a>.</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">“A Postfunctional Language,” <a href="http://www.scala-lang.org/node/4960">www.scala-lang.org/node/4960</a>.</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">“Scala: A Scalable Language” by Martin Odersky, Lex Spoon, and Bill Venners, Scalazine, May 6, 2008,<a href="http://www.artima.com/scalazine/articles/scalable-language.html">www.artima.com/scalazine/articles/scalable-language.html</a>.</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">“The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software,” by Herb Sutter, originallypublished in Dr. Dobb’s Journal, March 2005, <a href="http://www.gotw.ca/publications/concurrency-ddj.htm">www.gotw.ca/publications/concurrency-ddj.htm</a>.</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;"><a href="http://en.wikipedia.org/wiki/Actor_model">“Actor model,” Wikipedia</a>.</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;"><a href="http://docs.scala-lang.org/sips/pending/type-dynamic.html">“SIP-17 Type Dynamic”</a>.</span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;"><a href="http://docs.scala-lang.org/overviews/macros/overview.html">Eugene Burmako, &quot;Def Macros&quot;</a>.</span><a href="#fnref:11" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用说明</title>
      <link href="/2016/04/27/miscellaneous/git-branch/"/>
      <url>/2016/04/27/miscellaneous/git-branch/</url>
      
        <content type="html"><![CDATA[<h4><span id="git使用说明">Git使用说明</span></h4><h5><span id="git分支管理">Git分支管理</span></h5><p>通常项目需要建立5种分支：<code>master</code>、<code>hostfix</code>、<code>release</code>、<code>develop</code>、<code>feature</code></p><span id="more"></span><p><img src="/img/git/git-branch.jpg" alt="项目分支管理"></p><p>feature分支开始于develop分支，完成以后合并到develop分支。</p><p>当完成一定数量feature分支以后，从develop再开一个release分支出来，这些特性将被更行到下一个发布的版本中，之后的feature将不会被合并到release中。</p><p>之后在release分支中，只修改bug，然后完成release分支。完成release分支会完成以下三个操作：1、合并release分支到master；2、给master打上版本的标签；3、release回归到develop分支。</p><p>当发现master上有bug时，开一个hotfix，完成后合并到master分支。</p><p>基本的开发流程就是这样，不清楚的可以看看文档Gitflow Workflow。</p><h6><span id="远程仓库有master和dev分支">远程仓库有<code>master</code>和<code>dev</code>分支</span></h6><ol><li>克隆代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/master-dev.git  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个git路径是无效的，示例而已</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查看所有分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch --all  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认有了dev和master分支，所以会看到如下三个分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master[本地主分支] origin/master[远程主分支] origin/dev[远程开发分支]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是origin/dev分支在本地没有任何的关联，所以我们无法在那里开发</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建本地关联origin/dev的分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev origin/dev  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建本地分支dev，并且和远程origin/dev分支关联，本地dev分支的初始代码和远程的dev分支代码一样</span></span><br></pre></td></tr></table></figure><ol start="4"><li>切换到dev分支进行开发</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev  # 这个是切换到dev分支，然后就是常规的开发</span><br></pre></td></tr></table></figure><ol start="5"><li>为了更好的理解，最好继续看看下文。</li></ol><h6><span id="假设远程仓库只有master分支">假设远程仓库只有<code>master</code>分支</span></h6><ol><li>克隆代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/master-dev.git  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个git路径是无效的，示例而已</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查看所有分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch --all  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认只有master分支，所以会看到如下两个分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master[本地主分支] origin/master[远程主分支]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建本地新的dev分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch dev  # 创建本地分支</span><br><span class="line">git branch  # 查看分支</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是会看到master和dev，而且master上会有一个星号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候dev是一个本地分支，远程仓库不知道它的存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地分支可以不同步到远程仓库，我们可以在dev开发，然后merge到master，使用master同步代码，当然也可以同步</span></span><br></pre></td></tr></table></figure><ol start="4"><li>发布dev分支</li></ol><p>发布dev分支指的是同步dev分支的代码到远程服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev  # 这样远程仓库也有一个dev分支了</span><br></pre></td></tr></table></figure><ol start="5"><li>在dev分支开发代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev  # 切换到dev分支进行开发</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开发代码之后，我们有两个选择</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个：如果功能开发完成了，可以合并主分支</span></span><br><span class="line">git checkout master  # 切换到主分支</span><br><span class="line">git merge dev  # 把dev分支的更改和master合并</span><br><span class="line">git push  # 提交主分支代码远程</span><br><span class="line">git checkout dev  # 切换到dev远程分支</span><br><span class="line">git push  # 提交dev分支到远程</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个：如果功能没有完成，可以直接推送</span></span><br><span class="line">git push  # 提交到dev远程分支</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：在分支切换之前最好先commit全部的改变，除非你真的知道自己在做什么</span></span><br></pre></td></tr></table></figure><ol start="6"><li>删除分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push origin :dev  # 删除远程dev分支，危险命令哦</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面两条是删除本地分支</span></span><br><span class="line">git checkout master  # 切换到master分支</span><br><span class="line">git branch -d dev  # 删除本地dev分支</span><br></pre></td></tr></table></figure><ol start="7"><li>子分支</li></ol><p>要在原来的<code>dev</code>上创建子分支<code>feature</code>，假设分支名为<code>feature-vulcan</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-vulcan</span><br></pre></td></tr></table></figure><p>开发完成后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git add vulcan.py</span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch feature-vulcan</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       new file:   vulcan.py</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">git commit -m <span class="string">&quot;add feature vulcan&quot;</span></span></span><br><span class="line">[feature-vulcan 756d4af] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切换回<code>dev</code>，准备合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>如果要删除该功能，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令强行删除:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature-vulcan</span><br></pre></td></tr></table></figure><h5><span id="git常见操作">Git常见操作</span></h5><ol><li>新建代码库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>增加/删除文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>代码提交</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><ol start="5"><li>分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><ol start="6"><li>标签</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><ol start="7"><li>查看信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><ol start="8"><li>远程同步</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><ol start="9"><li>撤销</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><ol start="10"><li>其它</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multi plugin</title>
      <link href="/2016/04/27/miscellaneous/stack-edit/"/>
      <url>/2016/04/27/miscellaneous/stack-edit/</url>
      
        <content type="html"><![CDATA[<p>Welcome to StackEdit!</p><p>Hey! I’m your first Markdown document in <strong>StackEdit</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Don’t delete me, I’m very helpful! I can be recovered anyway in the <strong>Utils</strong> tab of the <i class="icon-cog"></i> <strong>Settings</strong> dialog.</p><span id="more"></span><p>Documents</p><p>StackEdit stores your documents in your browser, which means all your documents are automatically saved locally and are accessible <strong>offline!</strong></p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><ul><li>StackEdit is accessible offline after the application has been loaded for the first time.</li><li>Your local documents are not shared between different browsers or computers.</li><li>Clearing your browser’s data may <strong>delete all your local documents!</strong> Make sure your documents are synchronized with <strong>Google Drive</strong> or <strong>Dropbox</strong> (check out the <a href="#synchronization"><i class="icon-refresh"></i> Synchronization</a> section).</li></ul></blockquote><h4><span id="create-a-document">Create a document</span></h4><p>The document panel is accessible using the <i class="icon-folder-open"></i> button in the navigation bar. You can create a new document by clicking <i class="icon-file"></i> <strong>New document</strong> in the document panel.</p><h4><span id="switch-to-another-document">Switch to another document</span></h4><p>All your local documents are listed in the document panel. You can switch from one to another by clicking a document in the list or you can toggle documents using <kbd>Ctrl+[</kbd> and <kbd>Ctrl+]</kbd>.</p><h4><span id="rename-a-document">Rename a document</span></h4><p>You can rename the current document by clicking the document title in the navigation bar.</p><h4><span id="delete-a-document">Delete a document</span></h4><p>You can delete the current document by clicking <i class="icon-trash"></i> <strong>Delete document</strong> in the document panel.</p><h4><span id="export-a-document">Export a document</span></h4><p>You can save the current document to a file by clicking <i class="icon-hdd"></i> <strong>Export to disk</strong> from the <i class="icon-provider-stackedit"></i> menu panel.</p><blockquote><p><strong>Tip:</strong> Check out the <a href="#publish-a-document"><i class="icon-upload"></i> Publish a document</a> section for a description of the different output formats.</p></blockquote><h3><span id="synchronization">Synchronization</span></h3><p>StackEdit can be combined with <i class="icon-provider-gdrive"></i> <strong>Google Drive</strong> and <i class="icon-provider-dropbox"></i> <strong>Dropbox</strong> to have your documents saved in the <em>Cloud</em>. The synchronization mechanism takes care of uploading your modifications or downloading the latest version of your documents.</p><blockquote><p><strong>Note:</strong></p></blockquote><blockquote><ul><li>Full access to <strong>Google Drive</strong> or <strong>Dropbox</strong> is required to be able to import any document in StackEdit. Permission restrictions can be configured in the settings.</li><li>Imported documents are downloaded in your browser and are not transmitted to a server.</li><li>If you experience problems saving your documents on Google Drive, check and optionally disable browser extensions, such as Disconnect.</li></ul></blockquote><h4><span id="open-a-document">Open a document</span></h4><p>You can open a document from <i class="icon-provider-gdrive"></i> <strong>Google Drive</strong> or the <i class="icon-provider-dropbox"></i> <strong>Dropbox</strong> by opening the <i class="icon-refresh"></i> <strong>Synchronize</strong> sub-menu and by clicking <strong>Open from…</strong>. Once opened, any modification in your document will be automatically synchronized with the file in your <strong>Google Drive</strong> / <strong>Dropbox</strong> account.</p><h4><span id="save-a-document">Save a document</span></h4><p>You can save any document by opening the <i class="icon-refresh"></i> <strong>Synchronize</strong> sub-menu and by clicking <strong>Save on…</strong>. Even if your document is already synchronized with <strong>Google Drive</strong> or <strong>Dropbox</strong>, you can export it to a another location. StackEdit can synchronize one document with multiple locations and accounts.</p><h4><span id="synchronize-a-document">Synchronize a document</span></h4><p>Once your document is linked to a <i class="icon-provider-gdrive"></i> <strong>Google Drive</strong> or a <i class="icon-provider-dropbox"></i> <strong>Dropbox</strong> file, StackEdit will periodically (every 3 minutes) synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be detected.</p><p>If you just have modified your document and you want to force the synchronization, click the <i class="icon-refresh"></i> button in the navigation bar.</p><blockquote><p><strong>Note:</strong> The <i class="icon-refresh"></i> button is disabled when you have no document to synchronize.</p></blockquote><h4><span id="manage-document-synchronization">Manage document synchronization</span></h4><p>Since one document can be synchronized with multiple locations, you can list and manage synchronized locations by clicking <i class="icon-refresh"></i> <strong>Manage synchronization</strong> in the <i class="icon-refresh"></i> <strong>Synchronize</strong> sub-menu. This will let you remove synchronization locations that are associated to your document.</p><blockquote><p><strong>Note:</strong> If you delete the file from <strong>Google Drive</strong> or from <strong>Dropbox</strong>, the document will no longer be synchronized with that location.</p></blockquote><h3><span id="publication">Publication</span></h3><p>Once you are happy with your document, you can publish it on different websites directly from StackEdit. As for now, StackEdit can publish on <strong>Blogger</strong>, <strong>Dropbox</strong>, <strong>Gist</strong>, <strong>GitHub</strong>, <strong>Google Drive</strong>, <strong>Tumblr</strong>, <strong>WordPress</strong> and on any SSH server.</p><h4><span id="publish-a-document">Publish a document</span></h4><p>You can publish your document by opening the <i class="icon-upload"></i> <strong>Publish</strong> sub-menu and by choosing a website. In the dialog box, you can choose the publication format:</p><ul><li>Markdown, to publish the Markdown text on a website that can interpret it (<strong>GitHub</strong> for instance),</li><li>HTML, to publish the document converted into HTML (on a blog for example),</li><li>Template, to have a full control of the output.</li></ul><blockquote><p><strong>Note:</strong> The default template is a simple webpage wrapping your document in HTML format. You can customize it in the <strong>Advanced</strong> tab of the <i class="icon-cog"></i> <strong>Settings</strong> dialog.</p></blockquote><h4><span id="update-a-publication">Update a publication</span></h4><p>After publishing, StackEdit will keep your document linked to that publication which makes it easy for you to update it. Once you have modified your document and you want to update your publication, click on the <i class="icon-upload"></i> button in the navigation bar.</p><blockquote><p><strong>Note:</strong> The <i class="icon-upload"></i> button is disabled when your document has not been published yet.</p></blockquote><h4><span id="manage-document-publication">Manage document publication</span></h4><p>Since one document can be published on multiple locations, you can list and manage publish locations by clicking <i class="icon-upload"></i> <strong>Manage publication</strong> in the <i class="icon-provider-stackedit"></i> menu panel. This will let you remove publication locations that are associated to your document.</p><blockquote><p><strong>Note:</strong> If the file has been removed from the website or the blog, the document will no longer be published on that location.</p></blockquote><h3><span id="markdown-extra">Markdown Extra</span></h3><p>StackEdit supports <strong>Markdown Extra</strong>, which extends <strong>Markdown</strong> syntax with some nice features.</p><blockquote><p><strong>Tip:</strong> You can disable any <strong>Markdown Extra</strong> feature in the <strong>Extensions</strong> tab of the <i class="icon-cog"></i> <strong>Settings</strong> dialog.</p></blockquote><blockquote><p><strong>Note:</strong> You can find more information about <strong>Markdown</strong> syntax <a href="http://daringfireball.net/projects/markdown/syntax" title="Markdown">here</a> and <strong>Markdown Extra</strong> extension <a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra">here</a>.</p></blockquote><h3><span id="tables">Tables</span></h3><p><strong>Markdown Extra</strong> has a special syntax for tables:</p><table><thead><tr><th>Item</th><th>Value</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>You can specify column alignment with one or two colons:</p><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">Value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table><h3><span id="definition-lists">Definition Lists</span></h3><p><strong>Markdown Extra</strong> has a special syntax for definition lists too:</p><p>Term 1<br>Term 2<br>:   Definition A<br>:   Definition B</p><p>Term 3</p><p>:   Definition C</p><p>:   Definition D</p><pre><code>&gt; part of definition D</code></pre><h3><span id="fenced-code-blocks">Fenced code blocks</span></h3><p>GitHub’s fenced code blocks are also supported with <strong>Highlight.js</strong> syntax highlighting:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tip:</strong> To use <strong>Prettify</strong> instead of <strong>Highlight.js</strong>, just configure the <strong>Markdown Extra</strong> extension in the <i class="icon-cog"></i> <strong>Settings</strong> dialog.</p></blockquote><blockquote><p><strong>Note:</strong> You can find more information:</p></blockquote><blockquote><ul><li>about <strong>Prettify</strong> syntax highlighting <a href="https://code.google.com/p/google-code-prettify/">here</a>,</li><li>about <strong>Highlight.js</strong> syntax highlighting <a href="http://highlightjs.org/">here</a>.</li></ul></blockquote><h3><span id="footnotes">Footnotes</span></h3><p>You can create footnotes like this<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><h3><span id="smartypants">SmartyPants</span></h3><p>SmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example:</p><table><thead><tr><th></th><th style="text-align:left">ASCII</th><th style="text-align:left">HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td style="text-align:left"><code>'Isn't this fun?'</code></td><td style="text-align:left">‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td style="text-align:left"><code>&quot;Isn't this fun?&quot;</code></td><td style="text-align:left">“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td style="text-align:left"><code>-- is en-dash, --- is em-dash</code></td><td style="text-align:left">– is en-dash, — is em-dash</td></tr></tbody></table><h3><span id="table-of-contents">Table of contents</span></h3><p>You can insert a table of contents using the marker <code>[TOC]</code>:</p><p>[TOC]</p><h3><span id="mathjax">MathJax</span></h3><p>You can render <em>LaTeX</em> mathematical expressions using <strong>MathJax</strong>, as on <a href="http://math.stackexchange.com/">math.stackexchange.com</a>:</p><p>The <em>Gamma function</em> satisfying <img src="https://math.now.sh?inline=%5CGamma%28n%29%20%3D%20(n-1)!%5Cquad%5Cforall%20n%5Cin%5Cmathbb%20N" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"> is via the Euler integral</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=E%20%3D%20m%20*%20c%5E2%0A"></p><blockquote><p><strong>Tip:</strong> To make sure mathematical expressions are rendered properly on your website, include <strong>MathJax</strong> into your template:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> You can find more information about <strong>LaTeX</strong> mathematical expressions <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h3><span id="uml-diagrams">UML diagrams</span></h3><p>You can also render sequence diagrams like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><p>And flow charts like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> You can find more information:</p></blockquote><blockquote><ul><li>about <strong>Sequence diagrams</strong> syntax <a href="http://bramp.github.io/js-sequence-diagrams/">here</a>,</li><li>about <strong>Flow charts</strong> syntax <a href="http://adrai.github.io/flowchart.js/">here</a>.</li></ul></blockquote><h3><span id="support-stackedit">Support StackEdit</span></h3><p><a href="https://monetizejs.com/authorize?client_id=ESTHdCYOi18iLhhO&amp;summary=true"><img src="https://cdn.monetizejs.com/resources/button-32.png" alt></a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://stackedit.io/">StackEdit</a> is a full-featured, open-source Markdown editor based on PageDown, the Markdown library used by Stack Overflow and the other Stack Exchange sites. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Here is the <em>text</em> of the <strong>footnote</strong>. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/04/27/miscellaneous/hello-world/"/>
      <url>/2016/04/27/miscellaneous/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p><h3><span id="hexo-highlight-syntax">Hexo highlight syntax</span></h3><p>One way is <a href="https://hexo.io/docs/tag-plugins.html#Code-Block">Code Block</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>Another way is <a href="https://hexo.io/docs/tag-plugins.html#Backtick-Code-Block">Backtick Code Block</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` [language] [title] [url] [link text] code snippet ```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> beginning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> highlight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2016/04/27/miscellaneous/test/"/>
      <url>/2016/04/27/miscellaneous/test/</url>
      
        <content type="html"><![CDATA[<h4><span id="我是帅哥我会乱说吗">我是帅哥我会乱说吗</span></h4><figure class="highlight scala"><figcaption><span>actor模型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">ActorPath</span>, <span class="type">ActorSelection</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author Barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Name</span>(n) =&gt; println(<span class="string">&quot;Hello &quot;</span> + n)</span><br><span class="line">      <span class="keyword">case</span> name: <span class="type">String</span> =&gt; println(<span class="string">&quot;Goodbye &quot;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;greetings&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> a      = system.actorOf(<span class="type">Props</span>[<span class="type">GreetingsActor</span>], name = <span class="string">&quot;greetings-actor&quot;</span>)</span><br><span class="line"></span><br><span class="line">  a ! <span class="type">Name</span>(<span class="string">&quot;Nilanjan&quot;</span>)</span><br><span class="line">  a ! <span class="string">&quot;World&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> path          : <span class="type">ActorPath</span>      = system / <span class="string">&quot;GreetingsActor&quot;</span></span><br><span class="line">  <span class="keyword">val</span> actorSelection: <span class="type">ActorSelection</span> = system.actorSelection(path)</span><br><span class="line"></span><br><span class="line">  actorSelection ! <span class="type">Name</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">50</span>)</span><br><span class="line">  system.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> highlight </tag>
            
            <tag> akka </tag>
            
            <tag> actor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

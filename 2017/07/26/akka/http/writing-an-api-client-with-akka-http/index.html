<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>writing an api client with akka http</title><link rel="stylesheet" href="/css/layout.css">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css"><link rel="shortcut icon" href="/img/favicon.ico"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">简单易懂の现代魔法</a></li><li class="menu-item"><a href="/archives/" class="menu-link">Archives</a></li><li class="menu-item"><a href="http://weibo.com/u/2360401155" class="menu-link">Weibo</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li><li class="menu-item"><a href="/atom.xml" class="menu-link">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">简单易懂の现代魔法</a></li><li class="menu-item"><a href="/archives/" class="menu-link">Archives</a></li><li class="menu-item"><a href="http://weibo.com/u/2360401155" class="menu-link">Weibo</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li><li class="menu-item"><a href="/atom.xml" class="menu-link">Rss</a></li></ul></nav><div id="mobile-menu-toggle" class="toggle-menu"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">writing an api client with akka http</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2017-07-26</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a href="/tags/akka/" class="tag-link">akka</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a href="/categories/akka-http/" class="category-link">akka-http</a></p></div><div class="article-content"><p><a href="https://www.stockfighter.io/" target="_blank" rel="noopener">Stockfighter</a> is a CTF (short for Capture the Flag) game that I first heard about at Microconf 2015, but haven’t gotten a chance to play up until very recently. I plan on posting more about my impressions of the game later, but very shortly: it is a series of programming challenges based on the concept of stock exchanges and ways to manipulate stock exchanges. Along with the web UI, a public json <a href="https://starfighter.readme.io/" target="_blank" rel="noopener">API</a> is exposed as a mechanism for interacting with the game. There did not seem to be any Scala clients floating around, so I took this as a chance to play around with <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/index.html" target="_blank" rel="noopener">akka-http</a>.</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>
<h3><span id="scaffolding">Scaffolding</span></h3>
<p>After some quick googling and reading of tutorials, it looked like the basic structure of an http client would be something like this:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stockfighter.client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model._</span><br><span class="line"><span class="keyword">import</span> akka.stream.<span class="type">ActorMaterializer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TradingApiClient</span>(<span class="params">apiKey: <span class="type">String</span></span>)(<span class="params">implicit val system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  <span class="comment">// def endpoint(): Response = &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A couple of things to note here. First off, <code>akka-http</code> is a part of the (increasingly pervasive) akka ecosystem, so obviously actors have to be involved. The tutorials either had the <code>ActorSystem</code> at the top level or had the client itself be an <code>Actor</code>, but I felt like a regular class would suffice so I compromised by passing the system in as a parameter with a default. The <code>ActorMaterializer</code> is completely new to me, since I am coming from <code>spray</code> ~1.1 and have missed out on a lot of the latest reactive-buzzwordy developments.</p>
<p>I’m still not sure I grok it completely, but my understanding is that akka-http is backed completely by reactive streams, which the client constructs as lazy descriptions of computations. When the computations are run, the <code>ActorMaterializer</code> spins up the actors to do the actual work. In any case, I thought about putting the Materializer in the constructor as well, but the fact that it takes an implicit <code>ActorSystem</code> as an argument makes it fairly awkward to have both <code>ActorSystem</code> and <code>ActorMaterializer</code> live as constructor params with defaults. I can think of a few ways to deal with this, but for a quickie client I decided to just in-line the materializer and move on.</p>
<h3><span id="making-a-request">Making a request</span></h3>
<p>The Stockfighter API ships with a heartbeat/status endpoint, i.e., “is the service up?” The endpoint lives at <a href="https://api.stockfighter.io/ob/api/heartbeat" target="_blank" rel="noopener">https://api.stockfighter.io/ob/api/heartbeat</a> and returns a response in the following format:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ok"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This seemed like as good a starting point as any, in that it’s a fairly simple endpoint with a simple response type, but still complex enough to test a full request flow with some common functionality like serialization/deserialization.</p>
<p>As it turns out, it took a decent amount of time and a lot of reading to get to a basic implementation:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.http.scaladsl.<span class="type">Http</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model._</span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model.<span class="type">Uri</span>.<span class="type">Path</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl.&#123; <span class="type">Source</span>, <span class="type">Sink</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor boilerplate elided</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">HttpResponse</span>] = &#123;</span><br><span class="line">  <span class="comment">// Fancier DSL: `Path.singleSlash / "ob" / "api" / "heartbeat"`</span></span><br><span class="line">  <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">"/ob/api/heartbeat"</span>))))</span><br><span class="line">  <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">"api.stockfighter.io"</span>)</span><br><span class="line"></span><br><span class="line">  source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executive summary: <code>akka-http</code> leverages the concept of reactive streams that seems to be the new hot thing lately. Streams are essentially fancied up functions, and consist of three parts: the <code>Source</code>, the <code>Flow</code>, and the <code>Sink</code>. The <code>Source</code> describes the input, which can be single element (<code>Source.single</code>), an iterator (<code>Source.iterator</code>), a Future (<code>Source.fromFuture</code>), etc. The <code>Flow</code> is the description of a computation to run on the data from the <code>Source</code>. The <code>Sink</code> describes what to do with data after it has been run through the flow: push it into a <code>queue</code> (<code>Sink.queue[T]</code>), <code>fold</code> over it (<code>Sink.fold</code>), and so on. You can combine things in all sorts of different ways–the above uses <code>via</code> and <code>runWith</code>, but there’s also <code>viaMat</code>, <code>run</code>, and any number of other fancy combinators.</p>
<p>What it boils down to here is that the <code>Source</code> is an http request, the <code>Flow</code> describes how to send that request, and <code>runWith(Sink.head)</code> runs the flow and returns a future of the response. Phew…</p>
<h3><span id="serializationdeserialization">Serialization/Deserialization</span></h3>
<p>For serialization/deserialization, <code>akka-http</code> provides its own <code>Marshal/Unmarshal</code>. For json, the default option is to lean on <code>akka-http</code>’s predecessor, <code>spray</code>–Or more specifically, <code>spray-json</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADT describing the response</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatus</span>(<span class="params">ok: <span class="type">Boolean</span>, error: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">import</span> <span class="title">spray</span>.<span class="title">json</span>.<span class="title">_</span></span></span><br><span class="line"><span class="class"><span class="title">import</span> <span class="title">akka</span>.<span class="title">http</span>.<span class="title">scaladsl</span>.<span class="title">marshallers</span>.<span class="title">sprayjson</span>.<span class="title">SprayJsonSupport</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">TradingApiSerialization</span> <span class="keyword">extends</span> <span class="title">SprayJsonSupport</span> </span>&#123;</span><br><span class="line">  <span class="comment">// One of the built-in spray-json auto-formatters</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ApiStatusFormat</span> = jsonFormat2(<span class="type">ApiStatus</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Previous imports elided</span></span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.unmarshalling.<span class="type">Unmarshal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// N.B. mixing in TradingApiSerialization to get the automatic conversions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TradingApiClient</span>(<span class="params">apiKey: <span class="type">String</span></span>)(<span class="params">implicit val system: <span class="type">ActorSystem</span> = <span class="type">ActorSystem</span>(</span>)) <span class="keyword">extends</span> <span class="title">TradingApiSerialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> materializer = <span class="type">ActorMaterializer</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">ApiStatus</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">"/ob/api/heartbeat"</span>))))</span><br><span class="line">    <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">"api.stockfighter.io"</span>).mapAsync(<span class="number">1</span>) &#123; r =&gt;</span><br><span class="line">      <span class="type">Unmarshal</span>(r.entity).to[<span class="type">ApiStatus</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The Serialization trait is normal procedure for <code>spray-json</code>, and the <code>SprayJsonSupport</code> provided by <code>akka-http</code> just provides an implicit conversion that links the <code>Unmarshal(r.entity)</code> together with the <code>jsonFormat</code> for the entity. The big wart here is actually the <code>mapAsync(parallelism = 1)</code>, which is a result of <code>Unmarshall(...).to[T]</code> returning a <code>Future[T]</code>. I didn’t dig too deeply into this, but based on some quick googling the general consensus seems to be that the use of <code>Future</code> here is a way of handling lazy/streaming responses. Whatever the case, I could not find an alternative API for this so <code>mapAsync(1)</code> seemed to be the least of the evils–another choice would have been something like <code>.map { r =&gt; Await.result(Unmarshal(r.entity).to[ApiStatus], Duration.Inf) }</code> but that seems even clunkier.</p>
<h3><span id="error-handling">Error handling</span></h3>
<p>The above code still has the flaw that if the server responds with e.g. 404, it will throw an exception and the client will be SOL. This is not so much an issue for the heartbeat endpoint, but Stockfighter is nice enough to enumerate a bunch of its common errors for us so why not add in some minimal handling via <a href="http://danielwestheide.com/blog/2013/01/02/the-neophytes-guide-to-scala-part-7-the-either-type.html" target="_blank" rel="noopener">Either</a>?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type alias for readability's sake</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">TradingApiResult</span>[<span class="type">T</span>] </span>= <span class="type">Either</span>[<span class="type">ApiError</span>, <span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">NotFound</span>(<span class="params">error: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Unauthorized</span>(<span class="params">error: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">UnexpectedStatusCode</span>(<span class="params">status: <span class="type">StatusCode</span></span>) <span class="keyword">extends</span> <span class="title">ApiError</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">import</span> <span class="title">akka</span>.<span class="title">http</span>.<span class="title">scaladsl</span>.<span class="title">unmarshalling</span>.</span>&#123; <span class="type">Unmarshal</span>, <span class="type">Unmarshaller</span> &#125;</span><br><span class="line"><span class="keyword">import</span> akka.http.scaladsl.model.<span class="type">StatusCodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor/etc elided</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `um` is provided by the previously mentioned `SprayJsonSupport`</span></span><br><span class="line"><span class="comment">// This is a prevalent theme in akka-related code: IMPLICITS, IMPLICITS EVERYWHERE.  Fun fact: this also requires</span></span><br><span class="line"><span class="comment">// an implicit ActorSystem and ActorMaterializer floating around!</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span></span>[<span class="type">T</span>](r: <span class="type">HttpResponse</span>)(<span class="keyword">implicit</span> um: <span class="type">Unmarshaller</span>[<span class="type">ResponseEntity</span>, <span class="type">T</span>]): <span class="type">Future</span>[<span class="type">TradingApiResult</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">  r.status <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">OK</span> =&gt; <span class="type">Unmarshal</span>(r.entity).to[<span class="type">T</span>] map <span class="type">Right</span>.apply</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">Unauthorized</span> =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">Unauthorized</span>(r.entity.toString)))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StatusCodes</span>.<span class="type">NotFound</span> =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">NotFound</span>(r.entity.toString)))</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Future</span>(<span class="type">Left</span>(<span class="type">UnexpectedStatusCode</span>(r.status)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use it in the API call!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apiIsUp</span></span>: <span class="type">Future</span>[<span class="type">TradingApiResult</span>[<span class="type">ApiStatus</span>]] = &#123;</span><br><span class="line">  <span class="keyword">val</span> source = <span class="type">Source</span>.single(<span class="type">HttpRequest</span>(uri = <span class="type">Uri</span>(path = <span class="type">Path</span>(<span class="string">"/ob/api/heartbeat"</span>))))</span><br><span class="line">  <span class="keyword">val</span> flow = <span class="type">Http</span>().outgoingConnectionHttps(<span class="string">"api.stockfighter.io"</span>).mapAsync(<span class="number">1</span>) &#123; r =&gt;</span><br><span class="line">    deserialize[<span class="type">ApiStatus</span>](r)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  source.via(flow).runWith(<span class="type">Sink</span>.head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat for rest of the endpoints</span></span><br></pre></td></tr></table></figure>
<p><code>apiIsUp</code> should now return an <code>Either[ApiError, ApiStatus]</code> unless something really bad (dare I say, exceptional?) happens.</p>
<h3><span id="todos">TODOs</span></h3>
<p>The above is a nice start, but a few big TODOs stand out to me before I go on and toss this onto github.</p>
<p>First and foremost… Tests! Testing libraries like this is always tricky since they’re essentially all integration-y glue code, but I have always been a big fan of the <a href="https://github.com/vcr/vcr" target="_blank" rel="noopener">vcr</a> gem in Ruby. As far as I know the closest thing in Scala is <a href="https://github.com/betamaxteam/betamax" target="_blank" rel="noopener">betamax</a>, which I have not used but would like to. (I know, I know–Not writing test firsts? What about TDD? BAD DEVELOPER! <em>rolls up newspaper</em>)</p>
<p>Another big thing for me is domain modeling. The built-in json deserialization is fine for working with row-level data, but the plain case class format leaves a bit to be desired as far as robust data modeling. As a simple example:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simplistic "order request"</span></span><br><span class="line">&#123; price: <span class="number">0</span>, qty: <span class="number">0</span>, direction: <span class="string">"buy"</span> &#125; <span class="comment">// "buy" or "sell"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive translation:</span></span><br><span class="line"><span class="type">OrderRequest</span>(price: <span class="type">Int</span>, qty: <span class="type">Int</span>, direction: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferable:</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderDirection</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Buy</span> <span class="keyword">extends</span> <span class="title">OrderDirection</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Sell</span> <span class="keyword">extends</span> <span class="title">OrderDirection</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">BetterOrderRequest</span>(<span class="params">price: <span class="type">Int</span>, qty: <span class="type">Int</span>, direction: <span class="type">OrderDirection</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>I haven’t decided whether it would be better to add another step to the pipeline (e.g., <code>mapJsonToDomainObject</code>) or to roll custom spray <code>JsonFormat</code>s to do this.</p>
<p>Lastly: websockets. In <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/client-side/websocket-support.html" target="_blank" rel="noopener">theory</a> websockets are supported, but the documentation is even sparser than for http clients and I haven’t quite figured it out yet–especially since the deserialization provided in <code>SprayJsonSupport</code> does not seem to work with the types used in the websocket API.</p>
<h3><span id="overall-impressions">Overall Impressions</span></h3>
<p>So far, my impression of <code>akka-http</code> is by and large the same as my impression of <code>spray</code>. Actors (and now reactive streams) provide a lot of power and performance in exchange for non-trivial complexity. In my experience this tradeoff is generally worth it for server-side/business application code, but lugging around an ActorSystem/etc ends up feeling very clunky for a simple http client. It doesn’t help that the -client libraries seem to be the red-headed step-children of both ecosystems.</p>
<p>The documentation feels consistent with the general API design. That is: it tries to look simple for the most basic use-cases, but in reality there is a lot of implicit stuff floating around. It was basically a pre-requisite for me to go digging for not only how streams worked conceptually but all the varied APIs that need to be used to link everything together before I could unpack the examples in the client tutorials. For example, while playing with the <a href="http://doc.akka.io/docs/akka/2.4.4/scala/http/client-side/websocket-support.html" target="_blank" rel="noopener">websocket</a> tutorial I tried to switch the <code>Sink.foreach</code> with a <code>Sink.queue</code> and got the following:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[error] (...)/<span class="type">TradingApiClient</span>.scala:<span class="number">118</span>: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line">[error]  found:</span><br><span class="line">akka.stream.scaladsl.<span class="type">Sink</span>[<span class="type">Nothing</span>,akka.stream.scaladsl.<span class="type">SinkQueue</span>[<span class="type">Nothing</span>]]</span><br><span class="line">[error]  required:</span><br><span class="line">akka.stream.<span class="type">Graph</span>[akka.stream.<span class="type">SinkShape</span>[akka.http.scaladsl.model.ws.<span class="type">Message</span>],akka.stream.scaladsl.<span class="type">SinkQueue</span>[akka.http.scaladsl.model.ws.<span class="type">Message</span>]]</span><br><span class="line">[error]     outgoing.via(webSocketFlow).runWith(<span class="type">Sink</span>.queue)</span><br></pre></td></tr></table></figure>
<p>It’s not the end of the world as I worked out the need for a type parameter (i.e., <code>Sink.queue[Message]</code>) but there a lot of examples like this where the errors and tutorials are not exactly intuitive. I can see this being a huge deterrent to folks who are new to the ecosystem, to the concepts, or to Scala in general who will hit a wall and think, “Wow, all this and I can’t even open up a websocket/execute a json <code>POST</code>/etc?” Or even worse–the example code will be cargo-culted in by a harried developer on a deadline and carried on as the software version of the <a href="http://c2.com/cgi/wiki?TheFiveMonkeys" target="_blank" rel="noopener">five monkeys</a>. (This is not to say I could do any better. Documentation and API design are some of the most underrated hard problems in software today, IMO. :)</p>
<p>All my nitpicking aside, there is a lot to like about <code>akka-http</code>. In exchange for all the effort involved in learning about reactive streams and how to work with them, they provide a nice construct for abstracting away concerns like back-pressure management. This frees up developers to concentrate on the actual flow of the data. The resulting code is also quite clean and generally easy to follow, despite the time it took to actually get to that point. In other words, it trades off learning curve and ease of intuition for API comprehensiveness and composability. <code>akka-http</code> is especially nice on the server, where performance is a bigger concern. I’ve built a couple of internal webservices with <code>spray</code> previously, and it’s always been fairly performant without excessive tuning on my part. In addition, I’ve found the concept of Directives and the server-side routing DSL to be quite nice to work with in the past.</p>
<p>Overall I would recommend <code>akka-http</code> unreservedly for writing web services and business applications. My experience with it on the server side has been quite good. I would also use it again on the client side, mostly because there don’t seem to be any better options. I had looked into some alternatives, but e.g. play-ws has the same overloaded baggage problem and dispatch is like the poster-child of unintelligible symbolic operators (and seems unmaintained to boot). So until a better http client surfaces in the Scala ecosystem, one could do a lot worse.</p>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2017/07/26/akka/http/writing-an-api-client-with-akka-http/';
var disqus_title = 'writing an api client with akka http';
var disqus_url = 'http://galudisu.info/2017/07/26/akka/http/writing-an-api-client-with-akka-http/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//barudisshu-github-io.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2019 <a href="http://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css"><script src="/js/base.js"></script><script src="/js/rabbit-lyrics.js"></script></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>
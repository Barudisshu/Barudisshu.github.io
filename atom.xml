<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简单易懂の现代魔法</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://galudisu.info/"/>
  <updated>2020-03-26T07:28:46.815Z</updated>
  <id>http://galudisu.info/</id>
  
  <author>
    <name>barudisshu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单构建的自动化devOps方案</title>
    <link href="http://galudisu.info/2020/03/27/ci/devops-ha-design/"/>
    <id>http://galudisu.info/2020/03/27/ci/devops-ha-design/</id>
    <published>2020-03-27T07:50:03.000Z</published>
    <updated>2020-03-26T07:28:46.815Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="流程架构图">流程架构图</span></h2><p><img src="img/ci/devops.png" alt=""></p><p>简单设计了一套自动化devOps方案，其中有两个分支：</p><ul><li><p>jenkins分支，部署在公司内部开发服务器上。用于生产环境，由jenkins搭载一套CI/CD。开发完程序代码后，提交，触发构建、检查、单元测试、质量评估。之后推送到测试服务器，提供给测试人员进行功能测试。如果有问题，反馈给开发人员；如果功能点收集完善，通知teamcity分支。</p></li><li><p>teamcity分支，运营和项目负责人收集到功能点后，手动触发teamcity自动构建，推送镜像到harbor。邮件通知项目实施负责人。实施负责人收集功能点、汇报信息，更新k8s服务镜像，推送服务、进行灰度发布、之后上线、若有问题、回滚…</p></li></ul><p><img src="img/ci/M2WIQ.png" alt=""></p><h2><span id="系统配置">系统配置</span></h2><p>安装系统监控</p><figure class="highlight plain"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --tls --name grafana --namespace monitoring -f grafana-settings.yaml -f grafana-dashboards.yaml grafana</span><br></pre></td></tr></table></figure><p>安装harbor</p><figure class="highlight plain"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --wait --name harbor --namespace kube-system harbor/harbor --set persistence.enabled=false --set expose.type=nodePort --set externalURL=&quot;https://harbor.cplier.com&quot; --set expose.ingress.hosts.core=harbor.cplier.com --set expose.tls.enabled=false --set proxy.httpProxy=&apos;http://harbor.cplier.com&apos; --set proxy.httpsProxy=&apos;https://harbor.cplier.com&apos;</span><br></pre></td></tr></table></figure><p>安装k9s，查看部署和服务情况</p><p><img src="img/ci/k9s.png" alt=""></p><p>设置外部代理</p><p>nginx设置负载均衡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream harbor &#123;</span><br><span class="line">    server 192.168.0.160:30002;</span><br><span class="line">    server 192.168.0.125:30002;</span><br><span class="line">    server 192.168.0.56:30002;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name harbor.cplier.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">       proxy_pass http://harbor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name harbor.cplier.com;</span><br><span class="line">    ssl_certificate cert/1_harbor.cplier.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key cert/2_harbor.cplier.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        client_max_body_size 1000m;</span><br><span class="line">        proxy_pass http://harbor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>teamcity配置好参数后，触发构建。</p><p><img src="img/ci/teamcity.png" alt=""></p><p>在k8s集群中，编写相应的service，进行部署，写pvc、配ingress、配字典… what ever…</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">harbor.cplier.com/library/cplier-gateway:latest</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">cplier-gateway</span></span><br><span class="line"><span class="attr">      imagePullSecrets:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">cplier-gateway</span></span><br></pre></td></tr></table></figure><p><code>image</code>为你的镜像仓储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;流程架构图&quot;&gt;流程架构图&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;img/ci/devops.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单设计了一套自动化devOps方案，其中有两个分支：&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="devOps" scheme="http://galudisu.info/categories/devOps/"/>
    
    
      <category term="gitlab" scheme="http://galudisu.info/tags/gitlab/"/>
    
      <category term="k8s" scheme="http://galudisu.info/tags/k8s/"/>
    
      <category term="jenkins" scheme="http://galudisu.info/tags/jenkins/"/>
    
      <category term="harbor" scheme="http://galudisu.info/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>2020年学习计划</title>
    <link href="http://galudisu.info/2020/03/11/learning-plan/2020_03_11_study_plan/"/>
    <id>http://galudisu.info/2020/03/11/learning-plan/2020_03_11_study_plan/</id>
    <published>2020-03-11T07:34:35.000Z</published>
    <updated>2020-03-11T09:21:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，2019制定的学习计划很糟糕，受干扰的因素太多。另外一方面是自我没有养成良好的习惯。定了7、8个任务，结果也就勉强完成了一半。</p><p>后面发现，学习之前，首先要学会如何学习，于是我硬着头皮去看完了一些如何管理时间、排除外界干扰的一些书籍，例如《刻意学习》、《行为组织管理》、《原则》等。不得不说，结合自身情况后，从书本上也看到自己很多弱点，有些弱点貌似怎么也绕不过去。譬如：</p><a id="more"></a><ol><li>三天打鱼两天晒网。这是职场人士的通病，因为只有一个原因，就是“太累”了。上班一天的脑力劳动，不知烧死了多少细胞，头发还健在不？</li><li>外界干扰。貌似这是不可避免的，例如来场说走就走的旅行，公司突然搞个活动，楼下天天大排档，大病一场… 从《原则》上所说的，如何避免重复犯错，如何进行决策，走倾向于最小风险和最大收获的方向，这是需要以后不断思考的问题。</li><li>习惯就是力量。这是真的，毕业三年后，和同学来个深度对比。就会发现，最后混的好的，不是成绩优秀的人、也不是学生会那帮饕餮之辈，而是拥有良好习惯，善于思考，做事有准备的人。这里的混得好，不是指赚了很多钱，而是能够妥善应对和解决自身的问题。例如，安置家人，发现自己的人生目标并作出成就，学会一项新技能，譬如学个车、考个外语证、打球很溜…</li><li>善于总结。</li><li>向有经验的人请教以及如何请教。</li><li>勇敢说“不”。</li><li>太快或不专心从而导致忽略了上层原理。</li></ol><p>嗯哼！天呀，我怎么这么多缺点… 不活了…</p><p>下面是正题：</p><p>去年基本看完了rust、kubernates、spring cloud、微服务、cassandra。花了比较多精力在看rust，有点难啃，而且社区还在继续改进中。另外还折腾了一下React，做了一个前后端的token登录的例子，稍微写了个vue项目(emmm… 写vue的感觉像极了打酱油)；重新折腾了以前github的一些项目。修改一些以前实现上的缺陷或不对的地方。</p><p>今年计划补完：</p><ol><li>Learning React with TypeScript (20%)</li><li>think in python (60%)</li><li>learning-go (80%)</li><li>Mathematica (20%)</li></ol><p>另外一点需要补充的，需要转变思维。学习用数学建模和算法思维解决问题。这一点是从《原则》的作者中学习得到的，任何凭直觉和自己的经验处理问题的方式，最终都是一种懒惰的技能。用数据来说服自己和他人，是最有力的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，2019制定的学习计划很糟糕，受干扰的因素太多。另外一方面是自我没有养成良好的习惯。定了7、8个任务，结果也就勉强完成了一半。&lt;/p&gt;
&lt;p&gt;后面发现，学习之前，首先要学会如何学习，于是我硬着头皮去看完了一些如何管理时间、排除外界干扰的一些书籍，例如《刻意学习》、《行为组织管理》、《原则》等。不得不说，结合自身情况后，从书本上也看到自己很多弱点，有些弱点貌似怎么也绕不过去。譬如：&lt;/p&gt;
    
    </summary>
    
    
      <category term="study" scheme="http://galudisu.info/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Flink 集群搭建教程</title>
    <link href="http://galudisu.info/2020/03/04/flink/installation/"/>
    <id>http://galudisu.info/2020/03/04/flink/installation/</id>
    <published>2020-03-03T18:44:13.000Z</published>
    <updated>2020-03-11T08:18:20.696Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="先决条件">先决条件</span></h2><p>在部署Flink之前，请确认集群的每个节点都符合以下条件：</p><ol><li>已安装Java 1.8.x或以上版本（推荐1.8版本）</li><li>节点两两之间可以SSH免密码登录</li><li>已部署Hadoop（如果只是部署Standalone Cluster则不需要Hadoop）</li></ol><p>如果你已经按照<a href="/2020/03/04/hadoop/installation.md">Hadoop集群搭建教程</a>成功建立了Hadoop集群，那么以上条件均已满足。</p><h3><span id="下载flink二进制文件">下载Flink二进制文件</span></h3><p>在Flink的<a href="https://flink.apache.org/downloads.html" target="_blank" rel="noopener">下载页面</a>中有多个版本可以选择，因为之前选择了Hadoop 2.7.7版本，所以这里选择与之对应的 <a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.12.tgz" target="_blank" rel="noopener">Apache Flink 1.9.2 for Scala 2.12</a>版本，Scala版本选择最新的2.12。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.2/flink-1.9.2-bin-scala_2.12.tgz</span><br><span class="line">tar -xzvf flink-1.9.2-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><h3><span id="配置flink">配置Flink</span></h3><blockquote><p>注意：如果只需要部署Flink on YARN，那么可以跳过这小节，因为YARN会帮你打理好一切。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/flink-1.9.2/conf</span><br></pre></td></tr></table></figure><h4><span id="flink-confyaml">flink-conf.yaml</span></h4><p>将<code>jobmanager.rpc.address</code>指向master节点，其它配置可以按照机器实际硬件情况填写，此处使用默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The host/IP of JobManager</span></span><br><span class="line"><span class="string">jobmanager.rpc.address:</span> <span class="string">huawei-01</span></span><br><span class="line"><span class="comment"># The heap size for the JobManager JVM</span></span><br><span class="line"><span class="string">jobmanager.heap.size:</span> <span class="number">1024</span><span class="string">m</span></span><br><span class="line"><span class="comment"># The heap size for the TaskManager JVM</span></span><br><span class="line"><span class="string">taskmanager.heap.size:</span> <span class="number">1024</span><span class="string">m</span></span><br><span class="line"><span class="comment"># The number of task slots that each TaskManager offers. Each slot runs one parallel pipeline.</span></span><br><span class="line"><span class="string">taskmanager.numberOfTaskSlots:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># The parallelism used for programs that did not specify and other parallelism.</span></span><br><span class="line"><span class="string">parallelism.default:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="slaves">slaves</span></h3><p>向slaves文件写入slave节点的host/IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huawei-02</span><br><span class="line">huawei-03</span><br></pre></td></tr></table></figure><h3><span id="将配置好的flink分发到其它节点">将配置好的Flink分发到其它节点</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/flink-1.9.2 huawei-02:/opt/flink-1.9.2</span><br><span class="line">scp -r /opt/flink-1.9.2 huawei-03:/opt/flink-1.9.2</span><br></pre></td></tr></table></figure><h3><span id="以standalone模式启动flink">以Standalone模式启动Flink</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $FLINK_HOME</span><br><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>然后可以在<code>huawei-01:8081</code>查看Flink集群的运行情况</p><p><img src="/img/flink/flink-dashboard.png" alt="flink-dashboard.png"></p><p><code>./examples</code>路径下游许多打包好的实例程序，可以用于验证Flink集群是否正常运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run ./exmaple/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>上面的命令会向 Flink 集群提交一个 wordcount 任务，这个示例程序可以指定输入和输出路径，这里没有指定，因此输入文件为程序自带的一小段文本，结果直接输出在屏幕上。 如果 Flink 集群工作正常，应该会在屏幕上输出以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略前面的输出</span></span><br><span class="line">(wrong,1)</span><br><span class="line">(you,1)</span><br><span class="line">Program execution finished</span><br><span class="line">Job with JobID d7df697505c1f68d4eda2828b6eb18e2 has finished.</span><br><span class="line">Job Runtime: 3158 ms</span><br><span class="line">Accumulator Results:</span><br><span class="line">- 47b31488879a3449d67aca67f5b75188 (java.util.ArrayList) [170 elements]</span><br></pre></td></tr></table></figure><h2><span id="以flink-on-yarn模式启动">以Flink on YARN模式启动</span></h2><p>把 Flink 运行在 YARN 上有两种方式，第一种方式是建立一个长期运行的 Flink YARN Session，然后向这个 Session 提交 Flink Job，多个任务同时运行时会共享资源。第二种方式是为单个任务启动一个 Flink 集群，这个任务会独占 Flink 集群的所有资源，任务结束即代表集群被回收。</p><p>另外，Flink on YARN 模式需要系统中设置了 YARN_CONF_DIR 或 HADOOP_CONF_DIR 环境变量，如果未设置，请在 <code>~/.profile</code> 中加入以下内容，然后使用 <code>source ~/.profile</code> 命令使修改立即生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在这条命令前定义HADOOP_HOME环境变量</span></span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br></pre></td></tr></table></figure><h3><span id="flink-yarn-session">Flink YARN Session</span></h3><p>由于新版本的Flink已经不包含Hadoop依赖项，需要自己添加依赖。首先下载<a href="https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-uber/2.7.5-10.0/flink-shaded-hadoop-2-uber-2.7.5-10.0.jar" target="_blank" rel="noopener">Pre-bundled Hadoop 2.7.5</a> 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd cd $FLINK_HOME/lib</span><br><span class="line">wget https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-uber/2.7.5-10.0/flink-shaded-hadoop-2-uber-2.7.5-10.0.jar</span><br></pre></td></tr></table></figure><p>使用下列命令来启动一个拥有 2 个 TaskManager 的 Flink 集群，每个 TaskManager 有 2 GB 内存，2 个 slot。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/YARN-session.sh -n 2 -jm 1024m -tm 2048</span><br></pre></td></tr></table></figure><p>完整的参数列表如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">   Required</span><br><span class="line">     -n,--container &lt;arg&gt;   Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">   Optional</span><br><span class="line">     -D &lt;arg&gt;                        Dynamic properties</span><br><span class="line">     -d,--detached                   Start detached</span><br><span class="line">     -jm,--jobManagerMemory &lt;arg&gt;    Memory for JobManager Container with optional unit (default: MB)</span><br><span class="line">     -nm,--name                      Set a custom name for the application on YARN</span><br><span class="line">     -q,--query                      Display available YARN resources (memory, cores)</span><br><span class="line">     -qu,--queue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -s,--slots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -tm,--taskManagerMemory &lt;arg&gt;   Memory per TaskManager Container with optional unit (default: MB)</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths for HA mode</span><br></pre></td></tr></table></figure><p>启动 YARN Session 以后会输出 JobManager 的 Web Interface 地址，打开以后是这样的：</p><p><img src="/img/flink/tracking-ui.png" alt="hadop-application"></p><p><img src="/img/flink/yarn-session.png" alt="yarn-session.png"></p><p>仔细一看，Task Managers，Task Slots 怎么都是 0 呢？难道是哪里出了问题？其实并没有问题，从某个版本开始 Flink 允许动态分配资源，在没有任务的时候不分配 TaskManager。接下来我们就提交一个任务试试。</p><p>因为启动 YARN Session 以后 Flink Client 会一直在前台运行，所以先用 <code>Ctrl + Z</code> 快捷键把 Client 转到后台，然后再提交任务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p><img src="/img/flink/wordcount-job.png" alt="wordcount-job.png"></p><p>在任务运行期间观察 Web Interface，会发现 Task Managers 变为 1，Task Slots 变为 2 ，与启动集群时指定的参数不符，这是因为 YARN 集群中只有两个 NodeManager，huawei-02 和 huawei-03，其中一个作为 JobManager，因此只剩一个节点可以作为 TaskManager。</p><p>任务的运行结果和 Standalone 模式下完全一样。</p><h3><span id="single-flink-job-on-yarn">Single Flink job on YARN</span></h3><p>下面这条命令会为 wordcount 任务启动一个独占的 Flink 集群，任务结束集群即被回收。其中 -m 选项指定 Flink 集群的启动模式，-yn 选项指定 TaskManager 的数目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -m YARN-cluster -yn 2 ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>任务的运行结果和 Standalone 模式下完全一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;先决条件&quot;&gt;先决条件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在部署Flink之前，请确认集群的每个节点都符合以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;已安装Java 1.8.x或以上版本（推荐1.8版本）&lt;/li&gt;
&lt;li&gt;节点
      
    
    </summary>
    
    
      <category term="flink" scheme="http://galudisu.info/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 集群搭建教程</title>
    <link href="http://galudisu.info/2020/03/04/hadoop/installation/"/>
    <id>http://galudisu.info/2020/03/04/hadoop/installation/</id>
    <published>2020-03-03T16:44:13.000Z</published>
    <updated>2020-03-11T08:18:20.698Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>这篇文章介绍了搭建一个三节点Hadoop集群时的顺序，三台机为内网IP。对应的hostname分别为huawei-01，huawei-03，huawei-03。其中第一台作为master，后面两台作为slaves。</p><h2><span id="先决条件">先决条件</span></h2><p>在安装Hadoop之前，请确认集群的每台机器上均安装JDK，以及搭配环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Java Environment</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64/</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>另外，需要在三台机器<code>/etc/hosts</code>写入对应机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 三台机的私有网络IP</span><br><span class="line"></span><br><span class="line">192.168.0.125huawei-02</span><br><span class="line">192.168.0.160huawei-01</span><br><span class="line">192.168.0.56huawei-03</span><br></pre></td></tr></table></figure><p>还要修改对应hostname，因为DataNode上的日志文件后解释hostname（不知是不是这原因）。</p><h2><span id="下载二进制文件">下载二进制文件</span></h2><p>Hadoop有很多版本选择，考虑会后续Hadoop会部署其它应用，所以选择兼容性最好的2.7.7版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz</span><br><span class="line">tar -zxvf hadoop-2.7.7.tar.gz -C .</span><br></pre></td></tr></table></figure><h2><span id="修改配置文件">修改配置文件</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> Flink Environment</span></span><br><span class="line">export HADOOP_HOME=/opt/hadoop-2.7.7</span><br><span class="line">export PATH=$PATH:$&#123;HADOOP_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/sbin</span><br></pre></td></tr></table></figure><h3><span id="core-sitexml">core-site.xml</span></h3><p>指定NameNode的IP地址和端口号，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://huawei-01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="hdfs-sitexml">hdfs-site.xml</span></h3><p><code>dfs.replication</code> 指定备份数目为 3，<code>dfs.name.dir</code> 指定 NameNode 的文件存储路径，<code>dfs.data.dir</code> 指定 DataNode 的文件存储路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/opt/hadoop-2.7.7/data/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/opt/hadoop-2.7.7/data/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="mapred-sitexml">mapred-site.xml</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p>然后修改<code>mapred-site.xml</code>的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="yarn-sitexml">yarn-site.xml</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8025<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>huawei-01:8050<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="slaves">slaves</span></h3><p>添加slave节点的hostname到该文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huawei-02</span><br><span class="line">huawei-03</span><br></pre></td></tr></table></figure><h3><span id="hadoop-envsh"></span></h3><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64/</span><br></pre></td></tr></table></figure><h2><span id="分发配置文件">分发配置文件</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/hadoop-2.7.7 huawei-02:/opt/hadoop-2.7.7</span><br><span class="line">scp -r /opt/hadoop-2.7.7 huawei-03:/opt/hadoop-2.7.7</span><br></pre></td></tr></table></figure><h2><span id="启动集群">启动集群</span></h2><h3><span id="格式化hdfs">格式化HDFS</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><h3><span id="启动集群">启动集群</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><p>使用jps命令查看服务运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master节点中运行的服务</span></span><br><span class="line">25928 SecondaryNameNode</span><br><span class="line">25742 NameNode</span><br><span class="line">26387 Jps</span><br><span class="line">26078 ResourceManager</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slave节点中运行的服务</span></span><br><span class="line">24002 NodeManager</span><br><span class="line">23899 DataNode</span><br><span class="line">24179 Jps</span><br></pre></td></tr></table></figure><h2><span id="提交示例任务">提交示例任务</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/hadoop-2.7.7</span><br><span class="line">hdfs dfs -mkdir /wordcount/input</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把当前路径下的 LICENSE.txt 文件复制到 HDFS 中</span></span><br><span class="line">hadoop fs -put ./LICENSE.txt /wordcount/input</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交任务，最后两个参数分别指定任务的输入和输出</span></span><br><span class="line">hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /wordcount/input /wordcount/output</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看输出路径</span></span><br><span class="line">hadoop fs -ls /wordcount/output</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果一切正常，该路径下包含两个文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个文件是空文件，表示任务运行成功</span></span><br><span class="line">/wordcount/output/_SUCCESS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个文件是输出文件，统计了 LICENSE.txt 中每个单词出现的次数</span></span><br><span class="line">/wordcount/output/part-r-00000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这篇文章介绍了搭建一个三节点Hadoop集群时的顺序，三台机为内网IP。对应的hostname分别为huawei-01，huawei-03，huawei-03。其中第一台作为master，后面两台作为slaves。&lt;/p&gt;
&lt;h2&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="hadoop" scheme="http://galudisu.info/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Akka Typed 协议和行为</title>
    <link href="http://galudisu.info/2020/01/03/akka/typed/akka-typed/"/>
    <id>http://galudisu.info/2020/01/03/akka/typed/akka-typed/</id>
    <published>2020-01-03T06:26:45.000Z</published>
    <updated>2020-02-18T05:02:16.095Z</updated>
    
    <content type="html"><![CDATA[<p>2019年11月6号LightBend公司发布了AKKA 2.6版本，带来了类型安全的actor，新的Akka Cluster底层通信设施——Artery，带来了更好的稳定性，使用Jackson进行消息序列化，支持SLF4J日志接口。</p><h2><span id="why-akka-typed">Why Akka Typed</span></h2><p>actor编程模型是一个强有力的抽象模型，尤其擅长解决真实世界建模，容错、并发、分布式系统问题。actor抽象编程模型构建于在互相独立的actor之间发送消息的基础之上，actor可以创建子actor，并负责监管，当子actor出现错误的时候可以重启或者重新创建，这套容错机制给整个actor系统带来了自愈能力。</p><p>经典的Akka actor API非常简单，就是提供一组处理和接收消息的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the Actor trait (AbstractActor class in Java) is the entry point for using the API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// receive方法处理消息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> order @ <span class="type">OrderProcessor</span>.<span class="type">ProcessOrder</span> =&gt;</span><br><span class="line">  <span class="comment">// actor方法繁衍新的actor</span></span><br><span class="line">  <span class="keyword">val</span> connection = context.actorOf(</span><br><span class="line">    <span class="type">BankConnection</span>.props(order.bankIndentifier)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// !方法表示即发即弃</span></span><br><span class="line">  connection ! <span class="type">BankConnection</span>.<span class="type">ExecuteOrder</span>(order)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种编程模型和API在多线程环境中具有显著的优势，每个actor顺序处理接收到的消息，actor的内部状态也只有它本身可以修改，这比并发的修改共享状态容易多了。</p><p>天下没有免费的午餐，actor编程模型也有它的缺点，槽点在这篇文章中有提到：<a href="https://manuel.bernhardt.io/2017/05/29/akka-anti-patterns-overview/" target="_blank" rel="noopener">Akka anti-patterns series</a></p><p>这些年来我在一些稍微大一些的Akka工程中见到的最大的问题是actor系统随着业务越做越大，并且非常难以扩展。根本原因是这套Akka API没有强制用户采用“协议优先”的规范。实际上Akka官方教程里最先讲述的就是清晰的定义组件之间的通信协议（也就是消息），并使用全路径访问消息。已上面的例子来说，OrderProcessor的通信协议定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伴生对象存放了消息的定义</span></span><br><span class="line"><span class="comment">// 对于集群或持久化系统，消息定义需要使用合适的序列化机制，譬如protobuf</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">  <span class="title">final</span> <span class="title">case</span> <span class="title">class</span> <span class="title">ProcessOrder</span>(<span class="params">bank: <span class="type">BankId</span>, fromAccount: <span class="type">AccountId</span>, toAccount: <span class="type">AccountId</span>, amount: <span class="type">Amount</span></span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>即便你遵照Akka最佳实践，但还是无法保证给actor发送一些它不支持消息，actor的receive方法会接受任意类型的消息，当它收到不支持的消息时，便自动转给unhandled方法，此方法默认只会打日志记录一下（需要正确的配置日志打印机制），这对新人来说太坑了，你找不到任何错误，但是系统就是无法正常工作。</p><p>更深层次的原因在于缺少一种机制来帮助我们维护actor之间的通信协议。随着消息类型增多，很容易忘记这些actor都支持什么类型的消息。通过单元测试和严格的日志级别会有助于缓解这种问题（只要接受到不支持的消息就打warn日志），但是仍然无法完全避免。</p><p>Akka Typed就是为了解决这个问题，新的API是为“协议优先”设计的，在实现功能之前，你必须花一点时间想一想每一个actor要处理哪些消息。经典的Actor API的最佳实践也是如此，但却是可选的，你需要在实现的过程中使要处理消息条理清晰。</p><p>看过许多真实的Akka System分享之后，有一点必须强调一下：开发Akka Typed的目的不仅仅是为了以结构化的方式组织消息以及防止丢失那一点点actor不支持的消息，它的主要目的是引导我们优先考虑系统设计。设计一组恰到好处的actor，适当的通信粒度，正确的消息模式，这样就可以构建一个强大的系统，但是它的核心却非常简单，就像高考一样简单。但是我见到太多过度设计，大家倾向于设计过多的actor以及消息，引入了不必要的复杂度，最后尾大不掉。</p><h2><span id="lets-build-a-payment-processor">Let’s build a payment processor</span></h2><p>前面我们已经讲过使用Akka Typed可以非常容易的定义协议，但什么是“协议”呢？协议仅仅是“消息”吗？简单来说协议就是：定义一组消息，在两个及以上的组件之间按特定的顺序和组合传递。常见的协议有TCP、HTTPS等，而我们定义的是应用层的协议。你可以认为协议就是增强版的API：API只定义了个体之间的调用格式（参数、请求内容、响应内容等），协议描述了怎么通过组件之间的相互调用使系统到达期望的状态。</p><p>在Akka Typed API中，协议由一组消息class和对应类型的actor组成。下面的例子展示了从configuration组件获取配置数据的协议：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">case</span> <span class="title">class</span> <span class="title">RetrieveConfiguration</span>(<span class="params">merchantId: <span class="type">MerchantId</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">ConfigurationResponse</span>]</span>) <span class="keyword">extends</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">sealed</span> <span class="title">trait</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">case</span> <span class="title">class</span> <span class="title">ConfigurationFound</span>(<span class="params">merchantId: <span class="type">MerchantId</span>,  merchantConfiguration: <span class="type">MerchantConfiguration</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">case</span> <span class="title">class</span> <span class="title">ConfigurationNotFound</span>(<span class="params">merchanId: <span class="type">MerchantId</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">MerchantId</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">BankIdentifier</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">MerchantConfiguration</span>(<span class="params">bankIdentifier: <span class="type">BankIdentifier</span></span>)</span></span><br></pre></td></tr></table></figure><p>这个例子遵循了请求-响应的消息设计模式，欲知更多详情，请参见本书：<a href="https://www.manning.com/books/reactive-design-patterns" target="_blank" rel="noopener">Reactive Design Patterns</a></p><p>如果你以前用过经典的Actor API，你会发现这里的实现方式有两个不同的地方，第一个是消息发送者的引用包含在消息的定义中，经典的Actor API是通过Akka提供的sender()方法来获取发送者的。第二个是消息class中包含的ActorRef是有类型的，发送者使用它的时候就可以清楚的知道应该发送什么类型的消息。我们使用接口ConfigurationResponse定义了配置数据的返回格式，它有两个实现类，这样发送者就可以发送两种格式的消息。</p><p>看了Actor的定义之后，就能理解为什么Akka Typed比经典的Actor更容易且更安全的解决协议问题，Configuration的定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义的actor继承<code>AbstractBehavior</code>，并带有指定的类型，它只能处理<code>ConfigurationMessage</code>类型的消息，编译器可以帮助我们检查消息的发送者发送的消息是否正确。</p><p>上面的例子中我们使用面向对象的编程方式定义了Actor，稍后我们会展示函数式编程风格。</p><h2><span id="implementing-our-first-typed-actor">Implementing our first typed actor</span></h2><p><code>Configuration</code>提供查询功能：根据商户Id查询支付方式。我们继续使用面向对象的编程方式，如果使用过经典的Akka API，你对这种使用方式应该非常熟悉。</p><p>继承<code>AbstractBehavior</code>就必须实现<code>onMessage</code>方法，它返回一个<code>Behavior</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the AbstractBehavior trait is the entry point for using the object-oriented style API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the mutable state here holds the configuration values of each merchant we know about</span></span><br><span class="line">  <span class="keyword">var</span> configurations: <span class="type">Map</span>[<span class="type">MerchantId</span>, <span class="type">MerchantConfiguration</span>] = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the onMessage method defines the initial behavior applied to a message upon reception</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">ConfigurationMessage</span>): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = msg <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RetrieveConfiguration</span>(merchantId, replyTo) =&gt;</span><br><span class="line">      configurations.get(merchantId) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(configuration) =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationFound</span>(merchantId, configuration)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationNotFound</span>(merchantId)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// lastly, return the Behavior to be applied to the next received message</span></span><br><span class="line">      <span class="comment">// in this case, that's just the same Behavior as we already have</span></span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个actor与我们在本文开头使用经典的actor API定义的actor非常相似：覆盖onMessage方法，并根据指定的消息类型做出对应的响应。</p><p>不同点在于onMessage对应的方法返回的是一个Behavior，一个actor接收到消息之后的行为包含如下3个步骤：</p><p>发送一条或多条消息给其他的actor<br>创建子acotr<br>返回一个新的行为，准备接收下一个消息<br>在Akka Typed API中，一个Behavior即代表了处理当前消息的行为，也表明了如何处理下一个消息——通过返回一个新的Behavior。也可以只是返回当前行为（就像上面的例子一样），因为使用面向对象风格的actor继承自AbstractBehavior，它本身就是一个Behavior，所以可以使用return this。</p><p>本系列教程后面会讨论更多关于Behavior的用法，使用Akka Typed API定义的actor的一个优点就是非常容易组合和测试。</p><p>Typed Akka TestKit可以帮助你轻而易举的对actor进行测试：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationSpec</span> <span class="keyword">extends</span> <span class="title">ScalaTestWithActorTestKit</span> <span class="keyword">with</span> <span class="title">WordSpecLike</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">"The Configuration actor"</span> should &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"not find a configuration for an unknown merchant"</span> in &#123;</span><br><span class="line">      <span class="comment">// define a probe which allows it to easily send messages</span></span><br><span class="line">      <span class="keyword">val</span> probe = createTestProbe[<span class="type">ConfigurationResponse</span>]()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// spawn a new Configuration actor as child of the TestKit's guardian actor</span></span><br><span class="line">      <span class="keyword">val</span> configurationActor = spawn(<span class="type">Configuration</span>())</span><br><span class="line"></span><br><span class="line">      <span class="comment">// send a message to the actor under test with the probe's reference as sender</span></span><br><span class="line">      configurationActor ! <span class="type">Configuration</span>.<span class="type">RetrieveConfiguration</span>(<span class="type">MerchantId</span>(<span class="string">"unknown"</span>), probe.ref)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// expect a certain type of message as response. there are many different ways to retrieve</span></span><br><span class="line">      <span class="comment">// or to expect messages</span></span><br><span class="line">      <span class="keyword">val</span> response = probe.expectMessageType[<span class="type">Configuration</span>.<span class="type">ConfigurationNotFound</span>]</span><br><span class="line">      response.merchanId shouldBe <span class="type">MerchantId</span>(<span class="string">"unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="supervising-and-starting-the-actor">Supervising and starting the actor</span></h2><p>actor System为actor提供运行环境、分配资源、基础设施。在这个系统中，每一个actor都有一个父actor，最顶层的actor叫做根节点（<code>root</code>)，使用<code>/</code>代表，它的两个直接子actor是<code>/user</code>和<code>/system</code>，<code>/user</code>用于在用户空间创建子actor，<code>/system</code>属于akka系统内部管理，所以我们创建的所有的actor都从属于<code>/user</code>。</p><p>Akka Typed与经典的Actor API有一个非常重要的不同点：<code>/user</code>的处理逻辑。在经典的Akka API中，Akka提供的<code>/useractor</code>负责监管一切；但是Akka Typed把这个权力交给了用户。也就是说应用程序的开发者在实现actor的时候同时也必须多考虑一下actor都会有哪些行为。</p><p>在创建<code>Configuration</code> actor的时候，我们大可以直接把它传给<code>ActorSystem</code>并把它作为监管者，但当创建更多actor的时候，这些actor全部都由<code>Configuration</code> actor监管就不合适了。而且在actor模型中父监管机制采用级联的方式处理actor失败的问题：父actor负责决定如何处理子actor（当它抛异常的时候），因此如何对actor分组直接影响了监管策略。同样的我们应该使用一个专用的父actor做为监管actor，由它来决定如何处理子actor的失败问题。Akka Typed API中默认的监管策略是停止失败的子actor（经典的Akka API是重启）。由我们指定监管actor可以开发更灵活的监管策略，根据不同的异常做出相应的决策。综上所述我们决定使用<code>PaymentProcessor</code> actor做为所有actor的监管者，actor层级如下图所示：</p><p>![/img/akka/typed/supervison.png]</p><p><code>PaymentProcessor</code>的功能目前非常简单，启动的时候创建一个子actor——Configuration，它是无状态的，也不接收任何消息，这次我们使用函数式编程的风格，无需继承任何接口，只需要返回一个Behavior：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PaymentProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="type">Behaviors</span>.setup[<span class="type">Nothing</span>] &#123; context =&gt;</span><br><span class="line">    context.log.info(<span class="string">"Typed Payment Processor started"</span>)</span><br><span class="line">    context.spawn(<span class="type">Configuration</span>(), <span class="string">"config"</span>)</span><br><span class="line">    <span class="type">Behaviors</span>.empty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Behaviors.setup()</code>方法是创建<code>Behavior</code>的入口，该方法包含一个<code>ActorContext</code>变量，我们用它打日志，记录actor已经启动，并使用<code>spawn()</code>方法创建了一个<code>Configuration actor</code>，第一个参数用于创建actor，第二个参数是actor的名字，它在actor路径中是<code>/user/config</code>。</p><p>因为<code>PaymentProcessor</code>不处理任何消息，所以这里使用了<code>setup[Nothing]</code>。</p><p><code>Configuration</code> actor使用静态的create函数创建<code>Behavior</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Configuration</span>(context))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在万事俱备，只欠东风，需要启动<code>ActorSystem</code>来创建我们的监管actor。Akka提供了静态方法用来创建监管actor：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ActorSystem</span>[<span class="type">Nothing</span>](<span class="type">PaymentProcessor</span>(), <span class="string">"typed-payment-processor"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞定！现在运行<code>Main</code>方法，就可以看到<code>PaymentProcessor</code>启动了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[info] Running io.bernhardt.typedpayment.Main</span><br><span class="line">[INFO] [07/10/2019 09:36:42.483] [typed-payment-processor-akka.actor.default-dispatcher-5] [akka://typed-payment-processor/user] Typed Payment Processor started</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年11月6号LightBend公司发布了AKKA 2.6版本，带来了类型安全的actor，新的Akka Cluster底层通信设施——Artery，带来了更好的稳定性，使用Jackson进行消息序列化，支持SLF4J日志接口。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;w
      
    
    </summary>
    
      <category term="akka" scheme="http://galudisu.info/categories/akka/"/>
    
    
      <category term="akka-typed" scheme="http://galudisu.info/tags/akka-typed/"/>
    
  </entry>
  
  <entry>
    <title>第八章 React Redux</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_8_React_Redux/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_8_React_Redux/</id>
    <published>2019-11-27T07:50:08.000Z</published>
    <updated>2020-03-26T06:10:41.816Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Principles and key concepts</li><li>Installing Redux</li><li>Creating reducers</li><li>Creating actions</li><li>Creating a store</li><li>Connecting our React App to the store</li><li>Managing state with use Reducer</li></ul><h2><span id="principles-and-key-concepts">Principles and key concepts</span></h2><h3><span id="principles">Principles</span></h3><p>Redux的三大原则：</p><ul><li><strong>Single source of truth</strong>：意味着整个项目的状态被存储在一个单一对象。在一个真实应用系统中，这个对象很可能包含了一个复杂的内嵌对象树。</li><li><strong>State is read-only</strong>：意味着状态不能被直接改变。就是说不能通过组件来改变状态。在Redux中，唯一能改变状态的方法是通过action进行传递(dispatch)。</li><li><strong>Changes are made with pure functions</strong>：那些能够改变状态的函数被称为“<code>reducer</code>”。</li></ul><p>接下来的环节，会深入介绍action和reducer以及消息的store内容。</p><h3><span id="key-concepts">Key concepts</span></h3><p>Redux内存活的整个应用的状态被称为一个<code>store</code>。状态被存储在一个JavaScript对象中，形式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  products: [&#123; id: 1, name: "Table", ...&#125;, &#123;...&#125;, ...],</span><br><span class="line">  productsLoading: false,</span><br><span class="line">  currentProduct: &#123; id: 2, xname: "Chair", ... &#125;,</span><br><span class="line">  basket: [&#123; product: &#123; id: 2, xname: "Chair" &#125;, quantity: 1 &#125;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态不会包含有任何函数、setter或者getter。它就是一个简单的JavaScript对象。</p><p>要更新一个store中的state，就是派遣一个<strong>action</strong>。其中action又是另外一个简单的JavaScript对象，格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: "PRODUCTS/LOADING"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type</code>属性决定了哪种action需要被处理。<code>type</code>是必须的，否则reducer不知道如何改变状态。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: "PRODUCTS/GETSINGLE",</span><br><span class="line">  product: &#123; id: 1, name: "Table", ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个带有一个额外的属性值，因为reducer除了要知道action的类型外，还要获取更新的内容。</p><p>因此，reducer是纯函数。</p><blockquote><p>纯函数就是不依赖于外部自由变量的函数，对于给定的输入，总能得到相同的结果。</p></blockquote><p>下面是reducer的一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export const productsReducer = (state = initialProductState, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;PRODUCTS/LOADING&quot;: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...state,</span><br><span class="line">productsLoading: true</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;PRODUCTS/GETSINGLE&quot;: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...state,</span><br><span class="line">currentProduct: action.product,</span><br><span class="line">productsLoading: false</span><br><span class="line">  &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">default:</span><br><span class="line">  &#125;</span><br><span class="line">  return state || initialProductState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于reducer有几点：</p><ul><li>reducer接收两个参数，current state 和要处理的action</li><li>reducer第一次被调用时，state参数默认为一个初始化状态对象</li><li>这里需要使用switch语句处理不同的action类型</li><li>返回语句表示创建一个新的状态覆盖原来已有的状态属性</li><li>reducer返回新的(更新的)状态</li></ul><p>你会注意action和reducer都不是TypeScript类型的。下面开始实战。</p><h2><span id="installing-redux">Installing Redux</span></h2><p>在使用Redux之前，需要安装依赖项。另外还需要安装一个库<code>redux-thunk</code>，以实现异步的ation:</p><ol><li>安装redux,</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux</span><br></pre></td></tr></table></figure><ol start="2"><li>安装具体的redux的关联框架，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add rect-redux</span><br></pre></td></tr></table></figure><ol start="3"><li>对应TS，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @types/react-redux</span><br></pre></td></tr></table></figure><ol start="4"><li>安装<code>redux-thunk</code>，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux-thunk</span><br><span class="line">yarn add -D @types/redux-thunk</span><br></pre></td></tr></table></figure><h2><span id="creating-actions">Creating actions</span></h2><p>这里将沿用前面章节使用的代码，将Redux集成到产品页面上。本小节，我们会创建action获取产品内容。以及使用另外一个action更改新的状态。</p><p>在此之前，首先在<code>ProductsData.ts</code>创建一个假的API，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts = <span class="keyword">async</span> (): <span class="built_in">Promise</span>&lt;IProduct[]&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数异步等待返回的产品信息。</p><h3><span id="creating-state-and-action-types">Creating state and action types</span></h3><p>下面使用Redux来增强React shop。首先，创建一些state类型，以及action类型。</p><ol><li>在<code>src</code>文件夹创建一个新的文件<code>ProductsTypes.ts</code>，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IProduct &#125; <span class="keyword">from</span> <span class="string">"./ProductsData"</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加两种不同类型的action枚举，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> ProductsActionTypes &#123;</span><br><span class="line">  GETALL = <span class="string">"PRODUCTS/GETALL"</span>,</span><br><span class="line">  LOADING = <span class="string">"PRODUCTS/LOADING"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redux并没有要求action类型为字符串形式。这里我们选择用字符串来表述。同时要确保字符串是全局唯一的。我们定义的字符串中包含了两点重要信息：</p><ul><li>存储的action被关联。这里它是<code>PRODUCTS</code>。</li><li>特定的具体操作被指示。这里，<code>GETALL</code>表示获取所有商品，<code>LOADING</code>表示商品正在获取中。</li></ul><p>当然我们也可以写成类似<code>PRODUCTS-GETALL</code>或者<code>Get All Products</code>。我们只需要确保字符串是唯一的。</p><ol start="3"><li>下面为上述两种Action定义接口：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsGetAllAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: ProductsActionTypes.GETALL,</span><br><span class="line">  products: IProduct[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsLoadingAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: ProductsActionTypes.LOADING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IProductsGetAllAction</code>用作获取商品时的派遣动作。<code>IProductsLoadingAction</code>用作加载状态。</p><ol start="4"><li>组合为一个新的union type:</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ProductsActions = </span><br><span class="line">  | IProductsGetAllAction</span><br><span class="line">  | IProductsLoadingAction</span><br></pre></td></tr></table></figure><p>该类型将被传递在reducer的参数上。</p><ol start="5"><li>最后，为这种存储状态创建一个接口：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProductsState &#123;</span><br><span class="line">  readonly products: IProduct[];</span><br><span class="line">  readonly productsLoading: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的state将包含了一组商品信息，以及商品是否正在加载。</p><p>注意到属性前面引入了<code>readonly</code>关键字。它帮助我们避免对状态的直接修改。</p><p>有了state和action的类型后，接下来创建一些具体的action。</p><h3><span id="creating-actions">Creating actions</span></h3><p>本小节，将创建两个action。获取商品的action，商品处于加载的action。</p><ol><li>创建一个<code>ProductsActions.ts</code>文件，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ActionCreator, AnyAction, Dispatch &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br></pre></td></tr></table></figure><p>这里用到几个action类型需要实现。</p><ol start="2"><li>其中一个action用作异步操作。需要导入<code>redux-thunk</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ThunkAction &#125; <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外导入之前的模拟API。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getProducts <span class="keyword">as</span> getProductsFromAPI &#125; <span class="keyword">from</span> <span class="string">"./ProductsData"</span>;</span><br></pre></td></tr></table></figure><p>这里需要重命名<code>getProductsFromAPI</code>，避免和<code>getProducts</code>的action冲突。</p><ol start="4"><li>将先前定义的action类型导入。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IProductsGetAllAction, IProductsLoadingAction, IProductsState, ProductsActionTypes &#125; <span class="keyword">from</span> <span class="string">"./ProductsTypes"</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>接下来，创建一个action creator，顾名思义：它是一个函数，创建并返回一个action！</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading: ActionCreator&lt;IProductsLoadingAction&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: ProductsActionTypes.LOADING</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>我们使用了泛型<code>ActionCreator</code>作为函数签名</li><li>函数仅仅返回要求的action对象</li></ul><p>还可以使用隐式返回语句另函数更为简洁</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading: ActionCreator&lt;IProductsLoadingAction&gt; = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: ProductsActionTypes.LOADING,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们将用到这个简短语法用于action creator的实现。</p><ol start="6"><li>添加另一个action creator的实现，这稍微更复杂一些：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>因为这里的action是异步的，需要进行一层包装。这里使用了<code>ThunkAction</code>泛型类型来包装同步action，它包含4个参数：</p><ul><li>第一个参数是返回类型，理想上应该是<code>Promise&lt;IProductsGetAllAction&gt;</code>。然而，TypeScript编译器无法处理，因此折中放宽为<code>Promise&lt;AnyAction&gt;</code>类型。</li><li>第二个参数为关联的state接口。</li><li>第三个参数是传递给到action creator的函数参数的类型，因为我们的action creator没有定义参数，这里传递null。</li><li>最后一个参数是action的类型。</li></ul><p>我们对这些action creator进行暴露，因为最终会被<code>ProductsPage</code>组件调用。</p><ol start="7"><li>异步action需要返回一个异步函数，最终派遣我们的action：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，函数第一件事是返回另一个函数，使用<code>async</code>关键字标记为异步的。内部函数以Dispatcher作为回调参数。</p><ol start="8"><li>下面实现内部函数：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProducts: ActionCreator&lt;ThunkAction&lt;</span><br><span class="line">  <span class="built_in">Promise</span>&lt;AnyAction&gt;,</span><br><span class="line">  IProductsState,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  IProductsGetAllAction</span><br><span class="line">&gt;&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">    dispatch(loading());</span><br><span class="line">    <span class="keyword">const</span> products = <span class="keyword">await</span> getProductsFromAPI();</span><br><span class="line">    <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">      products,</span><br><span class="line">      <span class="keyword">type</span>: ProductsActionTypes.GETALL,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>首先做的，dispatch 启动action，以得到最终的loading state。</li><li>然后异步的方式，从模拟API获取商品信息</li><li>最后一步dispatch 要求的action。</li></ul><p>目前创建了好几个action了，接下来创建相应的reducer。</p><h3><span id="creating-reducers">Creating reducers</span></h3><p>一个reducer，就是一个传入给定的action，产生新的state的一个函数。因此，这个函数在当前state，接收了一个action，返回新的state。</p><ol><li>在<code>src</code>目录新建文件<code>ProductsReducer.ts</code>：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Reducer &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IProductsState, ProductsActions, ProductsActionTypes &#125; <span class="keyword">from</span> <span class="string">"./ProductsTypes"</span>;</span><br></pre></td></tr></table></figure><p>这里导入了<code>Reducer</code>依赖，以及前面定义的action和state。</p><ol start="2"><li>定义初始state：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialProductState: IProductsState = &#123;</span><br><span class="line">  products: [],</span><br><span class="line">  productsLoading: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始状态下，商品信息为空数组，处于非加载状态。</p><ol start="3"><li>接下来创建reducer函数：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> productsReducer: Reducer&lt;IProductsState, ProductsActions&gt; = (</span><br><span class="line">  state = initialProductState,</span><br><span class="line">  action</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line"><span class="comment">// TODO - change the state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>该函数返回<code>Reducer</code>，包含有state和action。</li><li>函数接收的参数由Redux提供。</li><li>状态默认为初始化时的状态。</li><li>对于不能识别的switch语句，返回默认的state。</li></ul><ol start="4"><li>实现我们商品的reducer：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ProductsActionTypes.LOADING: &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line">productsLoading: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ProductsActionTypes.GETALL: &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line">products: action.products,</span><br><span class="line">productsLoading: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为每个action实现了对应的reducer，合并旧的state，并返回一个新的state。</p><p>这样，我们的第一个reducer完成了。接下来创建我们的store。</p><h3><span id="creating-a-store">Creating a store</span></h3><p>本小节，将创建一个store，用于存放我们的state并管理这些action和reducer：</p><ol><li>新建文件<code>Store.tsx</code>文件，导入相应的需要的组件。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; applyMiddleware, combineReducers, createStore, Store &#125; from &quot;redux&quot;;</span><br></pre></td></tr></table></figure><ul><li><code>createStore</code> 创建store的函数</li><li>我们需要<code>applyMiddleware</code>函数，因为我们使用了redux thunk中间件来管理异步action。</li><li><code>combineReducers</code>函数用于合并reducer</li><li><code>Store</code>是一个TypeScript版的store对象</li></ul><ol start="2"><li>导入<code>redux-thunk</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import thunk from &quot;redux-thunk&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后，导入reducer和state，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; productsReducer &#125; from &quot;./ProductsReducer&quot;;</span><br><span class="line">import &#123; IProductsState &#125; from &quot;./ProductsTypes&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>store的关键部分是state。因此，定义一个接口：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export interface IApplicationState &#123;</span><br><span class="line">  products: IProductsState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口仅仅包含了商品的state。</p><ol start="5"><li>将reducer添加到Redux的<code>combineReducer</code>函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const rootReducer = combineReducers&lt;IApplicationState&gt;(&#123;</span><br><span class="line">  products: productsReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>定义好state和reducer后，我们可以创建我们的store了。实际上我们是创建一个函数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default function configureStore(): Store&lt;IApplicationState&gt; &#123;</span><br><span class="line">  const store = createStore(rootReducer, undefined, applyMiddleware(thunk));</span><br><span class="line">  return store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>configureStore</code>返回泛型<code>Store</code></li><li>Redux中的函数<code>createStore</code>，我们传入定义的reducer以及Redux Thunk中间件，传递<code>undefined</code>作为初始化状态。</li></ul><p>接下来，如何连接到我们创建的store？</p><h2><span id="connecting-our-react-app-to-the-store">Connecting our React app to the store</span></h2><p>在本小节，我们将<code>Products</code>页面连接到store。第一件要做的工作室添加React Redux的<code>Provider</code>组件。</p><h3><span id="adding-the-store-provider-component">Adding the store Provider component</span></h3><p><code>Provider</code>组件可以在它任意下层的组件传递store。因此，本小节，需要将<code>Provider</code>添加到组件的最高层级，这样其它组件都可以访问。</p><ol><li>打开原先的<code>index.tsx</code>，导入<code>Provider</code>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from &quot;react-redux&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>另外把<code>Store</code>也导入进来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Store &#125; from &quot;redux&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>其它用到的store和state也导入进来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import configureStore from &quot;./Store&quot;;</span><br><span class="line">import &#123; IApplicationState &#125; from &quot;./Store&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建一些功能组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  store: Store&lt;IApplicationState&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Root: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  return();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>Root</code>组件将会成为我们新的root element。它将store作为一个prop。</p><ol start="5"><li>这样一来，我们需要导入旧的根元素，<code>Routes</code>，放置在新的root组件中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Root: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Routes /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外还要把<code>Provider</code>组件加进来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;Provider store=&#123;props.store&#125;&gt;</span><br><span class="line">    &lt;Routes /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在已经将<code>Provider</code>组件的最上层，以及将store传递进去。</p><ol start="7"><li>另外还要更改根部渲染函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const store = configureStore();</span><br><span class="line">ReactDOM.render(&lt;Root store=&#123;store&#125; /&gt;, document.getElementById(&quot;root&quot;) as HTMLElement);</span><br></pre></td></tr></table></figure><p>首先通过<code>configureStore</code>函数创建了全局的store，并将它传递给<code>Root</code>组件。</p><p>这样一来，所有组件都已经连接到了这个store。接下来，需要需要在其它子层组件中对其进行连接。</p><h3><span id="connecting-components-to-the-store">Connecting components to the store</span></h3><h4><span id="connecting-productspage-to-the-store">Connecting ProductsPage to the store</span></h4><p>首先连接的组件是<code>ProductsPage</code>,</p><p>下面开始对其进行重构，</p><ol><li>导入<code>connect</code>函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &quot;react-redux&quot;;</span><br></pre></td></tr></table></figure><p>我们将使用<code>connect</code>将<code>ProductsPage</code>连接到store。</p><ol start="2"><li>导入store的state，以及<code>getProducts</code>action creator。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IApplicationState &#125; from &quot;./Store&quot;;</span><br><span class="line">import &#123; getProducts &#125; from &quot;./ProductsActions&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>组件<code>ProductPage</code>不再包含任何state，因为将由Redux store装载。因此，需要将组件原有的state接口、静态方法<code>getDerivedStateFromProps</code>、以及构造器进行整改。<code>ProductsPage</code>原来的外形是：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;RouteComponentProps&gt; &#123;</span><br><span class="line">  public async componentDidMount() &#123; ... &#125;</span><br><span class="line">  public render() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>组件的数据将通过props从store获得。一次，重构props接口：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IProps extends RouteComponentProps &#123;</span><br><span class="line">  getProducts: typeof getProducts;</span><br><span class="line">  loading: boolean;</span><br><span class="line">  products: IProduct[];</span><br><span class="line">&#125;</span><br><span class="line">class ProductsPage extends React.Component&lt;IProps&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>因此，我们会将下面信息经由store传递给该组件：</p><ul><li><p><code>getProducts</code> action creator</p></li><li><p><code>loading</code>标志，表示当前是否在获取商品信息</p></li><li><p>商品列表数组</p></li></ul><ol start="5"><li>接下来调整组件的生命周期方法<code>componentDidMount</code>，通过调用<code>getProducts</code> 这个action creator来获取商品信息：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">  this.props.getProducts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在不再直接从<code>ProductsData.ts</code>中获取<code>products</code>商品列表了。将导入语句移除掉：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IProduct &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>还有一个未使用的<code>search</code>state也不需要了。如下，我们原来仅仅是将它放置在<code>render</code>方法，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const searchParams = new URLSearchParams(this.props.location.search);</span><br><span class="line">  const search = searchParams.get(&quot;search&quot;) || &quot;&quot;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>现在需要替换掉原来对<code>state</code>的引用：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">  &#123;this.props.products.map(product =&gt; &#123;</span><br><span class="line">    if (!search || (search &amp;&amp; product.name.toLowerCase().indexOf(search.toLowerCase()) &gt; -1)) &#123; ... &#125;</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>在export语句之前，class语句之后，创建一个函数来映射store和组件props的state：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (store: IApplicationState) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    loading: store.products.productsLoading,</span><br><span class="line">    products: store.products.products</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们可以得知商品是否在loading，以及从store存储的商品信息传递到我们的props中。</p><ol start="10"><li>由前面得知，还有一个prop属性需要进行映射，即<code>getProducts</code>。因此创建另外一个函数来关联这种关系：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (dispath: any) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    getProducts: () =&gt; dispatch(getProducts())</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>剩下最后一件事，需要在该文件最后。包装React Redux的<code>connect</code> HOC（钩子）到<code>ProductsPage</code>中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default connect (</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(ProductsPage);</span><br></pre></td></tr></table></figure><p><code>connect</code>钩子将组件和Redux存储连接起来，由最高层的<code>Provider</code>提供。<code>connect</code>钩子会调用映射函数进行两者的state状态传递。</p><ol start="12"><li>最后验证我们的结果：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>我们会发现页面的行为并没有跟原来的有差异。唯一不同的是state现在由Redux store进行管理。</p><p>接下来的小节，我们将商品页面添加加载进度条。</p><h2><span id="connecting-productspage-to-the-loading-store-state">Connecting ProductsPage to the loading store state</span></h2><p>本小节将添加一个加载进度条。在此之前，需要将商品信息进行萃取。然后添加<code>withLoader</code>HOC到组件中：</p><ol><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Principles and key concepts&lt;/li&gt;
&lt;li&gt;Installing Redux&lt;/li&gt;
&lt;li&gt;Creating reducers&lt;/li&gt;
&lt;li&gt;Creating actions&lt;/li&gt;
&lt;li&gt;Creating a stor
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第七章 表单</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_7_Working_with_Forms/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_7_Working_with_Forms/</id>
    <published>2019-11-27T07:50:07.000Z</published>
    <updated>2019-11-05T03:57:08.008Z</updated>
    
    <content type="html"><![CDATA[<ul><li>creating a form with controlled components</li><li>Reducing boilerplate code with generic components</li><li>Validating forms</li><li>Form submission</li></ul><h2><span id="creating-a-form-with-controlled-components">Creating a form with controlled components</span></h2><p>表单是大部分应用的常见内容。在React中，创建表单的标准方式是使用被称为 <em>controlled component</em> 的组件。</p><h3><span id="adding-a-contact-us-page">Adding a Contact Us page</span></h3><p>在src目录添加一个新的文件<code>ContactUsPage.tsx</code>，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class ContactUsPage extends React.Component &#123;</span><br><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">If you enter your details we&apos;ll get back to you as soon as we can.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ContactUsPage;</span><br></pre></td></tr></table></figure><p>该组件需要包含状态，目前首先创建了header相关信息。接下来，导入该组件到页面中，打开<code>Routes.tsx</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ContactUsPage from &quot;./ContactUsPage&quot;;</span><br></pre></td></tr></table></figure><p>在<code>Routes</code>组件的<code>render</code>方法中，添加新的路由，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">&lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&quot;&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; compoent=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;contactus&quot; component=&#123;ContactUsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">&lt;Route path=&quot;/login&quot; compoent=&#123;LoginPage&#125; /&gt;</span><br><span class="line">&lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>打开<code>Header.tsx</code>，添加新的导航信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">&lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Products</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/contactus&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Contact Us</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;</span><br><span class="line">  Admin</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><p>现在，页面已经创建了，下面创建表单输入框。</p><h2><span id="creating-controlled-inputs">Creating controlled inputs</span></h2><p>在src目录下创建一个新文件<code>ContactUs.tsx</code>，包含下面内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ContactUs: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default ContactUs;</span><br></pre></td></tr></table></figure><p>这是一个功能组件，渲染一个表单包含label和用户名的输入框。</p><p>现在需要添加对应的css样式，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> auto <span class="number">0px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: lightgray solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在我们页面<code>ContactUsPage.tsx</code>添加并渲染表单，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ContactUs from &quot;./ContactUs&quot;;</span><br></pre></td></tr></table></figure><p>在<code>render</code>方法中添加，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;If you enter your details we&apos;ll get back to you as soon as we can.&lt;/p&gt;</span><br><span class="line">  &lt;ContactUs /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>表单已经创建好了，但需要创建一个状态类型到<code>ContactUsPage</code>页面中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  email: string;</span><br><span class="line">  reason: string;</span><br><span class="line">  notes: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContactUsPage extends React.Component&lt;&#123;&#125;, IState&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在构造器中初始化状态，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    email: &quot;&quot;,</span><br><span class="line">name: &quot;&quot;,</span><br><span class="line">notes: &quot;&quot;,</span><br><span class="line">reason: &quot;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要将<code>ContactUsPage</code>中的状态传递到<code>ContactUs</code>组件中。在<code>ContactUs</code>组件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  email: string;</span><br><span class="line">  reason: string;</span><br><span class="line">  notes: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>将表单名name绑定到<code>name</code>属性中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&#123;props.name&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>将表单状态传递给<code>ContactUsPage</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs</span><br><span class="line">  name=&#123;this.state.name&#125;</span><br><span class="line">  emial=&#123;this.state.email&#125;</span><br><span class="line">  reason=&#123;this.state.reason&#125;</span><br><span class="line">  notes=&#123;this.state.notes&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>添加事件监听，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&#123;props.name&#125; onChange=&#123;handleNameChange&#125; /&gt;</span><br></pre></td></tr></table></figure><p>创建对应的handler，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  const handleNameChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">    props.onNameChange(e.currentTarget.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是使用到了<code>React.ChangeEvent</code>。我们需要添加<code>onNameChange</code>函数到IProps中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  onNameChange: (name: string) =&gt; void;</span><br><span class="line">  email: string;</span><br><span class="line">  onEmailChange: (email: string) =&gt;void;</span><br><span class="line">  reason: string;</span><br><span class="line">  onReasonChange: (reason: string) =&gt; void;</span><br><span class="line">  notes: string;</span><br><span class="line">  onNotesChange: (notes: string) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要将来自<code>ContactUsPage</code>的Props传递到<code>ContactUs</code>中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs</span><br><span class="line">  name=&#123;this.state.name&#125;</span><br><span class="line">  onNameChange=&#123;this.handleNameChange&#125;</span><br><span class="line">  email=&#123;this.state.email&#125;</span><br><span class="line">  onEmailChange=&#123;this.handleEmailChange&#125;</span><br><span class="line">  reason=&#123;this.state.reason&#125;</span><br><span class="line">  onReasonChange=&#123;this.handleReasonChange&#125;</span><br><span class="line">  notes=&#123;this.state.notes&#125;</span><br><span class="line">  onNotesChange=&#123;this.handleNotesChange&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建对应的handlers方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private handleNameChange = (name: string =&gt; &#123;</span><br><span class="line">  this.setState(&#123; name &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleEmailChange = (email: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; email &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleReasonChange = (reason: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; reason &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">private handleNotesChange = (notes: string) =&gt; &#123;</span><br><span class="line">  this.setState(&#123; notes &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来在<code>ContactUs</code>中补充其它表单内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;name&quot;&gt;Your name&lt;/label&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      id=&quot;name&quot;</span><br><span class="line">      value=&#123;props.name&#125;</span><br><span class="line">      onChange=&#123;handleNameChange&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;email&quot;&gt;Your email address&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;email&quot; value=&#123;props.email&#125; onChange=&#123;handleEmailChange&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;reason&quot;&gt;Reason you need to contact us&lt;/label&gt;</span><br><span class="line">    &lt;select id=&quot;reason&quot; value=&#123;props.reason&#125; onChange=&#123;handleReasonChange&#125;&gt;</span><br><span class="line">      &lt;option value=&quot;Marketing&quot;&gt;Marketing&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Support&quot; selected=&#123;true&#125;&gt;Support&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Feedback&quot;&gt;Feedback&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Jobs&quot;&gt;Jobs&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;Other&quot;&gt;Other&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label htmlFor=&quot;notes&quot;&gt;Additional notes&lt;/label&gt;</span><br><span class="line">    &lt;textarea id=&quot;notes&quot; value=&#123;props.notes&#125; onChange=&#123;handleNotesChange&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>现在创建这些handler的函数属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleEmailChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;)</span><br><span class="line">=&gt; &#123;</span><br><span class="line">props.onEmailChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line">const handleReasonChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; &#123;</span><br><span class="line">props.onReasonChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line">const handleNotesChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; &#123;</span><br><span class="line">props.onNotesChange(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="reducing-boilerplate-code-with-generic-components">Reducing boilerplate code with generic components</span></h2><p>通用表单组件将有利于减少表单代码的重复实现。我们重构上面的<code>ContactUs</code>组件来实现generic form components。</p><p>假设我们希望，理想情况下消费组件<code>ContactUs</code>内容的generic component组件的形式如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form</span><br><span class="line">defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;email&quot; label=&quot;Your email address&quot; type=&quot;Email&quot; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;reason&quot; label=&quot;Reason you need to contact us&quot;</span><br><span class="line">type=&quot;Select&quot; options=&#123;[&quot;Marketing&quot;, &quot;Support&quot;, &quot;Feedback&quot;, &quot;Jobs&quot;,</span><br><span class="line">&quot;Other&quot;]&#125; /&gt;</span><br><span class="line">&lt;Form.Field name=&quot;notes&quot; label=&quot;Additional notes&quot; type=&quot;TextArea&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，有两个通用合成组件：<code>Form</code>和<code>Field</code>。它们有某些特点，</p><ul><li><code>Form</code>组件是用于合成、管理状态和交互的。</li><li><code>Fomr</code>组件使用<code>defaultValues</code>属性来传递默认值。</li><li><code>Field</code>组件渲染label和每个字段的一个编辑器。</li><li>每个字段包含一个<code>name</code>属性，并被存储在对应的state属性名内。</li><li>每个字段有一个<code>label</code>属性用于展示每个字段的标签。</li><li>特殊字段用<code>type</code>属性标识。默认的属性为文本类型<code>input</code>。</li><li>如果编辑器类型是<code>Select</code>，我们可以通过<code>options</code>属性指定。</li></ul><p>新版本的<code>ContactUs</code>组件相比原来的更简短、更易用。状态的管理和事件的处理被隐藏和封装在<code>Form</code>组件内。</p><h3><span id="creating-a-basic-form-component">Creating a basic form component</span></h3><p>下面开始构建我们的通用<code>Form</code>组件；</p><ol><li>在<code>src</code>文件夹下创建一个新的文件<code>Form.tsx</code>，包含下面内容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;&#125;</span><br><span class="line"></span><br><span class="line">export class Form extends React.Component&lt;IFormProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IFormProps) &#123;&#125;</span><br><span class="line">  public render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Form</code>是一个基类组件，因为它需要管理状态。我们将属性接口命名为<code>IFormProps</code>，因为之后我们将需要一个字段属性的接口。</p><ol start="2"><li>添加一个<code>defaultValues</code>属性到<code>IFormProps</code>接口中，它为每个字段提供默认值，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface IValues &#123;</span><br><span class="line">  [key: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个额外的接口<code>IValues</code>，它是一个索引的key/value类型<code>[key: string]: any</code>，key是字段名，value是字段值。</p><p>因此，<code>defaultValues</code>属性可以是，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: "", email: "", reason: "Support", notes: "" &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对于表单的state，需要存储这个接口类型，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来需要在构造方法中初始化组件的状态，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state =  &#123;</span><br><span class="line">    values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后一步，实现<code>render</code>方法，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  return (</span><br><span class="line">  &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">  &#123;this.props.children&#125;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>form</code>标签中渲染子组件，使用了<code>children</code>属性。</p><p>接下来，我们需要实现我们的<code>Field</code>组件。</p><h3><span id="adding-a-basic-field-component">Adding a basic Field component</span></h3><p><code>Field</code>组件需要渲染一个标签(label)和一个编辑框(editor)。</p><ol><li>首先在<code>Form.tsx</code>中创建一个接口属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IFieldProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  label: string;</span><br><span class="line">  type?: &quot;Text&quot; | &quot;Email&quot; | &quot;Select&quot; | &quot;TextArea&quot;;</span><br><span class="line">  options?: string[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>表示字段名</li><li><code>label</code>是展示标签</li><li><code>type</code>输入类型，可选</li><li><code>options</code>，仅作用于当<code>type</code>是<code>Select</code>时，可选</li></ul><ol start="2"><li>现在添加<code>Field</code>属性字段的骨架，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Field: React.SFC&lt;IFieldProps&gt; = props =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外，首先添加<code>type</code>字段的默认属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Form.Field.defaultProps = &#123;</span><br><span class="line">  type: &quot;Text&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，默认的<code>type</code>是一个文本类型，</p><ol start="4"><li>现在，渲染它的内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Field: React.SFC&lt;IFieldProps&gt; = props =&gt; &#123;</span><br><span class="line">  const &#123; name, label, type, options &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &lt;input type=&#123;type.toLowerCase()&#125; id=&#123;name&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这虽然是好的开头，但是，仅使用<code>Text</code>和<code>Email</code>类型。</p><ol start="5"><li>因此，需要添加合适的条件进行渲染，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;type === &quot;TextArea&quot; ... &#125;</span><br><span class="line"></span><br><span class="line">&#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">  &lt;select&gt;</span><br><span class="line">    &#123;options &amp;&amp;</span><br><span class="line">      options.map(option =&gt; (</span><br><span class="line">        &lt;option key=&#123;option&#125; value=&#123;option&#125;&gt;</span><br><span class="line">          &#123;option&#125;</span><br><span class="line">        &lt;/option&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h3><span id="sharing-state-with-react-context">Sharing state with React context</span></h3><p><code>Form</code>组件内的字段值状态，需要在<code>Field</code>组件内共享，即可以通过<code>Field</code>组件访问和修改。</p><ol><li>首先在<code>Form.tsx</code>创建一个接口，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>IFormContext</code>下使用<code>React.createContext</code>创建一个上下文创建(context component)，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const FormContext = React.createContext&lt;IFormContext&gt;(&#123;</span><br><span class="line">  values: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>Form</code>的<code>render</code>方法中，创建包含上下文的值，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>包装表单标签，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Provider value=&#123;context&#125;&gt;</span><br><span class="line">  &lt;form ... &gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/FormContext.Provider&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>Field</code>上下文进行消费，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Consumer&gt;</span><br><span class="line">  &#123;context =&gt; (</span><br><span class="line">    &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/FormContext.Consumer&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在可以访问这些上下文了，下面补充剩余的输入框，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">     &lt;input type=&#123;type.toLowerCase() id=&#123;name&#125; value=&#123;context.values[name]&#125; /&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">   </span><br><span class="line">   &#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">     &lt;textarea id=&#123;name&#125; value=&#123;context.values[name]&#125; /&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">   </span><br><span class="line">   &#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">     &lt;select value=&#123;context.values[name]&#125;&gt;</span><br><span class="line"> ...</span><br><span class="line"> &lt;/select&gt;</span><br><span class="line">   )&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>目前还没有添加事件用于更新上下文的状态，需要实现相应的事件处理机制。</p><ol start="7"><li>在<code>Form</code>类中创建一个<code>setValue</code>方法，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private setValue = (fieldName: string, value: any) =&gt; &#123;</span><br><span class="line">  const newValues = &#123; ...this.state.values, [fieldName]: value &#125;;</span><br><span class="line">  this.setState(&#123; values: newValues &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法包含有：</p><ul><li>该方法接收fieldName和value作为参数。</li><li>状态被更新为<code>newValues</code>，旧的值被更新，没有则添加。</li><li>新值被更新了。</li></ul><ol start="8"><li>接下来在<code>Field</code>组件中创建该方法的一个上下文属性，以实现访问，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>对应地，在<code>Form</code>组件也创建一个上下文属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const context: IFormContext = &#123;</span><br><span class="line">  setValue: this.setValue,</span><br><span class="line">  values: this.state.values</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="10"><li>现在可以在<code>Field</code>组件中访问该方法了。在<code>Field</code>中，即在解构(destucture)对象props后面，创建对应的事件Hnadler，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name, label, type, options &#125; = props;</span><br><span class="line"></span><br><span class="line">const handleChange = (</span><br><span class="line">  e:</span><br><span class="line">    | React.ChangeEvent&lt;HTMLInputElement&gt;</span><br><span class="line">    | React.ChangeEvent&lt;HTMLTextAreaElement&gt;</span><br><span class="line">    | React.ChangeEvent&lt;HTMLSelectElement&gt;,</span><br><span class="line">  context: IFormContext</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  if (context.setValue) &#123;</span><br><span class="line">    context.setValue(props.name, e.currentTarget.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法有几个关键的地方：</p><ul><li>TypeScript的事件改变类型是<code>ChangeEvent&lt;T&gt;</code>，其中<code>T</code>是被处理的元素。</li><li>该方法的第一个参数<code>e</code>，对应事件类型，组合(union)了所有不同的输入框事件，方便对事件进行统一处理。</li><li>该方法的第二个参数是表单上线文。</li><li>方法体内加入了条件语句，以确保编译顺利。</li><li>调用<code>setValue</code>方法更新或添加新值。</li></ul><ol start="11"><li>现在可以为<code>input</code>输入框添加这个事件处理，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input </span><br><span class="line">  type=&#123;type.toLowerCase() &#125;</span><br><span class="line">  id=&#123;name&#125;</span><br><span class="line">  value=&#123;context.values[name] &#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="12"><li>对于<code>textarea</code>标签，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea</span><br><span class="line">  id=&#123;name&#125;</span><br><span class="line">  value=&#123;context.values[name]&#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="13"><li>对于<code>select</code>标签，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select</span><br><span class="line">  value=&#123;context.values[name] &#125;</span><br><span class="line">  onChange=&#123;e =&gt; handleChange(e, context) &#125;</span><br><span class="line">&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>现在，我们的<code>Form</code>和<code>Field</code>组件可以组合在一起工作了。</p><h3><span id="implementing-our-new-contactus-component">Implementing our new ContactUs component</span></h3><p>接下来，我们使用<code>Form</code>和<code>Field</code>重新实现我们的<code>ContactUs</code>组件。</p><ol><li><p>首先删除<code>ContactUs.tsx</code>中的props，</p></li><li><p>重新定义<code>ContactUs</code>的SFC，</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC = () =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>ContactUs.tsx</code>中导入<code>Form</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>现在引用<code>Form</code>组件，带上默认值，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> return (</span><br><span class="line">   &lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">&lt;/Form&gt;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>name</code>输入框，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  &lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>注意这个没有写<code>type</code>属性，则默认使用<code>text</code>填充，</p><ol start="6"><li>下面补充<code>email</code>，<code>reason</code>和<code>notes</code>字段，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  &lt;Form.Field name=&quot;name&quot; label=&quot;Your name&quot; /&gt;</span><br><span class="line">  &lt;Form.Field name=&quot;email&quot; label=&quot;Your email address&quot; type=&quot;Email&quot; /&gt;</span><br><span class="line">  &lt;Form.Field</span><br><span class="line">    name=&quot;reason&quot;</span><br><span class="line">label=&quot;Reason you need to contact us&quot;</span><br><span class="line">type=&quot;Select&quot;</span><br><span class="line">options=&#123;[&quot;Marketing&quot;, &quot;Support&quot;, &quot;Feedback&quot;, &quot;Jobs&quot;, &quot;Other&quot;]&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;Form.Field name=&quot;notes&quot; label=&quot;Additional notes&quot; type=&quot;TextArea&quot; /&gt;</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>接下来的<code>ContactUsPage</code>就变得简单了。它不需要包含任何状态(state)，因为状态的维护已经交由<code>Form</code>组件管理。我们也不需要传递任何属性(props)到<code>ContactUs</code>组件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ContactUsPage extends React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123;</span><br><span class="line">  public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">  &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Contact Us&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  If you enter your details we&apos;ll get back to you as soon as we can.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;ContactUs /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止这个通用组件变得易用并减少我们的重复代码，但还需添加表单验证的实现。</p><h2><span id="validating-forms">Validating forms</span></h2><p>为了提升用户体验，需要在表单中实现校验功能。</p><p>在<code>ContactUs</code>组件中我们需要实现的校验规则是：</p><ul><li>name和email应该被填充</li><li>name字段不少于2个字符</li></ul><h3><span id="adding-a-validatio-rules-prop-to-form">Adding a validatio rules prop to form</span></h3><p>首先思考如何在表单中指定校验规则。我们需要为一个字段指定一个或多个规则。某些规则可能会有参数，例如最小长度。以如下形式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form</span><br><span class="line">  ...</span><br><span class="line">  validationRules=&#123;&#123;</span><br><span class="line">    email: &#123; validator: required &#125;,</span><br><span class="line">name: [&#123; validator: required &#125;, &#123; validator: minLength, arg: 3 &#125;]</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>首先在<code>Form</code>组件实现一个<code>validationRules</code>属性，</p><ol><li>在<code>Form.tsx</code>中定义一个<code>Validator</code>函数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export type Validator= (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  args?: any</span><br><span class="line">) =&gt; string;</span><br></pre></td></tr></table></figure><p>一个<code>Validator</code>函数包含字段名、值、以及一个可选参数，并返回string的字符串消息。如果输入内容合法，则返回空字符串。</p><ol start="2"><li>下面使用该类型创建一个<code>required</code>函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const required: Validator = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  args?: any</span><br><span class="line">): string =&gt;</span><br><span class="line">  values[fieldName] === undefined ||</span><br><span class="line">  values[fieldName] === null ||</span><br><span class="line">  values[fieldName] === &quot;&quot;</span><br><span class="line">    ? &quot;This must be populated&quot;</span><br><span class="line">: &quot;&quot;;</span><br></pre></td></tr></table></figure><p>这里需要将这个函数对外暴露使用。该函数会检测字段值是<code>undefined</code>、<code>null</code>还是空字符串，如果是则返回<code>This must be populated</code>的错误信息。</p><ol start="3"><li>类似地，创建一个长度判断的函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export const minLength: Validator = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  values: IValues,</span><br><span class="line">  length: number</span><br><span class="line">): string =&gt;</span><br><span class="line">  values[fieldName] &amp;&amp; values[fieldName].length &lt; length ? `This must be at least $&#123;length&#125; characters`</span><br><span class="line">  : &quot;&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来需要创建传递这些规则的props，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface IValidation &#123;</span><br><span class="line">  validator: Validator;</span><br><span class="line">  arg?: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IValidationProp &#123;</span><br><span class="line">  [key: string]: IValidation | IValidation[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">  validationRules: IValidationProp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>validationRules</code>是一个索引key/value类型，其中key是字段名，value是一个或多个验证规则。</li><li>一个校验规则包含函数类型和一个参数。</li></ul><ol start="5"><li>有了<code>validationRules</code>后，在<code>ContactUs</code>中添加，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form, minLenght, requied &#125; from &quot;./Forma&quot;;</span><br></pre></td></tr></table></figure><ol start="6"><li>现在，添加校验规则到<code>ContactUs</code>组件中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form defaultValues=&#123;&#123; name: &quot;&quot;, email: &quot;&quot;, reason: &quot;Support&quot;, notes: &quot;&quot; &#125;&#125;</span><br><span class="line">  valiationRules=&#123;&#123;</span><br><span class="line">    email: &#123; validator: required &#125;,</span><br><span class="line">name: [&#123; validator: required &#125;, &#123; validator: minLength, arg: 2 &#125;]</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><h3><span id="tracking-validation-error-messages">Tracking validation error messages</span></h3><p>有必要跟踪用户的不合法输入信息，提供友好的用户体验。</p><p><code>Form</code>组件的职责用于管理表单状态，因此将错误信息添加到state中，</p><ol><li>定义错误信息类型，添加到<code>IState</code>中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IErrors &#123;</span><br><span class="line">  [key: string]: string[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>errors</code>是一个key/value键值对，key为字段名，value为一组错误消息。</p><ol start="2"><li>在构造器中初始化<code>errors</code>的状态，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  const errors: IErrors = &#123;&#125;;</span><br><span class="line">  Object.keys(props.defaultValues).forEach(fieldName =&gt; &#123;</span><br><span class="line">    errors[fieldName] = [];</span><br><span class="line">  &#125;);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    errors,</span><br><span class="line">    values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的<code>defaultValues</code>包含了所有字段名。当<code>Form</code>组件初始化，所有字段的错误信息为空。</p><ol start="3"><li><code>Field</code>组件最终被用于渲染校验的错误信息，因此需要将这些信息添加到表单上下文。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  values: IValues;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加一个空白的<code>error</code>字面量作为默认值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const FormContext = React.createContext&lt;IFormContext&gt;(&#123;</span><br><span class="line">  errors: &#123;&#125;,</span><br><span class="line">  values: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>现在加入到context中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    errors: this.state.errors,</span><br><span class="line">setValue: this.setValue,</span><br><span class="line">values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，校验错误信息被设置在state中，并且可以被<code>Field</code>组件访问。接下来要创建一个方法来调用这些校验规则。</p><h3><span id="invoking-validation-rules">Invoking validation rules</span></h3><p>前面定义了校验规则，并且将校验信息关联到state中。但这些规则还没被调用。接下来我们要实现：</p><ol><li>我们需要在<code>Form</code>组件内创建一个方法，使用这些规则来校验字段。我们创建一个<code>validate</code>方法，它接收字段名和它的值。该方法会返回一个error message的数组信息，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private validate = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  value: any</span><br><span class="line">): string[] =&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法内，需要获取校验规则，并初始化返回信息<code>errors</code>。我们会收集校验的错误信息并存储在<code>errors</code>中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private validate = (</span><br><span class="line">  fieldName: string,</span><br><span class="line">  value: any</span><br><span class="line">): string[] =&gt; &#123;</span><br><span class="line">  const rules = this.props.validationRules[fieldName];</span><br><span class="line">  const errors: string[] = [];</span><br><span class="line">  </span><br><span class="line">  // TODO - execute all the validators</span><br><span class="line">  return errors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>上下文获取的规则可能是一个<code>IValidation</code>数组，也可能是一个<code>IValidation</code>对象。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const errors: string[] = [];</span><br><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  // TODO - execute all the validators in the array of rules</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  if (rules) &#123;</span><br><span class="line">    const error = rules.validator(fieldName, this.state.values, rules.arg);</span><br><span class="line">if (error) &#123;</span><br><span class="line">  errors.push(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="4"><li>有多个校验规则时，我们可以使用<code>forEach</code>函数迭代执行，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  rules.forEach(rule =&gt; &#123;</span><br><span class="line">    const error = rule.validator(</span><br><span class="line">  fieldNmae,</span><br><span class="line">  this.state.values,</span><br><span class="line">  rule.arg</span><br><span class="line">    );</span><br><span class="line">if (error) &#123;</span><br><span class="line">  errors.push(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="5"><li>剩下的代码部分是，将校验的结果存储到表单状态<code>errors</code>中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(rules)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">const newErrors = &#123; ...this.state.errors, [fieldName]: errors &#125;;</span><br><span class="line">this.setState(&#123; errors: newErrors &#125;);</span><br><span class="line">return errors;</span><br></pre></td></tr></table></figure><ol start="6"><li>表单<code>Field</code>组件需要调用到这个<code>validate</code>方法。首先添加到<code>IFormContext</code>接口，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IFormContext &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  setValue?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">  validate?: (fieldName: string, value: any) =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>现在将它添加到<code>Form</code>渲染内容中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">  const context: IFormContext = &#123;</span><br><span class="line">    errors: this.state.errors,</span><br><span class="line">setValue: this.setValue,</span><br><span class="line">validate: this.validate,</span><br><span class="line">values: this.state.values</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单的校验和方法的调用已经完成了。但没有事件触发这个动作，</p><h3><span id="triggering-validation-rule-execution-from-field">TRiggering validation rule execution from field</span></h3><p>当用户输入表单内容后，我们希望校验规则在blur时触发，</p><ol><li>首先创建一个函数处理这些输入框触发的<code>blur</code>事件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = (</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleBlur = (</span><br><span class="line">  e:</span><br><span class="line">    | React.FocusEvent&lt;HTMLInputElement&gt;</span><br><span class="line">| React.FocusEvent&lt;HTMLTextAreaElement&gt;</span><br><span class="line">| React.FocusEvent&lt;HTMLSelectElement&gt;,</span><br><span class="line">  context: IFormContext</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  if (context.validate) &#123;</span><br><span class="line">    context.validate(props.name, e.currentTarget.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return ( ... )</span><br></pre></td></tr></table></figure><ul><li>TypeScript的blur事件是<code>FocusEvent&lt;T&gt;</code>，其中<code>T</code>是被处理的元素。</li><li>参数<code>e</code>作为事件对象。</li><li>第二个参数是表单上下文。</li><li>需要使用条件语句判断<code>validate</code>方法是否定义。</li><li>方法体内调用<code>valdiate</code>方法。</li></ul><ol start="2"><li>将事件引入，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">&lt;input</span><br><span class="line">type=&#123;type.toLowerCase()&#125;</span><br><span class="line">id=&#123;name&#125;</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类似地，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">&lt;textarea</span><br><span class="line">id=&#123;name&#125;</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">&lt;select</span><br><span class="line">value=&#123;context.values[name]&#125;</span><br><span class="line">onChange=&#123;e =&gt; handleChange(e, context)&#125;</span><br><span class="line">onBlur=&#123;e =&gt; handleBlur(e, context)&#125;</span><br><span class="line">&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>输入框字段会在失去焦点时触发校验动作。</p><h3><span id="rendering-validation-error-messages">Rendering validation error messages</span></h3><p>在此之前，需要将错误信息展示或者隐藏。</p><ol><li>添加<code>form-error</code>样式控制，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt;</span><br><span class="line">  &#123;(type === &quot;Text&quot; || type === &quot;Email&quot;) &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">  &#123;type === &quot;TextArea&quot; &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">  &#123;type === &quot;Select&quot; &amp;&amp; (</span><br><span class="line">    ...</span><br><span class="line">  )&#125;</span><br><span class="line">&#123;context.errors[name] &amp;&amp;</span><br><span class="line">  context.errors[name].length &gt; 0 &amp;&amp;</span><br><span class="line">  context.errors[name].map(error =&gt; (</span><br><span class="line">    &lt;span key=&#123;error&#125; className=&quot;form-error&quot;&gt;</span><br><span class="line">       &#123;error&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>首先检测有错误的字段，再将错误信息渲染出来。</p><ol start="2"><li>下面是css样式，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.form-error &#123;</span><br><span class="line">font-size: 13px;</span><br><span class="line">color: red;</span><br><span class="line">margin: 3px auto 0px 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="form-submission">Form submission</span></h2><p>表单触发提交动作时，同样也需要进行校验。</p><ol><li>首先添加提交按钮，在<code>Form</code>组件中添加，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormContext.Provider value=&#123;context&#125;&gt;</span><br><span class="line">  &lt;form className=&quot;form&quot; noValidate=&#123;true&#125;&gt;</span><br><span class="line">    &#123;this.props.children&#125;</span><br><span class="line">&lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/FormContext.Provider&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>给按钮添加样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">border</span>: black solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-group</span> <span class="selector-tag">button</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: gray solid <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="adding-a-onsubmit-form-prop">Adding a onSubmit form prop</span></h3><p>在我们的<code>Form</code>组件中，需要一个新的属性来消费表单的提交动作。</p><ol><li>在<code>Form</code>组件中创建一个prop函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export interface ISubmitResult &#123;</span><br><span class="line">  success: boolean;</span><br><span class="line">  errors?: IErrors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IFormProps &#123;</span><br><span class="line">  defaultValues: IValues;</span><br><span class="line">  validationRules: IValidationProp;</span><br><span class="line">  onSubmit: (values: IValues) =&gt; Promise&lt;ISubmitResult&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onSubmit</code>函数会接收filed的值，并异步返回提交的信息。</p><ol start="2"><li>另外需要添加状态记录表单的提交动作，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  values: IValues;</span><br><span class="line">  errors: IErrors;</span><br><span class="line">  submitting: boolean;</span><br><span class="line">  submitted: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>另外需要在构造器初始化，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: IFormProps) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    errors,</span><br><span class="line">submitted: false,</span><br><span class="line">submitting: false,</span><br><span class="line">values: props.defaultValues</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>表单提交后按钮不可用，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;</span><br><span class="line">  disabled=&#123;this.state.submitting || this.state.submitted&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在表单中添加事件控制，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form className=&quot;form&quot; noValidate=&#123;true&#125; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>下面模拟这个提交动作，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用了<code>preventDefault</code>避免浏览器自动提交。</p><ol start="7"><li>接下来就是重点，表单验证！</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private validateForm(): boolean &#123;</span><br><span class="line">  const errors: IErrors = &#123;&#125;;</span><br><span class="line">  let haveError: boolean = false;</span><br><span class="line">  Object.keys(this.props.defaultValues).map(fieldName =&gt; &#123;</span><br><span class="line">    errors[fieldName] = this.validate(</span><br><span class="line">      fieldName,</span><br><span class="line">      this.state.values[fieldName]</span><br><span class="line">    );</span><br><span class="line">    if (errors[fieldName].length &gt; 0) &#123;</span><br><span class="line">      haveError = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  this.setState(&#123; errors &#125;);</span><br><span class="line">  return !haveError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  if (this.validateForm()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表单的状态会更新到最新的校验错误信息，</p><ol start="8"><li>实现剩余的代码，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; </span><br><span class="line">  e.preventDefault();</span><br><span class="line">  if (this.validateForm()) &#123;</span><br><span class="line">    this.setState(&#123; submitting: true &#125;);</span><br><span class="line">    const result = await this.props.onSubmit(this.state.values);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      errors: result.errors || &#123;&#125;,</span><br><span class="line">      submitted: result.success,</span><br><span class="line">      submitting: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="consuming-the-onsubmit-form-prop">Consuming the onSubmit form prop</span></h3><p>在本小节，将实现如何消费表单的提交内容。</p><ol><li>首先在<code>ContactUs</code>组件中导入<code>ISubmitResult</code>和<code>IValues</code>，用于处理提交的内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Form, ISubmitResult, IValues, minLength, required &#125; from &quot;./Form&quot;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  onSubmit: (values: IValues) =&gt; Promise&lt;ISubmitResult&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个<code>handleSubmit</code>函数，它将会调用<code>onSubmit</code>属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ContactUs: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">  const handleSubmit = async (values: IValues): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">    const result = await props.onSubmit(values);</span><br><span class="line">return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  return ( ... );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>onSubmit</code>属性是异步的，因此需要函数前缀带<code>async</code>以及<code>onSubmit</code>前面带<code>await</code>。</p><ol start="3"><li>绑定这个属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;Form ... onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/Form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="4"><li>现在移步到<code>ContactUsPage</code>组件，创建提交处理，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private handleSubmit = async (values: IValues): Promise&lt;ISubmitResult&gt; =&gt; &#123;</span><br><span class="line">  await wait(1000); // simulate asynchronous web API call</span><br><span class="line">  return &#123;</span><br><span class="line">    errors: &#123;</span><br><span class="line">  email: [&quot;Some is wrong with this&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">success: false</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>接着创建<code>wait</code>函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const wait = (ms: number): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li>在<code>ContactUs</code>组件中加上，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContactUs onSubmit=&#123;this.handleSubmit&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>导入暴露的属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ISubmitResult, IValues &#125; from &quot;./Form&quot;;</span><br></pre></td></tr></table></figure><h2><span id="summary">Summary</span></h2><p>本章讨论了控制组件，通过实现自定义表单组件描述。我们构建了一个通用型的<code>Form</code>和<code>Field</code>组件，并实现了状态控制、事件处理、表单提交等操作。</p><h2><span id="questions">Questions</span></h2><p>问题练习：</p><ol><li>扩展<code>Field</code>组件内容，包含<code>number</code>属性。</li><li>实现一个的输入框，该输入框响应紧急的程度，用数字表示。</li><li>实现一个新的校验函数，检测输入的数字是否在区间范围内。</li><li>合并实现2和3的功能。</li><li>为这个输入框添加事件。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;creating a form with controlled components&lt;/li&gt;
&lt;li&gt;Reducing boilerplate code with generic components&lt;/li&gt;
&lt;li&gt;Validating forms&lt;/li
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第六章 Component Patterns</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_6_Component_Patterns/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_6_Component_Patterns/</id>
    <published>2019-11-27T07:50:06.000Z</published>
    <updated>2019-11-05T03:57:07.987Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Container and presentational components</li><li>Compound compoents</li><li>Render props pattern</li><li>Higher-order components</li></ul><h2><span id="container-and-presentational-components">container and presentational components</span></h2><p>容器和表述组件。就是将复杂组件的属性内容进行抽取成为一个新的组件。</p><p>(略)</p><h2><span id="compound-components">Compound components</span></h2><p>合成组件，就是将一系列组件一起工作。</p><p>(略)</p><h2><span id="higher-order-components">Higher-order components</span></h2><p><strong>A higher-order component(HOC)</strong> 是一个函数组件，接收一个组件参数，返回该组件的增强版本。这样看起来没什么意义，下面通过一个例子<code>withLoader</code>组件来阐述。最终效果类似延迟加载动态圈。</p><h3><span id="adding-asynchronous-data-fetching">Adding asynchronous data fetching</span></h3><p>下面构造一份延迟数据来模拟真实的网络环境，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const wait = (ms: number): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">    return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const getProduct = async (id: number): Promise&lt;IProduct | null&gt; =&gt; &#123;</span><br><span class="line">    await wait(1000);</span><br><span class="line">    const foundProducts = products.filter(customer =&gt; customer.id === id);</span><br><span class="line">    return foundProducts.length === 0 ? null : foundProducts[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着在原来的<code>ProductPage</code>页面导入<code>getProduct</code>函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getProduct, IProduct &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><p>在<code>ProductPage</code>状态中加入一个新的属性<code>loading</code>，表示数据是否已经加载，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">product?: IProduct;</span><br><span class="line">added: boolean;</span><br><span class="line">loading: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中初始化状态属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public constructor(props: Props) &#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state = &#123;</span><br><span class="line">added: false,</span><br><span class="line">loading: true</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件加载时使用<code>getProduct</code>函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public async componentDidMount() &#123;</span><br><span class="line">  if (this.props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(this.props.match.params.id, 10);</span><br><span class="line">    const product = await getProduct(id);</span><br><span class="line">    if (product !== null) &#123;</span><br><span class="line">      this.setState(&#123; product, loading: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>await</code>关键字异步调用<code>getProduct</code>。另外还要修改生命周期方法<code>componentDidMount</code>带上<code>async</code>关键字。</p><h3><span id="implementing-the-withloader-hoc">Implementing the withLoader HOC</span></h3><p>我们将会创建<code>withLoader</code>加载组件，被用于指示组件处于繁忙状态。</p><ol><li>创建一个新文件，<code>withLoader.tsx</code>，内容如下，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface IProps &#123;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const withLoader = &lt;P extends object&gt;(</span><br><span class="line">  Component: React.ComponentType&lt;P&gt;</span><br><span class="line">): React.SFC&lt;P &amp; IProps&gt; =&gt; (props: P &amp; IProps) =&gt;</span><br><span class="line">  props.loading ? (</span><br><span class="line">    &lt;div className=&quot;loader-overlay&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;loader-circle-wrap&quot;&gt;</span><br><span class="line">        &lt;div className=&quot;loader-circle&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ) : (</span><br><span class="line">    &lt;Component &#123;...props&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">export default withLoader;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>withLoader</code>是一个函数，接收一个类型是<code>P</code>的组件</li><li><code>withLoader</code>调用一个函数组件</li><li>函数组件的属性定义是<code>P &amp; IProps</code>，它是一个交集类型</li><li>组件的所有属性会通过SFC传入，并带上一个新的属性<code>loading</code></li><li>props被解构为一个<code>loading</code>变量，剩余的其它属性作为rest参数</li></ul><ol start="2"><li>添加加载转轮的CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader-overlay</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10004</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loader-circle-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loader-circle</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">4px</span> solid <span class="number">#899091</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: loader-circle-spin <span class="number">0.7s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="consuming-the-withloader-hoc">Consuming the withLoader HOC</span></h3><p>要消费这个高阶组件，只需要简单包装原来的组件即可。</p><p>原来的<code>Product.tsx</code>文件修改为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import withLoader from &quot;./withLoader&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">export default withLoader(Product);</span><br></pre></td></tr></table></figure><p>在引用的页面部分修改为，即<code>ProductPage</code>页面，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;product || this.state.loading ? (</span><br><span class="line">  &lt;Product</span><br><span class="line">loading=&#123;this.state.loading&#125;</span><br><span class="line">product=&#123;product&#125;</span><br><span class="line">inBasket=&#123;this.state.added&#125;</span><br><span class="line">onAddToBasket=&#123;this.handleAddClick&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;p&gt;Product not found!&lt;/p&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>修改原来Props的属性选项为可选的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  product?: IProduct;</span><br><span class="line">  added: boolean;</span><br><span class="line">  loading: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要处理空值的情况，修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handleAddClick = () =&gt; &#123;</span><br><span class="line">props.onAddToBasket();</span><br><span class="line">&#125;;</span><br><span class="line">if (!product) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return (</span><br><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/React.Fragment&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>HOC非常适用于对原来组件的增强处理。比较常见的是React Router中使用了非常多这种HOC模式。React Router自身也实现了<code>withRouter</code>组件函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Container and presentational components&lt;/li&gt;
&lt;li&gt;Compound compoents&lt;/li&gt;
&lt;li&gt;Render props pattern&lt;/li&gt;
&lt;li&gt;Higher-order components&lt;
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第五章 高级类型</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_5_Advanced_Types/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_5_Advanced_Types/</id>
    <published>2019-11-27T07:50:05.000Z</published>
    <updated>2019-11-05T03:57:07.982Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Union Types</li><li>Type guards</li><li>Generics</li><li>Overload signatures</li><li>Lookup and mapped types</li></ul><h2><span id="union-types">Union types</span></h2><p>顾名思义，联合类型就是将类型组合的一种形式。</p><h3><span id="string-literal-types">String literal types</span></h3><p>字符串字面量类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot;</span><br></pre></td></tr></table></figure><p>这个类型的值仅能是<code>&quot;Textbox&quot;</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let notes: Control;</span><br><span class="line">notes = &quot;Textbox&quot;;</span><br></pre></td></tr></table></figure><p>用其它值表示则会报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notes = &quot;DropDown&quot;;// &quot;DropDown&quot; is not assignable to type &quot;Textbox&quot;</span><br></pre></td></tr></table></figure><p>和其它TypeScript类型一样，<code>null</code>和<code>undefined</code>是有效的值，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notes = null;</span><br><span class="line">notes = undefined;</span><br></pre></td></tr></table></figure><p>字符串字面量类型自身没有多大用处，它的用处在于结合到联合类型中。</p><h3><span id="string-literal-union-types">String literal union types</span></h3><p>字符串字面量联合类型就是将多个字符串字面类型组合在一起。例如，将原先的<code>Control</code>类型增强为联合类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot; | &quot;DropDown&quot;</span><br></pre></td></tr></table></figure><p>设置值为二选一，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notes: Control;</span><br><span class="line">notes = &quot;Textbox&quot;;</span><br><span class="line">notes = &quot;DropDown&quot;;</span><br></pre></td></tr></table></figure><p>扩展更多的字面量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Control = &quot;Textbox&quot; | &quot;DropDown&quot; | &quot;DatePicker&quot; | &quot;NumberSlider&quot;;</span><br></pre></td></tr></table></figure><h3><span id="discriminated-union-pattern">Discriminated union pattern</span></h3><p>区分联合模式(discriminated union pattern)允许我们从不同联合类型中处理逻辑，以一个例子说明，</p><ol><li>首先创建三个不同的接口分别表示textbox、date picker、number slider，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface ITextbox &#123;</span><br><span class="line">control: &quot;TextBox&quot;;</span><br><span class="line">value: string;</span><br><span class="line">multiline: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDatePicker &#123;</span><br><span class="line">control: &quot;DatePicker&quot;;</span><br><span class="line">value: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface INumberSlider &#123;</span><br><span class="line">control: &quot;NumberSlider&quot;;</span><br><span class="line">value: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都有一个属性<code>control</code>，会成为模式的判别准则，</p><ol start="2"><li>我们将这些接口组合成为一个联合类型叫做<code>Field</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Field = ITextbox | IDatePicker | INumberSlider;</span><br></pre></td></tr></table></figure><ol start="3"><li>接着创建一个函数来初始化<code>Field</code>类型的值，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function intializeValue(field: Field) &#123;</span><br><span class="line">switch (field.control) &#123;</span><br><span class="line">case &quot;Textbox&quot;:</span><br><span class="line">field.value = &quot;&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;DatePicker&quot;:</span><br><span class="line">field.value = new Date();</span><br><span class="line">break;</span><br><span class="line">case &quot;NumberSlier&quot;:</span><br><span class="line">filed.value = 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">const shouldNotReach: never = field;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化值的设置取决于这个区分属性<code>control</code>。因此我们需要使用<code>switch</code>语句进行分岔处理。</p><p>其中<code>default</code>分支在<code>switch</code>语句中应该从不达到，对于不可达语句，使用<code>never</code>类型表述。</p><ol start="4"><li>随着时间的推移，新增了一个checkbox字段需求，接着实现这个接口，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ICheckbox &#123;</span><br><span class="line">control: &quot;Checkbox&quot;;</span><br><span class="line">value: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>将这个field添加到联合<code>Field</code>类型中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Field = ITextbox | IDatePicker | INumberSlider | ICheckbox;</span><br></pre></td></tr></table></figure><p>我们将会立即看到<code>initializeValue</code>函数在<code>never</code>声明中抛出编译错误，</p><ol start="6"><li>增加一个分支即可，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function intializeValue(field: Field) &#123;</span><br><span class="line">switch (field.control) &#123;</span><br><span class="line">case &quot;Textbox&quot;:</span><br><span class="line">field.value = &quot;&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;DatePicker&quot;:</span><br><span class="line">field.value = new Date();</span><br><span class="line">break;</span><br><span class="line">case &quot;NumberSlider&quot;:</span><br><span class="line">field.value = 0;</span><br><span class="line">break;</span><br><span class="line">case &quot;Checkbox&quot;:</span><br><span class="line">field.value = false;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">const shouldNotReach: never = field;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，联合类型允许我们组合任何类型成为另外一种类型。</p><h2><span id="type-guards">Type guards</span></h2><p>类型守卫，允许我们在一个代码条件分支上缩小一个对象的具体类型。对于联合类型来说可以在代码分支对不同具体类型进行处理。</p><p>例如上面的<code>intializeValue</code>函数，通过<code>switch</code>语句控制分支<code>control</code>来对不同设值类型进行处理。</p><p>下面介绍另外一种不同的方式。</p><h3><span id="using-the-typeof-keyword">Using the typeof keyword</span></h3><p><code>typeof</code>关键字是JavaScript的关键字，它会返回改类型的一个字符串。因此可以使用它缩小类型。</p><p>例如，有一个包含字符串和一个字符串数组的类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type StringOrStringArray = string | string[];</span><br></pre></td></tr></table></figure><p>我们需要实现一个<code>first</code>的函数，它接收类型为<code>StringOrStringArray</code>的参数并返回一个字符串，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function first(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求函数，如果是一个字符串，则返回第一个字符，如果是一个字符串数组则返回数组第一个元素，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function first(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测是否生效，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(first(&quot;The&quot;));</span><br><span class="line">console.log(first([&quot;The&quot;, &quot;cat&quot;]));</span><br></pre></td></tr></table></figure><p>因为<code>typeof</code>关键字仅能被用于JavaScript类型。为了说明这一点，对原来的函数做了增强。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function firstEnhanced(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else if (typeof stringOrArray === &quot;string[]&quot;) &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">const shouldNotReach: never = stringOrArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时TypeScript编译器在第二个分支报错，<code>typeof</code>关键字仅作用于JavaScript类型，即<code>string</code>、<code>number</code>、<code>boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>object</code>以及<code>function</code>；错误信息告诉我们<code>string[]</code>类型和JavaScript的类型<code>object</code>重合了，因此第二个分支实际上返回的是<code>object</code>。</p><p>修改为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function firstEnhanced(stringOrArray: StringOrStringArray): string &#123;</span><br><span class="line">if (typeof stringOrArray === &quot;string&quot;) &#123;</span><br><span class="line">return stringOrArray.substr(0, 1);</span><br><span class="line">&#125; else if (typeof stringOrArray === &quot;object&quot;) &#123;</span><br><span class="line">return stringOrArray[0];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">const shouldNotReach: never = stringOrArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>typeof</code>对于JavaScript类型是良好的，但对于TypeScript的具体类型却无从入手。</p><h3><span id="using-the-instanceof-keyword">Using the instanceof keyword</span></h3><p><code>instanceof</code>关键字还是JavaScript的，典型地被用于决定一个对象是否是某个类的实例。</p><p>例如，有两个类<code>Person</code>和<code>Company</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class company &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及定义一个联合类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonOrCompany = Person | Company;</span><br></pre></td></tr></table></figure><p>现在编写一个函数，接收一个<code>Person</code>或<code>Company</code>，并输出名字到控制台，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function logName(personOrCompany: PersonOrCompany) &#123;</span><br><span class="line">if (personOrCompany instanceof Person) &#123;</span><br><span class="line">console.log(`$&#123;personOrCompany.firstName&#125; $&#123;personOrCompany.surname&#125;`);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.log(personOrCompany.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof</code>虽然缩小了类的类型，但它仍然是JavaScript类型，有许多TypeScript类型不能处理。</p><h3><span id="using-the-in-keyword">Using the in keyword</span></h3><p><code>in</code>关键字是另外一个JavaScript关键字，被用于检测一个属性是否是一个对象。</p><p>例如，取代原来类的定义，使用接口对<code>Person</code>和<code>Company</code>进行声明，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICompany &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及创建一个联合类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonOrCompany = IPerson | ICompany;</span><br></pre></td></tr></table></figure><p>重写原来的方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function logName(personOrCompany: PersonOrCompany) &#123;</span><br><span class="line">if (&quot;firstName&quot; in personOrCompany) &#123;</span><br><span class="line">console.log(`$&#123;personOrCompany.firstName&#125; $&#123;personOrCompany.surname&#125;`);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.log(personOrCompany.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>关键字比较灵活，可以被用于任何对象类型。</p><h3><span id="using-a-user-defined-type-guard">Using a user-defined type guard</span></h3><p>自定义类型守卫，这部分属于TypeScript3特性，改写原来的代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">firstName: string;</span><br><span class="line">surname: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ICompany &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PersonOrCompany = IPerson | ICompany;</span><br></pre></td></tr></table></figure><p>然后实现类型守卫函数，返回boolean，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isPerson(personOrCompany: PersonOrCompany): personOrCompany is IPerson &#123;</span><br><span class="line">return &quot;firstName&quot; in personOrCompany;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="generics">Generics</span></h2><p>泛型可以作用于一个函数或类中。</p><h3><span id="generic-functions">Generic functions</span></h3><p>下面通过一个例子描述泛型函数。我们将创建一个包装函数围绕<code>fetch</code>函数获取web servcie的数据，</p><ol><li>首先创建函数的方法签名，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function getData&lt;T&gt;(url: string): Promise&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要转变为arrow function的形式，我们可以…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getData = &lt;T&gt;(url: string): Promise&lt;T&gt; =&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>现在让我们实现我们的函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getData&lt;T&gt;(url: string): Promise&lt;T&gt; &#123;</span><br><span class="line">return fetch(url).then(response =&gt; &#123;</span><br><span class="line">if (!response.ok) &#123;</span><br><span class="line">throw new Error(response.statusText);</span><br><span class="line">&#125;</span><br><span class="line">return response.json();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后，消费这个函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;IPerson&gt;(&quot;/people/1&quot;).then(person =&gt; console.log(person));</span><br></pre></td></tr></table></figure><h3><span id="generic-classes">Generic classes</span></h3><p>泛型类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class List&lt;T&gt; &#123;</span><br><span class="line">private data: T[] = [];</span><br><span class="line"></span><br><span class="line">public getList(): T[] &#123;</span><br><span class="line">return this.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public add(item: T) &#123;</span><br><span class="line">this.data.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public remove(item: T) &#123;</span><br><span class="line">this.data = this.data.filter(dataItem: T) =&gt; &#123;</span><br><span class="line">return !this.equals(item, dataItem);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">private equals(obj1: T, obj2: T) &#123;</span><br><span class="line">return Object.keys(obj1).every(key =&gt; &#123;</span><br><span class="line">return obj1[key] === obj2[key];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对应的消费接口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br><span class="line">const billy: IPerson = &#123; id: 1, name: &quot;Billy&quot; &#125;;</span><br></pre></td></tr></table></figure><p>然后创建一个泛型类实例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const people = new List&lt;IPerson&gt;();</span><br></pre></td></tr></table></figure><p>调用泛型方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.add(billy);</span><br><span class="line">people.remove(billy);</span><br></pre></td></tr></table></figure><p>获取条目信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const items = people.getList();</span><br></pre></td></tr></table></figure><p>其中<code>React.Component</code>包含有两个泛型参数，分别是props和state。</p><h2><span id="overload-signatures">Overload signatures</span></h2><p>方法签名重载。</p><p>首先有两个函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function condenseString(string: string): string &#123;</span><br><span class="line">return string.split(&quot; &quot;).join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function condenseArray(array: string[]): string[] &#123;</span><br><span class="line">return array.map(item -&gt; item.split(&quot; &quot;).join(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在将这两个函数组合为一个函数。我们可以使用联合类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function condense(stringOrArray: string | string[]): string| string[] &#123;</span><br><span class="line">return typeof stringOrArray === &quot;string&quot; ? stringOrArray.split(&quot; &quot;).join(&quot;&quot;) : stringOrArray.map(item =&gt; item.split(&quot; &quot;).join(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const condensedText = condense(&quot;the cat sat on the mat&quot;);</span><br></pre></td></tr></table></figure><p>如果我们将鼠标放在<code>condensedText</code>上，我们会发现它是个联合类型，</p><p>现在添加两个重载的方法签名，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function condense(string: string): string;</span><br><span class="line">function condense(array: string[]): string[];</span><br><span class="line">function condense(stringOrArray: string | string[]): string | string[] &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>再次消费重载的函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const moreCondensedText = condense(&quot;The cat sat on the mat&quot;);</span><br></pre></td></tr></table></figure><p>将鼠标悬浮在<code>moreCondensedText</code>上，可以得到一个更好的确定类型是<code>string</code>。可以看到重载方法签名可以得到更好的类型推断。</p><h2><span id="lookup-and-mapped-types">Lookup and mapped types</span></h2><p>TypeScript中提供了一个关键字<code>keyof</code>用于为一个对象中的所有属性创建联合类型。这种被创建的类型被称为查询类型(lookup type)。它允许我们基于已有的类型的属性，动态地创建类型。</p><p>以一个例子为例，我们有下面这些接口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用关键字<code>keyof</code>创建该接口的查询类型(lookup type)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PersonProps = keyof IPerson;</span><br></pre></td></tr></table></figure><p>如果将光标悬浮在<code>PersonProps</code>类型上，我们可以看到它是个联合类型，包含<code>&quot;id&quot;</code>和<code>&quot;name&quot;</code>属性，</p><p>在原来的<code>IPerson</code>上添加一个新的属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">age: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>PersonProps</code>类型包含了一个新的扩展属性<code>&quot;age&quot;</code>，</p><p>因此<code>PersonProps</code>类型是个lookup type，顾名思义它总是会查询它需要的字面量。</p><p>接下来我们看看这种查询类型的某些有用的地方，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field &#123;</span><br><span class="line">name: string;</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这仅是开始，我们可以让<code>name</code>属性更强，并使原来的类是个泛型类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field&lt;T, K extends keyof T&gt; &#123;</span><br><span class="line">name: K,</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在该类创建了两个泛型参数。第一个泛型参数是对象类型，第二个是对象类型的属性类型。</p><p>然后我们创建这个类的实例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const idField: Field&lt;IPerson, &quot;id&quot;&gt; = new Field();</span><br></pre></td></tr></table></figure><p>尝试引用不存在于<code>IPerson</code>的属性会发生报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const addressField: Field&lt;IPerson, &quot;address&quot;&gt; = new Field();</span><br></pre></td></tr></table></figure><p>另外，<code>defaultValue</code>不是类型安全的，譬如可以设置值为字符串，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idField.defaultValue = &quot;2&quot;;</span><br></pre></td></tr></table></figure><p>可以改为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Field&lt;T, K extends keyof T&gt; &#123;</span><br><span class="line">name: K;</span><br><span class="line">label: string;</span><br><span class="line">defaultValue: T[K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询<code>T[K]</code>的类型，对于<code>idField</code>。它会处理到<code>IPerson</code>的属性<code>id</code>，即<code>number</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idFiled.defaultValue = 2;</span><br></pre></td></tr></table></figure><p>接下来创建一个映射类型。映射类型就是映射已存在类型的属性。</p><p>首先创建一个类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">id: number;</span><br><span class="line">name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个只读版本的新类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReadonlyPerson = &#123; readonly [P in keyof IPerson]: IPerson[P] &#125;;</span><br></pre></td></tr></table></figure><p>其中重要的是创建这个映射<code>[P in keyof IPerson]</code>。这里将<code>IPerson</code>的所有属性迭代指派给<code>P</code>。因此，这个类型实际上是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReadonlyPerson = &#123;</span><br><span class="line">readonly id: number</span><br><span class="line">readonly name: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在visual studio code中，它的实际定义会被解析为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Readonly&lt;T&gt; = &#123;</span><br><span class="line">readonly [P in keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以尝试创建我们自己呃泛型映射类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Stringify&lt;T&gt; = &#123; [P in keyof T]: string &#125;;</span><br></pre></td></tr></table></figure><p>然后消费我们的映射类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tim: Stringify&lt;IPerson&gt; = &#123;</span><br><span class="line">id: &quot;1&quot;,</span><br><span class="line">name: &quot;Time&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>映射类型适用于需要从已有的类型创建一个新的类型的场景。在TypeScript中，除了<code>Radonly&lt;T&gt;</code>类型外，还有<code>Partial&lt;T&gt;</code>，它会创建一个所有属性都是optional的映射类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Union Types&lt;/li&gt;
&lt;li&gt;Type guards&lt;/li&gt;
&lt;li&gt;Generics&lt;/li&gt;
&lt;li&gt;Overload signatures&lt;/li&gt;
&lt;li&gt;Lookup and mapped types&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;sp
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第四章 React Router</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_4_Routing_with_React_Router/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_4_Routing_with_React_Router/</id>
    <published>2019-11-27T07:50:04.000Z</published>
    <updated>2019-11-05T03:57:07.972Z</updated>
    
    <content type="html"><![CDATA[<ul><li>安装React Router</li><li>声明路由</li><li>创建向导</li><li>路由参数</li><li>处理not found路由</li><li>实现页面重定向</li><li>查询参数</li><li>路由提示符</li><li>内嵌路由</li><li>动画转换</li><li>lazy loading 路由</li></ul><h2><span id="installing-react-router-with-routing-types">Installing React Router with routing types</span></h2><p>将React Router添加进项目中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><p>以及将TypeScript版本的React Router添加到devDependency的开发依赖中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @types/react-router-dom</span><br></pre></td></tr></table></figure><h2><span id="declaring-routes">Declaring routes</span></h2><p>在页面我们需要使用<code>BrowserRouter</code>和<code>Route</code>组件。<code>BrowserRouter</code>是top-level组件，会寻找下层的<code>Route</code>组件以决定不同的页面路径。</p><p>在引入<code>BrowserRouter</code>和<code>Route</code>之前，首先创建两个页面，</p><ol><li>创建一个<code>ProductsData.ts</code>文件，内容如下，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IProduct &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> products: IProduct[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        description: <span class="string">"A collection of navigational components that compose declaratively with your app"</span>,</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">"React Router"</span>,</span><br><span class="line">        price: <span class="number">8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        description: <span class="string">"A library that helps manage state across your app"</span>,</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">"React Redux"</span>,</span><br><span class="line">        price: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        description: <span class="string">"A library that helps you interact with a GraphQL backend"</span>,</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        name: <span class="string">"React Apollo"</span>,</span><br><span class="line">        price: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>创建另外一个<code>ProductsPage.tsx</code>文件导入这些数据，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; IProduct, products &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>因为需要在组件引用数据，创建一个接口，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">products: IProduct[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建类组件，初始化状态，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;&#123;&#125;, IState&gt; &#123;</span><br><span class="line">    public constructor(props: &#123;&#125;) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            products: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ProductsPage;</span><br></pre></td></tr></table></figure><ol start="5"><li>实现<code>componentDidMount</code>生命周期方法，更新组件的State，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">this.setState(&#123; products &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>实现对应的<code>render</code>方法进行渲染，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&lt;p&gt;Welcome to React Shop where you can get all your tools for ReactJS!&lt;/p&gt;</span><br><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">&#123;this.state.products.map(product =&gt; (</span><br><span class="line">&lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">&#123;product.name&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">))&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>对应CSS样式为，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page-container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: large;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.product-list</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.product-list-item</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>实现第二个页面，文件名为<code>AdminPage.tsx</code>，它是个无状态组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const AdminPage: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;You should only be here if you have logged in&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default AdminPage;</span><br></pre></td></tr></table></figure><ol start="9"><li>现在我们有两个页面了，需要为其定义两个路由。首先创建一个<code>Routes.tsx</code>的文件，包含下面的内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import AdminPage from &quot;./AdminPage&quot;;</span><br><span class="line">import ProductsPage from &quot;./ProductsPage&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li>渲染路由页面，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">                &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Routes;</span><br></pre></td></tr></table></figure><ol start="11"><li>最后一步，把<code>Routes</code>添加到根组件<code>index.tsx</code>中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import Routes from &quot;./Routes&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Routes /&gt;, </span><br><span class="line">    document.getElementById(&apos;root&apos;) as HTMLElement);</span><br></pre></td></tr></table></figure><ol start="12"><li>目前页面上是什么也没有看到的，需要我们在浏览器直接输入地址，&quot;<code>/products</code>&quot;，或者访问另一个页面&quot;<code>/admin</code>&quot;,</li></ol><h2><span id="creating-navigation">Creating navigation</span></h2><p>非常幸运的是，React Router有一些组件提供了向导的功能。</p><h3><span id="using-the-link-component">Using the Link component</span></h3><p>使用<code>Link</code>组件实现向导功能，</p><ol><li>创建一个<code>Header.tsx</code>文件，包含以下内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; Link &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">import logo from &quot;./logo.svg&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着创建两个<code>Link</code>链接，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Header: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;header className=&quot;header&quot;&gt;</span><br><span class="line">            &lt;img src=&#123;logo&#125; className=&quot;header-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">            &lt;h1 className=&quot;header-title&quot;&gt;React Shop&lt;/h1&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;Link to=&quot;/products&quot; className=&quot;header-link&quot;&gt;Products&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/admin&quot; className=&quot;header-link&quot;&gt;Admin&lt;/Link&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应的CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-logo</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: header-logo-spin infinite <span class="number">20s</span> linear;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> header-logo-spin &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-link</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>把<code>Header</code>添加到我们的<code>Routes.tsx</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Header from &quot;./Header&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>加入导航，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><h2><span id="使用navlink组件">使用NavLink组件</span></h2><p>React Router还提供了另外一个组件用于页面链接，称为<code>NavLink</code>。下面我们用<code>NavLink</code>重构一下原来的<code>Header</code>组件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; NavLink &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">import logo from &quot;./logo.svg&quot;;</span><br><span class="line"></span><br><span class="line">const Header: React.SFC = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;header className=&quot;header&quot;&gt;</span><br><span class="line">            &lt;img src=&#123;logo&#125; className=&quot;header-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">            &lt;h1 className=&quot;header-title&quot;&gt;React Shop&lt;/h1&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">                &lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot;&gt;Admin&lt;/NavLink&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>NavLink</code>暴露了一个<code>activeClassName</code>属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=&quot;/products&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink to=&quot;/admin&quot; className=&quot;header-link&quot; activeClassName=&quot;header-link-active&quot;&gt;Admin&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.header-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">#ebebeb</span> solid <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>NavLink</code>主要让我们导航带上样式功能。</p><h3><span id="路由参数">路由参数</span></h3><p>路由参数是路径变量的部分，用于决定目标组件的渲染逻辑。</p><p>我们需要添加另外一个页面，来展示商品的描述内容和价格，我们想要让页面导向使用&quot;<code>/products/{id}</code>&quot;路径，其中<code>id</code>对应商品ID。</p><ol><li>首先在原来的<code>Routes.tsx</code>添加路由路径和参数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建对应的<code>ProductPage</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#123; IProduct, products &#125; from &quot;./ProductsData&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>这里的关键点是，我们需要用到<code>RouteComponentProps</code>来访问路径上的参数<code>id</code>。另外需要定义类型别名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Props = RouteComponentProps&lt;&#123;id: string&#125;&gt;;</span><br></pre></td></tr></table></figure><ol start="4"><li>另外还需要有个状态记录商品被添加到购物篮中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">    product?: IProduct;</span><br><span class="line">    added: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>初始化该状态，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ProductPage extends React.Component&lt;Props, IState&gt; &#123;</span><br><span class="line">    public constructor(props: Props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.setState(&#123; added: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ProductPage;</span><br></pre></td></tr></table></figure><ol start="6"><li>当组件被加载进DOM，会通过路径参数上的id查找商品。<code>RouteComponentProps</code>给我们提供了一个<code>match</code>对象，以访问路径上的参数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount() &#123;</span><br><span class="line">        if (this.props.match.params.id) &#123;</span><br><span class="line">          const id: number = parseInt(this.props.match.params.id, 10);</span><br><span class="line">          const product = products.filter(p =&gt; p.id === id)[0];</span><br><span class="line">          this.setState(&#123; product &#125;);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，路径参数id是个字符串，需要使用<code>parseInt</code>进行转换，</p><ol start="7"><li>初始化好商品和组件状态后，我们进入到<code>render</code>函数，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">const product = this.state.product;</span><br><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">&#123;product ? (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">&lt;h1&gt;&#123;product.name&#125;&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&#123;product.description&#125;&lt;/p&gt;</span><br><span class="line">&lt;p className=&quot;product-price&quot;&gt;</span><br><span class="line">&#123;new Intl.NumberFormat(&quot;en-US&quot;, &#123;</span><br><span class="line">currency: &quot;USD&quot;,</span><br><span class="line">style: &quot;currency&quot;</span><br><span class="line">&#125;).format(product.price)&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&#123;!this.state.added &amp;&amp; (</span><br><span class="line">&lt;button onClick=&#123;this.handleAddClick&#125;&gt;Add to basket&lt;/button&gt;</span><br><span class="line">)&#125;</span><br><span class="line">  &lt;/React.Fragment&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;p&gt;Product not found!&lt;/p&gt;</span><br><span class="line">)&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一些新东西，</p><ul><li>第一行创建了常量<code>product</code>；</li><li>三元运算符</li><li>使用了<code>React.Fragment</code>，类似实现单独一个parent的功能</li><li>使用了<code>Intl.NumberFormat</code>装换货币符号</li></ul><ol start="8"><li>另外还需要添加<code>handleAddClick</code>方法处理按钮事件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleAddClick = () =&gt; &#123;</span><br><span class="line">this.setState(&#123; added: true &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="9"><li>现在，将我们实现好的<code>ProductPage</code>组件，导入到<code>Routes.tsx</code>中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ProductPage from &quot;./ProductPage&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>直接浏览器键入&quot;<code>/products/2</code>“查看新路由页面，但有个问题是”<code>/products</code>“和”<code>/products/:id</code>&quot;都被渲染了</p></li><li><p>为了解决这个问题，修改为，</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="12"><li>进一步，我们需要为每个条目添加链接，回到原来的<code>ProductsPage.tsx</code>组件，修改相应部分内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Link &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          Welcome to React Shop where you can get all your tools for ReactJS!</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">          &#123;this.state.products.map(product =&gt; (</span><br><span class="line">            &lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">              &lt;Link to=&#123;`/products/$&#123;product.id&#125;`&#125;&gt;&#123;product.name&#125;&lt;/Link&gt;</span><br><span class="line">              &#123;product.name&#125;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="13"><li>补充CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.product-list-item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="handling-not-found-routes">Handling not found routes</span></h3><p>如果用户输入的路径不存在怎么处理？例如，我们尝试键入&quot;/tools&quot;，但路由中没有找到任何匹配的路由，我们希望提示该路径不存在。</p><ol><li>首先创建一个新的文件<code>NotFoundPage.tsx</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const NotFoundPage: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Sorry, this page cannot be found&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default NotFoundPage;</span><br></pre></td></tr></table></figure><ol start="2"><li>在路由组件中，导入，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import NotFoundPage from &quot;./NotFoundPage&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加到路由，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">&lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>但其他页面也一同渲染了，我们希望如果没有找到对应路由页面，仅渲染<code>NotFoundPage</code>，这是需要用到<code>Switch</code>组件。</p><ol start="4"><li>首先导入<code>Swith</code>组件到<code>Routes.tsx</code>中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="5"><li>在<code>Route</code>包一层<code>Switch</code>组件即可，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p><code>Switch</code>组件仅渲染第一个匹配到的<code>Route</code>组件。在我们案例中，当找不到页面是，第一个匹配到的就是<code>NotFoundPage</code>，这样就解决了我们的问题。</p><h2><span id="implementing-page-redirects">Implementing page redirects</span></h2><p>页面重定向使用了<code>Redirect</code>组件实现</p><h3><span id="simple-redirect">Simple redirect</span></h3><p>如果我们访问<code>/</code>路径，我们注意到它是个not found页面。我们希望当路径是<code>/</code>时，重定向到<code>/products</code>。</p><ol><li>首先，需要在<code>Routes.tsx</code>导入<code>Redirect</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter as Router, Redirect, Route, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后使用<code>Redirect</code>组件进行重定向，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot; component=&#123;AdminPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h3><span id="conditional-redirect">Conditional redirect</span></h3><p>另外我们可以用<code>Redirect</code>组件对为授权用户进行保护访问。例如，我们的shop例子中，我们仅确保登录用户可以访问我们的<code>Admin</code>页面。</p><ol><li>创建一个<code>LoginPage</code>路由，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/login&quot; component=&#123;LoginPage&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个登录页<code>LoginPage.tsx</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const LoginPage: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Login&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;You need to login... &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default LoginPage;</span><br></pre></td></tr></table></figure><ol start="3"><li>回到原来的<code>Routes.tsx</code>导入<code>LoginPage</code>:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import LoginPage from &quot;./LoginPage&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>在重定向到&quot;<code>admin</code>&quot;之前，我们需要在<code>Routes.tsx</code>中添加一些状态值，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC = () =&gt; &#123;</span><br><span class="line">const [loggedIn, setLoggedIn] = React.useState(false);</span><br><span class="line">return (</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后一步是添加条件判断，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? &lt;AdminPage /&gt; : &lt;Redirect to=&quot;/login&quot; /&gt;&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>如果我们将<code>loggedIn</code>状态修改为true，我们就可以再次访问我们的Admin页面了，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [loggedIn, setLoggedIn] = React.useState(true);</span><br></pre></td></tr></table></figure><h2><span id="query-parameters">Query parameters</span></h2><p>查询参数是URL地址的一部分，例如&quot;<code>/products?search=redux</code>&quot;。让我们实现一个商品查询功能。</p><ol><li>在原来的<code>ProductsPage.tsx</code>中，添加一个状态变量<code>search</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">  products: IProduct[];</span><br><span class="line">  search: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>我们需要用到<code>RouteComponentProps</code>作为属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ProductsPage extends React.Component&lt;RouteComponentProps, IState&gt; &#123;</span><br><span class="line">  public constructor(props: RouteComponentProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      products: [],</span><br><span class="line">      search: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>我们需要在<code>componentDidMount</code>确定好<code>search</code>的值，因此，实现<code>getDerivedStateFromProps</code>方法获取URL参数，并更新state，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static getDerivedStateFromProps(</span><br><span class="line">    props: RouteComponentProps,</span><br><span class="line">    state: IState</span><br><span class="line">  ) &#123;</span><br><span class="line">    const searchParams = new URLSearchParams(props.location.search);</span><br><span class="line">    const search = searchParams.get(&quot;search&quot;) || &quot;&quot;;</span><br><span class="line">    return &#123;</span><br><span class="line">      products: state.products,</span><br><span class="line">      search</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>不幸的是，<code>URLsearchParams</code>没有在所有浏览器中实现，所以我们需要用到<code>url-search-params-polyfill</code>，</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D url-search-params-polyfill</span><br></pre></td></tr></table></figure><ol start="6"><li>导入到<code>ProductPages.tsx</code>中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;url-search-params-polyfill&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>在渲染部分使用<code>search</code>状态，并包装一个<code>if</code>语句，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul className=&quot;product-list&quot;&gt;</span><br><span class="line">  &#123;this.state.products.map(product =&gt; &#123;</span><br><span class="line">  if(</span><br><span class="line">  !this.state.search || </span><br><span class="line">  (this.state.search &amp;&amp;</span><br><span class="line">product.name.toLowerCase().indexOf(this.state.search.toLowerCase()) &gt; -1)</span><br><span class="line">  ) &#123;</span><br><span class="line">  return (</span><br><span class="line">&lt;li key=&#123;product.id&#125; className=&quot;product-list-item&quot;&gt;</span><br><span class="line">  &lt;Link to=&#123;`/products/$&#123;product.id&#125;`&#125;&gt;&#123;product.name&#125;&lt;/Link&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>替换为搜索框搜索的方式… 我们需要，</p><ol start="8"><li>在<code>Header.tsx</code>文件中创建state，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [search, setSearch] = React.useState(&quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="9"><li>另外需要获取搜索参数，需要导入，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NavLink, RouteComponentProps, withRouter&#125; from &quot;reactrouter-</span><br><span class="line">dom&quot;;</span><br><span class="line">import &quot;url-search-params-polyfill&quot;;</span><br></pre></td></tr></table></figure><ol start="10"><li>添加<code>props</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Header: React.SFC&lt;RouteComponentProps&gt; = props =&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>组件首次渲染时，从路径参数获取值并设置<code>search</code>的状态，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [search, setSearch] = React.useState(&quot;&quot;);</span><br><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">const searchParams = new</span><br><span class="line">URLSearchParams(props.location.search);</span><br><span class="line">setSearch(searchParams.get(&quot;search&quot;) || &quot;&quot;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ol start="12"><li>将<code>search</code>添加到<code>redner</code>方法中，让用户进行输入，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">&lt;header className=&quot;header&quot;&gt;</span><br><span class="line">&lt;div className=&quot;search-container&quot;&gt;</span><br><span class="line">&lt;input </span><br><span class="line">type=&quot;search&quot;</span><br><span class="line">placeholder=&quot;search&quot;</span><br><span class="line">value=&#123;search&#125;</span><br><span class="line">onChange=&#123;handleSearchChange&#125;</span><br><span class="line">onKeyDown=&#123;handleSearchKeydown&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="13"><li>添加<code>search-container</code>CSS样式，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.search-container</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line"><span class="attribute">margin-bottom</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>回到原来的<code>Header.tsx</code>，添加对应的事件处理方法，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const handleSearchChange = (e:</span><br><span class="line">React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">setSearch(e.currentTarget.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleSearchKeydown = (e:</span><br><span class="line">React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">if (e.key === &quot;Enter&quot;) &#123;</span><br><span class="line">props.history.push(`/products?search=$&#123;search&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="15"><li>另外我们需要用<code>withRouter</code>包装<code>Header</code>暴露接口，以使<code>this.props.history</code>可以生效，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default withRouter(Hader);</span><br></pre></td></tr></table></figure><h3><span id="route-prompts">Route prompts</span></h3><p><code>react-router-dom</code>组件中还有一个<code>Prompt</code>组件，顾名思义就是弹出框…</p><ol><li>我们希望用户离开商品页面时，如果没有购物，则弹出提示，首先，在<code>ProductPage.tsx</code>中导入<code>Prompt</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Prompt, RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加对应触发条件即可，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;Prompt when=&#123;!this.state.added&#125; message=&#123;this.navAwayMessage&#125; /&gt;</span><br><span class="line">  ...</span><br><span class="line">    private navAwayMessage = () =&gt; &quot;Are you sure you leave without buying this product?&quot;;</span><br></pre></td></tr></table></figure><h2><span id="nested-routes">Nested routes</span></h2><p>内嵌路由就是在某一个一级URL下渲染多个组件。</p><p>譬如我们想要创建一个3层渲染，</p><ul><li>第一层包含<code>Users</code>和<code>Products</code>的链接</li><li><code>Users</code>层又包含所有用户</li><li>点击每个用户可以看到具体信息</li></ul><ol><li>首先修改<code>AdminPage.tsx</code>，导入向导组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NavLink, Route, RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ul><li>我们将会使用<code>NavLink</code>组件渲染菜单</li><li><code>Route</code>用于内嵌路由</li><li><code>RouteComponentProps</code>类型将会获取URL的参数id</li></ul><ol start="2"><li>将<code>p</code>标签内容替换为下面…</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">  &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">&lt;li key=&quot;users&quot; &gt;</span><br><span class="line">&lt;NavLink to=&#123;`/admin/user`&#125; activeClassName=&quot;admin-link-active&quot;&gt;Users&lt;/NavLink&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;products&quot;&gt;</span><br><span class="line">&lt;NavLink to=&#123;`/admin/products`&#125; activeClassName=&quot;admin-link-active&quot;&gt;Products&lt;/NavLink&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加对应样式…</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.admin-sections &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  margin: 0px 0px 20px 0px;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-sections li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-sections li a &#123;</span><br><span class="line">  color: #222;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.admin-link-active &#123;</span><br><span class="line">  border-bottom: #6f6e6e solid 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>回到原来的<code>AdminPage.tsx</code>，添加两个路由组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;page-container&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Admin Panel&lt;/h1&gt;</span><br><span class="line">  &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin/users/:id&quot; component=&#123;AdminUsers&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin/products&quot; component=&#123;AdminProducts&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建这两个路由组件，在<code>AdminPage.tsx</code>内添加，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const AdminProducts: React.SFC = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;Some options to administer products&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li>接下来的<code>AdminUsers</code>组件可能会复杂一些。首先定义一种数据结构，在<code>AdminPage.tsx</code>的组件<code>AdminProducts</code>下，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface IUser &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  isAdmin: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const adminUsersData: IUser[] = [</span><br><span class="line">  &#123; id: 1, name: &quot;Fred&quot;, isAdmin: true &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;Bob&quot;, isAdmin: false &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;Jane&quot;, isAdmin: true &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这样一来就有3个用户了。</p><ol start="7"><li>接下来实现<code>AdminUsers</code>组件的内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const AdminUsers: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">        &#123;adminUsersData.map(user =&gt; (</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;NavLink</span><br><span class="line">              to=&#123;`/admin/users/$&#123;user.id&#125;`&#125;</span><br><span class="line">              activeClassName=&quot;admin-link-active&quot;</span><br><span class="line">            &gt;</span><br><span class="line">              &#123;user.name&#125;</span><br><span class="line">            &lt;/NavLink&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该组件会渲染每个用户名的链接。它是一个内嵌路径，</p><ol start="8"><li>另外，还需要定义另外一个路由展示用户详细信息。添加一个路由，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ul className=&quot;admin-sections&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;Route path=&quot;/admin/users/:id&quot; component=&#123;AdminUser&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>这个<code>AdminUser</code>也还没有实现，因此，在<code>AdminUsers</code>组件下面添加上，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们用到了<code>RouteComponentProps</code>通过<code>id</code>来获取可用的属性。</p><ol start="10"><li>然后通过<code>id</code>获取定义的<code>adminUsersData</code>中的记录，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  let user: IUser;</span><br><span class="line">  if (props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(props.match.params.id, 10);</span><br><span class="line">    user = adminUsersData.filter(u =&gt; u.id === id)[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>有了<code>user</code>对象后，渲染其内容，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const AdminUser: React.SFC&lt;RouteComponentProps&lt;&#123; id: string &#125;&gt;&gt; = props =&gt; &#123;</span><br><span class="line">  let user: IUser;</span><br><span class="line">  if (props.match.params.id) &#123;</span><br><span class="line">    const id: number = parseInt(props.match.params.id, 10);</span><br><span class="line">    user = adminUsersData.filter(u =&gt; u.id === id)[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;Id: &lt;/b&gt;</span><br><span class="line">        &lt;span&gt;&#123;user.id.toString()&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;Is Admin: &lt;/b&gt;</span><br><span class="line">        &lt;span&gt;&#123;user.isAdmin.toString()&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="12"><li>再次运行，进入到<code>Admin</code>页面，点击<code>Products</code>… 点击<code>Users</code>…</li></ol><p>因此，如果需要实现内嵌路由，需要用到<code>NavLink</code>或<code>Link</code>组件，以及使用<code>Route</code>组件渲染这些内容。</p><h2><span id="animated-transitions">Animated transitions</span></h2><p>本小节将给不同的导航添加动画。我们会使用<code>react-transition-group</code>中的<code>TransitionGroup</code>和<code>CSSTransition</code>组件，步骤如下，</p><ol><li>首先安装对应这些包，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react-transition-group</span><br><span class="line">npm install @types/react-transition-group --save-dev</span><br></pre></td></tr></table></figure><p><code>TransitionGroup</code> 会持续跟踪它内部本地state的子组，并计算子组进入和退出。<code>CSSTransition</code>则在<code>TransitionGroup</code>子组离开或退出时，提供CSS类来表示一种状态。</p><p>因此，<code>TransitionGroup</code>和<code>CSSTransition</code>可以包装我们的路由，并调用CSS类，</p><ol start="2"><li>首先我们需要在我们的<code>Routes.tsx</code>中导入这些组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CSSTransition, TransitionGroup &#125; from &quot;react-transition-group&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们还需要路由属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Redirect, Route, RouteComponentProps, Switch &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure><ol start="4"><li>作用我们的<code>Route</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Routes: React.SFC&lt;RouteComponentProps&gt; = props =&gt; &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li>用<code>CSSTransition</code>和<code>TransitionGroup</code>来包装我们的路由，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;TransitionGroup&gt;</span><br><span class="line">  &lt;CSSTransition</span><br><span class="line">key=&#123;props.location.key&#125;</span><br><span class="line">timeout=&#123;500&#125;</span><br><span class="line">classNames=&quot;animate&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect exact=&#123;true&#125; from=&quot;/&quot; to=&quot;/products&quot; /&gt;</span><br><span class="line">  &lt;Route exact=&#123;true&#125; path=&quot;/products&quot; component=&#123;ProductsPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/products/:id&quot; component=&#123;ProductPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? &lt;AdminPage /&gt; : &lt;Redirect to=&quot;/login&quot; /&gt;&#125;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">  &lt;Route path=&quot;/login&quot; component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line">  &lt;/CSSTransition&gt;</span><br><span class="line">&lt;/TransitionGroup&gt;</span><br></pre></td></tr></table></figure><p><code>TransitionGroup</code>要求子组要有一个唯一的<code>key</code>决定退出和进入的动作。因此我们在<code>CSSTransition</code>上指定<code>key</code>属性为<code>RouteComponentProps</code>上的<code>location.key</code>。我们设置了transtion的timeout属性为半秒，以及它的样式类。</p><ol start="6"><li>接下来，我们需要添加这些CSS类到<code>index.css</code>中，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animate-enter</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animate-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">450ms</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animate-exit</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当它的<code>key</code>改变时，<code>CSSTransition</code>会调用这些CSS样式。</p><ol start="7"><li>因为我们不能在<code>Router</code>组件外部使用高阶组件<code>withRouter</code>。要解决这个问题，可以添加一个新的组件<code>RoutesWrap</code>进行包装，在原来的<code>Routes.tsx</code>中添加，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const RoutesWrap: React.SFC = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route component=&#123;Routes&#125; /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Routes extends React.Component&lt;RouteComponentProps,</span><br><span class="line">IState&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">export default RoutesWrap;</span><br></pre></td></tr></table></figure><ol start="8"><li>在<code>Routes</code>组件中移除<code>Router</code>，让<code>div</code>标签作为它的根。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Header /&gt;</span><br><span class="line">&lt;TransitionGroup&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/TransitionGroup&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行程序，可以看到进入不同页面是有一种渐退效果。</p><h2><span id="lazy-loading-routes">Lazy loading routes</span></h2><p>截至目前为止，所有JavaScript会在app第一次加载时全部加载。包括<code>Admin</code>这些我们不需要的页面。这一点会造成一些资源浪费。所以需要用到一种称为“lazy loading”的组件。</p><ol><li>首先我们需要导入<code>Suspense</code>这个组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Suspense &#125; from &quot;react&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着以另一种方式导入这个<code>AdminPage</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ADminPage = React.lazy(() =&gt; import(&quot;./AdminPage&quot;));</span><br></pre></td></tr></table></figure><p>我们使用了React的一个函数<code>lazy</code>，它接收一个函数并返回一个动态导入，换句话说就是指派了一个<code>AdminPage</code>组件变量。</p><ol start="3"><li>上面步骤会获得一个lint错误，<strong>A dynamic import call in ES5/ES3 requires the ‘Promise’ constructor. Make sure you have a declaration for the ‘Promise’ constructor or include ‘ES2015’ in your <code>--lib</code> option.</strong> 需要在<code>tsconfig.json</code>中添加<code>lib</code>选项。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="string">"lib"</span>: [<span class="string">"es6"</span>, <span class="string">"dom"</span>],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接下来的内容是，使用<code>Suspense</code>组件包装这个<code>AdminPage</code>组件，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/admin&quot;&gt;</span><br><span class="line">&#123;loggedIn ? (</span><br><span class="line">&lt;Suspense fallback=&#123;&lt;div className=&quot;pagecontainer&quot;&gt;</span><br><span class="line">Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">&lt;AdminPage /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">) : (</span><br><span class="line">&lt;Redirect to=&quot;/login&quot; /&gt;</span><br><span class="line">)&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p><code>Suspense</code>组件会在<code>AdminPage</code>被加载时，展示这个<code>div</code>部分内容。有点说明的是，组件加载非常快，可能实际浏览器看了没效果，需要进入<strong>Network</strong>选择<strong>Slow 3G</strong>网络环境模式。刷新页面便可看到出现Loading…</p><h2><span id="总结">总结</span></h2><p>React Router给我们一套全面的组件管理导航页。最先学习的是底层组件<code>Router</code>，它会查找下游的<code>Route</code>组件并根据路径进行渲染。</p><p><code>Link</code>组件让我们在应用中链接到不同的页面。我们学习了<code>NavLinke</code>和<code>Link</code>相似，但提供了对不同激活路径的样式功能。因此<code>NavLink</code>最大好处用在侧边栏或标头横幅，<code>Link</code>用在内嵌页面跳转。</p><p><code>RouteComponentProps</code>是一种泛型类型，它提供了访问路径参数的能力。我们还发现了React Router并不能解析路径参数，但可以使用本地的JavaScript的<code>URLSearchParams</code>实现。</p><p><code>Redirect</code>组件提供了路径重定向的功能。这非常适用于对权限页面的控制。</p><p><code>Prompt</code>组件提供了弹窗的能力。</p><p>我们还学习了通过使用<code>TransitionGroup</code>和<code>CSSTransition</code>组件，通过包装我们的<code>Route</code>组件实现一种渐退的效果。</p><p>另外我们还学习了使用<code>Suspense</code>组件配合React的<code>lazy</code>函数，对不同的页面实现延迟加载，帮助我们提升应用的性能效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;安装React Router&lt;/li&gt;
&lt;li&gt;声明路由&lt;/li&gt;
&lt;li&gt;创建向导&lt;/li&gt;
&lt;li&gt;路由参数&lt;/li&gt;
&lt;li&gt;处理not found路由&lt;/li&gt;
&lt;li&gt;实现页面重定向&lt;/li&gt;
&lt;li&gt;查询参数&lt;/li&gt;
&lt;li&gt;路由提示符&lt;/li&gt;

      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第三章 开始在React中使用TS</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_3_Getting_Started_with_React_and_TypeScript/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_3_Getting_Started_with_React_and_TypeScript/</id>
    <published>2019-11-27T07:50:03.000Z</published>
    <updated>2019-11-05T03:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>创建一个React和TypeScript项目</li><li>创建一个类组件</li><li>处理类组件的事件</li><li>类组件的状态</li><li>类组件声明周期方法</li><li>创建一个函数组件</li></ul><h2><span id="创建一个react和typescript项目">创建一个React和TypeScript项目</span></h2><h3><span id="使用create-react-app">使用<code>create-react-app</code></span></h3><p><code>create-eract-app</code>是一个npm包的命令行工具，用于快速创建React和TypeScript应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-react-ts-app --typescript</span><br></pre></td></tr></table></figure><p>项目创建后，添加TSLint，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-react-ts-app</span><br><span class="line">npm install tslint tslint-react tslint-config-prettier --save-dev</span><br></pre></td></tr></table></figure><p>添加文件<code>tslint.json</code>，包含一些规则，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"extends"</span>: [<span class="string">"tslint:recommended"</span>, <span class="string">"tslint-react"</span>, <span class="string">"tslintconfig-prettier"</span>],</span><br><span class="line"><span class="attr">"rules"</span>: &#123;</span><br><span class="line"><span class="attr">"ordered-imports"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"object-literal-sort-keys"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"no-debugger"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"no-console"</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"linterOptions"</span>: &#123;</span><br><span class="line"><span class="attr">"exclude"</span>: [</span><br><span class="line"><span class="string">"config/**/*.js"</span>,</span><br><span class="line"><span class="string">"node_modules/**/*.ts"</span>,</span><br><span class="line"><span class="string">"coverage/lcov-report/*.js"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3><span id="创建一个简单的react-component">创建一个简单的React component</span></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.SFC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;h1&gt; My React App!&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>React.SFC</code>是一个TypeScript的React类型，它不包含任何内部状态。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">const</span> App: React.SFC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;h1&gt;My React App!&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>) <span class="keyword">as</span> HTMLElement);</span><br></pre></td></tr></table></figure><h3><span id="添加webpack">添加webpack</span></h3><p>(略)</p><h3><span id="项目目录结构">项目目录结构</span></h3><p>(略)</p><h3><span id="创建一个基本的类组件">创建一个基本的类组件</span></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Confirm <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line"><span class="keyword">public</span> render() &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Confirm;</span><br></pre></td></tr></table></figure><p><code>render</code>方法决定了该组件需要展示的内容。我们用JSX来定义需要展示的内容。简单来说，JSX就是HTML和JavaScript的混合。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public render() &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div className=<span class="string">"confirm-wrapper confirm-visible"</span>&gt;</span><br><span class="line">&lt;div className=<span class="string">"confirm-container"</span>&gt;</span><br><span class="line">&lt;div className=<span class="string">"confirm-title-container"</span>&gt;</span><br><span class="line">&lt;span&gt;This is where our title should go&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div className=<span class="string">"confirm-content-container"</span>&gt;</span><br><span class="line">&lt;p&gt;This is where our content should go&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div className=<span class="string">"confirm-buttons-container"</span>&gt;</span><br><span class="line">&lt;button className=<span class="string">"confirm-cancel"</span>&gt;Cancel&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button className="confirm-ok"&gt;Okay&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>怎么使用<code>Confirm</code>组件？在<code>App.tsx</code>中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Confirm from &apos;./Confirm&apos;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">&lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/header&gt;</span><br><span class="line">&lt;Confirm /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2><span id="jsx">JSX</span></h2><p>JSX看起来很像HTML，它不是有效的JavaScript，我们需要一个处理步骤将其转换为JavaScript。</p><p>打开浏览器，进入<a href="https://babeljs.io/repl" target="_blank" rel="noopener">https://babeljs.io/repl</a>，输入下面内容，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>This is where our title should go<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>右侧会获得编译之后的JS文件，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">"span"</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="string">"This is where our title should go"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement</code>有三个参数，</p><ul><li>元素类型，可以是一个HTML标签，一个React组件类型，或一个React 代码段</li><li>属性对象</li><li>子类或内容</li></ul><p>例如，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"confirm-title-container"</span>&gt;</span><br><span class="line">&lt;span&gt;This is where our title should go&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>最终会被编译为，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">"div"</span>,</span><br><span class="line">&#123; <span class="attr">className</span>: <span class="string">"confirm-title-container"</span> &#125;,</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">"span"</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="string">"This is where our title should go"</span></span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在看是有意义的，但目前仅由HTML构筑。加点JavaScript代码看看，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = &#123;</span><br><span class="line">title: <span class="string">"React and TypeScript"</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;div className=<span class="string">"confirm-title-container"</span>&gt;</span><br><span class="line">&lt;span&gt;&#123;props.title&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>它会被编译为，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> props = &#123;</span><br><span class="line">title: <span class="string">"React and TypeScript"</span></span><br><span class="line">&#125;;</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">"div"</span>,</span><br><span class="line">&#123; <span class="attr">className</span>: <span class="string">"confirm-title-container"</span> &#125;,</span><br><span class="line">React.createElement(</span><br><span class="line"><span class="string">"span"</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">props.title</span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>更进一步，让字面量<code>props</code>为空，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line">&lt;div className=<span class="string">"confirm-title-container"</span>&gt;</span><br><span class="line">&lt;span&gt;&#123;props.title ? props.title : <span class="string">"React and TypeScript"</span>&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>内嵌调用原封不变，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"><span class="string">"span"</span>,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">props.title ? props.title : <span class="string">"React and TypeScript"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>因此，为什么我们使用<code>className</code>属性而不是<code>class</code>？现在知道JSX会编译为JavaScript，由于<code>class</code>是JavaScript的关键字，在JSX包含<code>class</code>属性会发生冲突。因此React使用<code>className</code>代替CSS引用。</p></blockquote><h2><span id="component-props">Component props</span></h2><p>目前，组件<code>Confirm</code>的标题和内容是硬编码的。需要将这些引用属性以组件形式接收</p><ol><li>首先，我们需要为我们的props定义个TypeScript类型。我们将会用到一个接口，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将该<code>IProps</code>类型以尖括号引入定义中，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Confirm extends React.Component&lt;IProps&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>React.Component</code>被称为泛型类。泛型类允许类型允许在内部传递使用。在我们的例子中，我们传递了<code>IProps</code>接口。</p></blockquote><ol start="3"><li>然后我们的类内使用<code>this.props.propName</code>。在我们的JSX文件中，可以直接引用这些属性，取代硬编码的方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;div className=&quot;confirm-title-container&quot;&gt;</span><br><span class="line">&lt;span&gt;&#123;this.props.title&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div className=&quot;confirm-content-container&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>目前编译不过，因为<code>Confirm</code>组件现在要求传入<code>title</code>和<code>content</code>属性，</p><p>修改为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">title=&quot;React and TypeScript&quot;</span><br><span class="line">content=&quot;Are you sure you want to learn React and TypeScript?&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="optional-props">Optional props</span></h3><p>接口Props的内容可以定义为可选属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">cancelCaption?: string;</span><br><span class="line">okCaption?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="default-prop-values">Default prop values</span></h3><blockquote><p>当组件被初始化，可以被组件添加默认props属性值。它通过一个称为<code>defaultProps</code>的静态对象字面量实现。</p></blockquote><ol><li>创建默认的<code>cancelCaption</code>和<code>okCaption</code>，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Confirm extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">public static defaultProps = &#123;</span><br><span class="line">cancelCaption: &quot;Cancel&quot;,</span><br><span class="line">okCaption: &quot;Okay&quot;</span><br><span class="line">&#125;;</span><br><span class="line">public render() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要覆盖默认属性，补充具体属性值即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">title=&quot;React and TypeScript&quot;</span><br><span class="line">content=&quot;Are you sure you want to learn React and TypeScript?&quot;</span><br><span class="line">cancelCaption=&quot;No way&quot;</span><br><span class="line">okCaption=&quot;Yes please!&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>带有默认值的可选属性便于组件使用，这样大部分通用的配置可以自动装配起来，不用组个指定。</p></blockquote><h2><span id="处理类组件事件">处理类组件事件</span></h2><p>事件存在于多数编程语言中。以允许我们执行特定逻辑。</p><h3><span id="基础事件句柄">基础事件句柄</span></h3><blockquote><p>所有的本地JavaScript事件都可以在JSX中处理。JSX允许我们通过属性来调用这些事件函数。本地事件名会被带上前缀<code>on</code>以峰驼方式传递。因此，例如在JS中的属性事件是<code>click</code>，在JSX则对应<code>onClick</code>。</p></blockquote><p><strong>要查看所有可用事件列表，可以前往<code>node_modules/@types/react</code>文件夹的<code>index.d.ts</code>文件</strong></p><ol><li>首先是我们需要处理按钮上的<code>click</code>事件，对应上为，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button className=&quot;confirm-ok&quot; onClick=&#123;this.handleOkClick&#125;&gt;...&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建这个<code>handleOkClick</code>方法，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick() &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="the-this-problem">The this problem</span></h3><p>在事件的处理上承受来自JavaScript的经典<code>this</code>问题。我们在事件处理上获取不到引用，譬如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick() &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;, this.props):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮，会出现undefined！！原因是<code>this</code>代表的是当前这个事件，而不是我们的类！</p><p>一种解决方法是，将<code>handleOkClick</code>方法改为 arrow function。</p><blockquote><p>arrow function相当于一个表达式。它不会创建自身的<code>this</code>——这样解决了<code>this</code>的问题。</p></blockquote><p>我们把原来的方法改一改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkClick = () =&gt; &#123;</span><br><span class="line">console.log(&quot;Ok clicked&quot;, this.props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再次点击按钮，程序正常了。</p><h3><span id="function-props">Function props</span></h3><p>有时候需要在组件消费者(component)中传递事件处理逻辑。</p><ol><li>修改对应的IProps接口，对应函数类型属性，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">title: string;</span><br><span class="line">content: string;</span><br><span class="line">cancelCaption?: string;</span><br><span class="line">okCaption?: string;</span><br><span class="line">onOkClick: () =&gt; void;</span><br><span class="line">onCancelClick: () =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在消费方引用函数属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">...</span><br><span class="line">onCancelClick=&#123;this.handleCancelConfirmClick&#125;</span><br><span class="line">onOkClick=&#123;this.handleOkConfirmClick&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="类组件状态">类组件状态</span></h3><p>状态是一个对象，它决定了组件的行为和渲染。我们需要在我们的app中引入状态，以管理我们Confirm窗口打开或关闭。</p><p>State的定义和Props类型，首先我们需要创建一个接口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span><br><span class="line">confirmOpen: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着传递<code>React.Component</code>的第二个泛型参数中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component&lt;&#123;&#125;, IState&gt;</span><br></pre></td></tr></table></figure><h3><span id="initializing-the-state">Initializing the state</span></h3><p>定义的状态需要被初始化，初始化动作在构造函数中实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props: &#123;&#125;) &#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state = &#123;</span><br><span class="line">confirmOpen: true,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state被存放在组件类内的一个私有属性中。以及可以在组件内被使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Confirm</span><br><span class="line">open=&#123;this.state.confirmOPen&#125;</span><br><span class="line">...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3><span id="changing-state">Changing state</span></h3><p>状态的改变不能直接访问控制，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkConfirmClick = () =&gt; &#123;</span><br><span class="line">this.state.confirmOpen = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它会出现错误消息说状态是read-only!的。我们需要使用<code>setState</code>方法来改变状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private handleOkConfirmClick = () =&gt; &#123;</span><br><span class="line">this.setState(&#123; confirmOpen: false &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们仅能在构造函数中初始化State，其它类组件任何地方都不能初始化状态。以及，状态的更改，仅能在改组件内调用<code>setState</code>实现。</p><h2><span id="class-component-life-cycle-methods">Class component life cycle methods</span></h2><p>生命周期允许我们在特定点做某些处理。</p><h3><span id="componentdidmount">componentDidMount</span></h3><p>当一个组件被插入到DOM中时，<code>componentDidMount</code>被调用。下面是一些该方法常见的用例：</p><ul><li>调用web service以获取某些数据</li><li>添加事件监听</li><li>初始化计时</li><li>初始化第三方库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private timer: number = 0;</span><br><span class="line"></span><br><span class="line">public componentDidMount() &#123;</span><br><span class="line">this.timer = window.setInterval(() =&gt; this.handleTimerTick(), 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="componentwillunmount">componentWillUnmount</span></h3><p>当组件从DOM内被移除时触发<code>componentWillUnmount</code>，下面是常见的用例，</p><ul><li>移除事件监听器</li><li>取消激活的网络请求</li><li>移除计时器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public componentWillUnmount() &#123;</span><br><span class="line">clearInterval(this.timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="getderivedstatefromprops">getDerivedStateFromProps</span></h3><p>每次组件被渲染时，触发<code>getDerivedStateFromProps</code>。它是一个组件的静态方法，返回改变的状态或返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static getDerivedStateFromProps(props: &#123;&#125;, state: IState) &#123;</span><br><span class="line">console.log(&quot;getDerivedStateFromProps&quot;, props, state);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="getsnapshotbeforeupdate-and-componentdidupdate">getSnapshotBeforeUpdate and componentDidUpdate</span></h3><h3><span id="shouldcomponentupdate">shouldComponentUpdate</span></h3><h2><span id="creating-a-function-component">Creating a function component</span></h2><p>函数组件是从JavaScript函数实现的。</p><h3><span id="creating-a-basic-function-component">Creating a basic function component</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Confirm: React.SFC&lt;IProps&gt; = (props) =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整示例如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ComponentName: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">const handler = () =&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">&lt;div&gt; Our JSX&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ComponentName.defaultProps = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default ComponentName;</span><br></pre></td></tr></table></figure><h3><span id="stateful-function-components">Stateful function components</span></h3><p>富状态函数组件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Confirm: React.SFC&lt;IProps&gt; = props =&gt; &#123;</span><br><span class="line">const [cancelClickCount, setCancelClickCount] = React.useState(0);</span><br><span class="line"></span><br><span class="line">const handleOkClick = () =&gt; &#123;</span><br><span class="line">props.onOkClick();</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;创建一个React和TypeScript项目&lt;/li&gt;
&lt;li&gt;创建一个类组件&lt;/li&gt;
&lt;li&gt;处理类组件的事件&lt;/li&gt;
&lt;li&gt;类组件的状态&lt;/li&gt;
&lt;li&gt;类组件声明周期方法&lt;/li&gt;
&lt;li&gt;创建一个函数组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第二章 TypeScript3的新特性</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_2_TypeScript_3/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_2_TypeScript_3/</id>
    <published>2019-11-27T07:50:01.000Z</published>
    <updated>2019-11-05T03:57:07.995Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Tuples</li><li>The unknown type</li><li>Project references</li><li>Default JSX properties</li></ul><h2><span id="tuples">Tuples</span></h2><p>元组类型用中括号表示，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">product = [<span class="string">"Table"</span>, <span class="number">500</span>];</span><br></pre></td></tr></table></figure><h2><span id="javascript-的rest扩展语法">JavaScript 的rest扩展语法</span></h2><p>在JavaScript中，一个<code>rest</code>参数就是汇集多个参数以一个参数表示。因此它称为<code>rest</code>(剩余的、)。不要跟RESTful混淆。</p><p>TS中用三个点表示这种<code>rest</code>参数，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">...scores</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="open-ended-tuples">Open-ended tuples</span></h3><p>结合rest的扩展，tuple可以写成，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">string</span>, ...number[]];</span><br><span class="line"><span class="keyword">const</span> billyScores: Scores = [<span class="string">"Billy"</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>];</span><br></pre></td></tr></table></figure><h3><span id="tuple-function-parameters">Tuple function parameters</span></h3><p>除了rest扩展写法，TS3支持带上参数类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">...scores: [...<span class="built_in">number</span>[]]</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">string</span>, ...number[]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndScores</span>(<span class="params">...scores: Scores</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores);</span><br><span class="line">&#125;</span><br><span class="line">logNameAndScores(<span class="string">"Sally"</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">70</span>);</span><br></pre></td></tr></table></figure><h3><span id="spread-expressions">Spread expressions</span></h3><p>TS3中允许使用扩展语法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScore</span>(<span class="params">score1: <span class="built_in">number</span>, score2: <span class="built_in">number</span>, score3: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(score1, score2, score3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scores: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">75</span>, <span class="number">65</span>, <span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">logScore(...scores);</span><br></pre></td></tr></table></figure><p>但不支持open-ended tuples，因此下面代码编译出错，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scoresUnlimited: [...number[]] = [<span class="number">75</span>, <span class="number">65</span>, <span class="number">80</span>];</span><br><span class="line">logScore(...scoresUnlimited);</span><br></pre></td></tr></table></figure><h3><span id="empty-tuples">Empty tuples</span></h3><p>TS3中可以定义空tuple，</p><p>对于类型别名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty = [];</span><br></pre></td></tr></table></figure><p>声明该类型的一个变量，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> empty: Empty = [];</span><br></pre></td></tr></table></figure><p>如果尝试给该类型指派一个非空值，会出现编译错误，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notEmpty: Empty = [<span class="string">"Billy"</span>];</span><br></pre></td></tr></table></figure><p>空tuple可能没什么用，它的主要用处在于作为联合类型(union type)的一部分。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [] | [<span class="built_in">number</span>] | [<span class="built_in">number</span>, <span class="built_in">number</span>] | [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> benScores: Scores = [];</span><br><span class="line"><span class="keyword">const</span> samScores: Scores = [<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> bobScores: Scores = [<span class="number">95</span>, <span class="number">75</span>];</span><br><span class="line"><span class="keyword">const</span> jayneScores: Scores = [<span class="number">65</span>, <span class="number">50</span>, <span class="number">70</span>];</span><br><span class="line"><span class="keyword">const</span> sarahScores: Scores = [<span class="number">95</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">75</span>];<span class="comment">// illegal</span></span><br></pre></td></tr></table></figure><h3><span id="可选tuple元素">可选tuple元素</span></h3><p>TS中用<code>?</code>表示一个可选元素，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = [<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?];</span><br></pre></td></tr></table></figure><p>这样就可以创建带一个到三个元素的变量，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> samScores: Scores = [<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> bobScores: Scores = [<span class="number">95</span>, <span class="number">75</span>];</span><br><span class="line"><span class="keyword">const</span> jayneScores: Scores = [<span class="number">65</span>, <span class="number">50</span>, <span class="number">70</span>];</span><br></pre></td></tr></table></figure><p>严格来说，TypeScript是把类型看做是“真实的”，因此对应Type Safe的层次也是看做是类型安全的，不匹配的类型将发生编译错误，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sarahScores: Scores = [<span class="number">95</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">75</span>];<span class="comment">// illegal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> benScores: Scores = [];<span class="comment">// illegal</span></span><br></pre></td></tr></table></figure><h3><span id="unknown-type">Unknown type</span></h3><p>TS中对未知类型使用<code>unknow</code>表示，<code>unknown</code>类型通常和<code>any</code>类型交替地使用，编译器不会对这种类型进行检查，因此，下面写法是正确的，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">scores: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(scores.scores);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call this function</span></span><br><span class="line">logScores(&#123;</span><br><span class="line">name: <span class="string">"Billy"</span>,</span><br><span class="line">scores: [<span class="number">60</span>, <span class="number">70</span>, <span class="number">75</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但如果改为，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScoresBetter</span>(<span class="params">socres: unknown</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scores.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(scores.scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即获得一个编译器警告，带程序依然有效。</p><h3><span id="type-checking-with-a-type-redicate">Type checking with a type redicate</span></h3><p>顾名思义，就是用“谓语”对类型作检查，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scoresCheck = (</span><br><span class="line">scores: <span class="built_in">any</span></span><br><span class="line">): scores is &#123; name: <span class="built_in">string</span>; scores: <span class="built_in">number</span>[] &#125; =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"name"</span> <span class="keyword">in</span> socres &amp;&amp; <span class="string">"scores"</span> <span class="keyword">in</span> scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>scores</code>参数带有类型谓语，<code>scores is { name: string; scores: number[] }</code>，以确保它包含类型属性<code>name</code>和<code>scores</code>。</p><p>可以结合类型别名，提高可读性，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = &#123; name: <span class="built_in">string</span>; scores: <span class="built_in">number</span>[] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scoresCheck = (</span><br><span class="line">scores: <span class="built_in">any</span></span><br><span class="line">): scores is Scores =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"name"</span> <span class="keyword">in</span> scores &amp;&amp; <span class="string">"scores"</span> <span class="keyword">in</span> scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类型谓语属于type guard的一种方式，还有其它几种实现type guard的方式。</p><h3><span id="type-narrowing-with-a-type-assertion">Type narrowing with a type assertion</span></h3><p>类型收缩(type narrowing)类似于Java的强制转换，通过类型断言的方式，使用<code>as</code>关键实现，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scores = &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">scores: <span class="built_in">number</span>[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logScores</span>(<span class="params">scores: unknown</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log((scores <span class="keyword">as</span> scores).name);</span><br><span class="line"><span class="built_in">console</span>.log((scores <span class="keyword">as</span> Scores).scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="project-reference">Project reference</span></h3><p>(略) 参考网上tsconfig.json内容，</p><h3><span id="default-jsx-properties">Default JSX properties</span></h3><p>在TS3之前，我们必须设置默认的Props属性，并检查是否为null，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">text: <span class="built_in">string</span>;</span><br><span class="line">delimiter?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SplitText <span class="keyword">extends</span> Component&lt;IProps&gt; &#123;</span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">delimiter: <span class="string">","</span></span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">const</span> bits = <span class="keyword">this</span>.props.text.split(<span class="keyword">this</span>.props.delimiter!);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;bits.map(<span class="function">(<span class="params">bit: <span class="built_in">string</span></span>) =&gt;</span> (</span><br><span class="line">&lt;li key=&#123;bit&#125;&gt;&#123;bit&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">))&#125;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;SplitText text=<span class="string">"Fred,Jane,Bob"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>TS3之后，可以不必要将<code>delimiter</code>属性设置为optional的，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">text: <span class="built_in">string</span>;</span><br><span class="line">delimiter: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SplitText <span class="keyword">extends</span> Component&lt;IProps&gt; &#123;</span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">delimiter: <span class="string">","</span></span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">const</span> bits = <span class="keyword">this</span>.props.text.split(<span class="keyword">this</span>.props.delimiter);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;bits.map(<span class="function">(<span class="params">bit: <span class="built_in">string</span></span>) =&gt;</span> (</span><br><span class="line">&lt;li key=&#123;bit&#125;&gt;&#123;bit&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">))&#125;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="问题">问题</span></h3><ol><li>怎么调用<code>drawPoint</code>这个函数，</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPoint</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, z: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line">drawPoint(...point);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建另外一个版本的<code>drawPoint</code>，参数用<code>[number, number, number]</code>实现，</p></li><li><p>在问题2中，让<code>z</code>是可选的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;The unknown type&lt;/li&gt;
&lt;li&gt;Project references&lt;/li&gt;
&lt;li&gt;Default JSX properties&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span id=&quot;tuples&quot;&gt;Tuple
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基础</title>
    <link href="http://galudisu.info/2019/11/27/react-ts/chapter_1_TypeScript_Basics/"/>
    <id>http://galudisu.info/2019/11/27/react-ts/chapter_1_TypeScript_Basics/</id>
    <published>2019-11-27T07:50:00.000Z</published>
    <updated>2019-11-05T03:57:07.992Z</updated>
    
    <content type="html"><![CDATA[<ul><li>TypeScript 的好处</li><li>基础类型</li><li>接口，类型alias，类</li><li>模块结构</li><li>配置</li><li>TypeScript lint</li><li>代码格式化</li></ul><h2><span id="技术前提">技术前提</span></h2><ul><li><p>TypeScript 背景： <a href="https://www.typescriptlang.org/play/" target="_blank" rel="noopener">https://www.typescriptlang.org/play/</a></p></li><li><p>Node.js 以及npm：Node &gt;= 8.2， npm &gt;= 5.2</p></li><li><p>TypeScript安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></li><li><p>Visual Studio Code：前端开发利器</p></li></ul><h2><span id="typescript-带来了什么">TypeScript 带来了什么</span></h2><p>TypeScript解决了JavaScript代码增长带来难于阅读和难于维护的痛点。比起JavaScript，</p><ul><li>开发前期可以捕获代码错误</li><li>静态类型允许开发工具提升开发者的经验和生产力</li><li>兼容各种浏览器，以及一些非浏览器平台</li></ul><h2><span id="基础类型">基础类型</span></h2><h3><span id="原生类型">原生类型</span></h3><ul><li><code>string</code>: Unicode字符串</li><li><code>number</code>: 表达整数和浮点数</li><li><code>boolean</code>: 逻辑true或false</li><li><code>undefined</code>: 未定义值</li><li><code>null</code>: null</li></ul><h3><span id="类型标注">类型标注</span></h3><p>TypeScript在变量声明时带有类型，语法为<code>:Type</code>。</p><h3><span id="类型推断">类型推断</span></h3><p>TypeScript可以简单地有赋值推断出其类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4><span id="any">Any</span></h4><p>既没有值，也没有指定类型的变量，它的类型是<code>any</code>，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag;</span><br></pre></td></tr></table></figure><p>它用于动态声明，表示其值的类型会随后被确定。</p><h4><span id="void">Void</span></h4><p>用于函数的返回表示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function logText(text: string): void &#123;</span><br><span class="line">console.log(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常不带return语句体的函数，返回值类型会自动推断为<code>void</code>。</p><h4><span id="never">Never</span></h4><p>表示“从不”，用于指定该代码不可达</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foreverTask(taskName: string): never &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">console.log(`Doing $&#123;taskName&#125; over and over again ...`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数一直循环，永不还回，所以需要给定类型<code>never</code>。</p><h4><span id="enumerations">Enumerations</span></h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> OrderStatus &#123;</span><br><span class="line">Paid,</span><br><span class="line">Shipped,</span><br><span class="line">Completed,</span><br><span class="line">Cancelled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问通过下标方式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let status = OrderStatus.Paid</span><br></pre></td></tr></table></figure><p>TypeScript的枚举，遵循自动下标的语法，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum OrderStatus &#123;</span><br><span class="line">Paid = 1,</span><br><span class="line">Shipped,</span><br><span class="line">Completed,</span><br><span class="line">Cancelled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不声明的部分按顺序逐个递增，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let status = OrderStatus.Shipped;</span><br><span class="line">console.log(status);// print 2</span><br></pre></td></tr></table></figure><h4><span id="objects">Objects</span></h4><p>TS的object和JS是共享的，是一种非原生类型。例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和JS一样，可以通过下标，直接修改和访问其值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customer.turnover = 123,</span><br></pre></td></tr></table></figure><p>不同的是，它有类型，所以下面会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customer.turnover = &quot;500,500&quot;,</span><br></pre></td></tr></table></figure><h4><span id="arrays">Arrays</span></h4><p>数组需要带类型，其它地方用法和JS差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers: number[] = [];</span><br><span class="line">number.push(1);</span><br></pre></td></tr></table></figure><p>另外可以通过类型推断来声明，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 3, 5];</span><br></pre></td></tr></table></figure><p>迭代方式有几种，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i in numbers) &#123;</span><br><span class="line">console.log(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.forEach(function (num)&#123;</span><br><span class="line">console.log(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="创建接口类型别名类">创建接口，类型别名，类</span></h3><p>常量的定义，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是改为下面会出现编译错误，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let customer: Object;</span><br><span class="line">customer = &#123;</span><br><span class="line">name: &quot;Lamps Ltd&quot;,</span><br><span class="line">turnover: 2000134,</span><br><span class="line">active: true</span><br><span class="line">&#125;;</span><br><span class="line">customer.turnover = 20002000;// error</span><br></pre></td></tr></table></figure><p>Typescript 编译器不知道<code>customer</code>有哪些属性，所以需要引入结构化特性。</p><h3><span id="interfaces">Interfaces</span></h3><p>接口用<code>interface</code>关键字声明，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="properties">Properties</span></h3><p>properties就是结构的其中一个属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的属性必须声明了才能访问，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是类型，所以可以在其它接口引用，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tableOrder: OrderDetail = &#123;</span><br><span class="line">product: table,</span><br><span class="line">quantity: 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="方法签名">方法签名</span></h3><p>接口可以包含方法签名而没有具体实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal(idscount: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体对象需要实现接口的方法签名，方法签名必须一致，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const tableOrder: OrderDetail = &#123;</span><br><span class="line">product: table,</span><br><span class="line">quantity: 1,</span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口中的方法签名，参数部分可以不用声明类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">....</span><br><span class="line">getTotal(number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但省略的参数类型使得阅读难于理解，我们不知道具体参数是什么类型？</p><h3><span id="可选属性可选参数">可选属性，可选参数</span></h3><p>和大部分现代语言类似，TypeScript中使用<code>?</code>表示属性或参数是个optional 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">dateAdded?: Date,</span><br><span class="line">getTotal(discount: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法签名的参数也可以是可选的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">dateAdded?: Date,</span><br><span class="line">getTotal(discount?: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法签名的实现可以改为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getTotal(discount?: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * (discount || 0);</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在方法调用时，可以不传参数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableOrder.getTotal();</span><br></pre></td></tr></table></figure><h3><span id="readonly-属性">Readonly 属性</span></h3><p><code>readonly</code>属性，顾名思义只能读取，不能修改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">readonly name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，下面操作发生编译错误，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const table: Product = &#123;</span><br><span class="line">name: &quot;Table&quot;;</span><br><span class="line">unitPrice: 500</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">table.name = &quot;Better Table&quot;;</span><br></pre></td></tr></table></figure><h3><span id="接口继承">接口继承</span></h3><p>接口继承使用<code>extends</code>关键字，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode [</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ProductWithDiscountCodes extends Product &#123;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实例可以简单创建，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const table: ProductWithDiscountCodes = &#123;</span><br><span class="line">name: &quot;Table&quot;,</span><br><span class="line">unitPrice: 500,</span><br><span class="line">discountCodes: [</span><br><span class="line">&#123; code: &quot;SUMMER10&quot;, percentage: 0.1 &#125;,</span><br><span class="line">&#123; code: &quot;BFRI&quot;, percentage: 0.2 &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="类型别名">类型别名</span></h3><p>类型别名就是给指定类型标准一个新的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type GetTotal = (discount: number) =&gt; number;</span><br><span class="line"></span><br><span class="line">interface OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal: GetTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名和接口相似，不同的是类型别名不能有extends，也不能implemented。</p><h3><span id="类">类</span></h3><p>类比起接口有更多的特性，</p><h3><span id="基础类">基础类</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">name: stirng;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分概念和Java类型，可以通过<code>new</code>关键字声明实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const table = new Product();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br></pre></td></tr></table></figure><p>可以调用对应的成员方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对应实例，调用成员方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const table = new Product();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br><span class="line"></span><br><span class="line">const orderDtail = new OrderDetail();</span><br><span class="line">orderDetail.product = table;</span><br><span class="line">orderDetail.quantity = 2;</span><br><span class="line"></span><br><span class="line">const total = orderDetail.getTotal(0.1);</span><br><span class="line">console.log(total);</span><br></pre></td></tr></table></figure><h3><span id="接口继承">接口继承</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line">getTotal(discount: number): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">const priceWithoutDiscount = this.product.unitPrice * this.quantity;</span><br><span class="line">const discountAmount = priceWithoutDiscount * discount;</span><br><span class="line">return priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="构造器">构造器</span></h3><p>TS中的构造函数概念和Java一样，形式不一样，TS中需要使用<code>constructor</code>私有成员，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: number;</span><br><span class="line"></span><br><span class="line">constructor(product: Product, quantity: number) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例时，会强制要求传递参数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const orderDetail = new OrderDetail(table, 2);</span><br></pre></td></tr></table></figure><p>某些情况下，可以使用默认值，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(product: Product, quantity: number = 1) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantitty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明实例时可以不写，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const orderDetail = new OrderDetail(table);</span><br></pre></td></tr></table></figure><p>可以少写点代码，在构造参数前引入<code>public</code>关键字，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OrderDetail implements IOrderDetail &#123;</span><br><span class="line">constructor(public product: Product, public quantity: number = 1) &#123;</span><br><span class="line">this.product = product;</span><br><span class="line">this.quantity = quantity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(discount: number): number &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="类继承">类继承</span></h3><p>类之间可以继承，使用关键字<code>extends</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">name: string;</span><br><span class="line">unitPrice: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode &#123;</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProductWithDiscountCodes etends Product &#123;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类型实例的创建如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const table = new ProductWithDiscountCodes();</span><br><span class="line">table.name = &quot;Table&quot;;</span><br><span class="line">table.unitPrice = 500;</span><br><span class="line">table.discountCodes = [</span><br><span class="line">&#123; code: &quot;SUMMER10&quot;, percentage: 0.1 &#125;,</span><br><span class="line">&#123; code: &quot;BFRI&quot;, percentage: 0.2 &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>父类包含构造函数，子类也必须包含构造函数的实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">constructor(public: name: string; public unitPrice: number) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface DiscountCode &#123;</span><br><span class="line">code: string;</span><br><span class="line">percentage: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProductWithDiscountCodes extends Product &#123;</span><br><span class="line">constructor(public name: string, public unitPrice: number) &#123;</span><br><span class="line">super(name, unitPrice);</span><br><span class="line">&#125;</span><br><span class="line">discountCodes: DiscountCode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="抽象类">抽象类</span></h3><p>抽象类使用<code>abstract</code>关键字声明，表示没有实例化能力的成员</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">uitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bread = <span class="keyword">new</span> Procut();<span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>抽象方法需要带有<code>abstract</code>关键字，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">uitPrice: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">delete</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有子类都要实现这个抽象方法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fond <span class="keyword">extends</span> Product &#123;</span><br><span class="line">deleted: <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> bestBefore: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.deleted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="访问修改器">访问修改器</span></h3><p>按照访问作用域划分，目前有以下几种，</p><ul><li><code>public</code>:</li><li><code>private</code>:</li><li><code>protected</code>:</li><li><default>:</default></li></ul><h3><span id="setter和getter">Setter和Getter</span></h3><p>和Java不同，TS中有关键字<code>get</code>和<code>set</code>，语法和方法类似，其中<code>get</code>不带参数；<code>set</code>但一个参数，一般用于私有方法的操作处理，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> _unitPrice: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">get</span> unitPrice(): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._unitPrice || <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> unitPrice(value: <span class="built_in">number</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>._unitPrice = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> table = <span class="keyword">new</span> Product();</span><br><span class="line">table.name = <span class="string">"Table"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(table.unitPrice);</span><br><span class="line">table.unitPrice = <span class="number">-10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(table.unitPrice);</span><br></pre></td></tr></table></figure><h3><span id="static">Static</span></h3><p>静态声明的方法或属性，作用域类自身而不是类的对象实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">static</span> getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = <span class="keyword">this</span>.product.unitPrice * <span class="keyword">this</span>.quantity;<span class="comment">// compile error</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态作用域里面的访问成员要求也必须是静态的，因此不能在静态方法中使用<code>this.properties</code>进行访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getTotal(unitPrice: <span class="built_in">number</span>, quantity: <span class="built_in">number</span>, discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = unitPrice * quantity;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = OrderDetail.getTotal(<span class="number">500</span>, <span class="number">2</span>, <span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br></pre></td></tr></table></figure><h2><span id="结构化-转变-为模块">结构化 转变 为模块</span></h2><p>由于TypeScript是最终编译成为JavaScript，并且其作用域的是全局的。这样就带来一个问题是，同名的条目会在不同文件中造成冲突，因此需要实现模块化来解决这个问题，使得代码更容易组织，更高的重用性。</p><h3><span id="模块化格式">模块化格式</span></h3><p>模块化是属于ES6的JavaScript的部分特性。简要描述一下TypeScript的不同模块化格式：</p><ul><li><code>AMD(Asynchronous Module Definition)</code>: 最常见，对目标浏览器，用一个<code>define</code>函数来定义模块。</li><li><code>CommonJS</code>: 用于Node.js程式，使用<code>module.exports</code>来定义模块，用<code>require</code>来定义依赖。</li><li><code>UMD(Universal Module Definition)</code>: 可以用于浏览器app和Node.js程式。</li><li><code>ES6</code>: 使用<code>export</code>关键字来定义模块，<code>import</code>来定义依赖。</li></ul><p>笔者这里使用ES6。</p><h3><span id="exporting">Exporting</span></h3><p>从一个module进行export以允许在其它module中被使用。使用<code>export</code>关键字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者重命名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Product <span class="keyword">as</span> Stock &#125;</span><br></pre></td></tr></table></figure><h3><span id="importing">Importing</span></h3><p>有export就需要在其它模块进行import，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">"./product"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line">getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者重命名，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product <span class="keyword">as</span> Stock &#125; <span class="keyword">from</span> <span class="string">"./product"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> OrderDetail &#123;</span><br><span class="line">product: Stock;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="default-exports">default exports</span></h3><p>带有<code>default</code> 语句的export不需要花括号，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Product <span class="keyword">from</span> <span class="string">"./product"</span>;</span><br></pre></td></tr></table></figure><h2><span id="编译配置">编译配置</span></h2><p>TypeScript的编译器是<code>tsc</code>，它会将对应的<code>TS</code>文件编译为<code>JS</code>文件，</p><p>新建文件，<code>orderDetail.ts</code>，内容如下，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Product &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">unitPrice: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> OrderDetail &#123;</span><br><span class="line">product: Product;</span><br><span class="line">quantity: <span class="built_in">number</span>;</span><br><span class="line">getTotal(discount: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">const</span> priceWithoutDiscount = <span class="keyword">this</span>.product.unitPrice * <span class="keyword">this</span>.quantity;</span><br><span class="line"><span class="keyword">const</span> discountAmount = priceWithoutDiscount * discount;</span><br><span class="line"><span class="keyword">return</span> priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开终端，输入如下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc orderDetail</span><br></pre></td></tr></table></figure><p>不出错的话，在对应目录会生成一个文件<code>orderDetail.js</code>，里面是转换的JavaScript内容，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">exports.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> OrderDetail = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OrderDetail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">OrderDetail.prototype.getTotal = <span class="function"><span class="keyword">function</span> (<span class="params">discount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> priceWithoutDiscount = <span class="keyword">this</span>.product.unitPrice * <span class="keyword">this</span>.quantity;</span><br><span class="line"><span class="keyword">var</span> discountAmount = priceWithoutDiscount * discount;</span><br><span class="line"><span class="keyword">return</span> priceWithoutDiscount - discountAmount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> OrderDetail;</span><br><span class="line">&#125;());</span><br><span class="line">exports.OrderDetail = OrderDetail;</span><br></pre></td></tr></table></figure><h3><span id="常见编译选项">常见编译选项</span></h3><ul><li><code>--target</code>: 目标，默认是<code>ES3</code>，</li><li><code>--outDir</code>: 输出目录</li><li><code>--module</code>: 指定模块格式，<code>--target</code>是ES3或ES5时，默认是<code>CommonJS</code></li><li><code>--allowJS</code>: 告诉编译器处理JavaScript文件，应对那些TypeScript无法应对时候，需要JavaScript的情况。</li><li><code>--watch</code>: watch mode模式，修改文件后保存后立即编译输出。</li><li><code>--noImplicitAny</code>: 强制显式指定<code>any</code>类型。</li><li><code>--noImplicitReturns</code>: 强制显式返回。即对于不是<code>void</code>返回类型，所有case必须有返回值。</li><li><code>--sourceMap</code>: development模式中，生成<code>*.map</code>文件，以允许调试</li><li><code>--moduleResolution</code>: 告诉编译器如何处理模块，有两个选项<code>classic</code>或<code>node</code>，如果不指定，默认是<code>classic</code>，会要求使用第三方包，所以需要显式设置为<code>node</code>，编译器会查找<code>node_modules</code>模块。</li></ul><h3><span id="tsconfigjson">tsconfig.json</span></h3><p><code>tsconfig.json</code>文件是上面这些开关的几种配置文件，样例如下，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"><span class="string">"target"</span>: <span class="string">"esnext"</span>,</span><br><span class="line"><span class="string">"outDir"</span>: <span class="string">"dist"</span>,</span><br><span class="line"><span class="string">"module"</span>: <span class="string">"es6"</span>,</span><br><span class="line"><span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line"><span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"noImplicitAny"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="指定编译文件">指定编译文件</span></h3><p>在<code>tsconfig.json</code>中可以指定编译那些TypeScript文件，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"files"</span>: [<span class="string">"product.ts"</span>, <span class="string">"orderDetail.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者指定目录，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"include"</span>: [<span class="string">"src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="typescript-linting">TypeScript linting</span></h3><p>linting是一种检查规则，用于加强语法或优化编译，参考TSLint官网。</p><h3><span id="code-formatting">Code Formatting</span></h3><p>代码格式化有很多种，常见的是<code>prettier</code>，另外还有less、css等等。</p><h2><span id="本章回归">本章回归</span></h2><ol><li>TS的5中原生类型是那些？// string, number, boolean, undefined, null</li><li>下面变量<code>flag</code>类型推断的类型是什么？// boolean</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>接口和类型别名的区别是什么？// type alias不能继承</li><li>下面代码有什么错误？如何处理？</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Product &#123;</span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> unitPrice: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> table = <span class="keyword">new</span> Product();</span><br><span class="line">table.name = <span class="string">"Table"</span>;</span><br><span class="line">table.unitPrice = <span class="number">700</span>;</span><br></pre></td></tr></table></figure><p>// 要么编写IProduct接口，继承成员属性；要么在Product中写上成员name，unitPrice；要么带上setter/getter方法；</p><ol start="5"><li>如果想要我们的TS支持IE11，编译选项<code>--target</code>应该带什么？</li><li>如何转换为ES6版本的<code>.js</code>文件？// --target ES6</li><li>如何阻止代码中出现<code>console.log</code>语句？// tslint.yml 带<code>no-console</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;TypeScript 的好处&lt;/li&gt;
&lt;li&gt;基础类型&lt;/li&gt;
&lt;li&gt;接口，类型alias，类&lt;/li&gt;
&lt;li&gt;模块结构&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;li&gt;TypeScript lint&lt;/li&gt;
&lt;li&gt;代码格式化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2
      
    
    </summary>
    
      <category term="react" scheme="http://galudisu.info/categories/react/"/>
    
    
      <category term="react" scheme="http://galudisu.info/tags/react/"/>
    
      <category term="typescript" scheme="http://galudisu.info/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Jira 快速安装</title>
    <link href="http://galudisu.info/2019/10/21/jira/jira-install/"/>
    <id>http://galudisu.info/2019/10/21/jira/jira-install/</id>
    <published>2019-10-21T09:13:27.000Z</published>
    <updated>2019-11-05T03:31:35.052Z</updated>
    
    <content type="html"><![CDATA[<p>JIRA是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件，开发者是澳大利亚的Atlassian。JIRA这个名字并不是一个缩写，而是截取自“<strong>Gojira</strong>”，日文的哥斯拉发音。</p><p>采用Docker实现破解版的Jira安装。</p><a id="more"></a><ol><li>下载镜像</li></ol><p>一定要安装<code>jira-software</code>(不是jira)，否则没有agile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dchevell/jira-software:7.13.0</span><br></pre></td></tr></table></figure><ol start="2"><li>运行容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it -p  8080:8080  --privileged  -m 4096M -v /data/jira-data:/var/atlassian/application-data/jira  -v /etc/localtime:/etc/localtime --name jira dchevell/jira-software:7.13.0</span><br></pre></td></tr></table></figure><ol start="3"><li>拷贝文件到容器内</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/mysql-connector-java-5.1.25-bin.jar</span><br><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/atlassian-universal-plugin-manager-plugin-2.22.4.jar</span><br><span class="line">wget https://github.com/hlwojiv/some-software/raw/master/Jira/atlassian-extras-3.2.jar</span><br></pre></td></tr></table></figure><p>拷贝mysql-connector</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp mysql-connector-java-5.1.25-bin.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</span><br></pre></td></tr></table></figure><p>进入容器修改mysql-connector的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/mysql-connector-java-5.1.25-bin.jar</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jira</span><br></pre></td></tr></table></figure><ol start="3"><li>安装MySQL</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -v /data/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --restart=unless-stopped -d mysql:5.7</span><br></pre></td></tr></table></figure><ol start="4"><li>设置</li></ol><p>浏览器访问JiraWeb，语言可以设为中文，选择「我将设置它自己」——「下一步」</p><p>数据库设置，数据库类型选择「MySQL」，接着填入你的MySQL连接信息（需要你在你的MySQL数据库中创建数据库，数据库的字符类型必须是utf8），测试可以连接之后点击「下一步」</p><p>设置应用程序的属性——「下一步」</p><p>申请许可证关键字，点击「生成Jira试用许可证」</p><p>需要注册账号，注册完之后重新回到这个页面，选择相关信息，点击「Generate License」</p><p>点击「Yes」</p><p>页面就会带着你的许可证关键字回到Jira的设置页面，接着点击「下一步」</p><p>等待一会就进入设置管理员页面，填入一些信息即可，接着「下一步」</p><p>点击「完成」即完成设置</p><ol start="5"><li>拷贝文件到容器内</li></ol><p>拷贝atlassian-extras到容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp atlassian-extras-3.2.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</span><br></pre></td></tr></table></figure><p>进入容器设置atlassian-extras的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/atlassian-extras-3.2.jar</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jira</span><br></pre></td></tr></table></figure><p>拷贝插件到容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp atlassian-universal-plugin-manager-plugin-2.22.4.jar jira:/opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jira bash</span><br><span class="line">chmod 755 /opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/atlassian-universal-plugin-manager-plugin-2.22.4.jar</span><br></pre></td></tr></table></figure><p>删除另一个插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /opt/atlassian/jira/atlassian-jira/WEB-INF/atlassian-bundled-plugins/atlassian-universal-plugin-manager-plugin-2.22.9.jar</span><br></pre></td></tr></table></figure><p>破解结束，进入jira下载任意插件，申请试用，自动破解</p><ol start="6"><li>下面来下载一个收费软件试试</li></ol><p>安装完了点击「获取许可证」</p><p>接着在「管理应用」中可以看到，该插件已经破解了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JIRA是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件，开发者是澳大利亚的Atlassian。JIRA这个名字并不是一个缩写，而是截取自“&lt;strong&gt;Gojira&lt;/strong&gt;”，日文的哥斯拉发音。&lt;/p&gt;
&lt;p&gt;采用Docker实现破解版的Jira安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="jira" scheme="http://galudisu.info/tags/jira/"/>
    
  </entry>
  
  <entry>
    <title>随机算法关于生日悖论的求值</title>
    <link href="http://galudisu.info/2019/02/26/algorithm/probabilistic/birthday-paradox-problem/"/>
    <id>http://galudisu.info/2019/02/26/algorithm/probabilistic/birthday-paradox-problem/</id>
    <published>2019-02-26T12:13:58.000Z</published>
    <updated>2019-08-27T09:05:47.468Z</updated>
    
    <content type="html"><![CDATA[<p>In probability theory, the birthday problem, or birthday paradox This not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naive intuition: most people estimate that the chance is much lower than 50%. pertains to the probalility that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probalility that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reachese 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap yeas). The mathematics behind this problem lead to a well-known cryptographic attack call the birthday attack.</p><a id="more"></a><p>Using simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 &amp; 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive…</p><h2><span id="calculating-the-probalility">Calculating the probalility</span></h2><p>数学概率推导方法，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">probe</span></span>(n: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> probe: <span class="built_in">f64</span> = <span class="number">0</span>.;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> k &lt; n &#123;</span><br><span class="line">        k += <span class="number">1</span>;</span><br><span class="line">        probe = <span class="number">1.0</span> - ((<span class="number">1.0</span> - probe) * ((<span class="number">365</span> - (k - <span class="number">1</span>)) <span class="keyword">as</span> <span class="built_in">f64</span>) / (<span class="number">365</span> <span class="keyword">as</span> <span class="built_in">f64</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Number of people: &#123;&#125;, \tProb. of same birthday: &#123;&#125;"</span>, k, probe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="birthday-attack">Birthday Attack</span></h2><p>生日悖论可以描述为：在N个人中，想使至少由两个人生日相同的概率大于50%，问N的最小值是多少？答案是23人。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DAYS_IN_YEAR: <span class="built_in">usize</span> = <span class="number">365</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">equal_birthdays</span></span>(n_sharers: <span class="built_in">usize</span>, group_size: <span class="built_in">usize</span>, n_repetitions: <span class="built_in">usize</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rng = rand::thread_rng();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> eq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..n_repetitions &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> group = <span class="built_in">vec!</span>[<span class="number">0</span>; DAYS_IN_YEAR];</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..group_size &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = rng.gen_range(<span class="number">0</span>, group.len());</span><br><span class="line">            group[idx] = group[idx] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> group.iter() &#123;</span><br><span class="line">            <span class="keyword">if</span> *k &gt;= n_sharers &#123;</span><br><span class="line">                eq = eq + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (eq <span class="keyword">as</span> <span class="built_in">f64</span> * <span class="number">100.0</span>) / n_repetitions <span class="keyword">as</span> <span class="built_in">f64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> group_est = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> sharers <span class="keyword">in</span> <span class="number">2</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="comment">// Coarse.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> group_size = group_est + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> equal_birthdays(sharers, group_size, <span class="number">100</span>) &lt; <span class="number">50.0</span> &#123;</span><br><span class="line">            group_size = group_size + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finer.</span></span><br><span class="line">        <span class="keyword">let</span> inf = ((group_size - (group_size - group_est)) <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="number">4.0</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">for</span> gs <span class="keyword">in</span> inf..(group_size + <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eq = equal_birthdays(sharers, group_size, <span class="number">250</span>);</span><br><span class="line">            <span class="keyword">if</span> eq &gt; <span class="number">50.0</span> &#123;</span><br><span class="line">                group_size = gs;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> gs <span class="keyword">in</span> (group_size - <span class="number">1</span>)..(group_size + <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eq = equal_birthdays(sharers, gs, <span class="number">50_000</span>);</span><br><span class="line">            <span class="keyword">if</span> eq &gt; <span class="number">50.0</span> &#123;</span><br><span class="line">                group_est = gs;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"&#123;&#125; independent people in a group of &#123;&#125; share a common birthday. &#123;&#125;"</span>, sharers, gs, eq);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In probability theory, the birthday problem, or birthday paradox This not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naive intuition: most people estimate that the chance is much lower than 50%. pertains to the probalility that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probalility that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reachese 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap yeas). The mathematics behind this problem lead to a well-known cryptographic attack call the birthday attack.&lt;/p&gt;
    
    </summary>
    
    
      <category term="probabilistic" scheme="http://galudisu.info/tags/probabilistic/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7快速构建Ceph集群</title>
    <link href="http://galudisu.info/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/"/>
    <id>http://galudisu.info/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/</id>
    <published>2019-02-08T02:34:51.000Z</published>
    <updated>2019-08-27T09:05:47.477Z</updated>
    
    <content type="html"><![CDATA[<p>Ceph是一个分布式、可扩展、高可用、性能优异的存储系统平台，支持块设备、文件系统和REST三种存储接口。它是一个高度可配置的系统，并提供了一个命令行界面用于监视和控制其存储集群。Ceph还包含认证和授权功能，可兼容多种存储网关接口，如OpenStack Swift和Amazon S3。</p><a id="more"></a><h2><span id="ceph-cluster">Ceph cluster</span></h2><p>机器准备，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ceph    10.10.51.200</span><br><span class="line">mon1    10.10.51.201</span><br><span class="line">mon2    10.10.51.202</span><br><span class="line">mon3    10.10.51.203</span><br><span class="line">osd1    10.10.51.211   (10.10.110.211)</span><br><span class="line">osd2    10.10.51.212   (10.10.110.212)</span><br><span class="line">osd3    10.10.51.213   (10.10.110.213)</span><br><span class="line">osd4    10.10.51.214   (10.10.110.214)</span><br></pre></td></tr></table></figure><p>因为ceph-deploy工具是通过主机名与其他节点通信，所以要通过hostnamectl修改主机名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname ceph</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname mon1</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname mon2</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname mon3</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname osd1</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname osd2</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname osd3</span><br><span class="line">hostnamectl --static <span class="built_in">set</span>-hostname osd4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每个节点执行以下命令，</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">useradd -d /home/cephuser -m cephuser</span><br><span class="line">passwd cephuser</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cephuser ALL = (root) NOPASSWD:ALL"</span> | sudo tee /etc/sudoers.d/cephuser</span><br><span class="line">chmod 0440 /etc/sudoers.d/cephuser</span><br><span class="line">yum install -y ntp ntpdate ntp-doc</span><br><span class="line">ntpdate 0.us.pool.ntp.org</span><br><span class="line">hwclock --systohc</span><br><span class="line">systemctl <span class="built_in">enable</span> ntpd.service</span><br><span class="line">systemctl start ntpd.service</span><br><span class="line">yum install -y open-vm-tools <span class="comment">## If you run the nodes as virtual machines, otherwise remove this line</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config</span><br><span class="line">sed -i s<span class="string">'/Defaults requiretty/#Defaults requiretty'</span>/g /etc/sudoers</span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure><p>每个节点建立cephuser用户的ssh连接，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id cephuser@osd1</span><br></pre></td></tr></table></figure><p>在每个节点执行下面命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br><span class="line">Host osd1</span><br><span class="line">Hostname osd1</span><br><span class="line">User cephuser</span><br><span class="line">Host osd2</span><br><span class="line">Hostname osd2</span><br><span class="line">User cephuser</span><br><span class="line">Host osd3</span><br><span class="line">Hostname osd3</span><br><span class="line">User cephuser</span><br><span class="line">Host osd4</span><br><span class="line">Hostname osd4</span><br><span class="line">User cephuser</span><br><span class="line">Host mon1</span><br><span class="line">Hostname mon1</span><br><span class="line">User cephuser</span><br><span class="line">Host mon2</span><br><span class="line">Hostname mon2</span><br><span class="line">User cephuser</span><br><span class="line">Host mon3</span><br><span class="line">Hostname mon3</span><br><span class="line">User cephuser</span><br></pre></td></tr></table></figure><p>更改权限，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 440 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>每个OSD节点准备磁盘，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parted -s /dev/sdc mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sdc -f</span><br><span class="line">parted -s /dev/sdd mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sdd -f</span><br><span class="line">parted /dev/sde mklabel gpt mkpart primary xfs 0% 100%</span><br><span class="line">mkfs.xfs /dev/sde -f</span><br><span class="line">parted -s /dev/sdb mklabel gpt mkpart primary 0% 33% mkpart primary 34% 66% mkpart primary 67% 100%</span><br></pre></td></tr></table></figure><p><img src="/img/ceph/osd-disk.png" alt=""></p><p>使用cephuser账号登录管理节点(即ceph node)，创建一个专用目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ceph-deploy</span><br><span class="line"><span class="built_in">cd</span> ceph-deploy/</span><br></pre></td></tr></table></figure><p>在监控节点安装和创建新集群，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uhv http://download.ceph.com/rpm-jewel/el7/noarch/ceph-release-1-1.el7.noarch.rpm</span><br><span class="line">sudo yum update -y &amp;&amp; sudo yum install ceph-deploy -y</span><br></pre></td></tr></table></figure><p>初始化配置，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi ceph.conf</span><br><span class="line">public network = 10.10.51.0/24</span><br><span class="line">cluster network = 10.10.110.0/24</span><br><span class="line"><span class="comment">#Choose reasonable numbers for number of replicas and placement groups.</span></span><br><span class="line">osd pool default size = 2 <span class="comment"># Write an object 2 times</span></span><br><span class="line">osd pool default min size = 1 <span class="comment"># Allow writing 1 copy in a degraded state</span></span><br><span class="line">osd pool default pg num = 256</span><br><span class="line">osd pool default pgp num = 256</span><br><span class="line"><span class="comment">#Choose a reasonable crush leaf type</span></span><br><span class="line"><span class="comment">#0 for a 1-node cluster.</span></span><br><span class="line"><span class="comment">#1 for a multi node cluster in a single rack</span></span><br><span class="line"><span class="comment">#2 for a multi node, multi chassis cluster with multiple hosts in a chassis</span></span><br><span class="line"><span class="comment">#3 for a multi node cluster with hosts across racks, etc.</span></span><br><span class="line">osd crush chooseleaf <span class="built_in">type</span> = 1</span><br></pre></td></tr></table></figure><p>然后，在为个节点安装ceph，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install ceph mon1 mon2 mon3 osd1 osd2 osd3 osd4</span><br><span class="line">ceph-deploy mon create-initial</span><br><span class="line">ceph-deploy gatherkeys mon1</span><br></pre></td></tr></table></figure><p>在每个OSD节点创建OSD磁盘，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy disk zap osd1:sdc osd1:sdd osd1:sde</span><br><span class="line">ceph-deploy osd create osd1:sdc:/dev/sdb1 osd1:sdd:/dev/sdb2 osd1:sde:/dev/sdb3</span><br></pre></td></tr></table></figure><p>集群创建完后，发现OSD没有开启，这时新版ceph-deploy一个issue，执行下面命令解决，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sgdisk -t 1:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br><span class="line">sgdisk -t 2:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br><span class="line">sgdisk -t 3:45b0969e-9b03-4f30-b4c6-b4b80ceff106 /dev/sdb</span><br></pre></td></tr></table></figure><p>重启每个节点，给每个monitor加入systemd，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> ceph-mon.target</span><br></pre></td></tr></table></figure><p>最后，给所有节点部署密钥，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy admin ceph mon1 mon2 mon3 osd1 osd2 osd3 osd4</span><br><span class="line">sudo chmod +r /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure><p>一切如果正常，使用<code>ceph -v</code>和<code>ceph -s</code>会看到，</p><p><img src="/img/ceph/ceph-cluster.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ceph是一个分布式、可扩展、高可用、性能优异的存储系统平台，支持块设备、文件系统和REST三种存储接口。它是一个高度可配置的系统，并提供了一个命令行界面用于监视和控制其存储集群。Ceph还包含认证和授权功能，可兼容多种存储网关接口，如OpenStack Swift和Amazon S3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ceph" scheme="http://galudisu.info/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 设计理念及主要概念之Volume(四)</title>
    <link href="http://galudisu.info/2019/02/08/kubernetes/kubernetes-04-theory-and-concpetion-md/"/>
    <id>http://galudisu.info/2019/02/08/kubernetes/kubernetes-04-theory-and-concpetion-md/</id>
    <published>2019-02-08T02:16:43.000Z</published>
    <updated>2019-08-27T09:05:47.521Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="kubernetes存储卷">Kubernetes存储卷</span></h2><p>默认情况下容器的数据都是非持久化的，在容器消亡以后数据也跟着丢失，所以Docker提供了Volume机制以便将数据持久化存储。类似的，Kubernetes提供了更强大的Volume机制和丰富的插件，解决了容器数据持久化和容器间共享数据的问题。</p><p>与Docker不同，Kubernetes Volume的生命周期与Pod绑定</p><ul><li>容器挂掉后Kubelet再次重启容器时，Volume的数据依然还在</li><li>而Pod删除时，Volume才会清理。数据是否丢失取决于具体的Volume类型，比如emptyDir的数据会丢失，而PV的数据不会丢失</li></ul><a id="more"></a><ol><li>Volume类型</li></ol><p>目前，Kubernetes支持以下Volume类型：</p><ul><li>emptyDir</li><li>hostPath</li><li>gcePersistentDisk</li><li>awsElasticBlokStore</li><li>nfs</li><li>iscsi</li><li>flocker</li><li>glusterfs</li><li>rbd</li><li>cephfs</li><li>gitRepo</li><li>secret</li><li>persistentVolumeClaim</li><li>downwardAPI</li><li>azureFileVolume</li><li>vsphereVolume</li><li>Quobyte</li><li>PortworxVolume</li><li>ScaleIO</li><li>FlexVolume</li><li>StorageOS</li><li>local</li></ul><p>这些Volume并非全部都是持久化的，emptyDir与hostPath数据节点级别的卷类型，emptyDir的生命周期与Pod资源相同，而使用hostPath卷的Pod一旦被重新调度至其他节点，那么它将无法再使用此前的数据。</p><p>再如，Secret和ConfigMap算得上是两种特殊的卷类型。</p><ul><li><p>Secret用于向Pod传递敏感信息、如密码、私钥、证书文件等，这些信息如果直接定义在镜像中很容易导致泄露，有了Secret资源，用户可以将这些信息存储于集群中而后再由Pod进行挂载，从而实现将敏感数据与系统解耦。</p></li><li><p>ConfigMap资源则用于向Pod注入非敏感数据，使用时，用户将数据直接存储于ConfigMap对象中，而后直接在Pod中使用ConfigMap卷引用它即可，它可以帮助实现容器配置文件集中化定义和管理。</p></li></ul><p>因此，类似于emptyDir、hostPath、secret、gitRepo等，这些Volume会随着Pod的消亡而消失。</p><ol start="2"><li>Volume的使用</li></ol><p>在Pod中定义Volume由两部分组成：一是<code>.spec.valumes</code>，用于支持不同的Volume类型；二是<code>.spec.containers.volumeMounts</code>，用于定义挂载列表。</p><p>在Pod级别定义Volume，<code>.spec.volumes</code>字段可以定义多个Volume，例如下面定义了emptyDir类型和gitRepo类型，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">logdata</span></span><br><span class="line"><span class="attr">  emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">  gitRepo:</span></span><br><span class="line"><span class="attr"> repository:</span> <span class="attr">https://github.com/barudisshu/kubernetes-pratise.git</span></span><br><span class="line"><span class="attr"> revision:</span> <span class="string">master</span></span><br><span class="line"><span class="attr"> directory:</span> <span class="string">.</span></span><br></pre></td></tr></table></figure><p>定义好的Volume可以共享。当Pod中只有一个容器时，使用存储卷通常用于数据持久化。</p><p><code>.spec.containers.volumeMounts</code>字段定义了Volume的挂载列表。它的挂载格式是固定的，如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"> spec:</span></span><br><span class="line">   <span class="string">...</span></span><br><span class="line"><span class="attr">   containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">&lt;String&gt;</span></span><br><span class="line"> <span class="string">...</span></span><br><span class="line"><span class="attr"> volumeMounts:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span> <span class="bullet">-required-</span></span><br><span class="line">   <span class="string">mountPath</span> <span class="string">&lt;string&gt;</span> <span class="bullet">-required-</span></span><br><span class="line"><span class="string">readOnly</span> <span class="string">&lt;boolean&gt;</span></span><br><span class="line"><span class="string">subPath</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="string">montPropagation</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name<string>：指定要挂载的存储的名称，必选</string></li><li>mountPath<string>：挂载点路径，容器文件系统上的路径，必选</string></li><li>readOnly<boolean>：是否挂载为只读</boolean></li><li>subPath<string>：子路径，即mountPath指定的路径下的一个字路径</string></li></ul><p>例如，容器myapp将logdata存储卷挂载在/var/log/myapp，将example挂载到/webdata/example目录，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">ikubernetes/myapp:v7</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">logdata</span></span><br><span class="line"><span class="attr">    mountPath:</span> <span class="string">/var/log/myapp/</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">    mountPath:</span> <span class="string">/webdata/example/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>emptyDir</li></ol><p>emptyDir，如果Pod设置了emptyDir类型Volume，Pod被分配到Node上时候，会创建emptyDir，只要Pod运行在Node上，emptyDir都会存在(容器挂掉不会导致emptyDir丢失数据)，但是如果Pod从Node上被删除(Pod被删除，或者Pod发生迁移)，emptyDir也会被删除，并且永久丢失。</p><p><code>.spec.volumes.emptyDir</code>嵌套字段包含有，</p><ul><li>medium：存储介质的类型，默认为default,表示为使用节点默认存储介质；另一种是Memory，表示使用RAM的临时文件系统tmpfs，空间受限于内存，但性能非常好，通常用于作为缓存。</li><li>sizeLimit：当前Volume的空间限额，默认为nil，表示不限制；不过如果medium字段值为Memory时建议定义限额。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">vol-emptydir-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">vol-emptydir-pod</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.12-alpine</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">pagegen</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/html</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"-c"</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">$(hostname)</span> <span class="string">$(date)</span> <span class="string">&gt;&gt;</span> <span class="string">/html/index.html;</span></span><br><span class="line">            <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line">          <span class="string">done</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>容器pagegen每隔10秒向Volume上的index.html文件追加一行信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods vol-emptydir-pod</span><br></pre></td></tr></table></figure><p>创建Service或直接在集群访问Pod的信息，可看到，</p><p><img src="/img/kubernetes/pagegen-vol.png" alt=""></p><p>边车(sidecar)容器pagegen每隔10秒生成一行信息追加到Volume上的index.html文件。另外emptyDir存储卷可以基于RAM创建tmpfs文件系统的存储卷，常用于缓存，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">  emptyDir:</span></span><br><span class="line"><span class="attr"> medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure><ol start="4"><li>gitRepo</li></ol><p>gitRepo存储卷是emptyDir的实际应用，它看做是将一份Git仓储中的数据克隆(clone)到创建的空目录(emptyDir)，而后再创建容器并挂载该存储卷。</p><p>gitRepo存储卷自Kubernetes1.12开始已经废弃，所以这里不再陈述。</p><ol start="5"><li>hostPath</li></ol><p>hostPath运行挂载Node上的文件系统到Pod里面去。如果Pod需要使用Node上的文件，可以使用hostPath。因为它独立于Pod资源的生命周期，因而具有持久性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">vol-hostpath-pod</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">ikubernetes/filebeat:5.6.7-alpine</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">REDIS_HOST</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">redis.kubernetes.io:6379</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LOG_LEVEL</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">socket</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">socket</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><p>这类Pod资源通常受控于daemonset类型的Pod控制器，它运行于集群中的每个工作节点之上，负责收集工作节点上系统级的相关数据，因此使用hostPath存储卷。这里的filebeat应用架构中，通过Redis进行资源收集，这些收集的日志信息会发往ELK进行统计展示。</p><p>hostPath上如果是不受控于Daemonset的无状态应用，重新调度节点运行时，无法确保此前创建的文件或目录是否存在。因此，hostPath虽能持久化数据，但对调度器来说并不适用，这时需要用到独立于集群节点的持久化存储卷，即网络存储卷。</p><blockquote><p>网络存储卷，就是类似于NAS或SAN设备、分布式存储(GlusterFS、RBD)、云端存储(gcePersistentDisk、azureDisk、cinder和awsElasticBlockStore)以及构建在各类存储系统之上的抽象管理层(flocker、portworx Volume和vsphere Volume)等这类网络服务存储。</p></blockquote><ol start="6"><li>NFS</li></ol><p>NFS，即Network File System，网络文件系统。Kubernetes中通过简单配置可以挂在NFS到Pod中，而NFS中的数据是可以永久保存的，同时NFS支持同时写操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">vol-nfs-pod</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:4-alpine</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redisport</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/data</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redisdata</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redisdata</span></span><br><span class="line"><span class="attr">      nfs:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/data/redis</span></span><br><span class="line"><span class="attr">        server:</span> <span class="string">nfs.kubernetes.io</span></span><br><span class="line"><span class="attr">        readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>RBD</li></ol><p>Ceph RBD<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是一个分布式、弹性可扩展的、高可靠的、性能优异的存储系统平台。要配置Pod资源使用RBD存储卷，前提条件要满足：</p><ul><li>Ceph RBD存储集群，</li><li>Ceph RBD集群中创建有满足Pod资源数据用到的存储image</li><li>Kubernetes集群内各个节点需要安装Ceph客户端程序包(ceph-common)</li></ul><p>它的字段信息有，</p><ul><li><code>monitors&lt;[]string&gt;</code>：Ceph存储监视器，逗号分隔的字符串列表；必选字段</li><li><code>image&lt;string&gt;</code>：rados image的名称，必选字段</li><li><code>pool&lt;string&gt;</code>：rados存储池名称，默认为RBD</li><li><code>user&lt;string&gt;</code>：rados用户名，默认为admin</li><li><code>keyring&lt;string&gt;</code>：RBD用户认证时使用的keyring文件路径，默认为<code>/etc/ceph/keyring</code></li><li><code>secretRef&lt;Object&gt;</code>：RBD用户认证时使用的保存有相应认证信息的Secret对象，会覆盖由keyring字段提供的密钥信息</li><li><code>readOnly&lt;boolean&gt;</code>：是否以只读的方式进行访问</li><li><code>fsType</code>：要挂载的存储卷的文件系统类型，至少应该是节点操作系统支持的文件系统，如ext4、xfs、ntf等，默认为ext4</li></ul><p>下面是使用RBD存储卷的Pod资源示例，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"kubernetes.io/rbd"</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">QVFENnNsNWMrQm52T2hBQXVYclJVeVNuUzBhOXVUVk00WnpiVFE9PQ==</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-rbd</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line"><span class="attr">  monitors:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.32</span><span class="string">,192.168.50.33,192.168.50.34</span></span><br><span class="line"><span class="attr">  adminId:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  adminSecretName:</span> <span class="string">ceph-secret</span></span><br><span class="line"><span class="attr">  pool:</span> <span class="string">kube</span></span><br><span class="line"><span class="attr">  userId:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  userSecretName:</span> <span class="string">ceph-secret</span></span><br><span class="line"><span class="attr">  fsType:</span> <span class="string">xfs</span></span><br><span class="line"><span class="attr">  imageFormat:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">  imageFeatures:</span> <span class="string">"layering"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">vol-rbd-pod</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:4-alpine</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redisport</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/data</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redis-rbd-vol</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redis-rbd-vol</span></span><br><span class="line"><span class="attr">      persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">        claimName:</span> <span class="string">ceph-claim</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOne</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>该示例依赖于事先存在的一个Ceph存储集群，这里假设其监视器的地址为192.168.50.32、192.168.50.33、192.168.50.34三个主机，并且集群上的存储池kube中存在创建好的映像Redis，此映像拥有xfs文件系统。Ceph客户端访问集群时需要事先完成认证之后才能进行后续访问操作，认证信息保存于名为ceph-secret的Secret资源对象中。</p><p>更多关于reph的配置方式，参考<a href="https://jimmysong.io/kubernetes-handbook/practice/using-ceph-for-persistent-storage.html" target="_blank" rel="noopener">这里</a>。</p><ol start="8"><li>GlusterFS 存储卷</li></ol><p>GlusterFS(Gluster File System)是一个开源的分布式文件系统，是水平扩展存储解决方案Gluster的核心，具有强大的横向扩展能力，GlusterFS通过扩展能够支持数PB存储容量和处理数千客户端。要配置Pod资源使用GlusterFS存储卷，需要事先满足以下前提条件。</p><ul><li>存在某个可用集群，</li><li>在GlusterFS集群创建了Pod需要使用的Volume，</li><li>Kubernetes集群各个节点安装GlusterFS客户端程序包(glusterfs和glusterfs-fuse),</li></ul><p>Pod定义GlusterFS类型Volume，包含的字段有，</p><ul><li><code>endpoint&lt;string&gt;</code>：访问入口，必选字段，</li><li><code>path&lt;string&gt;</code>：用到GlusterFS集群的卷路径，</li><li><code>readOnly&lt;boolean&gt;</code>：是否为只读卷，</li></ul><p>下面是一个定义在vol-glusterfs.yaml配置文件中的Pod资源示例，它使用了GlusterFS存储卷持久保存应用数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">vol-glusterfs-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">vol-glusterfs-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">redis:alpine</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redisport</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/data</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">redisdata</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redisdata</span></span><br><span class="line"><span class="attr">      glusterfs:</span></span><br><span class="line"><span class="attr">        endpoints:</span> <span class="string">glusterfs-endpoints</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">kube-redis</span></span><br><span class="line"><span class="attr">        readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>另外创建Endpoints资源glusterfs-endpoints，以用于Pod资源访问，</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="/2019/02/08/ceph/quickly-build-a-new-ceph-cluster-with-ceph-deploy-on-centos-7/">Ceph集群安装</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kubernetes存储卷&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#kubernetes存储卷&quot;&gt;¶&lt;/a&gt;Kubernetes存储卷&lt;/h2&gt;
&lt;p&gt;默认情况下容器的数据都是非持久化的，在容器消亡以后数据也跟着丢失，所以Docker提供了Volume机制以便将数据持久化存储。类似的，Kubernetes提供了更强大的Volume机制和丰富的插件，解决了容器数据持久化和容器间共享数据的问题。&lt;/p&gt;
&lt;p&gt;与Docker不同，Kubernetes Volume的生命周期与Pod绑定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器挂掉后Kubelet再次重启容器时，Volume的数据依然还在&lt;/li&gt;
&lt;li&gt;而Pod删除时，Volume才会清理。数据是否丢失取决于具体的Volume类型，比如emptyDir的数据会丢失，而PV的数据不会丢失&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://galudisu.info/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 设计理念及主要概念之Service(三)</title>
    <link href="http://galudisu.info/2019/02/06/kubernetes/kubernetes-03-theory-and-concpetion-md/"/>
    <id>http://galudisu.info/2019/02/06/kubernetes/kubernetes-03-theory-and-concpetion-md/</id>
    <published>2019-02-06T02:16:43.000Z</published>
    <updated>2019-08-27T09:05:47.519Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="服务发现与负载均衡">服务发现与负载均衡</span></h2><p>Kubernetes提供有服务发现和负载均衡机制，提供了Service资源，并通过kube-proxy配合cloud provider来适应不同的应用场景。</p><p>目前，Kubernetes中的负载均衡大致可以分为以下几种机制，每种机制都有其特定的应用场景：</p><ul><li>Service：直接用Service提供cluster内部的负载均衡，并借助cloud provider提供的LB提供外部访问</li><li>Ingress Controller：还是用Service提供cluster内部的负载均衡，但是通过自定义LB提供外部访问</li><li>Service Load Balancer：把load balancer直接跑在容器中，实现Bare Metal的Service Load Balancer</li><li>Custom Load Balancer：自定义负载均衡，并替代kube-proxy，一般在物理部署Kubernetes时使用，方便接入公司已有的外部服务</li></ul><a id="more"></a><h2><span id="service">Service</span></h2><p><img src="/img/kubernetes/service.svg" alt="service"></p><p>Kubernetes设计了Service的抽象：逻辑上的一组Pod，一种可以访问它们的策略。这一组Pod能够被Service访问，并为它们提供一个统一的入口。通常是通过Label Selector实现的。借助Service，应用可以方便的实现服务发现与负载均衡，实现应用的零宕机升级。</p><p>Service通过标签选取服务后端，一般配合Replication Controller或者Deployment来保证后端容器的正常运行。这些匹配标签的Pod IP和端口列表组成endpoints，由kube-proxy负责将服务IP负载均衡到这些endpoints上。</p><p>Service由四种类型：</p><ul><li>ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li><li>NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过<code>&lt;NodeIP&gt;:NodePort</code>来访问该服务</li><li>LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到<code>&lt;NodeIP&gt;:NodePort</code></li><li>ExternalName：将服务通过DNS CNAME记录方式转发到指定的域名(通过<code>spec.externalName</code>设定)。需要kube-dns版本在1.7以上。</li></ul><p>另外，也可以将已有的服务以Service的形式加入到Kubernetes集群中来，只需要在创建Service的时候不指定Label selector，而是在Service创建好后手动为其添加endpoint。</p><ol><li>Service定义</li></ol><p>通过yaml或json定义，比如下面定义一个名为nginx的服务，将服务的80端口转发到default namespace中带有标签<code>run=nginx</code>的Pod的80端口，</p><p>在此之前，首先要部署Pod，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>其次再定义Service，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure><p>Service自动分配了Cluster IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> kubectl get service nginx-app       </span><br><span class="line">NAME        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">nginx-app   ClusterIP   10.108.166.254   &lt;none&gt;        80/TCP    22s</span><br></pre></td></tr></table></figure><p>自动创建的endpoint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints nginx-app</span><br><span class="line">NAME        ENDPOINTS                       AGE</span><br><span class="line">nginx-app   10.244.1.38:80,10.244.3.28:80   82s</span><br></pre></td></tr></table></figure><p>自动关联endpoint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe service nginx-app  </span><br><span class="line">Name:              nginx-app</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            run=nginx-app</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          run=nginx-app</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.108.166.254</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.38:80,10.244.3.28:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不指定Selectors服务</li></ol><p>在创建Service的时候，也可以不指定Selectors，用来将Service转发到Kubernetes集群外部的服务(而不是Pod)。目前有两种方法</p><p>一是， 自定义endpoint，即创建同名的service和endpoint，在endpoint中设置外部服务的IP和端口</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">      - ip:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><p>二是，通过DNS转发，在Service定义中指定externalName。此时DNS服务会给<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>创建一个CNAME记录，其值为<code>my.database.example.com</code>。并且，该服务不会自动分配Cluster IP，需要通过Service的DNS来访问(这种服务也称为Headless Service)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ExternalName</span></span><br><span class="line"><span class="attr">  externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Headless服务</li></ol><p>Headless服务即不需要Cluster IP的服务，即在创建Service的时候，指定<code>spec.clusterIP=None</code>，包括两种类型，</p><ul><li>不指定Selectors，但设置externalName，通过CNAME记录处理</li><li>指定Selectors，通过DNS A记录设置后端endpoint列表</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tcp-80-80-3b6tl</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  revisionHistoryLimit:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="attr">nginx:latest</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>查询构建的nginx服务，可以看到Cluster IP是None</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service --all-namespaces=<span class="literal">true</span></span><br><span class="line">NAMESPACE     NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">default       kubernetes             ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP         36h</span><br><span class="line">default       nginx-app              ClusterIP   None            &lt;none&gt;        80/TCP          43s</span><br><span class="line">kube-system   kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP   36h</span><br><span class="line">kube-system   kubernetes-dashboard   NodePort    10.96.197.202   &lt;none&gt;        443:31234/TCP   27h</span><br></pre></td></tr></table></figure><p>查询部署的Pod信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> kubectl get pods -n default -o wide</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE    IP            NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-app-7d77b84f86-rsmrp   1/1     Running   0          2m1s   10.244.3.30   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-app-7d77b84f86-snx4p   1/1     Running   0          2m1s   10.244.2.19   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @10.96.0.10 nginx-app.default.svc.cluster.local</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/dig-nginx.png" alt="dig-nginx"></p><p>这类Headless Service资源，一般通过Ingress Controller进行负载，</p><ol start="4"><li>服务暴露</li></ol><p>Service的IP地址仅在集群内可达，然而有些服务需要暴露外部网络。此时需要在集群边缘为其添加一层转发机制，以实现将外部请求流量接入到集群Service资源上，</p><p>Kubernetes的Service共有四种类型， ClusterIP、NodePort、LoadBalancer和ExternalName：</p><ul><li>ClusterIP Service：使用iptables模式，集群内部的源IP会保留(不做SNAT)。如果client和server pod在同一个Node上，那源IP就是client pod的IP地址；如果在不同的Node上，源IP则取决于网络插件是如何处理的，比如使用flannel时，源IP是node flannel IP地址。</li><li>NodePort Service：源IP会做SNAT，server pod看到的源IP是Node IP。为了避免这种情况，可以给service加上annotation <code>service.beta.kubernetes.io/external-traffic=OnlyLocal</code>，让service只代理本地endpoint的请求(如果没有本地endpoint则直接丢包)，从而保留源IP。</li><li>LoadBalancer Service：源IP会做SNAT，server pod看到的源IP是Node IP。在GKE/GCE中，添加annotation <code>service.beta.kubernetes.io/external-traffic=OnlyLocal</code>后可以自动从负载均衡器中删除没有本地endpoint的Node。</li><li>ExternalName：主机名被DNS服务解析至CNAME类型的记录。它并不是由Kubernetes集群提供的服务，而是把集群外部的某服务以DNS CNAME记录的方式映射到集群。因此这种类型的Service没有ClusterIP、NodePort、label、也不会有endpoint。</li></ul><blockquote><p>为了减缓IP地址空间枯竭问题，NAT被引入提出，主要有两种方式，</p></blockquote><blockquote><p>SNAT，源地址转换，Source Network Address Translation，在NAT路由中，将ipv4的源地址转换为公网可访问的IP<br>DNAT，目标地址转换，Destination Network Address Translation，在NAT路由中，将ipv4的目标地址转换为私有网络的可访问IP</p></blockquote><ol start="5"><li>Ingress Controller</li></ol><p>Service虽然解决了服务发现和负载均衡的问题，但它在使用上还是有一些限制，比如</p><ul><li>只支持4层负载均衡，没有7层功能</li><li>对外访问的时候，NodePort类型需要在外部搭建额外的负载均衡，而LoadBalancer要求Kubernetes必须跑在支持的cloud provider上面</li></ul><p>Ingress就是为了解决这些限制而引入的新资源，主要用来将服务暴露到cluster外面，并且可以自定义服务的访问策略。比如想要通过负载均衡器实现不同子域名到不同服务的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com --|                |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132 |</span><br><span class="line">bar.foo.com --|                |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></figure><p>可以这样来定义Ingress：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ingress</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/nginx</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>注意Ingress本身并不会自动创建负载均衡器，cluster中需要运行一个ingress controller来根据Ingress的定义来管理负载均衡器。目前设计提供了nginx和gce的参考实现。</p><p>Kubernetes中，Service资源和Pod资源的IP地址仅能用于集群网络内部的通信，所有的网络流量都无法穿透边界路由器(Edge Router)以实现集群内外通信。即使Service中使用NodePort或LoadBalancer通过节点引入外部流量，它依然是4层流量转发，可用的负载均衡器也为传输层负载均衡机制。</p><p>Ingress是Kubernetes API的标准资源类型之一，Ingress控制器可以由任何具有反向代理(HTTP/HTTPS)功能的服务程序实现，例如Nginx、Envoy、HAProxy、Vulcand和Traefik等。</p><p>Traefik提供了易用的Ingress Controller，使用方法见<a href="https://docs.traefik.io/user-guide/kubernetes/" target="_blank" rel="noopener">https://docs.traefik.io/user-guide/kubernetes/</a>。</p><p>不管怎样，你都需要先安装Ingress Controller，</p><p>首先确保nginx-ingress是否部署，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm list</span><br><span class="line">NAME               REVISIONUPDATED                 STATUS  CHART              APP VERSIONNAMESPACE</span><br><span class="line">rolling-rattlesnake1       Wed Feb  6 05:09:06 2019DEPLOYEDnginx-ingress-0.9.50.10.2     default</span><br></pre></td></tr></table></figure><p>如果没有安装，部署一份，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br></pre></td></tr></table></figure><p>另外还需要手动创建一份Service为其创建相关的NodePort或LoadBalancer，并明确指定端口和IP地址，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="number">10.99</span><span class="number">.99</span><span class="number">.99</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>这是因为Ingress规则需要由一个Service资源对象辅助识别相关的所有Pod对象，但ingress-nginx控制器可经由<code>host</code>规则的定义直接将流量调度，</p><p>下面动手实践一下，部署两份Ingress，负载到这个nginx-ingress-controller下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tomcat-deploy</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">testing</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">    - host:</span> <span class="string">tomcat.kubernetes.io</span></span><br><span class="line"><span class="attr">      http:</span></span><br><span class="line"><span class="attr">        paths:</span></span><br><span class="line"><span class="attr">          - backend:</span></span><br><span class="line"><span class="attr">              serviceName:</span> <span class="string">tomcat-svc</span></span><br><span class="line"><span class="attr">              servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ingress</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">    - host:</span> <span class="string">nginx.kubernetes.io</span></span><br><span class="line"><span class="attr">      http:</span></span><br><span class="line"><span class="attr">        paths:</span></span><br><span class="line"><span class="attr">          - backend:</span></span><br><span class="line"><span class="attr">              serviceName:</span> <span class="string">nginx-app</span></span><br><span class="line"><span class="attr">              servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/ingress-controller-service.png" alt=""></p><p>通常情况下，servcie和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其它地方。从概念上讲，可能是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internet</span><br><span class="line">      |</span><br><span class="line">------------</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>Ingress是授权入站连接到达集群服务的规则集合，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>Ingress控制器自身也是运行于集群中的Pod资源对象，它与被代理的运行为Pod资源的应用运行在同一网络中，</p><p><img src="/img/kubernetes/ingress-controller.svg" alt=""></p><p>在实际使用中，在集群之外应该存在一个用于调度用户请求至个节点上Ingress控制器相关的NodePort的负载均衡器。如果不具有LBaaS的使用条件，用户也可以基于Nginx、Haproxy、LVS等手动构建，并通过Keepalived等解决方案实现其服务的高可用配置。</p><p><img src="/img/kubernetes/nginx-lb.png" alt="nginx-lb"></p><ol start="6"><li>Service Load Balancer</li></ol><p>在Ingress出现以前，Service Load Blancer是推荐的解决Service局限性的方式。Service Load Balancer将haproxy跑在容器中，并监控service和endpoint的变化，通过容器IP对外提供4层和7层负载均衡服务。</p><p>社区提供的Service Load Balancer支持四种负载均衡协议：TCP、HTTP、HTTPS和SSL TERMINATION，并支持ACL访问控制。</p><ol start="7"><li>Custom Load Balancer</li></ol><p>虽然Kubernetes提供了丰富的负载均衡机制，但在实际使用的时候，还是会碰到一些复杂的场景是它不能支持的，比如</p><ul><li>接入已有的负载均衡设备</li><li>多租户网络情况下，容器网络和主机网络是隔离的，这样<code>kube-proxy</code>就不能正常工作</li></ul><p>这个时候可以自定义组件，并代替kube-proxy来做负载均衡。基本的思路是监控Kubernetes中Service和endpoint的变化，并根据这些变化来配置负载均衡器。比如weave flux、nginx plus、kube2haproxy等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务发现与负载均衡&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#服务发现与负载均衡&quot;&gt;¶&lt;/a&gt;服务发现与负载均衡&lt;/h2&gt;
&lt;p&gt;Kubernetes提供有服务发现和负载均衡机制，提供了Service资源，并通过kube-proxy配合cloud provider来适应不同的应用场景。&lt;/p&gt;
&lt;p&gt;目前，Kubernetes中的负载均衡大致可以分为以下几种机制，每种机制都有其特定的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service：直接用Service提供cluster内部的负载均衡，并借助cloud provider提供的LB提供外部访问&lt;/li&gt;
&lt;li&gt;Ingress Controller：还是用Service提供cluster内部的负载均衡，但是通过自定义LB提供外部访问&lt;/li&gt;
&lt;li&gt;Service Load Balancer：把load balancer直接跑在容器中，实现Bare Metal的Service Load Balancer&lt;/li&gt;
&lt;li&gt;Custom Load Balancer：自定义负载均衡，并替代kube-proxy，一般在物理部署Kubernetes时使用，方便接入公司已有的外部服务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://galudisu.info/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 设计理念及主要概念之Pod(二)</title>
    <link href="http://galudisu.info/2019/02/04/kubernetes/kubernetes-02-theory-and-concpetion-md/"/>
    <id>http://galudisu.info/2019/02/04/kubernetes/kubernetes-02-theory-and-concpetion-md/</id>
    <published>2019-02-04T02:16:43.000Z</published>
    <updated>2019-08-27T09:05:47.517Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群时配置Kubernetes的所有组件、功能和工作负载的物理平台。集群中一台服务器(或高可用部署中的一组服务器)作为Master，负责管理整个集群，其余作为Worker Node，集群中的主机可以是物理服务器，也可以是虚拟机(包括云VPS)。</p><a id="more"></a><h2><span id="集群概念">集群概念</span></h2><ol><li>Master节点</li></ol><p>Master是集群的网关和中枢，负责为用户和客户端暴露API、状态信息、管理和调度负责，以及编排其它组件之间的通信等任务。单个Master节点可以完成所有功能，实际生产环境由于负载均衡等目的，需要协同部署多个Master节点。</p><ol start="2"><li>Node节点</li></ol><p>Node节点属于Worker节点，由多个主机构建。Worker节点不暴露任何信息，不对外开发接口。</p><h2><span id="主要概念">主要概念</span></h2><p>Kubernetes由很多技术概念，同时对应很多API对象，API对象是k8s集群中的管理操作单元。</p><p>每个API对象都有3大类属性：元数据metadat、规范spec和状态status。元数据是用来表示API对象的，每个对象至少有3个元数据：namespace、name和uid；除此之外还有各种各样的标签label是用来标识和匹配不同的对象。规范spec描述了用户期望k8s集群中的分布式系统达到的理想状态(desired State)，状态status描述了系统实际当前达到的状态(Status)。</p><p>k8s中的API对象设计理念之一，是所有操作都是声明式的(Declarative)。所以你会发现会有很多yaml配置。声明式操作在分布式系统中的好处是稳定，不怕丢失操作或运行多次。</p><p>下面简述一些常见的API对象。</p><h2><span id="pod">Pod</span></h2><p>Pod是k8s的最小调度单元，同一个Pod中的容器共享网络名称空间和存储资源，这些容器可经本地回环节口lo直接通信，但彼此又在Mount、User及PID等名称空间上保持隔离。</p><p>特性：</p><ul><li>包含多个共享IPC、Network和UTC namespace的容器，可直接本地通信</li><li>所有Pod内容器都可以访问共享的Volume，可以访问共享数据</li><li>Pod一旦调度后就跟Node绑定，即使Node挂掉也不会重新调度，推荐使用Deployments、Daemonsets等控制器来容错</li><li>优雅终止：Pod删除的时候先给其内的进程发送SIGTERM，等待一段时间(grace period)后才强制停止运行的进程</li><li>特权容器(通过SecurityContext配置)具有改变系统配置的权限</li></ul><p><img src="/img/kubernetes/module_03_pods.svg" alt="Pod"></p><p>通过yaml或接送描述Pod和其内Container的运行环境以及期望状态，比如一个最简单的nginx pod可以定义为，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">sepc:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>volume可以为容器提供持久化存储，比如，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-storage</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/data/redis</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">redis-storage</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>重启机制，RestartPolicy</p><p>目前支持三种RestartPolicy</p><ul><li>Always: 只要退出就重启</li><li>OnFailure: 失败退出时重启</li><li>Never: 只要退出就不再重启</li></ul><p>这里的重启指在Pod所在Node本地重启，它不会调度到其它Node上去。</p><p>环境变量为容器提供了一些重要的资源，包括容器和Pod的基本信息以及集群中服务的信息等，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gcr.io/google_containers/busybox</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">[</span> <span class="string">"sh"</span><span class="string">,</span> <span class="string">"-c"</span><span class="string">]</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">env</span></span><br><span class="line"><span class="attr">resource:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"32Mi"</span></span><br><span class="line"><span class="attr">cpu:</span> <span class="string">"125m"</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line"><span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_NODE_NAME</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">sepc.nodeName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAME</span></span><br><span class="line">  <span class="attr">valueFrom:</span></span><br><span class="line">    <span class="attr">fieldRef:</span></span><br><span class="line">  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAMESPACE</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_SERVICE_ACCOUNT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">fieldRef:</span></span><br><span class="line">    <span class="attr">fieldPath:</span> <span class="string">spec.serviceAccountName</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_REQUEST</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line"><span class="attr">resourceFieldRef:</span></span><br><span class="line">  <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_LIMIT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_REQUEST</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEM_LIMIT</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">  <span class="attr">resourceFieldRef:</span></span><br><span class="line">    <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p>ImagePullPolicy策略，</p><ul><li>Always: 不管镜像是否存在都会进行一次拉取。</li><li>Never：不管镜像是否存在都不会进行拉取。</li><li>IfNotPresent: 镜像不存在时，才进行拉取。</li></ul><p>注意，</p><ul><li>默认为IfNotPresent，但<code>:latest</code>标签的镜像默认为<code>Always</code>。</li><li>拉取镜像时docker会进行MD5校验，如果镜像中的MD5没变，不会拉取镜像数据。</li><li>生产环境中应该尽量避免使用<code>:latest</code>标签，而开发环境可以借助<code>:latest</code>标签自动拉取最新的镜像。</li></ul><p>访问DNS策略，</p><p>通过设置dnsPolicy参数，设置Pod中容器访问DNS的策略</p><ul><li>ClusterFirst: 优先基于cluster domain后缀，通过kube-dns查询</li><li>Default：首先从kubelet中配置的DNS查询</li></ul><p>默认是ClusterFirst</p><p>通过hostIPC设置参数为Ture，使用主机的IPC明明空间，默认为False。</p><p>通过hostNetwork设置参数为True，使用主机的命名空间，默认为False。</p><p>通过hostPID设置参数为True，使用主机的PID命名空间，默认为False。</p><p>通过subdomain参数设置Pod的子域名，默认为空</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">busybox2</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">busybox-2</span></span><br><span class="line"><span class="attr">subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">sleep</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"3600"</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure><p>kubernetes通过cgroups限制容器的CPU和内存等计算资源，包括requests和limits等：</p><ul><li><code>spec.containers[].resources.limits.cpu</code>：CPU上限，可以短暂超过，容器也不会被停止</li><li><code>spec.containers[].resources.limits.memory</code>：内存上限，不可以超过；如果超过，容器可能会被停止或调度到其它资源充足的机器上</li><li><code>spec.containers[].resources.requests.cpu</code>：CPU请求，可以超过</li><li><code>spec.containers[].resources.requests.memory</code>：内存请求，可以超过；但如果超过，容器可能会在Node内存不足时清理</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiServersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"300m"</span></span><br><span class="line"><span class="attr">memory:</span> <span class="string">"56Mi"</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br><span class="line"><span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br></pre></td></tr></table></figure><p>为了保证容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针(probe，支持exec、tcp和httpGet方式)来探测容器的状态：</p><ul><li>LivenessProbe：探测应用是否处于健康状态，如果不健康则删除重建容器</li><li>ReadinessProbe：探测应用是否启动完成并且处于正常服务状态，如果不正常则更新容器状态</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/ping</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>initContainers在容器执行前运行，常用来初始化容器操作，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">init-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">  initContainers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">install</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busygox</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">wget</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"-O"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"/work-dir/index.html"</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">http://kubernetes.io</span></span><br><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">"/work-dir"</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">workdir</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>容器生命周期钩子(Container Lifecycle Hooks)监听容器生命周期的特定事件，并在事件发生时执行已注册的回调函数。支持两种钩子：</p><ul><li>postStart：容器启动后执行，注意由于一步执行，它无法保证一定在ENTRYPOINT之后运行。如果失败，容器会被杀死，并根据RestartPolicy决定是否重启</li><li>preStop：容器停止前执行，常用于资源清理。如果失败，容器同样也会被杀死</li></ul><p>钩子的回调函数支持两种方式：</p><ul><li>exec: 在容器内执行命令</li><li>httpGet：向指定URL发起GET请求</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line">  <span class="attr">postStart:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">["/bin/sh"</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">preStop:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">["/usr/sbin/nginx",</span> <span class="string">"-s"</span><span class="string">,</span> <span class="string">"quit"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>默认情况下，容器都是以非特权容器方式运行。比如，不能再容器中创建虚拟网卡、配置虚拟网络。</p><p>Kubernetes提供了修改Capabilities的机制，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">hello-world</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">friendly-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"alpine:3.4"</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">["/bin/echo",</span> <span class="string">"hello"</span><span class="string">,</span> <span class="string">"world"</span><span class="string">]</span></span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">capabilities:</span></span><br><span class="line">    <span class="attr">add:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line"><span class="attr">drop:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>可以通过给Pod增加 <code>kubernetes.io/ingressbandwidth</code> 和 <code>kubernetes.io/egress-bandwidth</code> 这两个annotation来限制Pod的网络带宽</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">qos</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress-bandwidth:</span> <span class="number">3</span><span class="string">M</span></span><br><span class="line"><span class="string">kubernetes.io/egress-bandwidth:</span> <span class="number">4</span><span class="string">M</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">iperf3</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">networkstatic/iperf3</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">iperf3</span></span><br><span class="line"><span class="bullet">-</span> <span class="bullet">-s</span></span><br></pre></td></tr></table></figure><p>可以通过nodeSelector、nodeAffinity、podAffinity以及Taints和tolerations等来讲Pod调度到需要的Node上。</p><p>也可以通过设置nodeName参数，将Pod调度到制定node节点上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  spec:</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line"><span class="attr">    disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure><p>默认情况下，容器的<code>/etc/hosts</code>时kubelet自动生成的，并且仅包含localhost和podName等。不建议直接修改<code>/etc/hosts</code>文件，因为在Pod启动或重启时会被覆盖。</p><p>默认的<code>/etc/hosts</code>文件格式如下，其中<code>nginx-4217019353-fb2c5</code>是podName：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> nginx-app-5dd4f9fd4d-nm4sx -- cat /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/cat-etc-hosts.png" alt="executor"></p><p>从v1.7开始，可以通过<code>pod.Spec.HostAliases</code>来增加hosts内容，如，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">hostaliases-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  hostAliases:</span></span><br><span class="line"><span class="attr">  - ip:</span> <span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="attr">    hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"foo.local"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"bar.local"</span></span><br><span class="line"><span class="attr">  - ip:</span> <span class="string">"10.1.2.3"</span></span><br><span class="line"><span class="attr">    hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"foo.remote"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"bar.remote"</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cat-hosts</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"/etc/hosts"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs hostaliases-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes-managed hosts file.</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">fe00::0ip6-mcastprefix</span><br><span class="line">fe00::1ip6-allnodes</span><br><span class="line">fe00::2ip6-allrouters</span><br><span class="line">10.244.1.35hostaliases-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># Entries added by HostAliases.</span></span><br><span class="line">127.0.0.1foo.localbar.local</span><br><span class="line">10.1.2.3foo.remotebar.remote</span><br></pre></td></tr></table></figure><h2><span id="namespace">Namespace</span></h2><p>Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的pods，services，replication controller和deployments等都是属于某一个namespace的(默认是default)，而node，persistentVolumes等则不属于任何namespace。</p><p>Namespace常用来隔离不同的用户，比如Kubernetes自带的服务一般运行在<code>kube-system namespace</code>中。</p><ol><li>查询</li></ol><p>名称空间的选项可以用<code>--namespace</code>或<code>-n</code>来指定，不指定默认就是<code>default</code>。也可以通过<code>--all-namespace=true</code>来查看所有namespace下的资源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br><span class="line">NAME          STATUS   AGE</span><br><span class="line">default       Active   32h</span><br><span class="line">kube-public   Active   32h</span><br><span class="line">kube-system   Active   32h</span><br></pre></td></tr></table></figure><p>注意：<code>kubectl get namespace</code>等效；namespace包含两种状态“Active”和“Terminating”。在namespace删除过程中，namespace状态被设置成“Terminating”。</p><ol start="2"><li>创建</li></ol><p>命令行直接创建，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace new-namespace</span><br></pre></td></tr></table></figure><p>通过文件创建，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">new-namespace</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ./my-namespace.yaml</span><br></pre></td></tr></table></figure><p>注意：namespace的name满足正则表达式<code>[a-z0-9]([-a-z0-9]*[a-z0-9])?</code>，最大长度为63位，</p><ol start="3"><li>删除</li></ol><ul><li>删除一个namespace会自动删除所有属于该namespace的资源</li><li><code>default</code>和<code>kube-system</code>名称空间不可删除</li><li>PersistentVolumes是不属于任何namespace的，但PersistentVolumeClaim是属于某个特定namespace的</li><li>Events是否属于namespace取决于产生events的对象</li></ul><h2><span id="node">Node</span></h2><p>Node是Pod真正运行的主机，可以是物理机，也可以是虚拟机。为了管理Pod，每个Node节点上至少运行container runtime(比如docker或rkt)、<code>kubelet</code>和<code>kube-proxy</code>服务。</p><p><img src="/img/kubernetes/module_03_nodes.svg" alt="nodes"></p><ol><li>Node管理</li></ol><p>不像其它的资源(如Pod和Namespace)，Node本质上不是Kubernetes来创建的，Kubernetes只是管理Node上的资源。虽然可以通过Manifest创建一个Node对象(如下json)，但Kubernetes也只是去检查是否真的是有这么一个Node，如果检查失败，也不会往上调度Pod。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Node"</span>,</span><br><span class="line">  <span class="attr">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"10.240.79.157"</span>,</span><br><span class="line"><span class="attr">"labels"</span>: &#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-first-k8s-node"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个检查是由Node Controller来完成的。Node Controller负责</p><ul><li>维护Node状态</li><li>与Cloud Provider同步Node</li><li>给Node分配容器CIDR</li><li>删除带有<code>NoExecute</code> taint的Node上的Pods</li></ul><p>默认情况下，kubelet在启动时会向master注册自己，并创建Node资源。</p><ol start="2"><li>Node的状态</li></ol><p>每个Node都包括以下状态信息</p><ul><li>地址：包括hostname、外网IP和内网IP</li><li>条件(Condition)：包括OutOfDisk、Ready、MemoryPressure和DiskPressure</li><li>容量(Capacity)：Node上的可用资源，包括CPU、内存和Pod总数</li><li>基本信息(Info)：包括内核版本、容器引擎版本、OS类型等</li></ul><ol start="3"><li>Taints和tolerations</li></ol><p>Taints和tolerations用于保证Pod不被调度到不合适的Node上，Taint应用于Node上，而toleration则应用于Pod上(Toleration是可选的)。</p><p>比如，可以使用taint命令给node1添加taints：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br><span class="line">kubectl taint nodes node2 key1=value2:NoExecutte</span><br></pre></td></tr></table></figure><ol start="4"><li>Node维护模式</li></ol><p>标识Node为不可调度，但不影响其上正在运行的Pod，这种维护Node时时非常有用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon <span class="variable">$NODENAME</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群时配置Kubernetes的所有组件、功能和工作负载的物理平台。集群中一台服务器(或高可用部署中的一组服务器)作为Master，负责管理整个集群，其余作为Worker Node，集群中的主机可以是物理服务器，也可以是虚拟机(包括云VPS)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://galudisu.info/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 简介以及安装安装高可用v1.13.1集群(一)</title>
    <link href="http://galudisu.info/2019/02/03/kubernetes/kubernetes-01-centos-installation/"/>
    <id>http://galudisu.info/2019/02/03/kubernetes/kubernetes-01-centos-installation/</id>
    <published>2019-02-03T07:34:35.000Z</published>
    <updated>2019-08-27T09:05:47.515Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/kubernetes/kubernetes-kubectl-cheatsheet.png" alt="kubectl-cheatsheet"></p><p>Kubernetes是谷歌开源的容器集群管理系统，是Google多年大规模容器管理技术Borg的开源版本，也是CNCF最重要的项目之一，主要功能包括：</p><ul><li>基于容器的应用部署、维护和滚动升级</li><li>负载均衡和服务发现</li><li>跨机器和跨地区的集群调度</li><li>自动伸缩</li><li>无状态服务和有状态服务</li><li>广泛的Volumn支持</li><li>插件机制保证扩展性</li></ul><a id="more"></a><h2><span id="kubernetes架构">Kubernetes架构</span></h2><p>Kubernetes主要由以下几个核心组件组成：</p><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume(CVI)和网络(CNI)的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行(CRI)；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡</li></ul><h2><span id="kubeadm-113-安装高可用-kubernetes-v1131-集群">Kubeadm 1.13 安装高可用 kubernetes v1.13.1 集群</span></h2><p><img src="/img/kubernetes/dashboard.png" alt="kubernetes-dashboard"></p><p>先上图给个肯定信心。</p><h2><span id="部署">部署</span></h2><p>以CentOS7为基础，搭建一个Master主机和三个Node主机，各个Node主机的配置方式基本相同。</p><ul><li>OS: CentOS 7.5 x86_64</li><li>Container runtime: Docker 18.06.ce</li><li>Kubernetes: 1.13</li></ul><table><thead><tr><th style="text-align:left">IP 地址</th><th style="text-align:left">主机名</th><th style="text-align:left">角色</th></tr></thead><tbody><tr><td style="text-align:left">192.168.50.71</td><td style="text-align:left">master, <a href="http://master.kubernetes.io" target="_blank" rel="noopener">master.kubernetes.io</a></td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.50.72</td><td style="text-align:left">node01, <a href="http://node01.kubernetes.io" target="_blank" rel="noopener">node01.kubernetes.io</a></td><td style="text-align:left">node</td></tr><tr><td style="text-align:left">192.168.50.73</td><td style="text-align:left">node02, <a href="http://node02.kubernetes.io" target="_blank" rel="noopener">node02.kubernetes.io</a></td><td style="text-align:left">node</td></tr><tr><td style="text-align:left">192.168.50.74</td><td style="text-align:left">node03, <a href="http://node03.kubernetes.io" target="_blank" rel="noopener">node03.kubernetes.io</a></td><td style="text-align:left">node</td></tr></tbody></table><p>这里需要使用常规的域名格式，因为后面需要为集群配置Kubernetes Dashboard要求有SSL数字签名。</p><h2><span id="系统配置">系统配置</span></h2><p>配置host，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">192.168.50.71mastermaster.kubernetes.io</span><br><span class="line">192.168.50.72node1node01.kubernetes.io</span><br><span class="line">192.168.50.73node2node02.kubernetes.io</span><br><span class="line">192.168.50.74node3node03.kubernetes.io</span><br></pre></td></tr></table></figure><p>关闭防火墙，选择iptable加入端口或禁用防火墙服务两种方式。这里简单起见，禁用防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>禁用SELINUX，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo setenfore 0</span><br><span class="line">sudo vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>所有节点关闭交换分区，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line">sudo vi /etc/fstab</span><br></pre></td></tr></table></figure><p>将交换区注释掉，使用<code>free -m</code>查看交换分区是否关闭。</p><p>创建<code>/etc/sysctl.d/k8s.conf</code>文件，添加如下内容，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>执行命令使修改生效，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe br_netfilter</span><br><span class="line">sudo sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><p>kube-proxy开启ipvs，Kubernetes 1.11之后的版本默认支持使用ipvs代理模式的Service资源，但它依赖ipvs相关的内核模块，这些模块默认不会自动载入。kube-proxy开启ipvs的前提需要加载以下模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><p>创建<code>/etc/sysconfig/modules/ipvs.modules</code>文件，内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ipvs_mods_dir=<span class="string">"/usr/lib/modules/<span class="variable">$(uname -r)</span>/kernel/net/netfilter/ipvs"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls <span class="variable">$ipvs_mods_dir</span> | grep -o <span class="string">"^[^.]*"</span>); <span class="keyword">do</span></span><br><span class="line">/sbin/modinfo -F filename <span class="variable">$i</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">/sbin/modprobe <span class="variable">$i</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>修改文件权限，并加载内核模块，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">sudo /etc/sysconfig/modules/ipvs.modules</span><br></pre></td></tr></table></figure><p>注意该步骤不是必须的，因为ipvs仅负责负载均衡相关任务，它无法完成kube-proxy中的包过滤机SNAT等功能，这些仍需要由iptables实现。也就是说，如果条件不满足，即使kube-proxy开启了ipvs模式，也会回退到iptables模式。</p><h2><span id="安装docker">安装Docker</span></h2><p>Docker的安装可以参考阿里云的docker-ce的安装方法，目前Kubernetes推荐的最新支持的docker版本为18.06，注意不要使用不兼容的版本。</p><p>如果你有阿里云账号，可以参考<a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">镜像加速器</a>方法。</p><p>另外，如果想通过外网访问Docker，可以在Systemd加入启动参数配置sock进行访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>其它细节可以参考阿里docker相关文档。</p><h2><span id="配置外网访问ss">配置外网访问SS</span></h2><p>首先，你得先有一个SS，<a href="http://xn--k8s-628d2hjq96ozubb9tvvf3u9geh9blx1ac9a.gcr.io" target="_blank" rel="noopener">因为大陆内目前访问不了k8s.gcr.io</a>。虽然有人做了镜像同步，对同步的镜像进行retag也是可行的方式，但我有SS！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-pip epel-release -y</span><br><span class="line">sudo pip install shadowsocks</span><br><span class="line">cat &gt; /etc/shadowsocks.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"server"</span>:<span class="string">"xx.xx.xx.xx"</span>,</span><br><span class="line"><span class="string">"server_port"</span>: 443,</span><br><span class="line"><span class="string">"local_port"</span>: 1080,</span><br><span class="line"><span class="string">"password"</span>:<span class="string">"xxx"</span>,</span><br><span class="line"><span class="string">"timeout"</span>:600,</span><br><span class="line"><span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo sslocal -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure><p>SS主要是配给Docker用的，编辑<code>/lib/systemd/system/docker.service</code>文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Environment=<span class="string">"HTTP_PROXY=socks5://127.0.0.1:1080/"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=socks5://127.0.0.1:1080/"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=localhost,127.0.0.0/8,guqcep47.mirror.aliyuncs.com"</span></span><br></pre></td></tr></table></figure><h2><span id="kubeletkubeadmkubectl安装">kubelet，kubeadm，kubectl安装</span></h2><p>首先要设定组件的仓储，编辑<code>/etc/yum.repos.d/kubernetes.repo</code>，内容如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure><p>执行如下命令安装程序包，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><p>kubernetes自1.8版本开始，强制要求关闭系统swap，编辑kubelet配置文件<code>/etc/sysconfig/kubelet</code>，忽略禁止使用Swap限制，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--fail-swap-on=false"</span></span><br></pre></td></tr></table></figure><p>加入启动服务，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start kubelet</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure><h2><span id="集群初始化">集群初始化</span></h2><p>集群初始化动作需要在Master进行，然后在其它Node节点使用<code>join</code>加入，所以这里的命令行需要在各个主机单独敲命令了。</p><p>有两种初始化方式，一种是命令带参数方式；另一种是使用配置文件，两种方式是等效的，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --kubernetes-version=v1.13.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --apiserver-advertise-address=0.0.0.0 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>简单说一下这几个重要的参数，</p><ul><li><code>--kubernetes-version</code>：Kubernete的版本</li><li><code>--pod-network-cidr</code>：Pod网络地址范围，其值为CIDR格式的网络地址；使用flannel网络插件是，默认地址为10.244.0.0/16。</li><li><code>--service-cidr</code>：Service的网络地址范围，其值为CIDR格式的网络地址，默认地址为10.96.0.0/12。</li><li><code>--apiserver-advertise-address</code>：API server通告给其他组件的IP地址，一般应该为Master节点的IP地址，0.0.0.0表示节点上的所有可用地址。</li><li><code>--ignore-preflight-errors</code>：忽略哪些运行时的错误信息，其值为Swap时，表示忽略因swap未关闭而导致的错误。</li></ul><p>一般情况下，都是使用配置文件的方式，可以通过下面的命令查看一份完整的kubeadm配置示例，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm config <span class="built_in">print</span> init-defaults --component-configs KubeProxyConfiguration</span><br></pre></td></tr></table></figure><p>存储输出的内容为<code>kubeadm-config.yaml</code>，根据自己需求修改，执行命令初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init --config kubeadm-config.yaml --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>初始化如果成功，会打印两个重要信息，一是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOEM</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>照着写便是，默认情况下kubectl会从当前用户主目录的.kube下的config读取配置信息，包括Kubernetes集群、证书或令牌等。集群初始化时，kubeadm会自动生成一个用于此类功能的配置文件<code>/etc/kubernetes/admin.conf</code>，将它复制为<code>$HOME/.kube/config</code>文件即可直接使用。</p><p>kubectl有非常多的子命令，其中“<code>get compontsstatuses</code>”可显示集群组件当前的状态，简写为<code>get cs</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok                   </span><br><span class="line">scheduler            Healthy   ok                   </span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">"health"</span>: <span class="string">"true"</span>&#125;</span><br></pre></td></tr></table></figure><p>若命令结果的STATUS字段为“Healthy”，表示组件处于健康运行状态，否则需要检查其错误所在，必要时使用“kubeadm reset”命令重置重新进行初始化。</p><p>另外使用<code>kubectl get nodes</code>，获取集群节点的相关状态信息，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   NotReady master   7d5h   v1.13.2</span><br></pre></td></tr></table></figure><p>为Kubernetes提供的Pod网络插件非常多，目前流行的有flannel和Calico。flannel运行为Kubernetes集群的附件，它以Pod的形式部署运行与每个集群节点上以接受Kubernetes集群管理。事实上，flannel也可以以守护进程方式运行在各个节点，即以非托管的方式运行。部署命令使<code>kubectl apply</code>或<code>kubectl crreate</code>，下面是使用在线的方式进行flannel部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>部署成功会出现created字样，配置flannel网络插件时，Master节点上的Docker首先会去获取flannel镜像文件，而后根据镜像文件启动相应的Pod对象。现在再次查看Master已经变为“Ready”状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   Ready    master   7d5h   v1.13.2</span><br></pre></td></tr></table></figure><p>可通过，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system | grep flannel</span><br></pre></td></tr></table></figure><p>显示网络插件flannel的Pod状态情况。</p><p>集群初始化时，另一个信息是产生一段token信息，这段信息用于Node节点加入Master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join kubernetes-master:6443 --token 0qpyy8.iv5v2uhhrjy3wsri --discovery-token-ca-cert-hash sha256:c8ad1e333b6e2e1185ea2ab7beb97b90022f8285e79a1cc6a7e71ad772748f42 --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>每个节点加入到Master之后，再次通过<code>kubectl get nodes</code>查看节点信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME                STATUS   ROLES    AGE    VERSION</span><br><span class="line">kubernetes-master   Ready    master   7d5h   v1.13.2</span><br><span class="line">kubernetes-node1    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br><span class="line">kubernetes-node2    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br><span class="line">kubernetes-node3    Ready    &lt;none&gt;   7d4h   v1.13.2</span><br></pre></td></tr></table></figure><p>至此，Kubernetes集群的部署已经完成，后续有更多节点加入时，均可使用此方式。</p><p>Kubernetes的命令非常多，在文章最前面的大图已经描述清楚。由于这里仅介绍集群安装内容，下面简单了解下关于集群方面的命令，</p><p>获取集群信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.50.71:6443</span><br><span class="line">KubeDNS is running at https://192.168.50.71:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use <span class="string">'kubectl cluster-info dump'</span>.</span><br></pre></td></tr></table></figure><p>版本信息，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl version --short=<span class="literal">true</span></span><br><span class="line">Client Version: v1.13.2</span><br><span class="line">Server Version: v1.13.2</span><br></pre></td></tr></table></figure><p>移除节点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain NODE_ID --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node NODE_ID</span><br></pre></td></tr></table></figure><p>重置节点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2><span id="部署高可用coredns">部署高可用CoreDNS</span></h2><p>默认安装的CoreDNS存在单点问题。在Master节点查看<code>kubectl get pods -n kube-system -owide</code>分布如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide </span><br><span class="line">NAME                                           READY   STATUS              RESTARTS   AGE   IP              NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-86c58d9df4-6j2m6                       0/1     ContainerCreating   0          90m   &lt;none&gt;          master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-86c58d9df4-glvnp                       0/1     ContainerCreating   0          90m   &lt;none&gt;          master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-master.kubernetes.io                      1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-master.kubernetes.io            1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-master.kubernetes.io   1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-czh7z                    1/1     Running             0          80m   192.168.50.73   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-gcqkk                    1/1     Running             0          80m   192.168.50.74   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-lk5dw                    1/1     Running             0          81m   192.168.50.72   node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-amd64-xp5xf                    0/1     PodInitializing     0          83m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-b82sn                               1/1     Running             0          80m   192.168.50.73   node02.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-ql6hp                               1/1     Running             0          81m   192.168.50.72   node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-sh87s                               1/1     Running             0          80m   192.168.50.74   node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-w2kv4                               0/1     ContainerCreating   0          90m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-master.kubernetes.io            1/1     Running             2          89m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>删除原来的单点CoreDNS，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deploy coredns -n kube-system</span><br></pre></td></tr></table></figure><p>创建一份多实例配置coredns-ha.yaml，内容如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">coredns</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment">#集群规模可自行配置</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      affinity:</span></span><br><span class="line"><span class="attr">        podAntiAffinity:</span></span><br><span class="line"><span class="attr">          preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">          - weight:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">            podAffinityTerm:</span></span><br><span class="line"><span class="attr">              labelSelector:</span></span><br><span class="line"><span class="attr">                matchExpressions:</span></span><br><span class="line"><span class="attr">                - key:</span> <span class="string">k8s-app</span></span><br><span class="line"><span class="attr">                  operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">                  values:</span></span><br><span class="line"><span class="bullet">                  -</span> <span class="string">kube-dns</span></span><br><span class="line"><span class="attr">              topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">-conf</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">/etc/coredns/Corefile</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.2.6</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          failureThreshold:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/health</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">            scheme:</span> <span class="string">HTTP</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">          successThreshold:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">          timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">coredns</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">53</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">dns</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">UDP</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">53</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">dns-tcp</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">9153</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">metrics</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">170</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">70</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        securityContext:</span></span><br><span class="line"><span class="attr">          allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">          capabilities:</span></span><br><span class="line"><span class="attr">            add:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line"><span class="attr">            drop:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">all</span></span><br><span class="line"><span class="attr">          readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">        terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/etc/coredns</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">config-volume</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">      schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">      securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">      serviceAccount:</span> <span class="string">coredns</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">coredns</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">CriticalAddonsOnly</span></span><br><span class="line"><span class="attr">        operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">      - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - configMap:</span></span><br><span class="line"><span class="attr">          defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">          items:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">Corefile</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">Corefile</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">coredns</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">config-volume</span></span><br></pre></td></tr></table></figure><p>执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f coredns-ha.yaml</span><br></pre></td></tr></table></figure><p>再次查看分布，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE    IP              NODE                   NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-6c67f849c7-jhqhj                       1/1     Running   0          3m6s   10.244.1.3      node01.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-6c67f849c7-kxtkw                       1/1     Running   0          3m6s   10.244.3.4      node03.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-master.kubernetes.io                      1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-master.kubernetes.io            1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-master.kubernetes.io   1/1     Running   2          102m   192.168.50.71   master.kubernetes.io   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>CoreDNS的Pod落在节点node1和node3上了。</p><h2><span id="安装dashboard">安装dashboard</span></h2><p>Kubernetes dashboard的安装也是在pod上的，所以要在所有节点执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br></pre></td></tr></table></figure><p>下载官方推荐的部署文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p>因为前面我已经将镜像拉取下来了，所以不必要再拉取，修改这个<code>kubernetes-dashboard.yaml</code>文件，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="string">name</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>另外，需要暴露端口以给集群外部访问，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------------------- Dashboard Service ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">31234</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>OK，执行命令部署pod，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p>查看一下dashboard的pod是否正常启动，如果正常，说明安装成功，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -owide</span><br></pre></td></tr></table></figure><p><img src="/img/kubernetes/kube-system.png" alt="kube-system"></p><p>查看外网暴露的端口，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services -n kube-system                                                                        </span><br><span class="line">NAME                   TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10     &lt;none&gt;        53/UDP,53/TCP   7d5h</span><br><span class="line">kubernetes-dashboard   NodePort    10.104.42.80   &lt;none&gt;        443:31234/TCP   138m</span><br></pre></td></tr></table></figure><p>默认情况下，kubeadm创建集群时已经创建了admin角色，我们直接绑定即可，</p><p>创建一个<code>admin-user-role-binding.yaml</code>文件，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br></pre></td></tr></table></figure><p>执行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f admin-user-role-binding.yaml</span><br></pre></td></tr></table></figure><p>获取token，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br></pre></td></tr></table></figure><p>把Token复制的登录界面，即可。</p><p>这里登录时有个问题，就是HTTPS访问没有证书，chrome直接不让访问！Firefox还好可以绕过。所以需要自己加一个证书，</p><p>首先生成私钥和证书签名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'client-key-data'</span> ~/.kube/config | head -n 1 | awk <span class="string">'&#123;print $2&#125;'</span> | base64 -d &gt;&gt; dashboard.key</span><br><span class="line">grep <span class="string">'client-certificate-data'</span> ~/.kube/config | head -n 1 | awk <span class="string">'&#123;print $2&#125;'</span> | base64 -d &gt;&gt; dashboard.crt</span><br></pre></td></tr></table></figure><p>生成证书，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -inkey dashboard.key -<span class="keyword">in</span> dashboard.crt -out dashboard.p12 -name <span class="string">"kubernetes-client"</span></span><br></pre></td></tr></table></figure><p>将生成的<code>dashboard.key</code>和<code>dashboard.crt</code>放置在路径<code>/certs</code>下， 重新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br><span class="line">kubectl create -f admin-user-role-binding.yaml</span><br></pre></td></tr></table></figure><p>虽然添加了证书，但也仅能通过firefox添加例外访问，chrome根本不信任你。所以生产环境上还是要买一个SSL证书，另外Pod内的service最好也不要直接暴露给外网访问，一般用nginx-ingress做个代理。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">你可能需要安装额外的工具用于Kubernetes管理，参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-software-on-kubernetes-clusters-with-the-helm-package-manager" target="_blank" rel="noopener">这里</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/kubernetes/kubernetes-kubectl-cheatsheet.png&quot; alt=&quot;kubectl-cheatsheet&quot;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes是谷歌开源的容器集群管理系统，是Google多年大规模容器管理技术Borg的开源版本，也是CNCF最重要的项目之一，主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于容器的应用部署、维护和滚动升级&lt;/li&gt;
&lt;li&gt;负载均衡和服务发现&lt;/li&gt;
&lt;li&gt;跨机器和跨地区的集群调度&lt;/li&gt;
&lt;li&gt;自动伸缩&lt;/li&gt;
&lt;li&gt;无状态服务和有状态服务&lt;/li&gt;
&lt;li&gt;广泛的Volumn支持&lt;/li&gt;
&lt;li&gt;插件机制保证扩展性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://galudisu.info/tags/kubernetes/"/>
    
  </entry>
  
</feed>
